"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@glideapps";
exports.ids = ["vendor-chunks/@glideapps"];
exports.modules = {

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/index.css":
/*!****************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/index.css ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"89dd529078dc\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9pbmRleC5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2luZGV4LmNzcz9hM2MwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiODlkZDUyOTA3OGRjXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/index.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/boolean-cell.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/boolean-cell.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   booleanCellRenderer: () => (/* binding */ booleanCellRenderer)\n/* harmony export */ });\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* harmony import */ var _data_editor_data_editor_fns_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data-editor/data-editor-fns.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor-fns.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _internal_data_grid_render_draw_checkbox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/data-grid/render/draw-checkbox.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/draw-checkbox.js\");\n\n\n\n\nconst defaultCellMaxSize = 20;\nconst booleanCellRenderer = {\n    getAccessibilityString: c => c.data?.toString() ?? \"false\",\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Boolean,\n    needsHover: true,\n    useLabel: false,\n    needsHoverPosition: true,\n    measure: () => 50,\n    draw: a => drawBoolean(a, a.cell.data, (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanCellIsEditable)(a.cell), a.cell.maxSize ?? defaultCellMaxSize),\n    onDelete: c => ({\n        ...c,\n        data: false,\n    }),\n    onClick: e => {\n        const { cell, posX: pointerX, posY: pointerY, bounds, theme } = e;\n        const { width, height, x: cellX, y: cellY } = bounds;\n        const maxWidth = cell.maxSize ?? defaultCellMaxSize;\n        const cellCenterY = Math.floor(bounds.y + height / 2);\n        const checkBoxWidth = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.getSquareWidth)(maxWidth, height, theme.cellVerticalPadding);\n        const posX = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.getSquareXPosFromAlign)(cell.contentAlign ?? \"center\", cellX, width, theme.cellHorizontalPadding, checkBoxWidth);\n        const bb = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.getSquareBB)(posX, cellCenterY, checkBoxWidth);\n        const checkBoxClicked = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.pointIsWithinBB)(cellX + pointerX, cellY + pointerY, bb);\n        if ((0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.booleanCellIsEditable)(cell) && checkBoxClicked) {\n            return {\n                ...cell,\n                data: (0,_data_editor_data_editor_fns_js__WEBPACK_IMPORTED_MODULE_2__.toggleBoolean)(cell.data),\n            };\n        }\n        return undefined;\n    },\n    onPaste: (toPaste, cell) => {\n        let newVal = _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.BooleanEmpty;\n        if (toPaste.toLowerCase() === \"true\") {\n            newVal = true;\n        }\n        else if (toPaste.toLowerCase() === \"false\") {\n            newVal = false;\n        }\n        else if (toPaste.toLowerCase() === \"indeterminate\") {\n            newVal = _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.BooleanIndeterminate;\n        }\n        return newVal === cell.data\n            ? undefined\n            : {\n                ...cell,\n                data: newVal,\n            };\n    },\n};\nfunction drawBoolean(args, data, canEdit, maxSize) {\n    if (!canEdit && data === _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.BooleanEmpty) {\n        return;\n    }\n    const { ctx, hoverAmount, theme, rect, highlighted, hoverX, hoverY, cell: { contentAlign }, } = args;\n    const { x, y, width: w, height: h } = rect;\n    const hoverEffect = 0.35;\n    let alpha = canEdit ? 1 - hoverEffect + hoverEffect * hoverAmount : 0.4;\n    if (data === _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.BooleanEmpty) {\n        alpha *= hoverAmount;\n    }\n    if (alpha === 0) {\n        return;\n    }\n    ctx.globalAlpha = alpha;\n    (0,_internal_data_grid_render_draw_checkbox_js__WEBPACK_IMPORTED_MODULE_3__.drawCheckbox)(ctx, theme, data, x, y, w, h, highlighted, hoverX, hoverY, maxSize, contentAlign);\n    ctx.globalAlpha = 1;\n}\n//# sourceMappingURL=boolean-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvYm9vbGVhbi1jZWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBHO0FBQ3hDO0FBQ2tFO0FBQ3ZEO0FBQzdFO0FBQ087QUFDUDtBQUNBLFVBQVUsZ0ZBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNkZBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixzREFBc0Q7QUFDdEUsZ0JBQWdCLG9DQUFvQztBQUNwRDtBQUNBO0FBQ0EsOEJBQThCLGdFQUFjO0FBQzVDLHFCQUFxQix3RUFBc0I7QUFDM0MsbUJBQW1CLDZEQUFXO0FBQzlCLGdDQUFnQyxpRUFBZTtBQUMvQyxZQUFZLDZGQUFxQjtBQUNqQztBQUNBO0FBQ0Esc0JBQXNCLDhFQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixnRkFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3RkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QixnRkFBWTtBQUN6QztBQUNBO0FBQ0EsWUFBWSxvRUFBb0UsY0FBYyxJQUFJO0FBQ2xHLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUIsZ0ZBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5RkFBWTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9jZWxscy9ib29sZWFuLWNlbGwuanM/ZTg3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTcXVhcmVXaWR0aCwgZ2V0U3F1YXJlWFBvc0Zyb21BbGlnbiwgZ2V0U3F1YXJlQkIsIHBvaW50SXNXaXRoaW5CQiB9IGZyb20gXCIuLi9jb21tb24vdXRpbHMuanNcIjtcbmltcG9ydCB7IHRvZ2dsZUJvb2xlYW4gfSBmcm9tIFwiLi4vZGF0YS1lZGl0b3IvZGF0YS1lZGl0b3ItZm5zLmpzXCI7XG5pbXBvcnQgeyBHcmlkQ2VsbEtpbmQsIGJvb2xlYW5DZWxsSXNFZGl0YWJsZSwgQm9vbGVhbkVtcHR5LCBCb29sZWFuSW5kZXRlcm1pbmF0ZSwgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlcy5qc1wiO1xuaW1wb3J0IHsgZHJhd0NoZWNrYm94IH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9yZW5kZXIvZHJhdy1jaGVja2JveC5qc1wiO1xuY29uc3QgZGVmYXVsdENlbGxNYXhTaXplID0gMjA7XG5leHBvcnQgY29uc3QgYm9vbGVhbkNlbGxSZW5kZXJlciA9IHtcbiAgICBnZXRBY2Nlc3NpYmlsaXR5U3RyaW5nOiBjID0+IGMuZGF0YT8udG9TdHJpbmcoKSA/PyBcImZhbHNlXCIsXG4gICAga2luZDogR3JpZENlbGxLaW5kLkJvb2xlYW4sXG4gICAgbmVlZHNIb3ZlcjogdHJ1ZSxcbiAgICB1c2VMYWJlbDogZmFsc2UsXG4gICAgbmVlZHNIb3ZlclBvc2l0aW9uOiB0cnVlLFxuICAgIG1lYXN1cmU6ICgpID0+IDUwLFxuICAgIGRyYXc6IGEgPT4gZHJhd0Jvb2xlYW4oYSwgYS5jZWxsLmRhdGEsIGJvb2xlYW5DZWxsSXNFZGl0YWJsZShhLmNlbGwpLCBhLmNlbGwubWF4U2l6ZSA/PyBkZWZhdWx0Q2VsbE1heFNpemUpLFxuICAgIG9uRGVsZXRlOiBjID0+ICh7XG4gICAgICAgIC4uLmMsXG4gICAgICAgIGRhdGE6IGZhbHNlLFxuICAgIH0pLFxuICAgIG9uQ2xpY2s6IGUgPT4ge1xuICAgICAgICBjb25zdCB7IGNlbGwsIHBvc1g6IHBvaW50ZXJYLCBwb3NZOiBwb2ludGVyWSwgYm91bmRzLCB0aGVtZSB9ID0gZTtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4OiBjZWxsWCwgeTogY2VsbFkgfSA9IGJvdW5kcztcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSBjZWxsLm1heFNpemUgPz8gZGVmYXVsdENlbGxNYXhTaXplO1xuICAgICAgICBjb25zdCBjZWxsQ2VudGVyWSA9IE1hdGguZmxvb3IoYm91bmRzLnkgKyBoZWlnaHQgLyAyKTtcbiAgICAgICAgY29uc3QgY2hlY2tCb3hXaWR0aCA9IGdldFNxdWFyZVdpZHRoKG1heFdpZHRoLCBoZWlnaHQsIHRoZW1lLmNlbGxWZXJ0aWNhbFBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwb3NYID0gZ2V0U3F1YXJlWFBvc0Zyb21BbGlnbihjZWxsLmNvbnRlbnRBbGlnbiA/PyBcImNlbnRlclwiLCBjZWxsWCwgd2lkdGgsIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZywgY2hlY2tCb3hXaWR0aCk7XG4gICAgICAgIGNvbnN0IGJiID0gZ2V0U3F1YXJlQkIocG9zWCwgY2VsbENlbnRlclksIGNoZWNrQm94V2lkdGgpO1xuICAgICAgICBjb25zdCBjaGVja0JveENsaWNrZWQgPSBwb2ludElzV2l0aGluQkIoY2VsbFggKyBwb2ludGVyWCwgY2VsbFkgKyBwb2ludGVyWSwgYmIpO1xuICAgICAgICBpZiAoYm9vbGVhbkNlbGxJc0VkaXRhYmxlKGNlbGwpICYmIGNoZWNrQm94Q2xpY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRvZ2dsZUJvb2xlYW4oY2VsbC5kYXRhKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uUGFzdGU6ICh0b1Bhc3RlLCBjZWxsKSA9PiB7XG4gICAgICAgIGxldCBuZXdWYWwgPSBCb29sZWFuRW1wdHk7XG4gICAgICAgIGlmICh0b1Bhc3RlLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICBuZXdWYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvUGFzdGUudG9Mb3dlckNhc2UoKSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICBuZXdWYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b1Bhc3RlLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5kZXRlcm1pbmF0ZVwiKSB7XG4gICAgICAgICAgICBuZXdWYWwgPSBCb29sZWFuSW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3VmFsID09PSBjZWxsLmRhdGFcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IG5ld1ZhbCxcbiAgICAgICAgICAgIH07XG4gICAgfSxcbn07XG5mdW5jdGlvbiBkcmF3Qm9vbGVhbihhcmdzLCBkYXRhLCBjYW5FZGl0LCBtYXhTaXplKSB7XG4gICAgaWYgKCFjYW5FZGl0ICYmIGRhdGEgPT09IEJvb2xlYW5FbXB0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY3R4LCBob3ZlckFtb3VudCwgdGhlbWUsIHJlY3QsIGhpZ2hsaWdodGVkLCBob3ZlclgsIGhvdmVyWSwgY2VsbDogeyBjb250ZW50QWxpZ24gfSwgfSA9IGFyZ3M7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aDogdywgaGVpZ2h0OiBoIH0gPSByZWN0O1xuICAgIGNvbnN0IGhvdmVyRWZmZWN0ID0gMC4zNTtcbiAgICBsZXQgYWxwaGEgPSBjYW5FZGl0ID8gMSAtIGhvdmVyRWZmZWN0ICsgaG92ZXJFZmZlY3QgKiBob3ZlckFtb3VudCA6IDAuNDtcbiAgICBpZiAoZGF0YSA9PT0gQm9vbGVhbkVtcHR5KSB7XG4gICAgICAgIGFscGhhICo9IGhvdmVyQW1vdW50O1xuICAgIH1cbiAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICBkcmF3Q2hlY2tib3goY3R4LCB0aGVtZSwgZGF0YSwgeCwgeSwgdywgaCwgaGlnaGxpZ2h0ZWQsIGhvdmVyWCwgaG92ZXJZLCBtYXhTaXplLCBjb250ZW50QWxpZ24pO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLWNlbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/boolean-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/bubble-cell.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/bubble-cell.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bubbleCellRenderer: () => (/* binding */ bubbleCellRenderer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_data_grid_overlay_editor_private_bubbles_overlay_editor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/data-grid-overlay-editor/private/bubbles-overlay-editor.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/bubbles-overlay-editor.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* eslint-disable react/display-name */\n\n\n\n\n\nconst bubbleCellRenderer = {\n    getAccessibilityString: c => (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.makeAccessibilityStringForArray)(c.data),\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Bubble,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data).width + acc + 20, 0) + 2 * t.cellHorizontalPadding - 4,\n    draw: a => drawBubbles(a, a.cell.data),\n    provideEditor: () => p => {\n        const { value } = p;\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_data_grid_overlay_editor_private_bubbles_overlay_editor_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], { bubbles: value.data });\n    },\n    onPaste: () => undefined,\n};\nconst itemMargin = 4;\nfunction drawBubbles(args, data) {\n    const { rect, theme, ctx, highlighted } = args;\n    const { x, y, width: w, height: h } = rect;\n    const bubbleHeight = 20;\n    const bubblePad = 8;\n    const bubbleMargin = itemMargin;\n    let renderX = x + theme.cellHorizontalPadding;\n    const renderBoxes = [];\n    for (const s of data) {\n        if (renderX > x + w)\n            break;\n        const textWidth = (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.measureTextCached)(s, ctx, theme.baseFontFull).width;\n        renderBoxes.push({\n            x: renderX,\n            width: textWidth,\n        });\n        renderX += textWidth + bubblePad * 2 + bubbleMargin;\n    }\n    ctx.beginPath();\n    for (const rectInfo of renderBoxes) {\n        (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.roundedRect)(ctx, rectInfo.x, y + (h - bubbleHeight) / 2, rectInfo.width + bubblePad * 2, bubbleHeight, theme.roundingRadius ?? bubbleHeight / 2);\n    }\n    ctx.fillStyle = highlighted ? theme.bgBubbleSelected : theme.bgBubble;\n    ctx.fill();\n    for (const [i, rectInfo] of renderBoxes.entries()) {\n        ctx.beginPath();\n        ctx.fillStyle = theme.textBubble;\n        ctx.fillText(data[i], rectInfo.x + bubblePad, y + h / 2 + (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.getMiddleCenterBias)(ctx, theme));\n    }\n}\n//# sourceMappingURL=bubble-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvYnViYmxlLWNlbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDK0I7QUFDMkU7QUFDVTtBQUM1QztBQUNIO0FBQzlEO0FBQ1AsaUNBQWlDLGlGQUErQjtBQUNoRSxVQUFVLGdGQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGVBQWUsZ0RBQW1CLENBQUMsNEdBQW9CLElBQUkscUJBQXFCO0FBQ2hGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEZBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0ZBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdHQUFtQjtBQUNyRjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9jZWxscy9idWJibGUtY2VsbC5qcz82YTY3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L2Rpc3BsYXktbmFtZSAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgQnViYmxlc092ZXJsYXlFZGl0b3IgZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2J1YmJsZXMtb3ZlcmxheS1lZGl0b3IuanNcIjtcbmltcG9ydCB7IGdldE1pZGRsZUNlbnRlckJpYXMsIG1lYXN1cmVUZXh0Q2FjaGVkLCByb3VuZGVkUmVjdCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RhdGEtZ3JpZC1saWIuanNcIjtcbmltcG9ydCB7IEdyaWRDZWxsS2luZCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5pbXBvcnQgeyBtYWtlQWNjZXNzaWJpbGl0eVN0cmluZ0ZvckFycmF5IH0gZnJvbSBcIi4uL2NvbW1vbi91dGlscy5qc1wiO1xuZXhwb3J0IGNvbnN0IGJ1YmJsZUNlbGxSZW5kZXJlciA9IHtcbiAgICBnZXRBY2Nlc3NpYmlsaXR5U3RyaW5nOiBjID0+IG1ha2VBY2Nlc3NpYmlsaXR5U3RyaW5nRm9yQXJyYXkoYy5kYXRhKSxcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuQnViYmxlLFxuICAgIG5lZWRzSG92ZXI6IGZhbHNlLFxuICAgIHVzZUxhYmVsOiBmYWxzZSxcbiAgICBuZWVkc0hvdmVyUG9zaXRpb246IGZhbHNlLFxuICAgIG1lYXN1cmU6IChjdHgsIGNlbGwsIHQpID0+IGNlbGwuZGF0YS5yZWR1Y2UoKGFjYywgZGF0YSkgPT4gY3R4Lm1lYXN1cmVUZXh0KGRhdGEpLndpZHRoICsgYWNjICsgMjAsIDApICsgMiAqIHQuY2VsbEhvcml6b250YWxQYWRkaW5nIC0gNCxcbiAgICBkcmF3OiBhID0+IGRyYXdCdWJibGVzKGEsIGEuY2VsbC5kYXRhKSxcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiBwID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gcDtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnViYmxlc092ZXJsYXlFZGl0b3IsIHsgYnViYmxlczogdmFsdWUuZGF0YSB9KTtcbiAgICB9LFxuICAgIG9uUGFzdGU6ICgpID0+IHVuZGVmaW5lZCxcbn07XG5jb25zdCBpdGVtTWFyZ2luID0gNDtcbmZ1bmN0aW9uIGRyYXdCdWJibGVzKGFyZ3MsIGRhdGEpIHtcbiAgICBjb25zdCB7IHJlY3QsIHRoZW1lLCBjdHgsIGhpZ2hsaWdodGVkIH0gPSBhcmdzO1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCB9ID0gcmVjdDtcbiAgICBjb25zdCBidWJibGVIZWlnaHQgPSAyMDtcbiAgICBjb25zdCBidWJibGVQYWQgPSA4O1xuICAgIGNvbnN0IGJ1YmJsZU1hcmdpbiA9IGl0ZW1NYXJnaW47XG4gICAgbGV0IHJlbmRlclggPSB4ICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nO1xuICAgIGNvbnN0IHJlbmRlckJveGVzID0gW107XG4gICAgZm9yIChjb25zdCBzIG9mIGRhdGEpIHtcbiAgICAgICAgaWYgKHJlbmRlclggPiB4ICsgdylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSBtZWFzdXJlVGV4dENhY2hlZChzLCBjdHgsIHRoZW1lLmJhc2VGb250RnVsbCkud2lkdGg7XG4gICAgICAgIHJlbmRlckJveGVzLnB1c2goe1xuICAgICAgICAgICAgeDogcmVuZGVyWCxcbiAgICAgICAgICAgIHdpZHRoOiB0ZXh0V2lkdGgsXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJYICs9IHRleHRXaWR0aCArIGJ1YmJsZVBhZCAqIDIgKyBidWJibGVNYXJnaW47XG4gICAgfVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKGNvbnN0IHJlY3RJbmZvIG9mIHJlbmRlckJveGVzKSB7XG4gICAgICAgIHJvdW5kZWRSZWN0KGN0eCwgcmVjdEluZm8ueCwgeSArIChoIC0gYnViYmxlSGVpZ2h0KSAvIDIsIHJlY3RJbmZvLndpZHRoICsgYnViYmxlUGFkICogMiwgYnViYmxlSGVpZ2h0LCB0aGVtZS5yb3VuZGluZ1JhZGl1cyA/PyBidWJibGVIZWlnaHQgLyAyKTtcbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IGhpZ2hsaWdodGVkID8gdGhlbWUuYmdCdWJibGVTZWxlY3RlZCA6IHRoZW1lLmJnQnViYmxlO1xuICAgIGN0eC5maWxsKCk7XG4gICAgZm9yIChjb25zdCBbaSwgcmVjdEluZm9dIG9mIHJlbmRlckJveGVzLmVudHJpZXMoKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS50ZXh0QnViYmxlO1xuICAgICAgICBjdHguZmlsbFRleHQoZGF0YVtpXSwgcmVjdEluZm8ueCArIGJ1YmJsZVBhZCwgeSArIGggLyAyICsgZ2V0TWlkZGxlQ2VudGVyQmlhcyhjdHgsIHRoZW1lKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnViYmxlLWNlbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/bubble-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/drilldown-cell.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/drilldown-cell.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drilldownCellRenderer: () => (/* binding */ drilldownCellRenderer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_data_grid_overlay_editor_private_drilldown_overlay_editor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/data-grid-overlay-editor/private/drilldown-overlay-editor.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/drilldown-overlay-editor.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* eslint-disable react/display-name */\n\n\n\n\n\nconst drilldownCellRenderer = {\n    getAccessibilityString: c => (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.makeAccessibilityStringForArray)(c.data.map(d => d.text)),\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.GridCellKind.Drilldown,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    measure: (ctx, cell, t) => cell.data.reduce((acc, data) => ctx.measureText(data.text).width + acc + 20 + (data.img !== undefined ? 18 : 0), 0) +\n        2 * t.cellHorizontalPadding -\n        4,\n    draw: a => drawDrilldownCell(a, a.cell.data),\n    provideEditor: () => p => {\n        const { value } = p;\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_data_grid_overlay_editor_private_drilldown_overlay_editor_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], { drilldowns: value.data });\n    },\n    onPaste: () => undefined,\n};\nconst itemMargin = 4;\nconst drilldownCache = {};\nfunction getAndCacheDrilldownBorder(bgCell, border, height, rounding) {\n    const dpr = Math.ceil(window.devicePixelRatio);\n    const shadowBlur = 5;\n    const targetHeight = height - shadowBlur * 2;\n    const middleWidth = 4;\n    const innerHeight = height * dpr;\n    const sideWidth = rounding + shadowBlur;\n    const targetWidth = rounding * 3;\n    const innerWidth = (targetWidth + shadowBlur * 2) * dpr;\n    const key = `${bgCell},${border},${dpr},${height}`;\n    if (drilldownCache[key] !== undefined) {\n        return {\n            el: drilldownCache[key],\n            height: innerHeight,\n            width: innerWidth,\n            middleWidth: middleWidth * dpr,\n            sideWidth: sideWidth * dpr,\n            padding: shadowBlur * dpr,\n            dpr,\n        };\n    }\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\"); // alpha needed\n    if (ctx === null)\n        return null;\n    canvas.width = innerWidth;\n    canvas.height = innerHeight;\n    ctx.scale(dpr, dpr);\n    drilldownCache[key] = canvas;\n    ctx.beginPath();\n    (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.roundedRect)(ctx, shadowBlur, shadowBlur, targetWidth, targetHeight, rounding);\n    ctx.shadowColor = \"rgba(24, 25, 34, 0.4)\";\n    ctx.shadowBlur = 1;\n    ctx.fillStyle = bgCell;\n    ctx.fill();\n    ctx.shadowColor = \"rgba(24, 25, 34, 0.3)\";\n    ctx.shadowOffsetY = 1;\n    ctx.shadowBlur = 5;\n    ctx.fillStyle = bgCell;\n    ctx.fill();\n    ctx.shadowOffsetY = 0;\n    ctx.shadowBlur = 0;\n    ctx.shadowBlur = 0;\n    ctx.beginPath();\n    (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.roundedRect)(ctx, shadowBlur + 0.5, shadowBlur + 0.5, targetWidth, targetHeight, rounding);\n    ctx.strokeStyle = border;\n    ctx.lineWidth = 1;\n    ctx.stroke();\n    return {\n        el: canvas,\n        height: innerHeight,\n        width: innerWidth,\n        sideWidth: sideWidth * dpr,\n        middleWidth: rounding * dpr,\n        padding: shadowBlur * dpr,\n        dpr,\n    };\n}\nfunction drawDrilldownCell(args, data) {\n    const { rect, theme, ctx, imageLoader, col, row } = args;\n    const { x, width: w } = rect;\n    const font = theme.baseFontFull;\n    const emHeight = (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.getEmHeight)(ctx, font);\n    const h = Math.min(rect.height, Math.max(16, Math.ceil(emHeight * theme.lineHeight) * 2));\n    const y = Math.floor(rect.y + (rect.height - h) / 2);\n    const bubbleHeight = h - 10;\n    const bubblePad = 8;\n    const bubbleMargin = itemMargin;\n    let renderX = x + theme.cellHorizontalPadding;\n    const rounding = theme.roundingRadius ?? 6;\n    const tileMap = getAndCacheDrilldownBorder(theme.bgCell, theme.drilldownBorder, h, rounding);\n    const renderBoxes = [];\n    for (const el of data) {\n        if (renderX > x + w)\n            break;\n        const textMetrics = (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.measureTextCached)(el.text, ctx, font);\n        const textWidth = textMetrics.width;\n        let imgWidth = 0;\n        if (el.img !== undefined) {\n            const img = imageLoader.loadOrGetImage(el.img, col, row);\n            if (img !== undefined) {\n                imgWidth = bubbleHeight - 8 + 4;\n            }\n        }\n        const renderWidth = textWidth + imgWidth + bubblePad * 2;\n        renderBoxes.push({\n            x: renderX,\n            width: renderWidth,\n        });\n        renderX += renderWidth + bubbleMargin;\n    }\n    if (tileMap !== null) {\n        const { el, height, middleWidth, sideWidth, width, dpr, padding } = tileMap;\n        const outerSideWidth = sideWidth / dpr;\n        const outerPadding = padding / dpr;\n        for (const rectInfo of renderBoxes) {\n            const rx = Math.floor(rectInfo.x);\n            const rw = Math.floor(rectInfo.width);\n            const outerMiddleWidth = rw - (outerSideWidth - outerPadding) * 2;\n            ctx.imageSmoothingEnabled = false;\n            ctx.drawImage(el, 0, 0, sideWidth, height, rx - outerPadding, y, outerSideWidth, h);\n            if (outerMiddleWidth > 0)\n                ctx.drawImage(el, sideWidth, 0, middleWidth, height, rx + (outerSideWidth - outerPadding), y, outerMiddleWidth, h);\n            ctx.drawImage(el, width - sideWidth, 0, sideWidth, height, rx + rw - (outerSideWidth - outerPadding), y, outerSideWidth, h);\n            ctx.imageSmoothingEnabled = true;\n        }\n    }\n    ctx.beginPath();\n    for (const [i, rectInfo] of renderBoxes.entries()) {\n        const d = data[i];\n        let drawX = rectInfo.x + bubblePad;\n        if (d.img !== undefined) {\n            const img = imageLoader.loadOrGetImage(d.img, col, row);\n            if (img !== undefined) {\n                const imgSize = bubbleHeight - 8;\n                let srcX = 0;\n                let srcY = 0;\n                let srcWidth = img.width;\n                let srcHeight = img.height;\n                if (srcWidth > srcHeight) {\n                    // landscape\n                    srcX += (srcWidth - srcHeight) / 2;\n                    srcWidth = srcHeight;\n                }\n                else if (srcHeight > srcWidth) {\n                    //portrait\n                    srcY += (srcHeight - srcWidth) / 2;\n                    srcHeight = srcWidth;\n                }\n                ctx.beginPath();\n                (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.roundedRect)(ctx, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize, theme.roundingRadius ?? 3);\n                ctx.save();\n                ctx.clip();\n                ctx.drawImage(img, srcX, srcY, srcWidth, srcHeight, drawX, y + h / 2 - imgSize / 2, imgSize, imgSize);\n                ctx.restore();\n                drawX += imgSize + 4;\n            }\n        }\n        ctx.beginPath();\n        ctx.fillStyle = theme.textBubble;\n        ctx.fillText(d.text, drawX, y + h / 2 + (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.getMiddleCenterBias)(ctx, theme));\n    }\n}\n//# sourceMappingURL=drilldown-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvZHJpbGxkb3duLWNlbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDK0I7QUFDK0U7QUFDb0I7QUFDMUQ7QUFDSDtBQUM5RDtBQUNQLGlDQUFpQyxpRkFBK0I7QUFDaEUsVUFBVSxnRkFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZUFBZSxnREFBbUIsQ0FBQyw4R0FBc0IsSUFBSSx3QkFBd0I7QUFDckYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU8sR0FBRyxPQUFPLEdBQUcsSUFBSSxHQUFHLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3RkFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3RkFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUEwQztBQUN0RCxZQUFZLGNBQWM7QUFDMUI7QUFDQSxxQkFBcUIsd0ZBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhGQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUEwRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3RkFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0dBQW1CO0FBQ25FO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NlbGxzL2RyaWxsZG93bi1jZWxsLmpzPzQ1MjciXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcmVhY3QvZGlzcGxheS1uYW1lICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBEcmlsbGRvd25PdmVybGF5RWRpdG9yIGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9kcmlsbGRvd24tb3ZlcmxheS1lZGl0b3IuanNcIjtcbmltcG9ydCB7IGdldEVtSGVpZ2h0LCBnZXRNaWRkbGVDZW50ZXJCaWFzLCBtZWFzdXJlVGV4dENhY2hlZCwgcm91bmRlZFJlY3QsIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9yZW5kZXIvZGF0YS1ncmlkLWxpYi5qc1wiO1xuaW1wb3J0IHsgR3JpZENlbGxLaW5kIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmltcG9ydCB7IG1ha2VBY2Nlc3NpYmlsaXR5U3RyaW5nRm9yQXJyYXkgfSBmcm9tIFwiLi4vY29tbW9uL3V0aWxzLmpzXCI7XG5leHBvcnQgY29uc3QgZHJpbGxkb3duQ2VsbFJlbmRlcmVyID0ge1xuICAgIGdldEFjY2Vzc2liaWxpdHlTdHJpbmc6IGMgPT4gbWFrZUFjY2Vzc2liaWxpdHlTdHJpbmdGb3JBcnJheShjLmRhdGEubWFwKGQgPT4gZC50ZXh0KSksXG4gICAga2luZDogR3JpZENlbGxLaW5kLkRyaWxsZG93bixcbiAgICBuZWVkc0hvdmVyOiBmYWxzZSxcbiAgICB1c2VMYWJlbDogZmFsc2UsXG4gICAgbmVlZHNIb3ZlclBvc2l0aW9uOiBmYWxzZSxcbiAgICBtZWFzdXJlOiAoY3R4LCBjZWxsLCB0KSA9PiBjZWxsLmRhdGEucmVkdWNlKChhY2MsIGRhdGEpID0+IGN0eC5tZWFzdXJlVGV4dChkYXRhLnRleHQpLndpZHRoICsgYWNjICsgMjAgKyAoZGF0YS5pbWcgIT09IHVuZGVmaW5lZCA/IDE4IDogMCksIDApICtcbiAgICAgICAgMiAqIHQuY2VsbEhvcml6b250YWxQYWRkaW5nIC1cbiAgICAgICAgNCxcbiAgICBkcmF3OiBhID0+IGRyYXdEcmlsbGRvd25DZWxsKGEsIGEuY2VsbC5kYXRhKSxcbiAgICBwcm92aWRlRWRpdG9yOiAoKSA9PiBwID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gcDtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJpbGxkb3duT3ZlcmxheUVkaXRvciwgeyBkcmlsbGRvd25zOiB2YWx1ZS5kYXRhIH0pO1xuICAgIH0sXG4gICAgb25QYXN0ZTogKCkgPT4gdW5kZWZpbmVkLFxufTtcbmNvbnN0IGl0ZW1NYXJnaW4gPSA0O1xuY29uc3QgZHJpbGxkb3duQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldEFuZENhY2hlRHJpbGxkb3duQm9yZGVyKGJnQ2VsbCwgYm9yZGVyLCBoZWlnaHQsIHJvdW5kaW5nKSB7XG4gICAgY29uc3QgZHByID0gTWF0aC5jZWlsKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICBjb25zdCBzaGFkb3dCbHVyID0gNTtcbiAgICBjb25zdCB0YXJnZXRIZWlnaHQgPSBoZWlnaHQgLSBzaGFkb3dCbHVyICogMjtcbiAgICBjb25zdCBtaWRkbGVXaWR0aCA9IDQ7XG4gICAgY29uc3QgaW5uZXJIZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG4gICAgY29uc3Qgc2lkZVdpZHRoID0gcm91bmRpbmcgKyBzaGFkb3dCbHVyO1xuICAgIGNvbnN0IHRhcmdldFdpZHRoID0gcm91bmRpbmcgKiAzO1xuICAgIGNvbnN0IGlubmVyV2lkdGggPSAodGFyZ2V0V2lkdGggKyBzaGFkb3dCbHVyICogMikgKiBkcHI7XG4gICAgY29uc3Qga2V5ID0gYCR7YmdDZWxsfSwke2JvcmRlcn0sJHtkcHJ9LCR7aGVpZ2h0fWA7XG4gICAgaWYgKGRyaWxsZG93bkNhY2hlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWw6IGRyaWxsZG93bkNhY2hlW2tleV0sXG4gICAgICAgICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IGlubmVyV2lkdGgsXG4gICAgICAgICAgICBtaWRkbGVXaWR0aDogbWlkZGxlV2lkdGggKiBkcHIsXG4gICAgICAgICAgICBzaWRlV2lkdGg6IHNpZGVXaWR0aCAqIGRwcixcbiAgICAgICAgICAgIHBhZGRpbmc6IHNoYWRvd0JsdXIgKiBkcHIsXG4gICAgICAgICAgICBkcHIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTsgLy8gYWxwaGEgbmVlZGVkXG4gICAgaWYgKGN0eCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FudmFzLndpZHRoID0gaW5uZXJXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW5uZXJIZWlnaHQ7XG4gICAgY3R4LnNjYWxlKGRwciwgZHByKTtcbiAgICBkcmlsbGRvd25DYWNoZVtrZXldID0gY2FudmFzO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICByb3VuZGVkUmVjdChjdHgsIHNoYWRvd0JsdXIsIHNoYWRvd0JsdXIsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHJvdW5kaW5nKTtcbiAgICBjdHguc2hhZG93Q29sb3IgPSBcInJnYmEoMjQsIDI1LCAzNCwgMC40KVwiO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gMTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmdDZWxsO1xuICAgIGN0eC5maWxsKCk7XG4gICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDI0LCAyNSwgMzQsIDAuMylcIjtcbiAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDE7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSA1O1xuICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NlbGw7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgcm91bmRlZFJlY3QoY3R4LCBzaGFkb3dCbHVyICsgMC41LCBzaGFkb3dCbHVyICsgMC41LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCByb3VuZGluZyk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbDogY2FudmFzLFxuICAgICAgICBoZWlnaHQ6IGlubmVySGVpZ2h0LFxuICAgICAgICB3aWR0aDogaW5uZXJXaWR0aCxcbiAgICAgICAgc2lkZVdpZHRoOiBzaWRlV2lkdGggKiBkcHIsXG4gICAgICAgIG1pZGRsZVdpZHRoOiByb3VuZGluZyAqIGRwcixcbiAgICAgICAgcGFkZGluZzogc2hhZG93Qmx1ciAqIGRwcixcbiAgICAgICAgZHByLFxuICAgIH07XG59XG5mdW5jdGlvbiBkcmF3RHJpbGxkb3duQ2VsbChhcmdzLCBkYXRhKSB7XG4gICAgY29uc3QgeyByZWN0LCB0aGVtZSwgY3R4LCBpbWFnZUxvYWRlciwgY29sLCByb3cgfSA9IGFyZ3M7XG4gICAgY29uc3QgeyB4LCB3aWR0aDogdyB9ID0gcmVjdDtcbiAgICBjb25zdCBmb250ID0gdGhlbWUuYmFzZUZvbnRGdWxsO1xuICAgIGNvbnN0IGVtSGVpZ2h0ID0gZ2V0RW1IZWlnaHQoY3R4LCBmb250KTtcbiAgICBjb25zdCBoID0gTWF0aC5taW4ocmVjdC5oZWlnaHQsIE1hdGgubWF4KDE2LCBNYXRoLmNlaWwoZW1IZWlnaHQgKiB0aGVtZS5saW5lSGVpZ2h0KSAqIDIpKTtcbiAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihyZWN0LnkgKyAocmVjdC5oZWlnaHQgLSBoKSAvIDIpO1xuICAgIGNvbnN0IGJ1YmJsZUhlaWdodCA9IGggLSAxMDtcbiAgICBjb25zdCBidWJibGVQYWQgPSA4O1xuICAgIGNvbnN0IGJ1YmJsZU1hcmdpbiA9IGl0ZW1NYXJnaW47XG4gICAgbGV0IHJlbmRlclggPSB4ICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nO1xuICAgIGNvbnN0IHJvdW5kaW5nID0gdGhlbWUucm91bmRpbmdSYWRpdXMgPz8gNjtcbiAgICBjb25zdCB0aWxlTWFwID0gZ2V0QW5kQ2FjaGVEcmlsbGRvd25Cb3JkZXIodGhlbWUuYmdDZWxsLCB0aGVtZS5kcmlsbGRvd25Cb3JkZXIsIGgsIHJvdW5kaW5nKTtcbiAgICBjb25zdCByZW5kZXJCb3hlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWwgb2YgZGF0YSkge1xuICAgICAgICBpZiAocmVuZGVyWCA+IHggKyB3KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnN0IHRleHRNZXRyaWNzID0gbWVhc3VyZVRleHRDYWNoZWQoZWwudGV4dCwgY3R4LCBmb250KTtcbiAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gdGV4dE1ldHJpY3Mud2lkdGg7XG4gICAgICAgIGxldCBpbWdXaWR0aCA9IDA7XG4gICAgICAgIGlmIChlbC5pbWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgaW1nID0gaW1hZ2VMb2FkZXIubG9hZE9yR2V0SW1hZ2UoZWwuaW1nLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICBpZiAoaW1nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbWdXaWR0aCA9IGJ1YmJsZUhlaWdodCAtIDggKyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlcldpZHRoID0gdGV4dFdpZHRoICsgaW1nV2lkdGggKyBidWJibGVQYWQgKiAyO1xuICAgICAgICByZW5kZXJCb3hlcy5wdXNoKHtcbiAgICAgICAgICAgIHg6IHJlbmRlclgsXG4gICAgICAgICAgICB3aWR0aDogcmVuZGVyV2lkdGgsXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJYICs9IHJlbmRlcldpZHRoICsgYnViYmxlTWFyZ2luO1xuICAgIH1cbiAgICBpZiAodGlsZU1hcCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IGVsLCBoZWlnaHQsIG1pZGRsZVdpZHRoLCBzaWRlV2lkdGgsIHdpZHRoLCBkcHIsIHBhZGRpbmcgfSA9IHRpbGVNYXA7XG4gICAgICAgIGNvbnN0IG91dGVyU2lkZVdpZHRoID0gc2lkZVdpZHRoIC8gZHByO1xuICAgICAgICBjb25zdCBvdXRlclBhZGRpbmcgPSBwYWRkaW5nIC8gZHByO1xuICAgICAgICBmb3IgKGNvbnN0IHJlY3RJbmZvIG9mIHJlbmRlckJveGVzKSB7XG4gICAgICAgICAgICBjb25zdCByeCA9IE1hdGguZmxvb3IocmVjdEluZm8ueCk7XG4gICAgICAgICAgICBjb25zdCBydyA9IE1hdGguZmxvb3IocmVjdEluZm8ud2lkdGgpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ZXJNaWRkbGVXaWR0aCA9IHJ3IC0gKG91dGVyU2lkZVdpZHRoIC0gb3V0ZXJQYWRkaW5nKSAqIDI7XG4gICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGVsLCAwLCAwLCBzaWRlV2lkdGgsIGhlaWdodCwgcnggLSBvdXRlclBhZGRpbmcsIHksIG91dGVyU2lkZVdpZHRoLCBoKTtcbiAgICAgICAgICAgIGlmIChvdXRlck1pZGRsZVdpZHRoID4gMClcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGVsLCBzaWRlV2lkdGgsIDAsIG1pZGRsZVdpZHRoLCBoZWlnaHQsIHJ4ICsgKG91dGVyU2lkZVdpZHRoIC0gb3V0ZXJQYWRkaW5nKSwgeSwgb3V0ZXJNaWRkbGVXaWR0aCwgaCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGVsLCB3aWR0aCAtIHNpZGVXaWR0aCwgMCwgc2lkZVdpZHRoLCBoZWlnaHQsIHJ4ICsgcncgLSAob3V0ZXJTaWRlV2lkdGggLSBvdXRlclBhZGRpbmcpLCB5LCBvdXRlclNpZGVXaWR0aCwgaCk7XG4gICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yIChjb25zdCBbaSwgcmVjdEluZm9dIG9mIHJlbmRlckJveGVzLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBkID0gZGF0YVtpXTtcbiAgICAgICAgbGV0IGRyYXdYID0gcmVjdEluZm8ueCArIGJ1YmJsZVBhZDtcbiAgICAgICAgaWYgKGQuaW1nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGltYWdlTG9hZGVyLmxvYWRPckdldEltYWdlKGQuaW1nLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICBpZiAoaW1nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWdTaXplID0gYnViYmxlSGVpZ2h0IC0gODtcbiAgICAgICAgICAgICAgICBsZXQgc3JjWCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHNyY1kgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBzcmNXaWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgc3JjSGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoc3JjV2lkdGggPiBzcmNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFuZHNjYXBlXG4gICAgICAgICAgICAgICAgICAgIHNyY1ggKz0gKHNyY1dpZHRoIC0gc3JjSGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHNyY1dpZHRoID0gc3JjSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzcmNIZWlnaHQgPiBzcmNXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAvL3BvcnRyYWl0XG4gICAgICAgICAgICAgICAgICAgIHNyY1kgKz0gKHNyY0hlaWdodCAtIHNyY1dpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHNyY0hlaWdodCA9IHNyY1dpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgcm91bmRlZFJlY3QoY3R4LCBkcmF3WCwgeSArIGggLyAyIC0gaW1nU2l6ZSAvIDIsIGltZ1NpemUsIGltZ1NpemUsIHRoZW1lLnJvdW5kaW5nUmFkaXVzID8/IDMpO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgc3JjWCwgc3JjWSwgc3JjV2lkdGgsIHNyY0hlaWdodCwgZHJhd1gsIHkgKyBoIC8gMiAtIGltZ1NpemUgLyAyLCBpbWdTaXplLCBpbWdTaXplKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIGRyYXdYICs9IGltZ1NpemUgKyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lLnRleHRCdWJibGU7XG4gICAgICAgIGN0eC5maWxsVGV4dChkLnRleHQsIGRyYXdYLCB5ICsgaCAvIDIgKyBnZXRNaWRkbGVDZW50ZXJCaWFzKGN0eCwgdGhlbWUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kcmlsbGRvd24tY2VsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/drilldown-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/image-cell.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/image-cell.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawImage: () => (/* binding */ drawImage),\n/* harmony export */   imageCellRenderer: () => (/* binding */ imageCellRenderer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_data_grid_overlay_editor_private_image_overlay_editor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid-overlay-editor/private/image-overlay-editor.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/image-overlay-editor.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* eslint-disable react/display-name */\n\n\n\n\nconst imageCellRenderer = {\n    getAccessibilityString: c => c.data.join(\", \"),\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Image,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    draw: a => drawImage(a, a.cell.displayData ?? a.cell.data, a.cell.rounding ?? a.theme.roundingRadius ?? 4, a.cell.contentAlign),\n    measure: (_ctx, cell) => cell.data.length * 50,\n    onDelete: c => ({\n        ...c,\n        data: [],\n    }),\n    provideEditor: () => p => {\n        const { value, onFinishedEditing, imageEditorOverride } = p;\n        const ImageEditor = imageEditorOverride ?? _internal_data_grid_overlay_editor_private_image_overlay_editor_js__WEBPACK_IMPORTED_MODULE_2__.ImageOverlayEditor;\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(ImageEditor, { urls: value.data, canWrite: value.readonly !== false, onCancel: onFinishedEditing, onChange: newImage => {\n                onFinishedEditing({\n                    ...value,\n                    data: [newImage],\n                });\n            } }));\n    },\n    onPaste: (toPaste, cell) => {\n        toPaste = toPaste.trim();\n        const fragments = toPaste.split(\",\");\n        const uris = fragments\n            .map(f => {\n            try {\n                new URL(f);\n                return f;\n            }\n            catch {\n                return undefined;\n            }\n        })\n            .filter(x => x !== undefined);\n        if (uris.length === cell.data.length && uris.every((u, i) => u === cell.data[i]))\n            return undefined;\n        return {\n            ...cell,\n            data: uris,\n        };\n    },\n};\nconst itemMargin = 4;\nfunction drawImage(args, data, rounding, contentAlign) {\n    const { rect, col, row, theme, ctx, imageLoader } = args;\n    const { x, y, height: h, width: w } = rect;\n    const imgHeight = h - theme.cellVerticalPadding * 2;\n    const images = [];\n    let totalWidth = 0;\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < data.length; index++) {\n        const i = data[index];\n        if (i.length === 0)\n            continue;\n        const img = imageLoader.loadOrGetImage(i, col, row);\n        if (img !== undefined) {\n            images[index] = img;\n            const imgWidth = img.width * (imgHeight / img.height);\n            totalWidth += imgWidth + itemMargin;\n        }\n    }\n    if (totalWidth === 0)\n        return;\n    totalWidth -= itemMargin;\n    let drawX = x + theme.cellHorizontalPadding;\n    if (contentAlign === \"right\")\n        drawX = Math.floor(x + w - theme.cellHorizontalPadding - totalWidth);\n    else if (contentAlign === \"center\")\n        drawX = Math.floor(x + w / 2 - totalWidth / 2);\n    for (const img of images) {\n        if (img === undefined)\n            continue; //array is sparse\n        const imgWidth = img.width * (imgHeight / img.height);\n        if (rounding > 0) {\n            ctx.beginPath();\n            (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_3__.roundedRect)(ctx, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight, rounding);\n            ctx.save();\n            ctx.clip();\n        }\n        ctx.drawImage(img, drawX, y + theme.cellVerticalPadding, imgWidth, imgHeight);\n        if (rounding > 0) {\n            ctx.restore();\n        }\n        drawX += imgWidth + itemMargin;\n    }\n}\n//# sourceMappingURL=image-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvaW1hZ2UtY2VsbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUMrQjtBQUMyRTtBQUM5QjtBQUNKO0FBQ2pFO0FBQ1A7QUFDQSxVQUFVLGdGQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLG1EQUFtRCxrSEFBa0I7QUFDckUsZ0JBQWdCLGdEQUFtQixnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLFlBQVksMENBQTBDO0FBQ3RELFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0ZBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NlbGxzL2ltYWdlLWNlbGwuanM/YjkyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9kaXNwbGF5LW5hbWUgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgSW1hZ2VPdmVybGF5RWRpdG9yIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2ltYWdlLW92ZXJsYXktZWRpdG9yLmpzXCI7XG5pbXBvcnQgeyByb3VuZGVkUmVjdCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RhdGEtZ3JpZC1saWIuanNcIjtcbmltcG9ydCB7IEdyaWRDZWxsS2luZCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5leHBvcnQgY29uc3QgaW1hZ2VDZWxsUmVuZGVyZXIgPSB7XG4gICAgZ2V0QWNjZXNzaWJpbGl0eVN0cmluZzogYyA9PiBjLmRhdGEuam9pbihcIiwgXCIpLFxuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5JbWFnZSxcbiAgICBuZWVkc0hvdmVyOiBmYWxzZSxcbiAgICB1c2VMYWJlbDogZmFsc2UsXG4gICAgbmVlZHNIb3ZlclBvc2l0aW9uOiBmYWxzZSxcbiAgICBkcmF3OiBhID0+IGRyYXdJbWFnZShhLCBhLmNlbGwuZGlzcGxheURhdGEgPz8gYS5jZWxsLmRhdGEsIGEuY2VsbC5yb3VuZGluZyA/PyBhLnRoZW1lLnJvdW5kaW5nUmFkaXVzID8/IDQsIGEuY2VsbC5jb250ZW50QWxpZ24pLFxuICAgIG1lYXN1cmU6IChfY3R4LCBjZWxsKSA9PiBjZWxsLmRhdGEubGVuZ3RoICogNTAsXG4gICAgb25EZWxldGU6IGMgPT4gKHtcbiAgICAgICAgLi4uYyxcbiAgICAgICAgZGF0YTogW10sXG4gICAgfSksXG4gICAgcHJvdmlkZUVkaXRvcjogKCkgPT4gcCA9PiB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIG9uRmluaXNoZWRFZGl0aW5nLCBpbWFnZUVkaXRvck92ZXJyaWRlIH0gPSBwO1xuICAgICAgICBjb25zdCBJbWFnZUVkaXRvciA9IGltYWdlRWRpdG9yT3ZlcnJpZGUgPz8gSW1hZ2VPdmVybGF5RWRpdG9yO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW1hZ2VFZGl0b3IsIHsgdXJsczogdmFsdWUuZGF0YSwgY2FuV3JpdGU6IHZhbHVlLnJlYWRvbmx5ICE9PSBmYWxzZSwgb25DYW5jZWw6IG9uRmluaXNoZWRFZGl0aW5nLCBvbkNoYW5nZTogbmV3SW1hZ2UgPT4ge1xuICAgICAgICAgICAgICAgIG9uRmluaXNoZWRFZGl0aW5nKHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFtuZXdJbWFnZV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IH0pKTtcbiAgICB9LFxuICAgIG9uUGFzdGU6ICh0b1Bhc3RlLCBjZWxsKSA9PiB7XG4gICAgICAgIHRvUGFzdGUgPSB0b1Bhc3RlLnRyaW0oKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRzID0gdG9QYXN0ZS5zcGxpdChcIixcIik7XG4gICAgICAgIGNvbnN0IHVyaXMgPSBmcmFnbWVudHNcbiAgICAgICAgICAgIC5tYXAoZiA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBVUkwoZik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAodXJpcy5sZW5ndGggPT09IGNlbGwuZGF0YS5sZW5ndGggJiYgdXJpcy5ldmVyeSgodSwgaSkgPT4gdSA9PT0gY2VsbC5kYXRhW2ldKSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgZGF0YTogdXJpcyxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbmNvbnN0IGl0ZW1NYXJnaW4gPSA0O1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdJbWFnZShhcmdzLCBkYXRhLCByb3VuZGluZywgY29udGVudEFsaWduKSB7XG4gICAgY29uc3QgeyByZWN0LCBjb2wsIHJvdywgdGhlbWUsIGN0eCwgaW1hZ2VMb2FkZXIgfSA9IGFyZ3M7XG4gICAgY29uc3QgeyB4LCB5LCBoZWlnaHQ6IGgsIHdpZHRoOiB3IH0gPSByZWN0O1xuICAgIGNvbnN0IGltZ0hlaWdodCA9IGggLSB0aGVtZS5jZWxsVmVydGljYWxQYWRkaW5nICogMjtcbiAgICBjb25zdCBpbWFnZXMgPSBbXTtcbiAgICBsZXQgdG90YWxXaWR0aCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tZm9yLWxvb3BcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGF0YS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgaSA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoaS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgaW1nID0gaW1hZ2VMb2FkZXIubG9hZE9yR2V0SW1hZ2UoaSwgY29sLCByb3cpO1xuICAgICAgICBpZiAoaW1nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGltYWdlc1tpbmRleF0gPSBpbWc7XG4gICAgICAgICAgICBjb25zdCBpbWdXaWR0aCA9IGltZy53aWR0aCAqIChpbWdIZWlnaHQgLyBpbWcuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gaW1nV2lkdGggKyBpdGVtTWFyZ2luO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0b3RhbFdpZHRoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgdG90YWxXaWR0aCAtPSBpdGVtTWFyZ2luO1xuICAgIGxldCBkcmF3WCA9IHggKyB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgaWYgKGNvbnRlbnRBbGlnbiA9PT0gXCJyaWdodFwiKVxuICAgICAgICBkcmF3WCA9IE1hdGguZmxvb3IoeCArIHcgLSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmcgLSB0b3RhbFdpZHRoKTtcbiAgICBlbHNlIGlmIChjb250ZW50QWxpZ24gPT09IFwiY2VudGVyXCIpXG4gICAgICAgIGRyYXdYID0gTWF0aC5mbG9vcih4ICsgdyAvIDIgLSB0b3RhbFdpZHRoIC8gMik7XG4gICAgZm9yIChjb25zdCBpbWcgb2YgaW1hZ2VzKSB7XG4gICAgICAgIGlmIChpbWcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvL2FycmF5IGlzIHNwYXJzZVxuICAgICAgICBjb25zdCBpbWdXaWR0aCA9IGltZy53aWR0aCAqIChpbWdIZWlnaHQgLyBpbWcuaGVpZ2h0KTtcbiAgICAgICAgaWYgKHJvdW5kaW5nID4gMCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgcm91bmRlZFJlY3QoY3R4LCBkcmF3WCwgeSArIHRoZW1lLmNlbGxWZXJ0aWNhbFBhZGRpbmcsIGltZ1dpZHRoLCBpbWdIZWlnaHQsIHJvdW5kaW5nKTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCBkcmF3WCwgeSArIHRoZW1lLmNlbGxWZXJ0aWNhbFBhZGRpbmcsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICBpZiAocm91bmRpbmcgPiAwKSB7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdYICs9IGltZ1dpZHRoICsgaXRlbU1hcmdpbjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1jZWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/image-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllCellRenderers: () => (/* binding */ AllCellRenderers)\n/* harmony export */ });\n/* harmony import */ var _boolean_cell_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./boolean-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/boolean-cell.js\");\n/* harmony import */ var _bubble_cell_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bubble-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/bubble-cell.js\");\n/* harmony import */ var _drilldown_cell_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drilldown-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/drilldown-cell.js\");\n/* harmony import */ var _image_cell_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./image-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/image-cell.js\");\n/* harmony import */ var _loading_cell_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loading-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/loading-cell.js\");\n/* harmony import */ var _markdown_cell_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./markdown-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/markdown-cell.js\");\n/* harmony import */ var _marker_cell_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./marker-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/marker-cell.js\");\n/* harmony import */ var _new_row_cell_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./new-row-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/new-row-cell.js\");\n/* harmony import */ var _number_cell_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./number-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/number-cell.js\");\n/* harmony import */ var _protected_cell_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./protected-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/protected-cell.js\");\n/* harmony import */ var _row_id_cell_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./row-id-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/row-id-cell.js\");\n/* harmony import */ var _text_cell_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./text-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/text-cell.js\");\n/* harmony import */ var _uri_cell_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./uri-cell.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/uri-cell.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst AllCellRenderers = [\n    _marker_cell_js__WEBPACK_IMPORTED_MODULE_0__.markerCellRenderer,\n    _new_row_cell_js__WEBPACK_IMPORTED_MODULE_1__.newRowCellRenderer,\n    _boolean_cell_js__WEBPACK_IMPORTED_MODULE_2__.booleanCellRenderer,\n    _bubble_cell_js__WEBPACK_IMPORTED_MODULE_3__.bubbleCellRenderer,\n    _drilldown_cell_js__WEBPACK_IMPORTED_MODULE_4__.drilldownCellRenderer,\n    _image_cell_js__WEBPACK_IMPORTED_MODULE_5__.imageCellRenderer,\n    _loading_cell_js__WEBPACK_IMPORTED_MODULE_6__.loadingCellRenderer,\n    _markdown_cell_js__WEBPACK_IMPORTED_MODULE_7__.markdownCellRenderer,\n    _number_cell_js__WEBPACK_IMPORTED_MODULE_8__.numberCellRenderer,\n    _protected_cell_js__WEBPACK_IMPORTED_MODULE_9__.protectedCellRenderer,\n    _row_id_cell_js__WEBPACK_IMPORTED_MODULE_10__.rowIDCellRenderer,\n    _text_cell_js__WEBPACK_IMPORTED_MODULE_11__.textCellRenderer,\n    _uri_cell_js__WEBPACK_IMPORTED_MODULE_12__.uriCellRenderer,\n];\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDRjtBQUNGO0FBQ007QUFDUjtBQUNJO0FBQ0U7QUFDSjtBQUNDO0FBQ0Q7QUFDTTtBQUNQO0FBQ0g7QUFDRjtBQUN6QztBQUNQLElBQUksK0RBQWtCO0FBQ3RCLElBQUksZ0VBQWtCO0FBQ3RCLElBQUksaUVBQW1CO0FBQ3ZCLElBQUksK0RBQWtCO0FBQ3RCLElBQUkscUVBQXFCO0FBQ3pCLElBQUksNkRBQWlCO0FBQ3JCLElBQUksaUVBQW1CO0FBQ3ZCLElBQUksbUVBQW9CO0FBQ3hCLElBQUksK0RBQWtCO0FBQ3RCLElBQUkscUVBQXFCO0FBQ3pCLElBQUksK0RBQWlCO0FBQ3JCLElBQUksNERBQWdCO0FBQ3BCLElBQUksMERBQWU7QUFDbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NlbGxzL2luZGV4LmpzPzhhM2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5pbXBvcnQgeyBib29sZWFuQ2VsbFJlbmRlcmVyIH0gZnJvbSBcIi4vYm9vbGVhbi1jZWxsLmpzXCI7XG5pbXBvcnQgeyBidWJibGVDZWxsUmVuZGVyZXIgfSBmcm9tIFwiLi9idWJibGUtY2VsbC5qc1wiO1xuaW1wb3J0IHsgZHJpbGxkb3duQ2VsbFJlbmRlcmVyIH0gZnJvbSBcIi4vZHJpbGxkb3duLWNlbGwuanNcIjtcbmltcG9ydCB7IGltYWdlQ2VsbFJlbmRlcmVyIH0gZnJvbSBcIi4vaW1hZ2UtY2VsbC5qc1wiO1xuaW1wb3J0IHsgbG9hZGluZ0NlbGxSZW5kZXJlciB9IGZyb20gXCIuL2xvYWRpbmctY2VsbC5qc1wiO1xuaW1wb3J0IHsgbWFya2Rvd25DZWxsUmVuZGVyZXIgfSBmcm9tIFwiLi9tYXJrZG93bi1jZWxsLmpzXCI7XG5pbXBvcnQgeyBtYXJrZXJDZWxsUmVuZGVyZXIgfSBmcm9tIFwiLi9tYXJrZXItY2VsbC5qc1wiO1xuaW1wb3J0IHsgbmV3Um93Q2VsbFJlbmRlcmVyIH0gZnJvbSBcIi4vbmV3LXJvdy1jZWxsLmpzXCI7XG5pbXBvcnQgeyBudW1iZXJDZWxsUmVuZGVyZXIgfSBmcm9tIFwiLi9udW1iZXItY2VsbC5qc1wiO1xuaW1wb3J0IHsgcHJvdGVjdGVkQ2VsbFJlbmRlcmVyIH0gZnJvbSBcIi4vcHJvdGVjdGVkLWNlbGwuanNcIjtcbmltcG9ydCB7IHJvd0lEQ2VsbFJlbmRlcmVyIH0gZnJvbSBcIi4vcm93LWlkLWNlbGwuanNcIjtcbmltcG9ydCB7IHRleHRDZWxsUmVuZGVyZXIgfSBmcm9tIFwiLi90ZXh0LWNlbGwuanNcIjtcbmltcG9ydCB7IHVyaUNlbGxSZW5kZXJlciB9IGZyb20gXCIuL3VyaS1jZWxsLmpzXCI7XG5leHBvcnQgY29uc3QgQWxsQ2VsbFJlbmRlcmVycyA9IFtcbiAgICBtYXJrZXJDZWxsUmVuZGVyZXIsXG4gICAgbmV3Um93Q2VsbFJlbmRlcmVyLFxuICAgIGJvb2xlYW5DZWxsUmVuZGVyZXIsXG4gICAgYnViYmxlQ2VsbFJlbmRlcmVyLFxuICAgIGRyaWxsZG93bkNlbGxSZW5kZXJlcixcbiAgICBpbWFnZUNlbGxSZW5kZXJlcixcbiAgICBsb2FkaW5nQ2VsbFJlbmRlcmVyLFxuICAgIG1hcmtkb3duQ2VsbFJlbmRlcmVyLFxuICAgIG51bWJlckNlbGxSZW5kZXJlcixcbiAgICBwcm90ZWN0ZWRDZWxsUmVuZGVyZXIsXG4gICAgcm93SURDZWxsUmVuZGVyZXIsXG4gICAgdGV4dENlbGxSZW5kZXJlcixcbiAgICB1cmlDZWxsUmVuZGVyZXIsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/loading-cell.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/loading-cell.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadingCellRenderer: () => (/* binding */ loadingCellRenderer)\n/* harmony export */ });\n/* harmony import */ var _internal_data_grid_color_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/color-parser.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n\n\n\n// returns a \"random\" number between -1 and 1\nfunction getRandomNumber(x, y) {\n    let seed = x * 49632 + y * 325176;\n    // Inline Xorshift algorithm\n    seed ^= seed << 13;\n    seed ^= seed >> 17;\n    seed ^= seed << 5;\n    // eslint-disable-next-line unicorn/number-literal-case\n    return (seed / 4294967295) * 2;\n}\nconst loadingCellRenderer = {\n    getAccessibilityString: () => \"\",\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Loading,\n    needsHover: false,\n    useLabel: false,\n    needsHoverPosition: false,\n    measure: () => 120,\n    draw: a => {\n        const { cell, col, row, ctx, rect, theme } = a;\n        if (cell.skeletonWidth === undefined || cell.skeletonWidth === 0) {\n            return;\n        }\n        let width = cell.skeletonWidth;\n        if (cell.skeletonWidthVariability !== undefined && cell.skeletonWidthVariability > 0) {\n            width += Math.round(getRandomNumber(col, row) * cell.skeletonWidthVariability);\n        }\n        const hpad = theme.cellHorizontalPadding;\n        const rectHeight = cell.skeletonHeight ?? Math.min(18, rect.height - 2 * theme.cellVerticalPadding);\n        (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.roundedRect)(ctx, rect.x + hpad, rect.y + (rect.height - rectHeight) / 2, width, rectHeight, theme.roundingRadius ?? 3);\n        ctx.fillStyle = (0,_internal_data_grid_color_parser_js__WEBPACK_IMPORTED_MODULE_2__.withAlpha)(theme.textDark, 0.1);\n        ctx.fill();\n    },\n    onPaste: () => undefined,\n};\n//# sourceMappingURL=loading-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvbG9hZGluZy1jZWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0U7QUFDVTtBQUNKO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFVBQVUsZ0ZBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3RkFBVztBQUNuQix3QkFBd0IsOEVBQVM7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvbG9hZGluZy1jZWxsLmpzPzY0NjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2l0aEFscGhhIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9jb2xvci1wYXJzZXIuanNcIjtcbmltcG9ydCB7IHJvdW5kZWRSZWN0IH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9yZW5kZXIvZGF0YS1ncmlkLWxpYi5qc1wiO1xuaW1wb3J0IHsgR3JpZENlbGxLaW5kIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbi8vIHJldHVybnMgYSBcInJhbmRvbVwiIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxXG5mdW5jdGlvbiBnZXRSYW5kb21OdW1iZXIoeCwgeSkge1xuICAgIGxldCBzZWVkID0geCAqIDQ5NjMyICsgeSAqIDMyNTE3NjtcbiAgICAvLyBJbmxpbmUgWG9yc2hpZnQgYWxnb3JpdGhtXG4gICAgc2VlZCBePSBzZWVkIDw8IDEzO1xuICAgIHNlZWQgXj0gc2VlZCA+PiAxNztcbiAgICBzZWVkIF49IHNlZWQgPDwgNTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9udW1iZXItbGl0ZXJhbC1jYXNlXG4gICAgcmV0dXJuIChzZWVkIC8gNDI5NDk2NzI5NSkgKiAyO1xufVxuZXhwb3J0IGNvbnN0IGxvYWRpbmdDZWxsUmVuZGVyZXIgPSB7XG4gICAgZ2V0QWNjZXNzaWJpbGl0eVN0cmluZzogKCkgPT4gXCJcIixcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuTG9hZGluZyxcbiAgICBuZWVkc0hvdmVyOiBmYWxzZSxcbiAgICB1c2VMYWJlbDogZmFsc2UsXG4gICAgbmVlZHNIb3ZlclBvc2l0aW9uOiBmYWxzZSxcbiAgICBtZWFzdXJlOiAoKSA9PiAxMjAsXG4gICAgZHJhdzogYSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY2VsbCwgY29sLCByb3csIGN0eCwgcmVjdCwgdGhlbWUgfSA9IGE7XG4gICAgICAgIGlmIChjZWxsLnNrZWxldG9uV2lkdGggPT09IHVuZGVmaW5lZCB8fCBjZWxsLnNrZWxldG9uV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2lkdGggPSBjZWxsLnNrZWxldG9uV2lkdGg7XG4gICAgICAgIGlmIChjZWxsLnNrZWxldG9uV2lkdGhWYXJpYWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmIGNlbGwuc2tlbGV0b25XaWR0aFZhcmlhYmlsaXR5ID4gMCkge1xuICAgICAgICAgICAgd2lkdGggKz0gTWF0aC5yb3VuZChnZXRSYW5kb21OdW1iZXIoY29sLCByb3cpICogY2VsbC5za2VsZXRvbldpZHRoVmFyaWFiaWxpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhwYWQgPSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHJlY3RIZWlnaHQgPSBjZWxsLnNrZWxldG9uSGVpZ2h0ID8/IE1hdGgubWluKDE4LCByZWN0LmhlaWdodCAtIDIgKiB0aGVtZS5jZWxsVmVydGljYWxQYWRkaW5nKTtcbiAgICAgICAgcm91bmRlZFJlY3QoY3R4LCByZWN0LnggKyBocGFkLCByZWN0LnkgKyAocmVjdC5oZWlnaHQgLSByZWN0SGVpZ2h0KSAvIDIsIHdpZHRoLCByZWN0SGVpZ2h0LCB0aGVtZS5yb3VuZGluZ1JhZGl1cyA/PyAzKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHdpdGhBbHBoYSh0aGVtZS50ZXh0RGFyaywgMC4xKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9LFxuICAgIG9uUGFzdGU6ICgpID0+IHVuZGVmaW5lZCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkaW5nLWNlbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/loading-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/markdown-cell.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/markdown-cell.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   markdownCellRenderer: () => (/* binding */ markdownCellRenderer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_data_grid_overlay_editor_private_markdown_overlay_editor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/data-grid-overlay-editor/private/markdown-overlay-editor.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/markdown-overlay-editor.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* eslint-disable react/display-name */\n\n\n\n\nconst markdownCellRenderer = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Markdown,\n    needsHover: false,\n    needsHoverPosition: false,\n    drawPrep: _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.prepTextCell,\n    measure: (ctx, cell, t) => {\n        const firstLine = cell.data.split(\"\\n\")[0];\n        return ctx.measureText(firstLine).width + 2 * t.cellHorizontalPadding;\n    },\n    draw: a => (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)(a, a.cell.data, a.cell.contentAlign),\n    onDelete: c => ({\n        ...c,\n        data: \"\",\n    }),\n    provideEditor: () => p => {\n        const { onChange, value, target, onFinishedEditing, markdownDivCreateNode, forceEditMode, validatedSelection } = p;\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_data_grid_overlay_editor_private_markdown_overlay_editor_js__WEBPACK_IMPORTED_MODULE_3__.MarkdownOverlayEditor, { onFinish: onFinishedEditing, targetRect: target, value: value, validatedSelection: validatedSelection, onChange: e => onChange({\n                ...value,\n                data: e.target.value,\n            }), forceEditMode: forceEditMode, createNode: markdownDivCreateNode }));\n    },\n    onPaste: (toPaste, cell) => (toPaste === cell.data ? undefined : { ...cell, data: toPaste }),\n};\n//# sourceMappingURL=markdown-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvbWFya2Rvd24tY2VsbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQytCO0FBQ2lGO0FBQ3JCO0FBQ25CO0FBQ2pFO0FBQ1A7QUFDQSxVQUFVLGdGQUFZO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLHFGQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLHlGQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQix1R0FBdUc7QUFDdkgsZ0JBQWdCLGdEQUFtQixDQUFDLHdIQUFxQixJQUFJO0FBQzdEO0FBQ0E7QUFDQSxhQUFhLG9FQUFvRTtBQUNqRixLQUFLO0FBQ0wsdUVBQXVFLHdCQUF3QjtBQUMvRjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvbWFya2Rvd24tY2VsbC5qcz9hZmQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L2Rpc3BsYXktbmFtZSAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBNYXJrZG93bk92ZXJsYXlFZGl0b3IgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvbWFya2Rvd24tb3ZlcmxheS1lZGl0b3IuanNcIjtcbmltcG9ydCB7IGRyYXdUZXh0Q2VsbCwgcHJlcFRleHRDZWxsIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9yZW5kZXIvZGF0YS1ncmlkLWxpYi5qc1wiO1xuaW1wb3J0IHsgR3JpZENlbGxLaW5kIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmV4cG9ydCBjb25zdCBtYXJrZG93bkNlbGxSZW5kZXJlciA9IHtcbiAgICBnZXRBY2Nlc3NpYmlsaXR5U3RyaW5nOiBjID0+IGMuZGF0YT8udG9TdHJpbmcoKSA/PyBcIlwiLFxuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5NYXJrZG93bixcbiAgICBuZWVkc0hvdmVyOiBmYWxzZSxcbiAgICBuZWVkc0hvdmVyUG9zaXRpb246IGZhbHNlLFxuICAgIGRyYXdQcmVwOiBwcmVwVGV4dENlbGwsXG4gICAgbWVhc3VyZTogKGN0eCwgY2VsbCwgdCkgPT4ge1xuICAgICAgICBjb25zdCBmaXJzdExpbmUgPSBjZWxsLmRhdGEuc3BsaXQoXCJcXG5cIilbMF07XG4gICAgICAgIHJldHVybiBjdHgubWVhc3VyZVRleHQoZmlyc3RMaW5lKS53aWR0aCArIDIgKiB0LmNlbGxIb3Jpem9udGFsUGFkZGluZztcbiAgICB9LFxuICAgIGRyYXc6IGEgPT4gZHJhd1RleHRDZWxsKGEsIGEuY2VsbC5kYXRhLCBhLmNlbGwuY29udGVudEFsaWduKSxcbiAgICBvbkRlbGV0ZTogYyA9PiAoe1xuICAgICAgICAuLi5jLFxuICAgICAgICBkYXRhOiBcIlwiLFxuICAgIH0pLFxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+IHAgPT4ge1xuICAgICAgICBjb25zdCB7IG9uQ2hhbmdlLCB2YWx1ZSwgdGFyZ2V0LCBvbkZpbmlzaGVkRWRpdGluZywgbWFya2Rvd25EaXZDcmVhdGVOb2RlLCBmb3JjZUVkaXRNb2RlLCB2YWxpZGF0ZWRTZWxlY3Rpb24gfSA9IHA7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrZG93bk92ZXJsYXlFZGl0b3IsIHsgb25GaW5pc2g6IG9uRmluaXNoZWRFZGl0aW5nLCB0YXJnZXRSZWN0OiB0YXJnZXQsIHZhbHVlOiB2YWx1ZSwgdmFsaWRhdGVkU2VsZWN0aW9uOiB2YWxpZGF0ZWRTZWxlY3Rpb24sIG9uQ2hhbmdlOiBlID0+IG9uQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBlLnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgIH0pLCBmb3JjZUVkaXRNb2RlOiBmb3JjZUVkaXRNb2RlLCBjcmVhdGVOb2RlOiBtYXJrZG93bkRpdkNyZWF0ZU5vZGUgfSkpO1xuICAgIH0sXG4gICAgb25QYXN0ZTogKHRvUGFzdGUsIGNlbGwpID0+ICh0b1Bhc3RlID09PSBjZWxsLmRhdGEgPyB1bmRlZmluZWQgOiB7IC4uLmNlbGwsIGRhdGE6IHRvUGFzdGUgfSksXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFya2Rvd24tY2VsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/markdown-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/marker-cell.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/marker-cell.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   markerCellRenderer: () => (/* binding */ markerCellRenderer)\n/* harmony export */ });\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _internal_data_grid_render_draw_checkbox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/render/draw-checkbox.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/draw-checkbox.js\");\n\n\n\nconst markerCellRenderer = {\n    getAccessibilityString: c => c.row.toString(),\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.InnerGridCellKind.Marker,\n    needsHover: true,\n    needsHoverPosition: false,\n    drawPrep: prepMarkerRowCell,\n    measure: () => 44,\n    draw: a => drawMarkerRowCell(a, a.cell.row, a.cell.checked, a.cell.markerKind, a.cell.drawHandle, a.cell.checkboxStyle),\n    onClick: e => {\n        const { bounds, cell, posX: x, posY: y } = e;\n        const { width, height } = bounds;\n        const centerX = cell.drawHandle ? 7 + (width - 7) / 2 : width / 2;\n        const centerY = height / 2;\n        if (Math.abs(x - centerX) <= 10 && Math.abs(y - centerY) <= 10) {\n            return {\n                ...cell,\n                checked: !cell.checked,\n            };\n        }\n        return undefined;\n    },\n    onPaste: () => undefined,\n};\nfunction prepMarkerRowCell(args, lastPrep) {\n    const { ctx, theme } = args;\n    const newFont = theme.markerFontFull;\n    const result = lastPrep ?? {};\n    if (result?.font !== newFont) {\n        ctx.font = newFont;\n        result.font = newFont;\n    }\n    result.deprep = deprepMarkerRowCell;\n    ctx.textAlign = \"center\";\n    return result;\n}\nfunction deprepMarkerRowCell(args) {\n    const { ctx } = args;\n    ctx.textAlign = \"start\";\n}\nfunction drawMarkerRowCell(args, index, checked, markerKind, drawHandle, style) {\n    const { ctx, rect, hoverAmount, theme } = args;\n    const { x, y, width, height } = rect;\n    const checkedboxAlpha = checked ? 1 : markerKind === \"checkbox-visible\" ? 0.6 + 0.4 * hoverAmount : hoverAmount;\n    if (markerKind !== \"number\" && checkedboxAlpha > 0) {\n        ctx.globalAlpha = checkedboxAlpha;\n        const offsetAmount = 7 * (checked ? hoverAmount : 1);\n        (0,_internal_data_grid_render_draw_checkbox_js__WEBPACK_IMPORTED_MODULE_1__.drawCheckbox)(ctx, theme, checked, drawHandle ? x + offsetAmount : x, y, drawHandle ? width - offsetAmount : width, height, true, undefined, undefined, 18, \"center\", style);\n        if (drawHandle) {\n            ctx.globalAlpha = hoverAmount;\n            ctx.beginPath();\n            for (const xOffset of [3, 6]) {\n                for (const yOffset of [-5, -1, 3]) {\n                    ctx.rect(x + xOffset, y + height / 2 + yOffset, 2, 2);\n                }\n            }\n            ctx.fillStyle = theme.textLight;\n            ctx.fill();\n            ctx.beginPath();\n        }\n        ctx.globalAlpha = 1;\n    }\n    if (markerKind === \"number\" || (markerKind === \"both\" && !checked)) {\n        const text = index.toString();\n        const fontStyle = theme.markerFontFull;\n        const start = x + width / 2;\n        if (markerKind === \"both\" && hoverAmount !== 0) {\n            ctx.globalAlpha = 1 - hoverAmount;\n        }\n        ctx.fillStyle = theme.textLight;\n        ctx.font = fontStyle;\n        ctx.fillText(text, start, y + height / 2 + (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, fontStyle));\n        if (hoverAmount !== 0) {\n            ctx.globalAlpha = 1;\n        }\n    }\n}\n//# sourceMappingURL=marker-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvbWFya2VyLWNlbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRjtBQUNQO0FBQ0E7QUFDdEU7QUFDUDtBQUNBLFVBQVUscUZBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUMsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlGQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0dBQW1CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NlbGxzL21hcmtlci1jZWxsLmpzPzgwOTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TWlkZGxlQ2VudGVyQmlhcyB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RhdGEtZ3JpZC1saWIuanNcIjtcbmltcG9ydCB7IElubmVyR3JpZENlbGxLaW5kIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmltcG9ydCB7IGRyYXdDaGVja2JveCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RyYXctY2hlY2tib3guanNcIjtcbmV4cG9ydCBjb25zdCBtYXJrZXJDZWxsUmVuZGVyZXIgPSB7XG4gICAgZ2V0QWNjZXNzaWJpbGl0eVN0cmluZzogYyA9PiBjLnJvdy50b1N0cmluZygpLFxuICAgIGtpbmQ6IElubmVyR3JpZENlbGxLaW5kLk1hcmtlcixcbiAgICBuZWVkc0hvdmVyOiB0cnVlLFxuICAgIG5lZWRzSG92ZXJQb3NpdGlvbjogZmFsc2UsXG4gICAgZHJhd1ByZXA6IHByZXBNYXJrZXJSb3dDZWxsLFxuICAgIG1lYXN1cmU6ICgpID0+IDQ0LFxuICAgIGRyYXc6IGEgPT4gZHJhd01hcmtlclJvd0NlbGwoYSwgYS5jZWxsLnJvdywgYS5jZWxsLmNoZWNrZWQsIGEuY2VsbC5tYXJrZXJLaW5kLCBhLmNlbGwuZHJhd0hhbmRsZSwgYS5jZWxsLmNoZWNrYm94U3R5bGUpLFxuICAgIG9uQ2xpY2s6IGUgPT4ge1xuICAgICAgICBjb25zdCB7IGJvdW5kcywgY2VsbCwgcG9zWDogeCwgcG9zWTogeSB9ID0gZTtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBib3VuZHM7XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBjZWxsLmRyYXdIYW5kbGUgPyA3ICsgKHdpZHRoIC0gNykgLyAyIDogd2lkdGggLyAyO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgaWYgKE1hdGguYWJzKHggLSBjZW50ZXJYKSA8PSAxMCAmJiBNYXRoLmFicyh5IC0gY2VudGVyWSkgPD0gMTApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY2VsbCxcbiAgICAgICAgICAgICAgICBjaGVja2VkOiAhY2VsbC5jaGVja2VkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb25QYXN0ZTogKCkgPT4gdW5kZWZpbmVkLFxufTtcbmZ1bmN0aW9uIHByZXBNYXJrZXJSb3dDZWxsKGFyZ3MsIGxhc3RQcmVwKSB7XG4gICAgY29uc3QgeyBjdHgsIHRoZW1lIH0gPSBhcmdzO1xuICAgIGNvbnN0IG5ld0ZvbnQgPSB0aGVtZS5tYXJrZXJGb250RnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBsYXN0UHJlcCA/PyB7fTtcbiAgICBpZiAocmVzdWx0Py5mb250ICE9PSBuZXdGb250KSB7XG4gICAgICAgIGN0eC5mb250ID0gbmV3Rm9udDtcbiAgICAgICAgcmVzdWx0LmZvbnQgPSBuZXdGb250O1xuICAgIH1cbiAgICByZXN1bHQuZGVwcmVwID0gZGVwcmVwTWFya2VyUm93Q2VsbDtcbiAgICBjdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZGVwcmVwTWFya2VyUm93Q2VsbChhcmdzKSB7XG4gICAgY29uc3QgeyBjdHggfSA9IGFyZ3M7XG4gICAgY3R4LnRleHRBbGlnbiA9IFwic3RhcnRcIjtcbn1cbmZ1bmN0aW9uIGRyYXdNYXJrZXJSb3dDZWxsKGFyZ3MsIGluZGV4LCBjaGVja2VkLCBtYXJrZXJLaW5kLCBkcmF3SGFuZGxlLCBzdHlsZSkge1xuICAgIGNvbnN0IHsgY3R4LCByZWN0LCBob3ZlckFtb3VudCwgdGhlbWUgfSA9IGFyZ3M7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0O1xuICAgIGNvbnN0IGNoZWNrZWRib3hBbHBoYSA9IGNoZWNrZWQgPyAxIDogbWFya2VyS2luZCA9PT0gXCJjaGVja2JveC12aXNpYmxlXCIgPyAwLjYgKyAwLjQgKiBob3ZlckFtb3VudCA6IGhvdmVyQW1vdW50O1xuICAgIGlmIChtYXJrZXJLaW5kICE9PSBcIm51bWJlclwiICYmIGNoZWNrZWRib3hBbHBoYSA+IDApIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gY2hlY2tlZGJveEFscGhhO1xuICAgICAgICBjb25zdCBvZmZzZXRBbW91bnQgPSA3ICogKGNoZWNrZWQgPyBob3ZlckFtb3VudCA6IDEpO1xuICAgICAgICBkcmF3Q2hlY2tib3goY3R4LCB0aGVtZSwgY2hlY2tlZCwgZHJhd0hhbmRsZSA/IHggKyBvZmZzZXRBbW91bnQgOiB4LCB5LCBkcmF3SGFuZGxlID8gd2lkdGggLSBvZmZzZXRBbW91bnQgOiB3aWR0aCwgaGVpZ2h0LCB0cnVlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMTgsIFwiY2VudGVyXCIsIHN0eWxlKTtcbiAgICAgICAgaWYgKGRyYXdIYW5kbGUpIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGhvdmVyQW1vdW50O1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB4T2Zmc2V0IG9mIFszLCA2XSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeU9mZnNldCBvZiBbLTUsIC0xLCAzXSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCh4ICsgeE9mZnNldCwgeSArIGhlaWdodCAvIDIgKyB5T2Zmc2V0LCAyLCAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dExpZ2h0O1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIH1cbiAgICBpZiAobWFya2VyS2luZCA9PT0gXCJudW1iZXJcIiB8fCAobWFya2VyS2luZCA9PT0gXCJib3RoXCIgJiYgIWNoZWNrZWQpKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBpbmRleC50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBmb250U3R5bGUgPSB0aGVtZS5tYXJrZXJGb250RnVsbDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB4ICsgd2lkdGggLyAyO1xuICAgICAgICBpZiAobWFya2VyS2luZCA9PT0gXCJib3RoXCIgJiYgaG92ZXJBbW91bnQgIT09IDApIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEgLSBob3ZlckFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dExpZ2h0O1xuICAgICAgICBjdHguZm9udCA9IGZvbnRTdHlsZTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHN0YXJ0LCB5ICsgaGVpZ2h0IC8gMiArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCBmb250U3R5bGUpKTtcbiAgICAgICAgaWYgKGhvdmVyQW1vdW50ICE9PSAwKSB7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFya2VyLWNlbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/marker-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/new-row-cell.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/new-row-cell.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   newRowCellRenderer: () => (/* binding */ newRowCellRenderer)\n/* harmony export */ });\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n\n\nconst newRowCellRenderer = {\n    getAccessibilityString: () => \"\",\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.InnerGridCellKind.NewRow,\n    needsHover: true,\n    needsHoverPosition: false,\n    measure: () => 200,\n    draw: a => drawNewRowCell(a, a.cell.hint, a.cell.icon),\n    onPaste: () => undefined,\n};\nfunction drawNewRowCell(args, data, icon) {\n    const { ctx, rect, hoverAmount, theme, spriteManager } = args;\n    const { x, y, width: w, height: h } = rect;\n    ctx.beginPath();\n    ctx.globalAlpha = hoverAmount;\n    ctx.rect(x + 1, y + 1, w, h - 2);\n    ctx.fillStyle = theme.bgHeaderHovered;\n    ctx.fill();\n    ctx.globalAlpha = 1;\n    ctx.beginPath();\n    const alwaysShowIcon = data !== \"\";\n    let textX = 0;\n    if (icon !== undefined) {\n        const padding = 8;\n        const size = h - padding;\n        const px = x + padding / 2;\n        const py = y + padding / 2;\n        spriteManager.drawSprite(icon, \"normal\", ctx, px, py, size, theme, alwaysShowIcon ? 1 : hoverAmount);\n        textX = size;\n    }\n    else {\n        textX = 24;\n        const finalLineSize = 12;\n        const lineSize = alwaysShowIcon ? finalLineSize : hoverAmount * finalLineSize;\n        const xTranslate = alwaysShowIcon ? 0 : (1 - hoverAmount) * finalLineSize * 0.5;\n        const padPlus = theme.cellHorizontalPadding + 4;\n        if (lineSize > 0) {\n            ctx.moveTo(x + padPlus + xTranslate, y + h / 2);\n            ctx.lineTo(x + padPlus + xTranslate + lineSize, y + h / 2);\n            ctx.moveTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 - lineSize * 0.5);\n            ctx.lineTo(x + padPlus + xTranslate + lineSize * 0.5, y + h / 2 + lineSize * 0.5);\n            ctx.lineWidth = 2;\n            ctx.strokeStyle = theme.bgIconHeader;\n            ctx.lineCap = \"round\";\n            ctx.stroke();\n        }\n    }\n    ctx.fillStyle = theme.textMedium;\n    ctx.fillText(data, textX + x + theme.cellHorizontalPadding + 0.5, y + h / 2 + (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.getMiddleCenterBias)(ctx, theme));\n    ctx.beginPath();\n}\n//# sourceMappingURL=new-row-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvbmV3LXJvdy1jZWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRjtBQUNQO0FBQ3RFO0FBQ1A7QUFDQSxVQUFVLHFGQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNELFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsZ0dBQW1CO0FBQ3JHO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NlbGxzL25ldy1yb3ctY2VsbC5qcz82ZTc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldE1pZGRsZUNlbnRlckJpYXMgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtbGliLmpzXCI7XG5pbXBvcnQgeyBJbm5lckdyaWRDZWxsS2luZCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5leHBvcnQgY29uc3QgbmV3Um93Q2VsbFJlbmRlcmVyID0ge1xuICAgIGdldEFjY2Vzc2liaWxpdHlTdHJpbmc6ICgpID0+IFwiXCIsXG4gICAga2luZDogSW5uZXJHcmlkQ2VsbEtpbmQuTmV3Um93LFxuICAgIG5lZWRzSG92ZXI6IHRydWUsXG4gICAgbmVlZHNIb3ZlclBvc2l0aW9uOiBmYWxzZSxcbiAgICBtZWFzdXJlOiAoKSA9PiAyMDAsXG4gICAgZHJhdzogYSA9PiBkcmF3TmV3Um93Q2VsbChhLCBhLmNlbGwuaGludCwgYS5jZWxsLmljb24pLFxuICAgIG9uUGFzdGU6ICgpID0+IHVuZGVmaW5lZCxcbn07XG5mdW5jdGlvbiBkcmF3TmV3Um93Q2VsbChhcmdzLCBkYXRhLCBpY29uKSB7XG4gICAgY29uc3QgeyBjdHgsIHJlY3QsIGhvdmVyQW1vdW50LCB0aGVtZSwgc3ByaXRlTWFuYWdlciB9ID0gYXJncztcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3LCBoZWlnaHQ6IGggfSA9IHJlY3Q7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IGhvdmVyQW1vdW50O1xuICAgIGN0eC5yZWN0KHggKyAxLCB5ICsgMSwgdywgaCAtIDIpO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS5iZ0hlYWRlckhvdmVyZWQ7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjb25zdCBhbHdheXNTaG93SWNvbiA9IGRhdGEgIT09IFwiXCI7XG4gICAgbGV0IHRleHRYID0gMDtcbiAgICBpZiAoaWNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSA4O1xuICAgICAgICBjb25zdCBzaXplID0gaCAtIHBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHB4ID0geCArIHBhZGRpbmcgLyAyO1xuICAgICAgICBjb25zdCBweSA9IHkgKyBwYWRkaW5nIC8gMjtcbiAgICAgICAgc3ByaXRlTWFuYWdlci5kcmF3U3ByaXRlKGljb24sIFwibm9ybWFsXCIsIGN0eCwgcHgsIHB5LCBzaXplLCB0aGVtZSwgYWx3YXlzU2hvd0ljb24gPyAxIDogaG92ZXJBbW91bnQpO1xuICAgICAgICB0ZXh0WCA9IHNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0ZXh0WCA9IDI0O1xuICAgICAgICBjb25zdCBmaW5hbExpbmVTaXplID0gMTI7XG4gICAgICAgIGNvbnN0IGxpbmVTaXplID0gYWx3YXlzU2hvd0ljb24gPyBmaW5hbExpbmVTaXplIDogaG92ZXJBbW91bnQgKiBmaW5hbExpbmVTaXplO1xuICAgICAgICBjb25zdCB4VHJhbnNsYXRlID0gYWx3YXlzU2hvd0ljb24gPyAwIDogKDEgLSBob3ZlckFtb3VudCkgKiBmaW5hbExpbmVTaXplICogMC41O1xuICAgICAgICBjb25zdCBwYWRQbHVzID0gdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nICsgNDtcbiAgICAgICAgaWYgKGxpbmVTaXplID4gMCkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcGFkUGx1cyArIHhUcmFuc2xhdGUsIHkgKyBoIC8gMik7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBwYWRQbHVzICsgeFRyYW5zbGF0ZSArIGxpbmVTaXplLCB5ICsgaCAvIDIpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcGFkUGx1cyArIHhUcmFuc2xhdGUgKyBsaW5lU2l6ZSAqIDAuNSwgeSArIGggLyAyIC0gbGluZVNpemUgKiAwLjUpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgcGFkUGx1cyArIHhUcmFuc2xhdGUgKyBsaW5lU2l6ZSAqIDAuNSwgeSArIGggLyAyICsgbGluZVNpemUgKiAwLjUpO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZS5iZ0ljb25IZWFkZXI7XG4gICAgICAgICAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dE1lZGl1bTtcbiAgICBjdHguZmlsbFRleHQoZGF0YSwgdGV4dFggKyB4ICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nICsgMC41LCB5ICsgaCAvIDIgKyBnZXRNaWRkbGVDZW50ZXJCaWFzKGN0eCwgdGhlbWUpKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXctcm93LWNlbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/new-row-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/number-cell.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/number-cell.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   numberCellRenderer: () => (/* binding */ numberCellRenderer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* eslint-disable react/display-name */\n\n\n\nconst NumberOverlayEditor = react__WEBPACK_IMPORTED_MODULE_0__.lazy(async () => await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@glideapps\"), __webpack_require__.e(\"vendor-chunks/react-number-format\")]).then(__webpack_require__.bind(__webpack_require__, /*! ../internal/data-grid-overlay-editor/private/number-overlay-editor.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/number-overlay-editor.js\")));\nconst numberCellRenderer = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Number,\n    needsHover: false,\n    needsHoverPosition: false,\n    useLabel: true,\n    drawPrep: _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.prepTextCell,\n    draw: a => (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)(a, a.cell.displayData, a.cell.contentAlign),\n    measure: (ctx, cell, theme) => ctx.measureText(cell.displayData).width + theme.cellHorizontalPadding * 2,\n    onDelete: c => ({\n        ...c,\n        data: undefined,\n    }),\n    provideEditor: () => p => {\n        const { isHighlighted, onChange, value, validatedSelection } = p;\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: null },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(NumberOverlayEditor, { highlight: isHighlighted, disabled: value.readonly === true, value: value.data, fixedDecimals: value.fixedDecimals, allowNegative: value.allowNegative, thousandSeparator: value.thousandSeparator, decimalSeparator: value.decimalSeparator, validatedSelection: validatedSelection, onChange: x => onChange({\n                    ...value,\n                    data: Number.isNaN(x.floatValue ?? 0) ? 0 : x.floatValue,\n                }) })));\n    },\n    onPaste: (toPaste, cell, details) => {\n        const newNumber = typeof details.rawValue === \"number\"\n            ? details.rawValue\n            : Number.parseFloat(typeof details.rawValue === \"string\" ? details.rawValue : toPaste);\n        if (Number.isNaN(newNumber) || cell.data === newNumber)\n            return undefined;\n        return { ...cell, data: newNumber, displayData: details.formattedString ?? cell.displayData };\n    },\n};\n//# sourceMappingURL=number-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvbnVtYmVyLWNlbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQytCO0FBQzREO0FBQ25CO0FBQ3hFLDRCQUE0Qix1Q0FBVSxtQkFBbUIsMllBQStFO0FBQ2pJO0FBQ1A7QUFDQSxVQUFVLGdGQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUZBQVk7QUFDMUIsZUFBZSx5RkFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckUsZ0JBQWdCLGdEQUFtQixDQUFDLDJDQUFjLElBQUksZ0JBQWdCO0FBQ3RFLFlBQVksZ0RBQW1CLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0EsaUJBQWlCLEdBQUc7QUFDcEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NlbGxzL251bWJlci1jZWxsLmpzP2FlMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcmVhY3QvZGlzcGxheS1uYW1lICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGRyYXdUZXh0Q2VsbCwgcHJlcFRleHRDZWxsIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9yZW5kZXIvZGF0YS1ncmlkLWxpYi5qc1wiO1xuaW1wb3J0IHsgR3JpZENlbGxLaW5kIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmNvbnN0IE51bWJlck92ZXJsYXlFZGl0b3IgPSBSZWFjdC5sYXp5KGFzeW5jICgpID0+IGF3YWl0IGltcG9ydChcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL251bWJlci1vdmVybGF5LWVkaXRvci5qc1wiKSk7XG5leHBvcnQgY29uc3QgbnVtYmVyQ2VsbFJlbmRlcmVyID0ge1xuICAgIGdldEFjY2Vzc2liaWxpdHlTdHJpbmc6IGMgPT4gYy5kYXRhPy50b1N0cmluZygpID8/IFwiXCIsXG4gICAga2luZDogR3JpZENlbGxLaW5kLk51bWJlcixcbiAgICBuZWVkc0hvdmVyOiBmYWxzZSxcbiAgICBuZWVkc0hvdmVyUG9zaXRpb246IGZhbHNlLFxuICAgIHVzZUxhYmVsOiB0cnVlLFxuICAgIGRyYXdQcmVwOiBwcmVwVGV4dENlbGwsXG4gICAgZHJhdzogYSA9PiBkcmF3VGV4dENlbGwoYSwgYS5jZWxsLmRpc3BsYXlEYXRhLCBhLmNlbGwuY29udGVudEFsaWduKSxcbiAgICBtZWFzdXJlOiAoY3R4LCBjZWxsLCB0aGVtZSkgPT4gY3R4Lm1lYXN1cmVUZXh0KGNlbGwuZGlzcGxheURhdGEpLndpZHRoICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nICogMixcbiAgICBvbkRlbGV0ZTogYyA9PiAoe1xuICAgICAgICAuLi5jLFxuICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgfSksXG4gICAgcHJvdmlkZUVkaXRvcjogKCkgPT4gcCA9PiB7XG4gICAgICAgIGNvbnN0IHsgaXNIaWdobGlnaHRlZCwgb25DaGFuZ2UsIHZhbHVlLCB2YWxpZGF0ZWRTZWxlY3Rpb24gfSA9IHA7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5TdXNwZW5zZSwgeyBmYWxsYmFjazogbnVsbCB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChOdW1iZXJPdmVybGF5RWRpdG9yLCB7IGhpZ2hsaWdodDogaXNIaWdobGlnaHRlZCwgZGlzYWJsZWQ6IHZhbHVlLnJlYWRvbmx5ID09PSB0cnVlLCB2YWx1ZTogdmFsdWUuZGF0YSwgZml4ZWREZWNpbWFsczogdmFsdWUuZml4ZWREZWNpbWFscywgYWxsb3dOZWdhdGl2ZTogdmFsdWUuYWxsb3dOZWdhdGl2ZSwgdGhvdXNhbmRTZXBhcmF0b3I6IHZhbHVlLnRob3VzYW5kU2VwYXJhdG9yLCBkZWNpbWFsU2VwYXJhdG9yOiB2YWx1ZS5kZWNpbWFsU2VwYXJhdG9yLCB2YWxpZGF0ZWRTZWxlY3Rpb246IHZhbGlkYXRlZFNlbGVjdGlvbiwgb25DaGFuZ2U6IHggPT4gb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogTnVtYmVyLmlzTmFOKHguZmxvYXRWYWx1ZSA/PyAwKSA/IDAgOiB4LmZsb2F0VmFsdWUsXG4gICAgICAgICAgICAgICAgfSkgfSkpKTtcbiAgICB9LFxuICAgIG9uUGFzdGU6ICh0b1Bhc3RlLCBjZWxsLCBkZXRhaWxzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld051bWJlciA9IHR5cGVvZiBkZXRhaWxzLnJhd1ZhbHVlID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IGRldGFpbHMucmF3VmFsdWVcbiAgICAgICAgICAgIDogTnVtYmVyLnBhcnNlRmxvYXQodHlwZW9mIGRldGFpbHMucmF3VmFsdWUgPT09IFwic3RyaW5nXCIgPyBkZXRhaWxzLnJhd1ZhbHVlIDogdG9QYXN0ZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4obmV3TnVtYmVyKSB8fCBjZWxsLmRhdGEgPT09IG5ld051bWJlcilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7IC4uLmNlbGwsIGRhdGE6IG5ld051bWJlciwgZGlzcGxheURhdGE6IGRldGFpbHMuZm9ybWF0dGVkU3RyaW5nID8/IGNlbGwuZGlzcGxheURhdGEgfTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci1jZWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/number-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/protected-cell.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/protected-cell.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   protectedCellRenderer: () => (/* binding */ protectedCellRenderer)\n/* harmony export */ });\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n\n\nconst protectedCellRenderer = {\n    getAccessibilityString: () => \"\",\n    measure: () => 108,\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Protected,\n    needsHover: false,\n    needsHoverPosition: false,\n    draw: drawProtectedCell,\n    onPaste: () => undefined,\n};\nfunction drawProtectedCell(args) {\n    const { ctx, theme, rect } = args;\n    const { x, y, height: h } = rect;\n    ctx.beginPath();\n    const radius = 2.5;\n    let xStart = x + theme.cellHorizontalPadding + radius;\n    const center = y + h / 2;\n    const p = Math.cos((0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(30)) * radius;\n    const q = Math.sin((0,_common_utils_js__WEBPACK_IMPORTED_MODULE_1__.degreesToRadians)(30)) * radius;\n    for (let i = 0; i < 12; i++) {\n        ctx.moveTo(xStart, center - radius);\n        ctx.lineTo(xStart, center + radius);\n        ctx.moveTo(xStart + p, center - q);\n        ctx.lineTo(xStart - p, center + q);\n        ctx.moveTo(xStart - p, center - q);\n        ctx.lineTo(xStart + p, center + q);\n        xStart += 8;\n    }\n    ctx.lineWidth = 1.1;\n    ctx.lineCap = \"square\";\n    ctx.strokeStyle = theme.textLight;\n    ctx.stroke();\n}\n//# sourceMappingURL=protected-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvcHJvdGVjdGVkLWNlbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXNEO0FBQ2tCO0FBQ2pFO0FBQ1A7QUFDQTtBQUNBLFVBQVUsZ0ZBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0IsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQWdCO0FBQ3ZDLHVCQUF1QixrRUFBZ0I7QUFDdkMsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NlbGxzL3Byb3RlY3RlZC1jZWxsLmpzP2E4YTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVncmVlc1RvUmFkaWFucyB9IGZyb20gXCIuLi9jb21tb24vdXRpbHMuanNcIjtcbmltcG9ydCB7IEdyaWRDZWxsS2luZCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5leHBvcnQgY29uc3QgcHJvdGVjdGVkQ2VsbFJlbmRlcmVyID0ge1xuICAgIGdldEFjY2Vzc2liaWxpdHlTdHJpbmc6ICgpID0+IFwiXCIsXG4gICAgbWVhc3VyZTogKCkgPT4gMTA4LFxuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5Qcm90ZWN0ZWQsXG4gICAgbmVlZHNIb3ZlcjogZmFsc2UsXG4gICAgbmVlZHNIb3ZlclBvc2l0aW9uOiBmYWxzZSxcbiAgICBkcmF3OiBkcmF3UHJvdGVjdGVkQ2VsbCxcbiAgICBvblBhc3RlOiAoKSA9PiB1bmRlZmluZWQsXG59O1xuZnVuY3Rpb24gZHJhd1Byb3RlY3RlZENlbGwoYXJncykge1xuICAgIGNvbnN0IHsgY3R4LCB0aGVtZSwgcmVjdCB9ID0gYXJncztcbiAgICBjb25zdCB7IHgsIHksIGhlaWdodDogaCB9ID0gcmVjdDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgcmFkaXVzID0gMi41O1xuICAgIGxldCB4U3RhcnQgPSB4ICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nICsgcmFkaXVzO1xuICAgIGNvbnN0IGNlbnRlciA9IHkgKyBoIC8gMjtcbiAgICBjb25zdCBwID0gTWF0aC5jb3MoZGVncmVlc1RvUmFkaWFucygzMCkpICogcmFkaXVzO1xuICAgIGNvbnN0IHEgPSBNYXRoLnNpbihkZWdyZWVzVG9SYWRpYW5zKDMwKSkgKiByYWRpdXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeFN0YXJ0LCBjZW50ZXIgLSByYWRpdXMpO1xuICAgICAgICBjdHgubGluZVRvKHhTdGFydCwgY2VudGVyICsgcmFkaXVzKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4U3RhcnQgKyBwLCBjZW50ZXIgLSBxKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4U3RhcnQgLSBwLCBjZW50ZXIgKyBxKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4U3RhcnQgLSBwLCBjZW50ZXIgLSBxKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4U3RhcnQgKyBwLCBjZW50ZXIgKyBxKTtcbiAgICAgICAgeFN0YXJ0ICs9IDg7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSAxLjE7XG4gICAgY3R4LmxpbmVDYXAgPSBcInNxdWFyZVwiO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lLnRleHRMaWdodDtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm90ZWN0ZWQtY2VsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/protected-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/row-id-cell.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/row-id-cell.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rowIDCellRenderer: () => (/* binding */ rowIDCellRenderer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_growing_entry_growing_entry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/growing-entry/growing-entry.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n\n\n\n\nconst rowIDCellRenderer = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.RowID,\n    needsHover: false,\n    needsHoverPosition: false,\n    drawPrep: (a, b) => (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.prepTextCell)(a, b, a.theme.textLight),\n    draw: a => (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)(a, a.cell.data, a.cell.contentAlign),\n    measure: (ctx, cell, theme) => ctx.measureText(cell.data).width + theme.cellHorizontalPadding * 2,\n    // eslint-disable-next-line react/display-name\n    provideEditor: () => p => {\n        const { isHighlighted, onChange, value, validatedSelection } = p;\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_growing_entry_growing_entry_js__WEBPACK_IMPORTED_MODULE_3__.GrowingEntry, { highlight: isHighlighted, autoFocus: value.readonly !== true, disabled: value.readonly !== false, value: value.data, validatedSelection: validatedSelection, onChange: e => onChange({\n                ...value,\n                data: e.target.value,\n            }) }));\n    },\n    onPaste: () => undefined,\n};\n//# sourceMappingURL=row-id-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvcm93LWlkLWNlbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEI7QUFDZ0Q7QUFDaUI7QUFDbkI7QUFDakU7QUFDUDtBQUNBLFVBQVUsZ0ZBQVk7QUFDdEI7QUFDQTtBQUNBLHdCQUF3Qix5RkFBWTtBQUNwQyxlQUFlLHlGQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckUsZ0JBQWdCLGdEQUFtQixDQUFDLGtGQUFZLElBQUk7QUFDcEQ7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvcm93LWlkLWNlbGwuanM/MzlhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBHcm93aW5nRW50cnkgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZ3Jvd2luZy1lbnRyeS9ncm93aW5nLWVudHJ5LmpzXCI7XG5pbXBvcnQgeyBkcmF3VGV4dENlbGwsIHByZXBUZXh0Q2VsbCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RhdGEtZ3JpZC1saWIuanNcIjtcbmltcG9ydCB7IEdyaWRDZWxsS2luZCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5leHBvcnQgY29uc3Qgcm93SURDZWxsUmVuZGVyZXIgPSB7XG4gICAgZ2V0QWNjZXNzaWJpbGl0eVN0cmluZzogYyA9PiBjLmRhdGE/LnRvU3RyaW5nKCkgPz8gXCJcIixcbiAgICBraW5kOiBHcmlkQ2VsbEtpbmQuUm93SUQsXG4gICAgbmVlZHNIb3ZlcjogZmFsc2UsXG4gICAgbmVlZHNIb3ZlclBvc2l0aW9uOiBmYWxzZSxcbiAgICBkcmF3UHJlcDogKGEsIGIpID0+IHByZXBUZXh0Q2VsbChhLCBiLCBhLnRoZW1lLnRleHRMaWdodCksXG4gICAgZHJhdzogYSA9PiBkcmF3VGV4dENlbGwoYSwgYS5jZWxsLmRhdGEsIGEuY2VsbC5jb250ZW50QWxpZ24pLFxuICAgIG1lYXN1cmU6IChjdHgsIGNlbGwsIHRoZW1lKSA9PiBjdHgubWVhc3VyZVRleHQoY2VsbC5kYXRhKS53aWR0aCArIHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZyAqIDIsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHByb3ZpZGVFZGl0b3I6ICgpID0+IHAgPT4ge1xuICAgICAgICBjb25zdCB7IGlzSGlnaGxpZ2h0ZWQsIG9uQ2hhbmdlLCB2YWx1ZSwgdmFsaWRhdGVkU2VsZWN0aW9uIH0gPSBwO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3Jvd2luZ0VudHJ5LCB7IGhpZ2hsaWdodDogaXNIaWdobGlnaHRlZCwgYXV0b0ZvY3VzOiB2YWx1ZS5yZWFkb25seSAhPT0gdHJ1ZSwgZGlzYWJsZWQ6IHZhbHVlLnJlYWRvbmx5ICE9PSBmYWxzZSwgdmFsdWU6IHZhbHVlLmRhdGEsIHZhbGlkYXRlZFNlbGVjdGlvbjogdmFsaWRhdGVkU2VsZWN0aW9uLCBvbkNoYW5nZTogZSA9PiBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YTogZS50YXJnZXQudmFsdWUsXG4gICAgICAgICAgICB9KSB9KSk7XG4gICAgfSxcbiAgICBvblBhc3RlOiAoKSA9PiB1bmRlZmluZWQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm93LWlkLWNlbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/row-id-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/text-cell.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/text-cell.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   textCellRenderer: () => (/* binding */ textCellRenderer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_growing_entry_growing_entry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../internal/growing-entry/growing-entry.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _internal_data_grid_color_parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/data-grid/color-parser.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\");\n/* eslint-disable react/display-name */\n\n\n\n\n\nconst textCellRenderer = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Text,\n    needsHover: textCell => textCell.hoverEffect === true,\n    needsHoverPosition: false,\n    drawPrep: _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.prepTextCell,\n    useLabel: true,\n    draw: a => {\n        const { cell, hoverAmount, hyperWrapping, ctx, rect, theme, overrideCursor } = a;\n        const { displayData, contentAlign, hoverEffect, allowWrapping } = cell;\n        if (hoverEffect === true && hoverAmount > 0) {\n            ctx.textBaseline = \"alphabetic\";\n            const padX = theme.cellHorizontalPadding;\n            const padY = theme.cellVerticalPadding;\n            const m = (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.measureTextCached)(displayData, ctx, theme.baseFontFull, \"alphabetic\");\n            const maxH = rect.height - padY;\n            const h = Math.min(maxH, m.actualBoundingBoxAscent * 2.5);\n            ctx.beginPath();\n            (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.roundedRect)(ctx, rect.x + padX / 2, rect.y + (rect.height - h) / 2 + 1, m.width + padX * 3, h - 1, theme.roundingRadius ?? 4);\n            ctx.globalAlpha = hoverAmount;\n            ctx.fillStyle = (0,_internal_data_grid_color_parser_js__WEBPACK_IMPORTED_MODULE_3__.withAlpha)(theme.textDark, 0.1);\n            ctx.fill();\n            // restore\n            ctx.globalAlpha = 1;\n            ctx.fillStyle = theme.textDark;\n            ctx.textBaseline = \"middle\";\n            overrideCursor?.(\"text\");\n        }\n        (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)(a, displayData, contentAlign, allowWrapping, hyperWrapping);\n    },\n    measure: (ctx, cell, t) => {\n        const lines = cell.displayData.split(\"\\n\", cell.allowWrapping === true ? undefined : 1);\n        let maxLineWidth = 0;\n        for (const line of lines) {\n            maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line).width);\n        }\n        return maxLineWidth + 2 * t.cellHorizontalPadding;\n    },\n    onDelete: c => ({\n        ...c,\n        data: \"\",\n    }),\n    provideEditor: cell => ({\n        disablePadding: cell.allowWrapping === true,\n        editor: p => {\n            const { isHighlighted, onChange, value, validatedSelection } = p;\n            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_growing_entry_growing_entry_js__WEBPACK_IMPORTED_MODULE_4__.GrowingEntry, { style: cell.allowWrapping === true ? { padding: \"3px 8.5px\" } : undefined, highlight: isHighlighted, autoFocus: value.readonly !== true, disabled: value.readonly === true, altNewline: true, value: value.data, validatedSelection: validatedSelection, onChange: e => onChange({\n                    ...value,\n                    data: e.target.value,\n                }) }));\n        },\n    }),\n    onPaste: (toPaste, cell, details) => toPaste === cell.data\n        ? undefined\n        : { ...cell, data: toPaste, displayData: details.formattedString ?? cell.displayData },\n};\n//# sourceMappingURL=text-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvdGV4dC1jZWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQytCO0FBQzJDO0FBQ2tEO0FBQ3BEO0FBQ047QUFDM0Q7QUFDUDtBQUNBLFVBQVUsZ0ZBQVk7QUFDdEI7QUFDQTtBQUNBLGNBQWMscUZBQVk7QUFDMUI7QUFDQTtBQUNBLGdCQUFnQixxRUFBcUU7QUFDckYsZ0JBQWdCLHdEQUF3RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4RkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3RkFBVztBQUN2QjtBQUNBLDRCQUE0Qiw4RUFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUZBQVk7QUFDcEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQXFEO0FBQ3pFLG9CQUFvQixnREFBbUIsQ0FBQyxrRkFBWSxJQUFJLHVDQUF1Qyx1QkFBdUI7QUFDdEg7QUFDQTtBQUNBLGlCQUFpQixHQUFHO0FBQ3BCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksa0ZBQWtGO0FBQzlGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9jZWxscy90ZXh0LWNlbGwuanM/NzdjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9kaXNwbGF5LW5hbWUgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgR3Jvd2luZ0VudHJ5IH0gZnJvbSBcIi4uL2ludGVybmFsL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS5qc1wiO1xuaW1wb3J0IHsgZHJhd1RleHRDZWxsLCBtZWFzdXJlVGV4dENhY2hlZCwgcHJlcFRleHRDZWxsLCByb3VuZGVkUmVjdCwgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtbGliLmpzXCI7XG5pbXBvcnQgeyBHcmlkQ2VsbEtpbmQgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlcy5qc1wiO1xuaW1wb3J0IHsgd2l0aEFscGhhIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9jb2xvci1wYXJzZXIuanNcIjtcbmV4cG9ydCBjb25zdCB0ZXh0Q2VsbFJlbmRlcmVyID0ge1xuICAgIGdldEFjY2Vzc2liaWxpdHlTdHJpbmc6IGMgPT4gYy5kYXRhPy50b1N0cmluZygpID8/IFwiXCIsXG4gICAga2luZDogR3JpZENlbGxLaW5kLlRleHQsXG4gICAgbmVlZHNIb3ZlcjogdGV4dENlbGwgPT4gdGV4dENlbGwuaG92ZXJFZmZlY3QgPT09IHRydWUsXG4gICAgbmVlZHNIb3ZlclBvc2l0aW9uOiBmYWxzZSxcbiAgICBkcmF3UHJlcDogcHJlcFRleHRDZWxsLFxuICAgIHVzZUxhYmVsOiB0cnVlLFxuICAgIGRyYXc6IGEgPT4ge1xuICAgICAgICBjb25zdCB7IGNlbGwsIGhvdmVyQW1vdW50LCBoeXBlcldyYXBwaW5nLCBjdHgsIHJlY3QsIHRoZW1lLCBvdmVycmlkZUN1cnNvciB9ID0gYTtcbiAgICAgICAgY29uc3QgeyBkaXNwbGF5RGF0YSwgY29udGVudEFsaWduLCBob3ZlckVmZmVjdCwgYWxsb3dXcmFwcGluZyB9ID0gY2VsbDtcbiAgICAgICAgaWYgKGhvdmVyRWZmZWN0ID09PSB0cnVlICYmIGhvdmVyQW1vdW50ID4gMCkge1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xuICAgICAgICAgICAgY29uc3QgcGFkWCA9IHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZztcbiAgICAgICAgICAgIGNvbnN0IHBhZFkgPSB0aGVtZS5jZWxsVmVydGljYWxQYWRkaW5nO1xuICAgICAgICAgICAgY29uc3QgbSA9IG1lYXN1cmVUZXh0Q2FjaGVkKGRpc3BsYXlEYXRhLCBjdHgsIHRoZW1lLmJhc2VGb250RnVsbCwgXCJhbHBoYWJldGljXCIpO1xuICAgICAgICAgICAgY29uc3QgbWF4SCA9IHJlY3QuaGVpZ2h0IC0gcGFkWTtcbiAgICAgICAgICAgIGNvbnN0IGggPSBNYXRoLm1pbihtYXhILCBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICogMi41KTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHJvdW5kZWRSZWN0KGN0eCwgcmVjdC54ICsgcGFkWCAvIDIsIHJlY3QueSArIChyZWN0LmhlaWdodCAtIGgpIC8gMiArIDEsIG0ud2lkdGggKyBwYWRYICogMywgaCAtIDEsIHRoZW1lLnJvdW5kaW5nUmFkaXVzID8/IDQpO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gaG92ZXJBbW91bnQ7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gd2l0aEFscGhhKHRoZW1lLnRleHREYXJrLCAwLjEpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIC8vIHJlc3RvcmVcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgICAgIG92ZXJyaWRlQ3Vyc29yPy4oXCJ0ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdUZXh0Q2VsbChhLCBkaXNwbGF5RGF0YSwgY29udGVudEFsaWduLCBhbGxvd1dyYXBwaW5nLCBoeXBlcldyYXBwaW5nKTtcbiAgICB9LFxuICAgIG1lYXN1cmU6IChjdHgsIGNlbGwsIHQpID0+IHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBjZWxsLmRpc3BsYXlEYXRhLnNwbGl0KFwiXFxuXCIsIGNlbGwuYWxsb3dXcmFwcGluZyA9PT0gdHJ1ZSA/IHVuZGVmaW5lZCA6IDEpO1xuICAgICAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heExpbmVXaWR0aCArIDIgKiB0LmNlbGxIb3Jpem9udGFsUGFkZGluZztcbiAgICB9LFxuICAgIG9uRGVsZXRlOiBjID0+ICh7XG4gICAgICAgIC4uLmMsXG4gICAgICAgIGRhdGE6IFwiXCIsXG4gICAgfSksXG4gICAgcHJvdmlkZUVkaXRvcjogY2VsbCA9PiAoe1xuICAgICAgICBkaXNhYmxlUGFkZGluZzogY2VsbC5hbGxvd1dyYXBwaW5nID09PSB0cnVlLFxuICAgICAgICBlZGl0b3I6IHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpc0hpZ2hsaWdodGVkLCBvbkNoYW5nZSwgdmFsdWUsIHZhbGlkYXRlZFNlbGVjdGlvbiB9ID0gcDtcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChHcm93aW5nRW50cnksIHsgc3R5bGU6IGNlbGwuYWxsb3dXcmFwcGluZyA9PT0gdHJ1ZSA/IHsgcGFkZGluZzogXCIzcHggOC41cHhcIiB9IDogdW5kZWZpbmVkLCBoaWdobGlnaHQ6IGlzSGlnaGxpZ2h0ZWQsIGF1dG9Gb2N1czogdmFsdWUucmVhZG9ubHkgIT09IHRydWUsIGRpc2FibGVkOiB2YWx1ZS5yZWFkb25seSA9PT0gdHJ1ZSwgYWx0TmV3bGluZTogdHJ1ZSwgdmFsdWU6IHZhbHVlLmRhdGEsIHZhbGlkYXRlZFNlbGVjdGlvbjogdmFsaWRhdGVkU2VsZWN0aW9uLCBvbkNoYW5nZTogZSA9PiBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlLnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgICB9KSB9KSk7XG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgb25QYXN0ZTogKHRvUGFzdGUsIGNlbGwsIGRldGFpbHMpID0+IHRvUGFzdGUgPT09IGNlbGwuZGF0YVxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IHsgLi4uY2VsbCwgZGF0YTogdG9QYXN0ZSwgZGlzcGxheURhdGE6IGRldGFpbHMuZm9ybWF0dGVkU3RyaW5nID8/IGNlbGwuZGlzcGxheURhdGEgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0LWNlbGwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/text-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/uri-cell.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/cells/uri-cell.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uriCellRenderer: () => (/* binding */ uriCellRenderer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_data_grid_overlay_editor_private_uri_overlay_editor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../internal/data-grid-overlay-editor/private/uri-overlay-editor.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/uri-overlay-editor.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _common_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/math.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js\");\n/* eslint-disable react/display-name */\n\n\n\n\n\nfunction getTextRect(metrics, rect, theme, contentAlign) {\n    let x = theme.cellHorizontalPadding;\n    const y = rect.height / 2 - metrics.actualBoundingBoxAscent / 2;\n    const width = metrics.width;\n    const height = metrics.actualBoundingBoxAscent;\n    if (contentAlign === \"right\") {\n        x = rect.width - width - theme.cellHorizontalPadding;\n    }\n    else if (contentAlign === \"center\") {\n        x = rect.width / 2 - width / 2;\n    }\n    return { x, y, width, height };\n}\nconst uriCellRenderer = {\n    getAccessibilityString: c => c.data?.toString() ?? \"\",\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Uri,\n    needsHover: uriCell => uriCell.hoverEffect === true,\n    needsHoverPosition: true,\n    useLabel: true,\n    drawPrep: _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.prepTextCell,\n    draw: a => {\n        const { cell, theme, overrideCursor, hoverX, hoverY, rect, ctx } = a;\n        const txt = cell.displayData ?? cell.data;\n        const isLinky = cell.hoverEffect === true;\n        if (overrideCursor !== undefined && isLinky && hoverX !== undefined && hoverY !== undefined) {\n            const m = (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.measureTextCached)(txt, ctx, theme.baseFontFull);\n            const textRect = getTextRect(m, rect, theme, cell.contentAlign);\n            const { x, y, width: w, height: h } = textRect;\n            // check if hoverX and hoverY inside the box\n            if (hoverX >= x - 4 && hoverX <= x - 4 + w + 8 && hoverY >= y - 4 && hoverY <= y - 4 + h + 8) {\n                const middleCenterBias = (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, theme.baseFontFull);\n                overrideCursor(\"pointer\");\n                const underlineOffset = 5;\n                const drawY = y - middleCenterBias;\n                ctx.beginPath();\n                ctx.moveTo(rect.x + x, Math.floor(rect.y + drawY + h + underlineOffset) + 0.5);\n                ctx.lineTo(rect.x + x + w, Math.floor(rect.y + drawY + h + underlineOffset) + 0.5);\n                ctx.strokeStyle = theme.linkColor;\n                ctx.stroke();\n                ctx.save();\n                ctx.fillStyle = a.cellFillColor;\n                (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)({ ...a, rect: { ...rect, x: rect.x - 1 } }, txt, cell.contentAlign);\n                (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)({ ...a, rect: { ...rect, x: rect.x - 2 } }, txt, cell.contentAlign);\n                (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)({ ...a, rect: { ...rect, x: rect.x + 1 } }, txt, cell.contentAlign);\n                (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)({ ...a, rect: { ...rect, x: rect.x + 2 } }, txt, cell.contentAlign);\n                ctx.restore();\n            }\n        }\n        ctx.fillStyle = isLinky ? theme.linkColor : theme.textDark;\n        (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawTextCell)(a, txt, cell.contentAlign);\n    },\n    onClick: a => {\n        const { cell, bounds, posX, posY, theme } = a;\n        const txt = cell.displayData ?? cell.data;\n        if (cell.hoverEffect !== true || cell.onClickUri === undefined)\n            return;\n        const m = (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.getMeasuredTextCache)(txt, theme.baseFontFull);\n        if (m === undefined)\n            return;\n        const textRect = getTextRect(m, bounds, theme, cell.contentAlign);\n        const didClick = (0,_common_math_js__WEBPACK_IMPORTED_MODULE_3__.pointInRect)({\n            x: textRect.x - 4,\n            y: textRect.y - 4,\n            width: textRect.width + 8,\n            height: textRect.height + 8,\n        }, posX, posY);\n        if (didClick) {\n            cell.onClickUri(a);\n        }\n        return undefined;\n    },\n    measure: (ctx, cell, theme) => ctx.measureText(cell.displayData ?? cell.data).width + theme.cellHorizontalPadding * 2,\n    onDelete: c => ({\n        ...c,\n        data: \"\",\n    }),\n    provideEditor: cell => p => {\n        const { onChange, value, forceEditMode, validatedSelection } = p;\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_data_grid_overlay_editor_private_uri_overlay_editor_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { forceEditMode: value.readonly !== true &&\n                (forceEditMode || (cell.hoverEffect === true && cell.onClickUri !== undefined)), uri: value.data, preview: value.displayData ?? value.data, validatedSelection: validatedSelection, readonly: value.readonly === true, onChange: e => onChange({\n                ...value,\n                data: e.target.value,\n            }) }));\n    },\n    onPaste: (toPaste, cell, details) => toPaste === cell.data\n        ? undefined\n        : { ...cell, data: toPaste, displayData: details.formattedString ?? cell.displayData },\n};\n//# sourceMappingURL=uri-cell.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvdXJpLWNlbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDK0I7QUFDbUU7QUFDd0Q7QUFDakY7QUFDekI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQSxVQUFVLGdGQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUZBQVk7QUFDMUI7QUFDQSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4RkFBaUI7QUFDdkM7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQSx5Q0FBeUMsZ0dBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlGQUFZLEdBQUcsY0FBYywwQkFBMEI7QUFDdkUsZ0JBQWdCLHlGQUFZLEdBQUcsY0FBYywwQkFBMEI7QUFDdkUsZ0JBQWdCLHlGQUFZLEdBQUcsY0FBYywwQkFBMEI7QUFDdkUsZ0JBQWdCLHlGQUFZLEdBQUcsY0FBYywwQkFBMEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlGQUFZO0FBQ3BCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlHQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFLGdCQUFnQixnREFBbUIsQ0FBQyx3R0FBZ0IsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGtGQUFrRjtBQUM5RjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY2VsbHMvdXJpLWNlbGwuanM/YzhjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9kaXNwbGF5LW5hbWUgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFVyaU92ZXJsYXlFZGl0b3IgZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL3VyaS1vdmVybGF5LWVkaXRvci5qc1wiO1xuaW1wb3J0IHsgZHJhd1RleHRDZWxsLCBnZXRNZWFzdXJlZFRleHRDYWNoZSwgZ2V0TWlkZGxlQ2VudGVyQmlhcywgbWVhc3VyZVRleHRDYWNoZWQsIHByZXBUZXh0Q2VsbCwgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtbGliLmpzXCI7XG5pbXBvcnQgeyBHcmlkQ2VsbEtpbmQsIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmltcG9ydCB7IHBvaW50SW5SZWN0IH0gZnJvbSBcIi4uL2NvbW1vbi9tYXRoLmpzXCI7XG5mdW5jdGlvbiBnZXRUZXh0UmVjdChtZXRyaWNzLCByZWN0LCB0aGVtZSwgY29udGVudEFsaWduKSB7XG4gICAgbGV0IHggPSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgY29uc3QgeSA9IHJlY3QuaGVpZ2h0IC8gMiAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgLyAyO1xuICAgIGNvbnN0IHdpZHRoID0gbWV0cmljcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGlmIChjb250ZW50QWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICB4ID0gcmVjdC53aWR0aCAtIHdpZHRoIC0gdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250ZW50QWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgeCA9IHJlY3Qud2lkdGggLyAyIC0gd2lkdGggLyAyO1xuICAgIH1cbiAgICByZXR1cm4geyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH07XG59XG5leHBvcnQgY29uc3QgdXJpQ2VsbFJlbmRlcmVyID0ge1xuICAgIGdldEFjY2Vzc2liaWxpdHlTdHJpbmc6IGMgPT4gYy5kYXRhPy50b1N0cmluZygpID8/IFwiXCIsXG4gICAga2luZDogR3JpZENlbGxLaW5kLlVyaSxcbiAgICBuZWVkc0hvdmVyOiB1cmlDZWxsID0+IHVyaUNlbGwuaG92ZXJFZmZlY3QgPT09IHRydWUsXG4gICAgbmVlZHNIb3ZlclBvc2l0aW9uOiB0cnVlLFxuICAgIHVzZUxhYmVsOiB0cnVlLFxuICAgIGRyYXdQcmVwOiBwcmVwVGV4dENlbGwsXG4gICAgZHJhdzogYSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY2VsbCwgdGhlbWUsIG92ZXJyaWRlQ3Vyc29yLCBob3ZlclgsIGhvdmVyWSwgcmVjdCwgY3R4IH0gPSBhO1xuICAgICAgICBjb25zdCB0eHQgPSBjZWxsLmRpc3BsYXlEYXRhID8/IGNlbGwuZGF0YTtcbiAgICAgICAgY29uc3QgaXNMaW5reSA9IGNlbGwuaG92ZXJFZmZlY3QgPT09IHRydWU7XG4gICAgICAgIGlmIChvdmVycmlkZUN1cnNvciAhPT0gdW5kZWZpbmVkICYmIGlzTGlua3kgJiYgaG92ZXJYICE9PSB1bmRlZmluZWQgJiYgaG92ZXJZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZWFzdXJlVGV4dENhY2hlZCh0eHQsIGN0eCwgdGhlbWUuYmFzZUZvbnRGdWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHRSZWN0ID0gZ2V0VGV4dFJlY3QobSwgcmVjdCwgdGhlbWUsIGNlbGwuY29udGVudEFsaWduKTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCB9ID0gdGV4dFJlY3Q7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBob3ZlclggYW5kIGhvdmVyWSBpbnNpZGUgdGhlIGJveFxuICAgICAgICAgICAgaWYgKGhvdmVyWCA+PSB4IC0gNCAmJiBob3ZlclggPD0geCAtIDQgKyB3ICsgOCAmJiBob3ZlclkgPj0geSAtIDQgJiYgaG92ZXJZIDw9IHkgLSA0ICsgaCArIDgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaWRkbGVDZW50ZXJCaWFzID0gZ2V0TWlkZGxlQ2VudGVyQmlhcyhjdHgsIHRoZW1lLmJhc2VGb250RnVsbCk7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVDdXJzb3IoXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuZGVybGluZU9mZnNldCA9IDU7XG4gICAgICAgICAgICAgICAgY29uc3QgZHJhd1kgPSB5IC0gbWlkZGxlQ2VudGVyQmlhcztcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhyZWN0LnggKyB4LCBNYXRoLmZsb29yKHJlY3QueSArIGRyYXdZICsgaCArIHVuZGVybGluZU9mZnNldCkgKyAwLjUpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocmVjdC54ICsgeCArIHcsIE1hdGguZmxvb3IocmVjdC55ICsgZHJhd1kgKyBoICsgdW5kZXJsaW5lT2Zmc2V0KSArIDAuNSk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhlbWUubGlua0NvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBhLmNlbGxGaWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgZHJhd1RleHRDZWxsKHsgLi4uYSwgcmVjdDogeyAuLi5yZWN0LCB4OiByZWN0LnggLSAxIH0gfSwgdHh0LCBjZWxsLmNvbnRlbnRBbGlnbik7XG4gICAgICAgICAgICAgICAgZHJhd1RleHRDZWxsKHsgLi4uYSwgcmVjdDogeyAuLi5yZWN0LCB4OiByZWN0LnggLSAyIH0gfSwgdHh0LCBjZWxsLmNvbnRlbnRBbGlnbik7XG4gICAgICAgICAgICAgICAgZHJhd1RleHRDZWxsKHsgLi4uYSwgcmVjdDogeyAuLi5yZWN0LCB4OiByZWN0LnggKyAxIH0gfSwgdHh0LCBjZWxsLmNvbnRlbnRBbGlnbik7XG4gICAgICAgICAgICAgICAgZHJhd1RleHRDZWxsKHsgLi4uYSwgcmVjdDogeyAuLi5yZWN0LCB4OiByZWN0LnggKyAyIH0gfSwgdHh0LCBjZWxsLmNvbnRlbnRBbGlnbik7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gaXNMaW5reSA/IHRoZW1lLmxpbmtDb2xvciA6IHRoZW1lLnRleHREYXJrO1xuICAgICAgICBkcmF3VGV4dENlbGwoYSwgdHh0LCBjZWxsLmNvbnRlbnRBbGlnbik7XG4gICAgfSxcbiAgICBvbkNsaWNrOiBhID0+IHtcbiAgICAgICAgY29uc3QgeyBjZWxsLCBib3VuZHMsIHBvc1gsIHBvc1ksIHRoZW1lIH0gPSBhO1xuICAgICAgICBjb25zdCB0eHQgPSBjZWxsLmRpc3BsYXlEYXRhID8/IGNlbGwuZGF0YTtcbiAgICAgICAgaWYgKGNlbGwuaG92ZXJFZmZlY3QgIT09IHRydWUgfHwgY2VsbC5vbkNsaWNrVXJpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG0gPSBnZXRNZWFzdXJlZFRleHRDYWNoZSh0eHQsIHRoZW1lLmJhc2VGb250RnVsbCk7XG4gICAgICAgIGlmIChtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHRleHRSZWN0ID0gZ2V0VGV4dFJlY3QobSwgYm91bmRzLCB0aGVtZSwgY2VsbC5jb250ZW50QWxpZ24pO1xuICAgICAgICBjb25zdCBkaWRDbGljayA9IHBvaW50SW5SZWN0KHtcbiAgICAgICAgICAgIHg6IHRleHRSZWN0LnggLSA0LFxuICAgICAgICAgICAgeTogdGV4dFJlY3QueSAtIDQsXG4gICAgICAgICAgICB3aWR0aDogdGV4dFJlY3Qud2lkdGggKyA4LFxuICAgICAgICAgICAgaGVpZ2h0OiB0ZXh0UmVjdC5oZWlnaHQgKyA4LFxuICAgICAgICB9LCBwb3NYLCBwb3NZKTtcbiAgICAgICAgaWYgKGRpZENsaWNrKSB7XG4gICAgICAgICAgICBjZWxsLm9uQ2xpY2tVcmkoYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG1lYXN1cmU6IChjdHgsIGNlbGwsIHRoZW1lKSA9PiBjdHgubWVhc3VyZVRleHQoY2VsbC5kaXNwbGF5RGF0YSA/PyBjZWxsLmRhdGEpLndpZHRoICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nICogMixcbiAgICBvbkRlbGV0ZTogYyA9PiAoe1xuICAgICAgICAuLi5jLFxuICAgICAgICBkYXRhOiBcIlwiLFxuICAgIH0pLFxuICAgIHByb3ZpZGVFZGl0b3I6IGNlbGwgPT4gcCA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25DaGFuZ2UsIHZhbHVlLCBmb3JjZUVkaXRNb2RlLCB2YWxpZGF0ZWRTZWxlY3Rpb24gfSA9IHA7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChVcmlPdmVybGF5RWRpdG9yLCB7IGZvcmNlRWRpdE1vZGU6IHZhbHVlLnJlYWRvbmx5ICE9PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgKGZvcmNlRWRpdE1vZGUgfHwgKGNlbGwuaG92ZXJFZmZlY3QgPT09IHRydWUgJiYgY2VsbC5vbkNsaWNrVXJpICE9PSB1bmRlZmluZWQpKSwgdXJpOiB2YWx1ZS5kYXRhLCBwcmV2aWV3OiB2YWx1ZS5kaXNwbGF5RGF0YSA/PyB2YWx1ZS5kYXRhLCB2YWxpZGF0ZWRTZWxlY3Rpb246IHZhbGlkYXRlZFNlbGVjdGlvbiwgcmVhZG9ubHk6IHZhbHVlLnJlYWRvbmx5ID09PSB0cnVlLCBvbkNoYW5nZTogZSA9PiBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YTogZS50YXJnZXQudmFsdWUsXG4gICAgICAgICAgICB9KSB9KSk7XG4gICAgfSxcbiAgICBvblBhc3RlOiAodG9QYXN0ZSwgY2VsbCwgZGV0YWlscykgPT4gdG9QYXN0ZSA9PT0gY2VsbC5kYXRhXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogeyAuLi5jZWxsLCBkYXRhOiB0b1Bhc3RlLCBkaXNwbGF5RGF0YTogZGV0YWlscy5mb3JtYXR0ZWRTdHJpbmcgPz8gY2VsbC5kaXNwbGF5RGF0YSB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS1jZWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/uri-cell.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/browser-detect.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/common/browser-detect.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   browserIsFirefox: () => (/* binding */ browserIsFirefox),\n/* harmony export */   browserIsOSX: () => (/* binding */ browserIsOSX),\n/* harmony export */   browserIsSafari: () => (/* binding */ browserIsSafari)\n/* harmony export */ });\nclass Lazy {\n    fn;\n    val;\n    constructor(fn) {\n        this.fn = fn;\n    }\n    get value() {\n        return this.val ?? (this.val = this.fn());\n    }\n}\nfunction lazy(fn) {\n    return new Lazy(fn);\n}\n// next.js apps don't have window available at import time, so this will fail if its not lazy.\nconst browserIsFirefox = lazy(() => window.navigator.userAgent.includes(\"Firefox\"));\nconst browserIsSafari = lazy(() => window.navigator.userAgent.includes(\"Mac OS\") &&\n    window.navigator.userAgent.includes(\"Safari\") &&\n    !window.navigator.userAgent.includes(\"Chrome\"));\nconst browserIsOSX = lazy(() => window.navigator.platform.toLowerCase().startsWith(\"mac\"));\n//# sourceMappingURL=browser-detect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL2Jyb3dzZXItZGV0ZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9jb21tb24vYnJvd3Nlci1kZXRlY3QuanM/MjhkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBMYXp5IHtcbiAgICBmbjtcbiAgICB2YWw7XG4gICAgY29uc3RydWN0b3IoZm4pIHtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbCA/PyAodGhpcy52YWwgPSB0aGlzLmZuKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxhenkoZm4pIHtcbiAgICByZXR1cm4gbmV3IExhenkoZm4pO1xufVxuLy8gbmV4dC5qcyBhcHBzIGRvbid0IGhhdmUgd2luZG93IGF2YWlsYWJsZSBhdCBpbXBvcnQgdGltZSwgc28gdGhpcyB3aWxsIGZhaWwgaWYgaXRzIG5vdCBsYXp5LlxuZXhwb3J0IGNvbnN0IGJyb3dzZXJJc0ZpcmVmb3ggPSBsYXp5KCgpID0+IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveFwiKSk7XG5leHBvcnQgY29uc3QgYnJvd3NlcklzU2FmYXJpID0gbGF6eSgoKSA9PiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIk1hYyBPU1wiKSAmJlxuICAgIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiU2FmYXJpXCIpICYmXG4gICAgIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiQ2hyb21lXCIpKTtcbmV4cG9ydCBjb25zdCBicm93c2VySXNPU1ggPSBsYXp5KCgpID0+IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwibWFjXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXItZGV0ZWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/browser-detect.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/image-window-loader.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/common/image-window-loader.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _internal_data_grid_cell_set_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/data-grid/cell-set.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/cell-set.js\");\n/* harmony import */ var lodash_throttle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/throttle.js */ \"(ssr)/./node_modules/lodash/throttle.js\");\n/* harmony import */ var _render_state_provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render-state-provider.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/render-state-provider.js\");\n\n\n\nconst imgPool = [];\nclass ImageWindowLoaderImpl extends _render_state_provider_js__WEBPACK_IMPORTED_MODULE_1__.WindowingTrackerBase {\n    imageLoaded = () => undefined;\n    loadedLocations = [];\n    cache = {};\n    setCallback(imageLoaded) {\n        this.imageLoaded = imageLoaded;\n    }\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    sendLoaded = lodash_throttle_js__WEBPACK_IMPORTED_MODULE_0__(() => {\n        this.imageLoaded(new _internal_data_grid_cell_set_js__WEBPACK_IMPORTED_MODULE_2__.CellSet(this.loadedLocations));\n        this.loadedLocations = [];\n    }, 20);\n    clearOutOfWindow = () => {\n        const keys = Object.keys(this.cache);\n        for (const key of keys) {\n            const obj = this.cache[key];\n            let keep = false;\n            for (let j = 0; j < obj.cells.length; j++) {\n                const packed = obj.cells[j];\n                if (this.isInWindow(packed)) {\n                    keep = true;\n                    break;\n                }\n            }\n            if (keep) {\n                obj.cells = obj.cells.filter(this.isInWindow);\n            }\n            else {\n                obj.cancel();\n                delete this.cache[key];\n            }\n        }\n    };\n    loadImage(url, col, row, key) {\n        let loaded = false;\n        const img = imgPool.pop() ?? new Image();\n        let canceled = false;\n        const result = {\n            img: undefined,\n            cells: [(0,_render_state_provider_js__WEBPACK_IMPORTED_MODULE_1__.packColRowToNumber)(col, row)],\n            url,\n            cancel: () => {\n                if (canceled)\n                    return;\n                canceled = true;\n                if (imgPool.length < 12) {\n                    imgPool.unshift(img); // never retain more than 12\n                }\n                else if (!loaded) {\n                    img.src = \"\";\n                }\n            },\n        };\n        const loadPromise = new Promise(r => img.addEventListener(\"load\", () => r(null)));\n        // use request animation time to avoid paying src set costs during draw calls\n        requestAnimationFrame(async () => {\n            try {\n                img.src = url;\n                await loadPromise;\n                await img.decode();\n                const toWrite = this.cache[key];\n                if (toWrite !== undefined && !canceled) {\n                    toWrite.img = img;\n                    for (const packed of toWrite.cells) {\n                        this.loadedLocations.push((0,_render_state_provider_js__WEBPACK_IMPORTED_MODULE_1__.unpackNumberToColRow)(packed));\n                    }\n                    loaded = true;\n                    this.sendLoaded();\n                }\n            }\n            catch {\n                result.cancel();\n            }\n        });\n        this.cache[key] = result;\n    }\n    loadOrGetImage(url, col, row) {\n        const key = url;\n        const current = this.cache[key];\n        if (current !== undefined) {\n            const packed = (0,_render_state_provider_js__WEBPACK_IMPORTED_MODULE_1__.packColRowToNumber)(col, row);\n            if (!current.cells.includes(packed)) {\n                current.cells.push(packed);\n            }\n            return current.img;\n        }\n        else {\n            this.loadImage(url, col, row, key);\n        }\n        return undefined;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImageWindowLoaderImpl);\n//# sourceMappingURL=image-window-loader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL2ltYWdlLXdpbmRvdy1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0RDtBQUNsQjtBQUNrRTtBQUM1RztBQUNBLG9DQUFvQywyRUFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQVE7QUFDekIsNkJBQTZCLG9FQUFPO0FBQ3BDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwrRUFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkVBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxxQkFBcUIsRUFBQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NvbW1vbi9pbWFnZS13aW5kb3ctbG9hZGVyLmpzPzZhNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2VsbFNldCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvY2VsbC1zZXQuanNcIjtcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwibG9kYXNoL3Rocm90dGxlLmpzXCI7XG5pbXBvcnQgeyBwYWNrQ29sUm93VG9OdW1iZXIsIHVucGFja051bWJlclRvQ29sUm93LCBXaW5kb3dpbmdUcmFja2VyQmFzZSB9IGZyb20gXCIuL3JlbmRlci1zdGF0ZS1wcm92aWRlci5qc1wiO1xuY29uc3QgaW1nUG9vbCA9IFtdO1xuY2xhc3MgSW1hZ2VXaW5kb3dMb2FkZXJJbXBsIGV4dGVuZHMgV2luZG93aW5nVHJhY2tlckJhc2Uge1xuICAgIGltYWdlTG9hZGVkID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgIGxvYWRlZExvY2F0aW9ucyA9IFtdO1xuICAgIGNhY2hlID0ge307XG4gICAgc2V0Q2FsbGJhY2soaW1hZ2VMb2FkZWQpIHtcbiAgICAgICAgdGhpcy5pbWFnZUxvYWRlZCA9IGltYWdlTG9hZGVkO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9jb25zaXN0ZW50LWZ1bmN0aW9uLXNjb3BpbmdcbiAgICBzZW5kTG9hZGVkID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgICB0aGlzLmltYWdlTG9hZGVkKG5ldyBDZWxsU2V0KHRoaXMubG9hZGVkTG9jYXRpb25zKSk7XG4gICAgICAgIHRoaXMubG9hZGVkTG9jYXRpb25zID0gW107XG4gICAgfSwgMjApO1xuICAgIGNsZWFyT3V0T2ZXaW5kb3cgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmNhY2hlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jYWNoZVtrZXldO1xuICAgICAgICAgICAgbGV0IGtlZXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb2JqLmNlbGxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja2VkID0gb2JqLmNlbGxzW2pdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW5XaW5kb3cocGFja2VkKSkge1xuICAgICAgICAgICAgICAgICAgICBrZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtlZXApIHtcbiAgICAgICAgICAgICAgICBvYmouY2VsbHMgPSBvYmouY2VsbHMuZmlsdGVyKHRoaXMuaXNJbldpbmRvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmouY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgbG9hZEltYWdlKHVybCwgY29sLCByb3csIGtleSkge1xuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGltZyA9IGltZ1Bvb2wucG9wKCkgPz8gbmV3IEltYWdlKCk7XG4gICAgICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBpbWc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlbGxzOiBbcGFja0NvbFJvd1RvTnVtYmVyKGNvbCwgcm93KV0sXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGltZ1Bvb2wubGVuZ3RoIDwgMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nUG9vbC51bnNoaWZ0KGltZyk7IC8vIG5ldmVyIHJldGFpbiBtb3JlIHRoYW4gMTJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKHIgPT4gaW1nLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHIobnVsbCkpKTtcbiAgICAgICAgLy8gdXNlIHJlcXVlc3QgYW5pbWF0aW9uIHRpbWUgdG8gYXZvaWQgcGF5aW5nIHNyYyBzZXQgY29zdHMgZHVyaW5nIGRyYXcgY2FsbHNcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBhd2FpdCBpbWcuZGVjb2RlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9Xcml0ZSA9IHRoaXMuY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodG9Xcml0ZSAhPT0gdW5kZWZpbmVkICYmICFjYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0b1dyaXRlLmltZyA9IGltZztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWNrZWQgb2YgdG9Xcml0ZS5jZWxscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkZWRMb2NhdGlvbnMucHVzaCh1bnBhY2tOdW1iZXJUb0NvbFJvdyhwYWNrZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRMb2FkZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gcmVzdWx0O1xuICAgIH1cbiAgICBsb2FkT3JHZXRJbWFnZSh1cmwsIGNvbCwgcm93KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHVybDtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY2FjaGVba2V5XTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcGFja2VkID0gcGFja0NvbFJvd1RvTnVtYmVyKGNvbCwgcm93KTtcbiAgICAgICAgICAgIGlmICghY3VycmVudC5jZWxscy5pbmNsdWRlcyhwYWNrZWQpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5jZWxscy5wdXNoKHBhY2tlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudC5pbWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZSh1cmwsIGNvbCwgcm93LCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXaW5kb3dMb2FkZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2Utd2luZG93LWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/image-window-loader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/is-hotkey.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/common/is-hotkey.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isHotkey: () => (/* binding */ isHotkey)\n/* harmony export */ });\n/* harmony import */ var _browser_detect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser-detect.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/browser-detect.js\");\n\n// brain dead syntax, find your deps, and make buggy replacements with 5 times the effort\n// all lower case\n// ctrl+shift+alt+d or ctrl+x or shift+c or shift+Backspace or alt+_53\n// you get it, last one is always event.key, nothing fancy\n// special: primary === ctrl on windows, meta on mac\n// no to lower, its a waste, we're the only consumer, don't use caps\n// and before you ask, yes space is \" \", e.g. \"ctrl+alt+ \", whatacountry.gif\n// load bearing whitespace, it's basically python\n// if the char starts with a _ it is the event.keycode instead\nfunction checkKey(key, args) {\n    if (key === undefined)\n        return false;\n    if (key.length > 1 && key.startsWith(\"_\")) {\n        const keycode = Number.parseInt(key.slice(1));\n        return keycode === args.keyCode;\n    }\n    if (key.length === 1 && key >= \"a\" && key <= \"z\") {\n        return key.toUpperCase().codePointAt(0) === args.keyCode;\n    }\n    return key === args.key;\n}\nfunction isHotkey(hotkey, args, details) {\n    const result = isHotkeyInner(hotkey, args);\n    if (result)\n        details.didMatch = true;\n    return result;\n}\nfunction isHotkeyInner(hotkey, args) {\n    if (hotkey.length === 0)\n        return false;\n    if (hotkey.includes(\"|\")) {\n        const parts = hotkey.split(\"|\");\n        for (const part of parts) {\n            if (isHotkeyInner(part, args))\n                return true;\n        }\n        return false;\n    }\n    let wantCtrl = false;\n    let wantShift = false;\n    let wantAlt = false;\n    let wantMeta = false;\n    const split = hotkey.split(\"+\");\n    const key = split.pop();\n    if (!checkKey(key, args))\n        return false;\n    if (split[0] === \"any\")\n        return true;\n    for (const accel of split) {\n        switch (accel) {\n            case \"ctrl\":\n                wantCtrl = true;\n                break;\n            case \"shift\":\n                wantShift = true;\n                break;\n            case \"alt\":\n                wantAlt = true;\n                break;\n            case \"meta\":\n                wantMeta = true;\n                break;\n            case \"primary\":\n                if (_browser_detect_js__WEBPACK_IMPORTED_MODULE_0__.browserIsOSX.value) {\n                    wantMeta = true;\n                }\n                else {\n                    wantCtrl = true;\n                }\n                break;\n        }\n    }\n    return (args.altKey === wantAlt && args.ctrlKey === wantCtrl && args.shiftKey === wantShift && args.metaKey === wantMeta);\n}\n//# sourceMappingURL=is-hotkey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL2lzLWhvdGtleS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NvbW1vbi9pcy1ob3RrZXkuanM/MmE4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBicm93c2VySXNPU1ggfSBmcm9tIFwiLi9icm93c2VyLWRldGVjdC5qc1wiO1xuLy8gYnJhaW4gZGVhZCBzeW50YXgsIGZpbmQgeW91ciBkZXBzLCBhbmQgbWFrZSBidWdneSByZXBsYWNlbWVudHMgd2l0aCA1IHRpbWVzIHRoZSBlZmZvcnRcbi8vIGFsbCBsb3dlciBjYXNlXG4vLyBjdHJsK3NoaWZ0K2FsdCtkIG9yIGN0cmwreCBvciBzaGlmdCtjIG9yIHNoaWZ0K0JhY2tzcGFjZSBvciBhbHQrXzUzXG4vLyB5b3UgZ2V0IGl0LCBsYXN0IG9uZSBpcyBhbHdheXMgZXZlbnQua2V5LCBub3RoaW5nIGZhbmN5XG4vLyBzcGVjaWFsOiBwcmltYXJ5ID09PSBjdHJsIG9uIHdpbmRvd3MsIG1ldGEgb24gbWFjXG4vLyBubyB0byBsb3dlciwgaXRzIGEgd2FzdGUsIHdlJ3JlIHRoZSBvbmx5IGNvbnN1bWVyLCBkb24ndCB1c2UgY2Fwc1xuLy8gYW5kIGJlZm9yZSB5b3UgYXNrLCB5ZXMgc3BhY2UgaXMgXCIgXCIsIGUuZy4gXCJjdHJsK2FsdCsgXCIsIHdoYXRhY291bnRyeS5naWZcbi8vIGxvYWQgYmVhcmluZyB3aGl0ZXNwYWNlLCBpdCdzIGJhc2ljYWxseSBweXRob25cbi8vIGlmIHRoZSBjaGFyIHN0YXJ0cyB3aXRoIGEgXyBpdCBpcyB0aGUgZXZlbnQua2V5Y29kZSBpbnN0ZWFkXG5mdW5jdGlvbiBjaGVja0tleShrZXksIGFyZ3MpIHtcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoa2V5Lmxlbmd0aCA+IDEgJiYga2V5LnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICAgIGNvbnN0IGtleWNvZGUgPSBOdW1iZXIucGFyc2VJbnQoa2V5LnNsaWNlKDEpKTtcbiAgICAgICAgcmV0dXJuIGtleWNvZGUgPT09IGFyZ3Mua2V5Q29kZTtcbiAgICB9XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDEgJiYga2V5ID49IFwiYVwiICYmIGtleSA8PSBcInpcIikge1xuICAgICAgICByZXR1cm4ga2V5LnRvVXBwZXJDYXNlKCkuY29kZVBvaW50QXQoMCkgPT09IGFyZ3Mua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleSA9PT0gYXJncy5rZXk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNIb3RrZXkoaG90a2V5LCBhcmdzLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gaXNIb3RrZXlJbm5lcihob3RrZXksIGFyZ3MpO1xuICAgIGlmIChyZXN1bHQpXG4gICAgICAgIGRldGFpbHMuZGlkTWF0Y2ggPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0hvdGtleUlubmVyKGhvdGtleSwgYXJncykge1xuICAgIGlmIChob3RrZXkubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGhvdGtleS5pbmNsdWRlcyhcInxcIikpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBob3RrZXkuc3BsaXQoXCJ8XCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChpc0hvdGtleUlubmVyKHBhcnQsIGFyZ3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHdhbnRDdHJsID0gZmFsc2U7XG4gICAgbGV0IHdhbnRTaGlmdCA9IGZhbHNlO1xuICAgIGxldCB3YW50QWx0ID0gZmFsc2U7XG4gICAgbGV0IHdhbnRNZXRhID0gZmFsc2U7XG4gICAgY29uc3Qgc3BsaXQgPSBob3RrZXkuc3BsaXQoXCIrXCIpO1xuICAgIGNvbnN0IGtleSA9IHNwbGl0LnBvcCgpO1xuICAgIGlmICghY2hlY2tLZXkoa2V5LCBhcmdzKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzcGxpdFswXSA9PT0gXCJhbnlcIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChjb25zdCBhY2NlbCBvZiBzcGxpdCkge1xuICAgICAgICBzd2l0Y2ggKGFjY2VsKSB7XG4gICAgICAgICAgICBjYXNlIFwiY3RybFwiOlxuICAgICAgICAgICAgICAgIHdhbnRDdHJsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzaGlmdFwiOlxuICAgICAgICAgICAgICAgIHdhbnRTaGlmdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYWx0XCI6XG4gICAgICAgICAgICAgICAgd2FudEFsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWV0YVwiOlxuICAgICAgICAgICAgICAgIHdhbnRNZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwcmltYXJ5XCI6XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXJJc09TWC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB3YW50TWV0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YW50Q3RybCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoYXJncy5hbHRLZXkgPT09IHdhbnRBbHQgJiYgYXJncy5jdHJsS2V5ID09PSB3YW50Q3RybCAmJiBhcmdzLnNoaWZ0S2V5ID09PSB3YW50U2hpZnQgJiYgYXJncy5tZXRhS2V5ID09PSB3YW50TWV0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1ob3RrZXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/is-hotkey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   combineRects: () => (/* binding */ combineRects),\n/* harmony export */   getClosestRect: () => (/* binding */ getClosestRect),\n/* harmony export */   hugRectToTarget: () => (/* binding */ hugRectToTarget),\n/* harmony export */   intersectRect: () => (/* binding */ intersectRect),\n/* harmony export */   pointInRect: () => (/* binding */ pointInRect),\n/* harmony export */   rectContains: () => (/* binding */ rectContains),\n/* harmony export */   splitRectIntoRegions: () => (/* binding */ splitRectIntoRegions)\n/* harmony export */ });\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* eslint-disable unicorn/prefer-ternary */\n\nfunction getClosestRect(rect, px, py, allowedDirections) {\n    if (allowedDirections === \"any\")\n        return combineRects(rect, { x: px, y: py, width: 1, height: 1 });\n    if (allowedDirections === \"vertical\")\n        px = rect.x;\n    if (allowedDirections === \"horizontal\")\n        py = rect.y;\n    // Check if the point is inside the rectangle\n    if ((0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__.itemIsInRect)([px, py], rect)) {\n        return undefined;\n    }\n    // Calculate distances to the closest edges\n    const distanceToLeft = px - rect.x;\n    const distanceToRight = rect.x + rect.width - px;\n    const distanceToTop = py - rect.y + 1;\n    const distanceToBottom = rect.y + rect.height - py;\n    // Find the minimum distance\n    const minDistance = Math.min(allowedDirections === \"vertical\" ? Number.MAX_SAFE_INTEGER : distanceToLeft, allowedDirections === \"vertical\" ? Number.MAX_SAFE_INTEGER : distanceToRight, allowedDirections === \"horizontal\" ? Number.MAX_SAFE_INTEGER : distanceToTop, allowedDirections === \"horizontal\" ? Number.MAX_SAFE_INTEGER : distanceToBottom);\n    // eslint-disable-next-line unicorn/prefer-switch\n    if (minDistance === distanceToBottom) {\n        return { x: rect.x, y: rect.y + rect.height, width: rect.width, height: py - rect.y - rect.height + 1 };\n    }\n    else if (minDistance === distanceToTop) {\n        return { x: rect.x, y: py, width: rect.width, height: rect.y - py };\n    }\n    else if (minDistance === distanceToRight) {\n        return { x: rect.x + rect.width, y: rect.y, width: px - rect.x - rect.width + 1, height: rect.height };\n    }\n    else {\n        return { x: px, y: rect.y, width: rect.x - px, height: rect.height };\n    }\n}\nfunction intersectRect(x1, y1, w1, h1, x2, y2, w2, h2) {\n    return x1 <= x2 + w2 && x2 <= x1 + w1 && y1 <= y2 + h2 && y2 <= y1 + h1;\n}\nfunction pointInRect(rect, x, y) {\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n}\nfunction combineRects(a, b) {\n    const x = Math.min(a.x, b.x);\n    const y = Math.min(a.y, b.y);\n    const width = Math.max(a.x + a.width, b.x + b.width) - x;\n    const height = Math.max(a.y + a.height, b.y + b.height) - y;\n    return { x, y, width, height };\n}\nfunction rectContains(a, b) {\n    return a.x <= b.x && a.y <= b.y && a.x + a.width >= b.x + b.width && a.y + a.height >= b.y + b.height;\n}\n/**\n * This function is absolutely critical for the performance of the fill handle and highlight regions. If you don't\n * hug rectanges when they are dashed and they are huge you will get giant GPU stalls. The reason for the mod is\n * if you don't respect the dash stroke size you will get weird artificts as the rectangle changes sizes (the dashes\n * won't line up from one frame to the next)\n */\nfunction hugRectToTarget(rect, width, height, mod) {\n    // Combine checks for early return\n    if (rect.x > width ||\n        rect.y > height ||\n        (rect.x < 0 && rect.y < 0 && rect.x + rect.width > width && rect.y + rect.height > height)) {\n        return undefined;\n    }\n    // Direct return if the rectangle is completely within bounds\n    if (rect.x >= 0 && rect.y >= 0 && rect.x + rect.width <= width && rect.y + rect.height <= height) {\n        return rect;\n    }\n    // Pre-compute constants for boundaries, we are giving ourselves slop here because we don't want to have weird\n    // issues when scaling is applied. 4px is more than enough slop.\n    const leftMax = -4;\n    const topMax = -4;\n    const rightMax = width + 4;\n    const bottomMax = height + 4;\n    // Pre-compute boundary overflows\n    const leftOverflow = leftMax - rect.x;\n    const rightOverflow = rect.x + rect.width - rightMax;\n    const topOverflow = topMax - rect.y;\n    const bottomOverflow = rect.y + rect.height - bottomMax;\n    // Adjust if necessary, using simplified calculations\n    const left = leftOverflow > 0 ? rect.x + Math.floor(leftOverflow / mod) * mod : rect.x;\n    const right = rightOverflow > 0 ? rect.x + rect.width - Math.floor(rightOverflow / mod) * mod : rect.x + rect.width;\n    const top = topOverflow > 0 ? rect.y + Math.floor(topOverflow / mod) * mod : rect.y;\n    const bottom = bottomOverflow > 0 ? rect.y + rect.height - Math.floor(bottomOverflow / mod) * mod : rect.y + rect.height;\n    return { x: left, y: top, width: right - left, height: bottom - top };\n}\nfunction splitRectIntoRegions(rect, splitIndicies, width, height, splitLocations) {\n    const [lSplit, tSplit, rSplit, bSplit] = splitIndicies;\n    const [lClip, tClip, rClip, bClip] = splitLocations;\n    const { x: inX, y: inY, width: inW, height: inH } = rect;\n    const result = [];\n    if (inW <= 0 || inH <= 0)\n        return result;\n    const inRight = inX + inW;\n    const inBottom = inY + inH;\n    // The goal is to split the inbound rect into up to 9 regions based on the provided split indicies which are\n    // more or less cut lines. The cut lines are whole numbers as is the rect. We are dividing cells on a table.\n    // In theory there can be up to 9 regions returned, so we need to be careful to make sure we get them all and\n    // not return any empty regions.\n    // compute some handy values\n    const isOverLeft = inX < lSplit;\n    const isOverTop = inY < tSplit;\n    const isOverRight = inX + inW > rSplit;\n    const isOverBottom = inY + inH > bSplit;\n    const isOverCenterVert = (inX >= lSplit && inX < rSplit) ||\n        (inRight > lSplit && inRight <= rSplit) ||\n        (inX < lSplit && inRight > rSplit);\n    const isOverCenterHoriz = (inY >= tSplit && inY < bSplit) ||\n        (inBottom > tSplit && inBottom <= bSplit) ||\n        (inY < tSplit && inBottom > bSplit);\n    const isOverCenter = isOverCenterVert && isOverCenterHoriz;\n    // center\n    if (isOverCenter) {\n        const x = Math.max(inX, lSplit);\n        const y = Math.max(inY, tSplit);\n        const right = Math.min(inRight, rSplit);\n        const bottom = Math.min(inBottom, bSplit);\n        result.push({\n            rect: { x, y, width: right - x, height: bottom - y },\n            clip: {\n                x: lClip,\n                y: tClip,\n                width: rClip - lClip + 1,\n                height: bClip - tClip + 1,\n            },\n        });\n    }\n    // top left\n    if (isOverLeft && isOverTop) {\n        const x = inX;\n        const y = inY;\n        const right = Math.min(inRight, lSplit);\n        const bottom = Math.min(inBottom, tSplit);\n        result.push({\n            rect: {\n                x,\n                y,\n                width: right - x,\n                height: bottom - y,\n            },\n            clip: {\n                x: 0,\n                y: 0,\n                width: lClip + 1,\n                height: tClip + 1,\n            },\n        });\n    }\n    // top center\n    if (isOverTop && isOverCenterVert) {\n        const x = Math.max(inX, lSplit);\n        const y = inY;\n        const right = Math.min(inRight, rSplit);\n        const bottom = Math.min(inBottom, tSplit);\n        result.push({\n            rect: {\n                x,\n                y,\n                width: right - x,\n                height: bottom - y,\n            },\n            clip: {\n                x: lClip,\n                y: 0,\n                width: rClip - lClip + 1,\n                height: tClip + 1,\n            },\n        });\n    }\n    // top right\n    if (isOverTop && isOverRight) {\n        const x = Math.max(inX, rSplit);\n        const y = inY;\n        const right = inRight;\n        const bottom = Math.min(inBottom, tSplit);\n        result.push({\n            rect: {\n                x,\n                y,\n                width: right - x,\n                height: bottom - y,\n            },\n            clip: {\n                x: rClip,\n                y: 0,\n                width: width - rClip + 1,\n                height: tClip + 1,\n            },\n        });\n    }\n    // center left\n    if (isOverLeft && isOverCenterHoriz) {\n        const x = inX;\n        const y = Math.max(inY, tSplit);\n        const right = Math.min(inRight, lSplit);\n        const bottom = Math.min(inBottom, bSplit);\n        result.push({\n            rect: {\n                x,\n                y,\n                width: right - x,\n                height: bottom - y,\n            },\n            clip: {\n                x: 0,\n                y: tClip,\n                width: lClip + 1,\n                height: bClip - tClip + 1,\n            },\n        });\n    }\n    // center right\n    if (isOverRight && isOverCenterHoriz) {\n        const x = Math.max(inX, rSplit);\n        const y = Math.max(inY, tSplit);\n        const right = inRight;\n        const bottom = Math.min(inBottom, bSplit);\n        result.push({\n            rect: {\n                x,\n                y,\n                width: right - x,\n                height: bottom - y,\n            },\n            clip: {\n                x: rClip,\n                y: tClip,\n                width: width - rClip + 1,\n                height: bClip - tClip + 1,\n            },\n        });\n    }\n    // bottom left\n    if (isOverLeft && isOverBottom) {\n        const x = inX;\n        const y = Math.max(inY, bSplit);\n        const right = Math.min(inRight, lSplit);\n        const bottom = inBottom;\n        result.push({\n            rect: {\n                x,\n                y,\n                width: right - x,\n                height: bottom - y,\n            },\n            clip: {\n                x: 0,\n                y: bClip,\n                width: lClip + 1,\n                height: height - bClip + 1,\n            },\n        });\n    }\n    // bottom center\n    if (isOverBottom && isOverCenterVert) {\n        const x = Math.max(inX, lSplit);\n        const y = Math.max(inY, bSplit);\n        const right = Math.min(inRight, rSplit);\n        const bottom = inBottom;\n        result.push({\n            rect: {\n                x,\n                y,\n                width: right - x,\n                height: bottom - y,\n            },\n            clip: {\n                x: lClip,\n                y: bClip,\n                width: rClip - lClip + 1,\n                height: height - bClip + 1,\n            },\n        });\n    }\n    // bottom right\n    if (isOverRight && isOverBottom) {\n        const x = Math.max(inX, rSplit);\n        const y = Math.max(inY, bSplit);\n        const right = inRight;\n        const bottom = inBottom;\n        result.push({\n            rect: {\n                x,\n                y,\n                width: right - x,\n                height: bottom - y,\n            },\n            clip: {\n                x: rClip,\n                y: bClip,\n                width: width - rClip + 1,\n                height: height - bClip + 1,\n            },\n        });\n    }\n    return result;\n}\n//# sourceMappingURL=math.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL21hdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUM2RTtBQUN0RTtBQUNQO0FBQ0Esb0NBQW9DLG1DQUFtQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5RkFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNENBQTRDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL21hdGguanM/OWE1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSB1bmljb3JuL3ByZWZlci10ZXJuYXJ5ICovXG5pbXBvcnQgeyBpdGVtSXNJblJlY3QgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtbGliLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc2VzdFJlY3QocmVjdCwgcHgsIHB5LCBhbGxvd2VkRGlyZWN0aW9ucykge1xuICAgIGlmIChhbGxvd2VkRGlyZWN0aW9ucyA9PT0gXCJhbnlcIilcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVSZWN0cyhyZWN0LCB7IHg6IHB4LCB5OiBweSwgd2lkdGg6IDEsIGhlaWdodDogMSB9KTtcbiAgICBpZiAoYWxsb3dlZERpcmVjdGlvbnMgPT09IFwidmVydGljYWxcIilcbiAgICAgICAgcHggPSByZWN0Lng7XG4gICAgaWYgKGFsbG93ZWREaXJlY3Rpb25zID09PSBcImhvcml6b250YWxcIilcbiAgICAgICAgcHkgPSByZWN0Lnk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gICAgaWYgKGl0ZW1Jc0luUmVjdChbcHgsIHB5XSwgcmVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlcyB0byB0aGUgY2xvc2VzdCBlZGdlc1xuICAgIGNvbnN0IGRpc3RhbmNlVG9MZWZ0ID0gcHggLSByZWN0Lng7XG4gICAgY29uc3QgZGlzdGFuY2VUb1JpZ2h0ID0gcmVjdC54ICsgcmVjdC53aWR0aCAtIHB4O1xuICAgIGNvbnN0IGRpc3RhbmNlVG9Ub3AgPSBweSAtIHJlY3QueSArIDE7XG4gICAgY29uc3QgZGlzdGFuY2VUb0JvdHRvbSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0IC0gcHk7XG4gICAgLy8gRmluZCB0aGUgbWluaW11bSBkaXN0YW5jZVxuICAgIGNvbnN0IG1pbkRpc3RhbmNlID0gTWF0aC5taW4oYWxsb3dlZERpcmVjdGlvbnMgPT09IFwidmVydGljYWxcIiA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogZGlzdGFuY2VUb0xlZnQsIGFsbG93ZWREaXJlY3Rpb25zID09PSBcInZlcnRpY2FsXCIgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IGRpc3RhbmNlVG9SaWdodCwgYWxsb3dlZERpcmVjdGlvbnMgPT09IFwiaG9yaXpvbnRhbFwiID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiBkaXN0YW5jZVRvVG9wLCBhbGxvd2VkRGlyZWN0aW9ucyA9PT0gXCJob3Jpem9udGFsXCIgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IGRpc3RhbmNlVG9Cb3R0b20pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1zd2l0Y2hcbiAgICBpZiAobWluRGlzdGFuY2UgPT09IGRpc3RhbmNlVG9Cb3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHsgeDogcmVjdC54LCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCwgd2lkdGg6IHJlY3Qud2lkdGgsIGhlaWdodDogcHkgLSByZWN0LnkgLSByZWN0LmhlaWdodCArIDEgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWluRGlzdGFuY2UgPT09IGRpc3RhbmNlVG9Ub3ApIHtcbiAgICAgICAgcmV0dXJuIHsgeDogcmVjdC54LCB5OiBweSwgd2lkdGg6IHJlY3Qud2lkdGgsIGhlaWdodDogcmVjdC55IC0gcHkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWluRGlzdGFuY2UgPT09IGRpc3RhbmNlVG9SaWdodCkge1xuICAgICAgICByZXR1cm4geyB4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnksIHdpZHRoOiBweCAtIHJlY3QueCAtIHJlY3Qud2lkdGggKyAxLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB4OiBweCwgeTogcmVjdC55LCB3aWR0aDogcmVjdC54IC0gcHgsIGhlaWdodDogcmVjdC5oZWlnaHQgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0UmVjdCh4MSwgeTEsIHcxLCBoMSwgeDIsIHkyLCB3MiwgaDIpIHtcbiAgICByZXR1cm4geDEgPD0geDIgKyB3MiAmJiB4MiA8PSB4MSArIHcxICYmIHkxIDw9IHkyICsgaDIgJiYgeTIgPD0geTEgKyBoMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludEluUmVjdChyZWN0LCB4LCB5KSB7XG4gICAgcmV0dXJuIHggPj0gcmVjdC54ICYmIHggPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiB5ID49IHJlY3QueSAmJiB5IDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVSZWN0cyhhLCBiKSB7XG4gICAgY29uc3QgeCA9IE1hdGgubWluKGEueCwgYi54KTtcbiAgICBjb25zdCB5ID0gTWF0aC5taW4oYS55LCBiLnkpO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoYS54ICsgYS53aWR0aCwgYi54ICsgYi53aWR0aCkgLSB4O1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KGEueSArIGEuaGVpZ2h0LCBiLnkgKyBiLmhlaWdodCkgLSB5O1xuICAgIHJldHVybiB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWN0Q29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhLnggPD0gYi54ICYmIGEueSA8PSBiLnkgJiYgYS54ICsgYS53aWR0aCA+PSBiLnggKyBiLndpZHRoICYmIGEueSArIGEuaGVpZ2h0ID49IGIueSArIGIuaGVpZ2h0O1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGFic29sdXRlbHkgY3JpdGljYWwgZm9yIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgZmlsbCBoYW5kbGUgYW5kIGhpZ2hsaWdodCByZWdpb25zLiBJZiB5b3UgZG9uJ3RcbiAqIGh1ZyByZWN0YW5nZXMgd2hlbiB0aGV5IGFyZSBkYXNoZWQgYW5kIHRoZXkgYXJlIGh1Z2UgeW91IHdpbGwgZ2V0IGdpYW50IEdQVSBzdGFsbHMuIFRoZSByZWFzb24gZm9yIHRoZSBtb2QgaXNcbiAqIGlmIHlvdSBkb24ndCByZXNwZWN0IHRoZSBkYXNoIHN0cm9rZSBzaXplIHlvdSB3aWxsIGdldCB3ZWlyZCBhcnRpZmljdHMgYXMgdGhlIHJlY3RhbmdsZSBjaGFuZ2VzIHNpemVzICh0aGUgZGFzaGVzXG4gKiB3b24ndCBsaW5lIHVwIGZyb20gb25lIGZyYW1lIHRvIHRoZSBuZXh0KVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHVnUmVjdFRvVGFyZ2V0KHJlY3QsIHdpZHRoLCBoZWlnaHQsIG1vZCkge1xuICAgIC8vIENvbWJpbmUgY2hlY2tzIGZvciBlYXJseSByZXR1cm5cbiAgICBpZiAocmVjdC54ID4gd2lkdGggfHxcbiAgICAgICAgcmVjdC55ID4gaGVpZ2h0IHx8XG4gICAgICAgIChyZWN0LnggPCAwICYmIHJlY3QueSA8IDAgJiYgcmVjdC54ICsgcmVjdC53aWR0aCA+IHdpZHRoICYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID4gaGVpZ2h0KSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBEaXJlY3QgcmV0dXJuIGlmIHRoZSByZWN0YW5nbGUgaXMgY29tcGxldGVseSB3aXRoaW4gYm91bmRzXG4gICAgaWYgKHJlY3QueCA+PSAwICYmIHJlY3QueSA+PSAwICYmIHJlY3QueCArIHJlY3Qud2lkdGggPD0gd2lkdGggJiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPD0gaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICAvLyBQcmUtY29tcHV0ZSBjb25zdGFudHMgZm9yIGJvdW5kYXJpZXMsIHdlIGFyZSBnaXZpbmcgb3Vyc2VsdmVzIHNsb3AgaGVyZSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gaGF2ZSB3ZWlyZFxuICAgIC8vIGlzc3VlcyB3aGVuIHNjYWxpbmcgaXMgYXBwbGllZC4gNHB4IGlzIG1vcmUgdGhhbiBlbm91Z2ggc2xvcC5cbiAgICBjb25zdCBsZWZ0TWF4ID0gLTQ7XG4gICAgY29uc3QgdG9wTWF4ID0gLTQ7XG4gICAgY29uc3QgcmlnaHRNYXggPSB3aWR0aCArIDQ7XG4gICAgY29uc3QgYm90dG9tTWF4ID0gaGVpZ2h0ICsgNDtcbiAgICAvLyBQcmUtY29tcHV0ZSBib3VuZGFyeSBvdmVyZmxvd3NcbiAgICBjb25zdCBsZWZ0T3ZlcmZsb3cgPSBsZWZ0TWF4IC0gcmVjdC54O1xuICAgIGNvbnN0IHJpZ2h0T3ZlcmZsb3cgPSByZWN0LnggKyByZWN0LndpZHRoIC0gcmlnaHRNYXg7XG4gICAgY29uc3QgdG9wT3ZlcmZsb3cgPSB0b3BNYXggLSByZWN0Lnk7XG4gICAgY29uc3QgYm90dG9tT3ZlcmZsb3cgPSByZWN0LnkgKyByZWN0LmhlaWdodCAtIGJvdHRvbU1heDtcbiAgICAvLyBBZGp1c3QgaWYgbmVjZXNzYXJ5LCB1c2luZyBzaW1wbGlmaWVkIGNhbGN1bGF0aW9uc1xuICAgIGNvbnN0IGxlZnQgPSBsZWZ0T3ZlcmZsb3cgPiAwID8gcmVjdC54ICsgTWF0aC5mbG9vcihsZWZ0T3ZlcmZsb3cgLyBtb2QpICogbW9kIDogcmVjdC54O1xuICAgIGNvbnN0IHJpZ2h0ID0gcmlnaHRPdmVyZmxvdyA+IDAgPyByZWN0LnggKyByZWN0LndpZHRoIC0gTWF0aC5mbG9vcihyaWdodE92ZXJmbG93IC8gbW9kKSAqIG1vZCA6IHJlY3QueCArIHJlY3Qud2lkdGg7XG4gICAgY29uc3QgdG9wID0gdG9wT3ZlcmZsb3cgPiAwID8gcmVjdC55ICsgTWF0aC5mbG9vcih0b3BPdmVyZmxvdyAvIG1vZCkgKiBtb2QgOiByZWN0Lnk7XG4gICAgY29uc3QgYm90dG9tID0gYm90dG9tT3ZlcmZsb3cgPiAwID8gcmVjdC55ICsgcmVjdC5oZWlnaHQgLSBNYXRoLmZsb29yKGJvdHRvbU92ZXJmbG93IC8gbW9kKSAqIG1vZCA6IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xuICAgIHJldHVybiB7IHg6IGxlZnQsIHk6IHRvcCwgd2lkdGg6IHJpZ2h0IC0gbGVmdCwgaGVpZ2h0OiBib3R0b20gLSB0b3AgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFJlY3RJbnRvUmVnaW9ucyhyZWN0LCBzcGxpdEluZGljaWVzLCB3aWR0aCwgaGVpZ2h0LCBzcGxpdExvY2F0aW9ucykge1xuICAgIGNvbnN0IFtsU3BsaXQsIHRTcGxpdCwgclNwbGl0LCBiU3BsaXRdID0gc3BsaXRJbmRpY2llcztcbiAgICBjb25zdCBbbENsaXAsIHRDbGlwLCByQ2xpcCwgYkNsaXBdID0gc3BsaXRMb2NhdGlvbnM7XG4gICAgY29uc3QgeyB4OiBpblgsIHk6IGluWSwgd2lkdGg6IGluVywgaGVpZ2h0OiBpbkggfSA9IHJlY3Q7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKGluVyA8PSAwIHx8IGluSCA8PSAwKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGNvbnN0IGluUmlnaHQgPSBpblggKyBpblc7XG4gICAgY29uc3QgaW5Cb3R0b20gPSBpblkgKyBpbkg7XG4gICAgLy8gVGhlIGdvYWwgaXMgdG8gc3BsaXQgdGhlIGluYm91bmQgcmVjdCBpbnRvIHVwIHRvIDkgcmVnaW9ucyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc3BsaXQgaW5kaWNpZXMgd2hpY2ggYXJlXG4gICAgLy8gbW9yZSBvciBsZXNzIGN1dCBsaW5lcy4gVGhlIGN1dCBsaW5lcyBhcmUgd2hvbGUgbnVtYmVycyBhcyBpcyB0aGUgcmVjdC4gV2UgYXJlIGRpdmlkaW5nIGNlbGxzIG9uIGEgdGFibGUuXG4gICAgLy8gSW4gdGhlb3J5IHRoZXJlIGNhbiBiZSB1cCB0byA5IHJlZ2lvbnMgcmV0dXJuZWQsIHNvIHdlIG5lZWQgdG8gYmUgY2FyZWZ1bCB0byBtYWtlIHN1cmUgd2UgZ2V0IHRoZW0gYWxsIGFuZFxuICAgIC8vIG5vdCByZXR1cm4gYW55IGVtcHR5IHJlZ2lvbnMuXG4gICAgLy8gY29tcHV0ZSBzb21lIGhhbmR5IHZhbHVlc1xuICAgIGNvbnN0IGlzT3ZlckxlZnQgPSBpblggPCBsU3BsaXQ7XG4gICAgY29uc3QgaXNPdmVyVG9wID0gaW5ZIDwgdFNwbGl0O1xuICAgIGNvbnN0IGlzT3ZlclJpZ2h0ID0gaW5YICsgaW5XID4gclNwbGl0O1xuICAgIGNvbnN0IGlzT3ZlckJvdHRvbSA9IGluWSArIGluSCA+IGJTcGxpdDtcbiAgICBjb25zdCBpc092ZXJDZW50ZXJWZXJ0ID0gKGluWCA+PSBsU3BsaXQgJiYgaW5YIDwgclNwbGl0KSB8fFxuICAgICAgICAoaW5SaWdodCA+IGxTcGxpdCAmJiBpblJpZ2h0IDw9IHJTcGxpdCkgfHxcbiAgICAgICAgKGluWCA8IGxTcGxpdCAmJiBpblJpZ2h0ID4gclNwbGl0KTtcbiAgICBjb25zdCBpc092ZXJDZW50ZXJIb3JpeiA9IChpblkgPj0gdFNwbGl0ICYmIGluWSA8IGJTcGxpdCkgfHxcbiAgICAgICAgKGluQm90dG9tID4gdFNwbGl0ICYmIGluQm90dG9tIDw9IGJTcGxpdCkgfHxcbiAgICAgICAgKGluWSA8IHRTcGxpdCAmJiBpbkJvdHRvbSA+IGJTcGxpdCk7XG4gICAgY29uc3QgaXNPdmVyQ2VudGVyID0gaXNPdmVyQ2VudGVyVmVydCAmJiBpc092ZXJDZW50ZXJIb3JpejtcbiAgICAvLyBjZW50ZXJcbiAgICBpZiAoaXNPdmVyQ2VudGVyKSB7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChpblgsIGxTcGxpdCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChpblksIHRTcGxpdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5taW4oaW5SaWdodCwgclNwbGl0KTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5taW4oaW5Cb3R0b20sIGJTcGxpdCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHJlY3Q6IHsgeCwgeSwgd2lkdGg6IHJpZ2h0IC0geCwgaGVpZ2h0OiBib3R0b20gLSB5IH0sXG4gICAgICAgICAgICBjbGlwOiB7XG4gICAgICAgICAgICAgICAgeDogbENsaXAsXG4gICAgICAgICAgICAgICAgeTogdENsaXAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJDbGlwIC0gbENsaXAgKyAxLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYkNsaXAgLSB0Q2xpcCArIDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gdG9wIGxlZnRcbiAgICBpZiAoaXNPdmVyTGVmdCAmJiBpc092ZXJUb3ApIHtcbiAgICAgICAgY29uc3QgeCA9IGluWDtcbiAgICAgICAgY29uc3QgeSA9IGluWTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLm1pbihpblJpZ2h0LCBsU3BsaXQpO1xuICAgICAgICBjb25zdCBib3R0b20gPSBNYXRoLm1pbihpbkJvdHRvbSwgdFNwbGl0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmlnaHQgLSB4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0geSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGlwOiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBsQ2xpcCArIDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0Q2xpcCArIDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gdG9wIGNlbnRlclxuICAgIGlmIChpc092ZXJUb3AgJiYgaXNPdmVyQ2VudGVyVmVydCkge1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoaW5YLCBsU3BsaXQpO1xuICAgICAgICBjb25zdCB5ID0gaW5ZO1xuICAgICAgICBjb25zdCByaWdodCA9IE1hdGgubWluKGluUmlnaHQsIHJTcGxpdCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWluKGluQm90dG9tLCB0U3BsaXQpO1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiByaWdodCAtIHgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3R0b20gLSB5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsaXA6IHtcbiAgICAgICAgICAgICAgICB4OiBsQ2xpcCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiByQ2xpcCAtIGxDbGlwICsgMSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRDbGlwICsgMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB0b3AgcmlnaHRcbiAgICBpZiAoaXNPdmVyVG9wICYmIGlzT3ZlclJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChpblgsIHJTcGxpdCk7XG4gICAgICAgIGNvbnN0IHkgPSBpblk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gaW5SaWdodDtcbiAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5taW4oaW5Cb3R0b20sIHRTcGxpdCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0geCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpcDoge1xuICAgICAgICAgICAgICAgIHg6IHJDbGlwLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoIC0gckNsaXAgKyAxLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdENsaXAgKyAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNlbnRlciBsZWZ0XG4gICAgaWYgKGlzT3ZlckxlZnQgJiYgaXNPdmVyQ2VudGVySG9yaXopIHtcbiAgICAgICAgY29uc3QgeCA9IGluWDtcbiAgICAgICAgY29uc3QgeSA9IE1hdGgubWF4KGluWSwgdFNwbGl0KTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLm1pbihpblJpZ2h0LCBsU3BsaXQpO1xuICAgICAgICBjb25zdCBib3R0b20gPSBNYXRoLm1pbihpbkJvdHRvbSwgYlNwbGl0KTtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmlnaHQgLSB4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0geSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGlwOiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiB0Q2xpcCxcbiAgICAgICAgICAgICAgICB3aWR0aDogbENsaXAgKyAxLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYkNsaXAgLSB0Q2xpcCArIDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2VudGVyIHJpZ2h0XG4gICAgaWYgKGlzT3ZlclJpZ2h0ICYmIGlzT3ZlckNlbnRlckhvcml6KSB7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChpblgsIHJTcGxpdCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChpblksIHRTcGxpdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gaW5SaWdodDtcbiAgICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5taW4oaW5Cb3R0b20sIGJTcGxpdCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0geCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpcDoge1xuICAgICAgICAgICAgICAgIHg6IHJDbGlwLFxuICAgICAgICAgICAgICAgIHk6IHRDbGlwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCAtIHJDbGlwICsgMSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJDbGlwIC0gdENsaXAgKyAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGJvdHRvbSBsZWZ0XG4gICAgaWYgKGlzT3ZlckxlZnQgJiYgaXNPdmVyQm90dG9tKSB7XG4gICAgICAgIGNvbnN0IHggPSBpblg7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChpblksIGJTcGxpdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5taW4oaW5SaWdodCwgbFNwbGl0KTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gaW5Cb3R0b207XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0geCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpcDoge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogYkNsaXAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGxDbGlwICsgMSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAtIGJDbGlwICsgMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBib3R0b20gY2VudGVyXG4gICAgaWYgKGlzT3ZlckJvdHRvbSAmJiBpc092ZXJDZW50ZXJWZXJ0KSB7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChpblgsIGxTcGxpdCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChpblksIGJTcGxpdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5taW4oaW5SaWdodCwgclNwbGl0KTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gaW5Cb3R0b207XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0geCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpcDoge1xuICAgICAgICAgICAgICAgIHg6IGxDbGlwLFxuICAgICAgICAgICAgICAgIHk6IGJDbGlwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiByQ2xpcCAtIGxDbGlwICsgMSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAtIGJDbGlwICsgMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBib3R0b20gcmlnaHRcbiAgICBpZiAoaXNPdmVyUmlnaHQgJiYgaXNPdmVyQm90dG9tKSB7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChpblgsIHJTcGxpdCk7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChpblksIGJTcGxpdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gaW5SaWdodDtcbiAgICAgICAgY29uc3QgYm90dG9tID0gaW5Cb3R0b207XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0geCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpcDoge1xuICAgICAgICAgICAgICAgIHg6IHJDbGlwLFxuICAgICAgICAgICAgICAgIHk6IGJDbGlwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCAtIHJDbGlwICsgMSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAtIGJDbGlwICsgMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/render-state-provider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/common/render-state-provider.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderStateProvider: () => (/* binding */ RenderStateProvider),\n/* harmony export */   WindowingTrackerBase: () => (/* binding */ WindowingTrackerBase),\n/* harmony export */   packColRowToNumber: () => (/* binding */ packColRowToNumber),\n/* harmony export */   unpackCol: () => (/* binding */ unpackCol),\n/* harmony export */   unpackNumberToColRow: () => (/* binding */ unpackNumberToColRow),\n/* harmony export */   unpackRow: () => (/* binding */ unpackRow)\n/* harmony export */ });\n/* harmony import */ var _support_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n\n// max safe int 2^53 - 1 (minus 1 omitted from here on)\n// max safe columns is 2^21 or 2,097,151\n// max safe rows is 2^32 or 4,294,967,295\n// If 3 rows render as an inch, then the max safe height is 1,431,655,765 inches or 22,426,868 miles\n// the distance to the moon is 238,900 miles, so this would give you a data grid that goes to the moon and back 94 times\n// seems fine\nconst rowShift = 1 << 21;\nfunction packColRowToNumber(col, row) {\n    return (row + 2) * rowShift + col;\n}\nfunction unpackCol(packed) {\n    return packed % rowShift;\n}\nfunction unpackRow(packed) {\n    return Math.floor(packed / rowShift) - 2;\n}\nfunction unpackNumberToColRow(packed) {\n    const col = unpackCol(packed);\n    const row = unpackRow(packed);\n    return [col, row];\n}\nclass WindowingTrackerBase {\n    visibleWindow = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n    };\n    freezeCols = 0;\n    freezeRows = [];\n    isInWindow = (packed) => {\n        const col = unpackCol(packed);\n        const row = unpackRow(packed);\n        const w = this.visibleWindow;\n        const colInWindow = (col >= w.x && col <= w.x + w.width) || col < this.freezeCols;\n        const rowInWindow = (row >= w.y && row <= w.y + w.height) || this.freezeRows.includes(row);\n        return colInWindow && rowInWindow;\n    };\n    setWindow(newWindow, freezeCols, freezeRows) {\n        if (this.visibleWindow.x === newWindow.x &&\n            this.visibleWindow.y === newWindow.y &&\n            this.visibleWindow.width === newWindow.width &&\n            this.visibleWindow.height === newWindow.height &&\n            this.freezeCols === freezeCols &&\n            (0,_support_js__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(this.freezeRows, freezeRows))\n            return;\n        this.visibleWindow = newWindow;\n        this.freezeCols = freezeCols;\n        this.freezeRows = freezeRows;\n        this.clearOutOfWindow();\n    }\n}\nclass RenderStateProvider extends WindowingTrackerBase {\n    cache = new Map();\n    setValue = (location, state) => {\n        this.cache.set(packColRowToNumber(location[0], location[1]), state);\n    };\n    getValue = (location) => {\n        return this.cache.get(packColRowToNumber(location[0], location[1]));\n    };\n    clearOutOfWindow = () => {\n        for (const [key] of this.cache.entries()) {\n            if (!this.isInWindow(key)) {\n                this.cache.delete(key);\n            }\n        }\n    };\n}\n//# sourceMappingURL=render-state-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL3JlbmRlci1zdGF0ZS1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NvbW1vbi9yZW5kZXItc3RhdGUtcHJvdmlkZXIuanM/NGM0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWVwRXF1YWwgfSBmcm9tIFwiLi9zdXBwb3J0LmpzXCI7XG4vLyBtYXggc2FmZSBpbnQgMl41MyAtIDEgKG1pbnVzIDEgb21pdHRlZCBmcm9tIGhlcmUgb24pXG4vLyBtYXggc2FmZSBjb2x1bW5zIGlzIDJeMjEgb3IgMiwwOTcsMTUxXG4vLyBtYXggc2FmZSByb3dzIGlzIDJeMzIgb3IgNCwyOTQsOTY3LDI5NVxuLy8gSWYgMyByb3dzIHJlbmRlciBhcyBhbiBpbmNoLCB0aGVuIHRoZSBtYXggc2FmZSBoZWlnaHQgaXMgMSw0MzEsNjU1LDc2NSBpbmNoZXMgb3IgMjIsNDI2LDg2OCBtaWxlc1xuLy8gdGhlIGRpc3RhbmNlIHRvIHRoZSBtb29uIGlzIDIzOCw5MDAgbWlsZXMsIHNvIHRoaXMgd291bGQgZ2l2ZSB5b3UgYSBkYXRhIGdyaWQgdGhhdCBnb2VzIHRvIHRoZSBtb29uIGFuZCBiYWNrIDk0IHRpbWVzXG4vLyBzZWVtcyBmaW5lXG5jb25zdCByb3dTaGlmdCA9IDEgPDwgMjE7XG5leHBvcnQgZnVuY3Rpb24gcGFja0NvbFJvd1RvTnVtYmVyKGNvbCwgcm93KSB7XG4gICAgcmV0dXJuIChyb3cgKyAyKSAqIHJvd1NoaWZ0ICsgY29sO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVucGFja0NvbChwYWNrZWQpIHtcbiAgICByZXR1cm4gcGFja2VkICUgcm93U2hpZnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrUm93KHBhY2tlZCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHBhY2tlZCAvIHJvd1NoaWZ0KSAtIDI7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5wYWNrTnVtYmVyVG9Db2xSb3cocGFja2VkKSB7XG4gICAgY29uc3QgY29sID0gdW5wYWNrQ29sKHBhY2tlZCk7XG4gICAgY29uc3Qgcm93ID0gdW5wYWNrUm93KHBhY2tlZCk7XG4gICAgcmV0dXJuIFtjb2wsIHJvd107XG59XG5leHBvcnQgY2xhc3MgV2luZG93aW5nVHJhY2tlckJhc2Uge1xuICAgIHZpc2libGVXaW5kb3cgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgfTtcbiAgICBmcmVlemVDb2xzID0gMDtcbiAgICBmcmVlemVSb3dzID0gW107XG4gICAgaXNJbldpbmRvdyA9IChwYWNrZWQpID0+IHtcbiAgICAgICAgY29uc3QgY29sID0gdW5wYWNrQ29sKHBhY2tlZCk7XG4gICAgICAgIGNvbnN0IHJvdyA9IHVucGFja1JvdyhwYWNrZWQpO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy52aXNpYmxlV2luZG93O1xuICAgICAgICBjb25zdCBjb2xJbldpbmRvdyA9IChjb2wgPj0gdy54ICYmIGNvbCA8PSB3LnggKyB3LndpZHRoKSB8fCBjb2wgPCB0aGlzLmZyZWV6ZUNvbHM7XG4gICAgICAgIGNvbnN0IHJvd0luV2luZG93ID0gKHJvdyA+PSB3LnkgJiYgcm93IDw9IHcueSArIHcuaGVpZ2h0KSB8fCB0aGlzLmZyZWV6ZVJvd3MuaW5jbHVkZXMocm93KTtcbiAgICAgICAgcmV0dXJuIGNvbEluV2luZG93ICYmIHJvd0luV2luZG93O1xuICAgIH07XG4gICAgc2V0V2luZG93KG5ld1dpbmRvdywgZnJlZXplQ29scywgZnJlZXplUm93cykge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlV2luZG93LnggPT09IG5ld1dpbmRvdy54ICYmXG4gICAgICAgICAgICB0aGlzLnZpc2libGVXaW5kb3cueSA9PT0gbmV3V2luZG93LnkgJiZcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZVdpbmRvdy53aWR0aCA9PT0gbmV3V2luZG93LndpZHRoICYmXG4gICAgICAgICAgICB0aGlzLnZpc2libGVXaW5kb3cuaGVpZ2h0ID09PSBuZXdXaW5kb3cuaGVpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUNvbHMgPT09IGZyZWV6ZUNvbHMgJiZcbiAgICAgICAgICAgIGRlZXBFcXVhbCh0aGlzLmZyZWV6ZVJvd3MsIGZyZWV6ZVJvd3MpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnZpc2libGVXaW5kb3cgPSBuZXdXaW5kb3c7XG4gICAgICAgIHRoaXMuZnJlZXplQ29scyA9IGZyZWV6ZUNvbHM7XG4gICAgICAgIHRoaXMuZnJlZXplUm93cyA9IGZyZWV6ZVJvd3M7XG4gICAgICAgIHRoaXMuY2xlYXJPdXRPZldpbmRvdygpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZW5kZXJTdGF0ZVByb3ZpZGVyIGV4dGVuZHMgV2luZG93aW5nVHJhY2tlckJhc2Uge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHNldFZhbHVlID0gKGxvY2F0aW9uLCBzdGF0ZSkgPT4ge1xuICAgICAgICB0aGlzLmNhY2hlLnNldChwYWNrQ29sUm93VG9OdW1iZXIobG9jYXRpb25bMF0sIGxvY2F0aW9uWzFdKSwgc3RhdGUpO1xuICAgIH07XG4gICAgZ2V0VmFsdWUgPSAobG9jYXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KHBhY2tDb2xSb3dUb051bWJlcihsb2NhdGlvblswXSwgbG9jYXRpb25bMV0pKTtcbiAgICB9O1xuICAgIGNsZWFyT3V0T2ZXaW5kb3cgPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcy5jYWNoZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0luV2luZG93KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlci1zdGF0ZS1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/render-state-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/resize-detector.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/common/resize-detector.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useResizeDetector: () => (/* binding */ useResizeDetector)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n\nfunction useResizeDetector(initialSize) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [size, setSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        width: initialSize?.[0],\n        height: initialSize?.[1],\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        const resizeCallback = entries => {\n            for (const entry of entries) {\n                const { width, height } = (entry && entry.contentRect) || {};\n                setSize(cv => (cv.width === width && cv.height === height ? cv : { width, height }));\n            }\n        };\n        const resizeObserver = new window.ResizeObserver(resizeCallback);\n        if (ref.current) {\n            resizeObserver.observe(ref.current, undefined);\n        }\n        return () => {\n            resizeObserver.disconnect();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [ref.current]);\n    return { ref, ...size };\n}\n//# sourceMappingURL=resize-detector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL3Jlc2l6ZS1kZXRlY3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQzBEO0FBQ25EO0FBQ1AsZ0JBQWdCLDZDQUFNO0FBQ3RCLDRCQUE0QiwrQ0FBUTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksc0RBQWU7QUFDbkI7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEMsbUZBQW1GLGVBQWU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9jb21tb24vcmVzaXplLWRldGVjdG9yLmpzP2M4ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zICovXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXNpemVEZXRlY3Rvcihpbml0aWFsU2l6ZSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBbc2l6ZSwgc2V0U2l6ZV0gPSB1c2VTdGF0ZSh7XG4gICAgICAgIHdpZHRoOiBpbml0aWFsU2l6ZT8uWzBdLFxuICAgICAgICBoZWlnaHQ6IGluaXRpYWxTaXplPy5bMV0sXG4gICAgfSk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzaXplQ2FsbGJhY2sgPSBlbnRyaWVzID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gKGVudHJ5ICYmIGVudHJ5LmNvbnRlbnRSZWN0KSB8fCB7fTtcbiAgICAgICAgICAgICAgICBzZXRTaXplKGN2ID0+IChjdi53aWR0aCA9PT0gd2lkdGggJiYgY3YuaGVpZ2h0ID09PSBoZWlnaHQgPyBjdiA6IHsgd2lkdGgsIGhlaWdodCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IHdpbmRvdy5SZXNpemVPYnNlcnZlcihyZXNpemVDYWxsYmFjayk7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW3JlZi5jdXJyZW50XSk7XG4gICAgcmV0dXJuIHsgcmVmLCAuLi5zaXplIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNpemUtZGV0ZWN0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/resize-detector.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ThemeContext: () => (/* binding */ ThemeContext),\n/* harmony export */   getDataEditorTheme: () => (/* binding */ getDataEditorTheme),\n/* harmony export */   makeCSSStyle: () => (/* binding */ makeCSSStyle),\n/* harmony export */   mergeAndRealizeTheme: () => (/* binding */ mergeAndRealizeTheme),\n/* harmony export */   useTheme: () => (/* binding */ useTheme)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_data_grid_color_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/color-parser.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\");\n\n\n// theme variable precidence\n/** @category Theme */\nfunction makeCSSStyle(theme) {\n    return {\n        \"--gdg-accent-color\": theme.accentColor,\n        \"--gdg-accent-fg\": theme.accentFg,\n        \"--gdg-accent-light\": theme.accentLight,\n        \"--gdg-text-dark\": theme.textDark,\n        \"--gdg-text-medium\": theme.textMedium,\n        \"--gdg-text-light\": theme.textLight,\n        \"--gdg-text-bubble\": theme.textBubble,\n        \"--gdg-bg-icon-header\": theme.bgIconHeader,\n        \"--gdg-fg-icon-header\": theme.fgIconHeader,\n        \"--gdg-text-header\": theme.textHeader,\n        \"--gdg-text-group-header\": theme.textGroupHeader ?? theme.textHeader,\n        \"--gdg-text-header-selected\": theme.textHeaderSelected,\n        \"--gdg-bg-cell\": theme.bgCell,\n        \"--gdg-bg-cell-medium\": theme.bgCellMedium,\n        \"--gdg-bg-header\": theme.bgHeader,\n        \"--gdg-bg-header-has-focus\": theme.bgHeaderHasFocus,\n        \"--gdg-bg-header-hovered\": theme.bgHeaderHovered,\n        \"--gdg-bg-bubble\": theme.bgBubble,\n        \"--gdg-bg-bubble-selected\": theme.bgBubbleSelected,\n        \"--gdg-bg-search-result\": theme.bgSearchResult,\n        \"--gdg-border-color\": theme.borderColor,\n        \"--gdg-horizontal-border-color\": theme.horizontalBorderColor ?? theme.borderColor,\n        \"--gdg-drilldown-border\": theme.drilldownBorder,\n        \"--gdg-link-color\": theme.linkColor,\n        \"--gdg-cell-horizontal-padding\": `${theme.cellHorizontalPadding}px`,\n        \"--gdg-cell-vertical-padding\": `${theme.cellVerticalPadding}px`,\n        \"--gdg-header-font-style\": theme.headerFontStyle,\n        \"--gdg-base-font-style\": theme.baseFontStyle,\n        \"--gdg-marker-font-style\": theme.markerFontStyle,\n        \"--gdg-font-family\": theme.fontFamily,\n        \"--gdg-editor-font-size\": theme.editorFontSize,\n        ...(theme.resizeIndicatorColor === undefined\n            ? {}\n            : { \"--gdg-resize-indicator-color\": theme.resizeIndicatorColor }),\n        ...(theme.headerBottomBorderColor === undefined\n            ? {}\n            : { \"--gdg-header-bottom-border-color\": theme.headerBottomBorderColor }),\n        ...(theme.roundingRadius === undefined ? {} : { \"--gdg-rounding-radius\": `${theme.roundingRadius}px` }),\n    };\n}\nconst dataEditorBaseTheme = {\n    accentColor: \"#4F5DFF\",\n    accentFg: \"#FFFFFF\",\n    accentLight: \"rgba(62, 116, 253, 0.1)\",\n    textDark: \"#313139\",\n    textMedium: \"#737383\",\n    textLight: \"#B2B2C0\",\n    textBubble: \"#313139\",\n    bgIconHeader: \"#737383\",\n    fgIconHeader: \"#FFFFFF\",\n    textHeader: \"#313139\",\n    textGroupHeader: \"#313139BB\",\n    textHeaderSelected: \"#FFFFFF\",\n    bgCell: \"#FFFFFF\",\n    bgCellMedium: \"#FAFAFB\",\n    bgHeader: \"#F7F7F8\",\n    bgHeaderHasFocus: \"#E9E9EB\",\n    bgHeaderHovered: \"#EFEFF1\",\n    bgBubble: \"#EDEDF3\",\n    bgBubbleSelected: \"#FFFFFF\",\n    bgSearchResult: \"#fff9e3\",\n    borderColor: \"rgba(115, 116, 131, 0.16)\",\n    drilldownBorder: \"rgba(0, 0, 0, 0)\",\n    linkColor: \"#353fb5\",\n    cellHorizontalPadding: 8,\n    cellVerticalPadding: 3,\n    headerIconSize: 18,\n    headerFontStyle: \"600 13px\",\n    baseFontStyle: \"13px\",\n    markerFontStyle: \"9px\",\n    fontFamily: \"Inter, Roboto, -apple-system, BlinkMacSystemFont, avenir next, avenir, segoe ui, helvetica neue, helvetica, Ubuntu, noto, arial, sans-serif\",\n    editorFontSize: \"13px\",\n    lineHeight: 1.4, //unitless scaler depends on your font\n};\n/** @category Theme */\nfunction getDataEditorTheme() {\n    return dataEditorBaseTheme;\n}\n/** @category Theme */\nconst ThemeContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(dataEditorBaseTheme);\n/** @category Hooks */\nfunction useTheme() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(ThemeContext);\n}\nfunction mergeAndRealizeTheme(theme, ...overlays) {\n    const merged = { ...theme };\n    for (const overlay of overlays) {\n        if (overlay !== undefined) {\n            for (const key in overlay) {\n                // eslint-disable-next-line no-prototype-builtins\n                if (overlay.hasOwnProperty(key)) {\n                    if (key === \"bgCell\") {\n                        merged[key] = (0,_internal_data_grid_color_parser_js__WEBPACK_IMPORTED_MODULE_1__.blend)(overlay[key], merged[key]);\n                    }\n                    else {\n                        merged[key] = overlay[key];\n                    }\n                }\n            }\n        }\n    }\n    if (merged.headerFontFull === undefined ||\n        theme.fontFamily !== merged.fontFamily ||\n        theme.headerFontStyle !== merged.headerFontStyle) {\n        merged.headerFontFull = `${merged.headerFontStyle} ${merged.fontFamily}`;\n    }\n    if (merged.baseFontFull === undefined ||\n        theme.fontFamily !== merged.fontFamily ||\n        theme.baseFontStyle !== merged.baseFontStyle) {\n        merged.baseFontFull = `${merged.baseFontStyle} ${merged.fontFamily}`;\n    }\n    if (merged.markerFontFull === undefined ||\n        theme.fontFamily !== merged.fontFamily ||\n        theme.markerFontStyle !== merged.markerFontStyle) {\n        merged.markerFontFull = `${merged.markerFontStyle} ${merged.fontFamily}`;\n    }\n    return merged;\n}\n//# sourceMappingURL=styles.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL3N0eWxlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBCO0FBQ29DO0FBQzlEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDRCQUE0QjtBQUN4RSwwQ0FBMEMsMEJBQTBCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUE0RDtBQUM1RTtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFtRTtBQUNuRixvREFBb0QsSUFBSSw0QkFBNEIscUJBQXFCLEtBQUs7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQixnREFBbUI7QUFDL0M7QUFDTztBQUNQLFdBQVcsNkNBQWdCO0FBQzNCO0FBQ087QUFDUCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBFQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCLEVBQUUsa0JBQWtCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFzQixFQUFFLGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0IsRUFBRSxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9jb21tb24vc3R5bGVzLmpzPzA2OGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgYmxlbmQgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL2NvbG9yLXBhcnNlci5qc1wiO1xuLy8gdGhlbWUgdmFyaWFibGUgcHJlY2lkZW5jZVxuLyoqIEBjYXRlZ29yeSBUaGVtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDU1NTdHlsZSh0aGVtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiLS1nZGctYWNjZW50LWNvbG9yXCI6IHRoZW1lLmFjY2VudENvbG9yLFxuICAgICAgICBcIi0tZ2RnLWFjY2VudC1mZ1wiOiB0aGVtZS5hY2NlbnRGZyxcbiAgICAgICAgXCItLWdkZy1hY2NlbnQtbGlnaHRcIjogdGhlbWUuYWNjZW50TGlnaHQsXG4gICAgICAgIFwiLS1nZGctdGV4dC1kYXJrXCI6IHRoZW1lLnRleHREYXJrLFxuICAgICAgICBcIi0tZ2RnLXRleHQtbWVkaXVtXCI6IHRoZW1lLnRleHRNZWRpdW0sXG4gICAgICAgIFwiLS1nZGctdGV4dC1saWdodFwiOiB0aGVtZS50ZXh0TGlnaHQsXG4gICAgICAgIFwiLS1nZGctdGV4dC1idWJibGVcIjogdGhlbWUudGV4dEJ1YmJsZSxcbiAgICAgICAgXCItLWdkZy1iZy1pY29uLWhlYWRlclwiOiB0aGVtZS5iZ0ljb25IZWFkZXIsXG4gICAgICAgIFwiLS1nZGctZmctaWNvbi1oZWFkZXJcIjogdGhlbWUuZmdJY29uSGVhZGVyLFxuICAgICAgICBcIi0tZ2RnLXRleHQtaGVhZGVyXCI6IHRoZW1lLnRleHRIZWFkZXIsXG4gICAgICAgIFwiLS1nZGctdGV4dC1ncm91cC1oZWFkZXJcIjogdGhlbWUudGV4dEdyb3VwSGVhZGVyID8/IHRoZW1lLnRleHRIZWFkZXIsXG4gICAgICAgIFwiLS1nZGctdGV4dC1oZWFkZXItc2VsZWN0ZWRcIjogdGhlbWUudGV4dEhlYWRlclNlbGVjdGVkLFxuICAgICAgICBcIi0tZ2RnLWJnLWNlbGxcIjogdGhlbWUuYmdDZWxsLFxuICAgICAgICBcIi0tZ2RnLWJnLWNlbGwtbWVkaXVtXCI6IHRoZW1lLmJnQ2VsbE1lZGl1bSxcbiAgICAgICAgXCItLWdkZy1iZy1oZWFkZXJcIjogdGhlbWUuYmdIZWFkZXIsXG4gICAgICAgIFwiLS1nZGctYmctaGVhZGVyLWhhcy1mb2N1c1wiOiB0aGVtZS5iZ0hlYWRlckhhc0ZvY3VzLFxuICAgICAgICBcIi0tZ2RnLWJnLWhlYWRlci1ob3ZlcmVkXCI6IHRoZW1lLmJnSGVhZGVySG92ZXJlZCxcbiAgICAgICAgXCItLWdkZy1iZy1idWJibGVcIjogdGhlbWUuYmdCdWJibGUsXG4gICAgICAgIFwiLS1nZGctYmctYnViYmxlLXNlbGVjdGVkXCI6IHRoZW1lLmJnQnViYmxlU2VsZWN0ZWQsXG4gICAgICAgIFwiLS1nZGctYmctc2VhcmNoLXJlc3VsdFwiOiB0aGVtZS5iZ1NlYXJjaFJlc3VsdCxcbiAgICAgICAgXCItLWdkZy1ib3JkZXItY29sb3JcIjogdGhlbWUuYm9yZGVyQ29sb3IsXG4gICAgICAgIFwiLS1nZGctaG9yaXpvbnRhbC1ib3JkZXItY29sb3JcIjogdGhlbWUuaG9yaXpvbnRhbEJvcmRlckNvbG9yID8/IHRoZW1lLmJvcmRlckNvbG9yLFxuICAgICAgICBcIi0tZ2RnLWRyaWxsZG93bi1ib3JkZXJcIjogdGhlbWUuZHJpbGxkb3duQm9yZGVyLFxuICAgICAgICBcIi0tZ2RnLWxpbmstY29sb3JcIjogdGhlbWUubGlua0NvbG9yLFxuICAgICAgICBcIi0tZ2RnLWNlbGwtaG9yaXpvbnRhbC1wYWRkaW5nXCI6IGAke3RoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZ31weGAsXG4gICAgICAgIFwiLS1nZGctY2VsbC12ZXJ0aWNhbC1wYWRkaW5nXCI6IGAke3RoZW1lLmNlbGxWZXJ0aWNhbFBhZGRpbmd9cHhgLFxuICAgICAgICBcIi0tZ2RnLWhlYWRlci1mb250LXN0eWxlXCI6IHRoZW1lLmhlYWRlckZvbnRTdHlsZSxcbiAgICAgICAgXCItLWdkZy1iYXNlLWZvbnQtc3R5bGVcIjogdGhlbWUuYmFzZUZvbnRTdHlsZSxcbiAgICAgICAgXCItLWdkZy1tYXJrZXItZm9udC1zdHlsZVwiOiB0aGVtZS5tYXJrZXJGb250U3R5bGUsXG4gICAgICAgIFwiLS1nZGctZm9udC1mYW1pbHlcIjogdGhlbWUuZm9udEZhbWlseSxcbiAgICAgICAgXCItLWdkZy1lZGl0b3ItZm9udC1zaXplXCI6IHRoZW1lLmVkaXRvckZvbnRTaXplLFxuICAgICAgICAuLi4odGhlbWUucmVzaXplSW5kaWNhdG9yQ29sb3IgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgOiB7IFwiLS1nZGctcmVzaXplLWluZGljYXRvci1jb2xvclwiOiB0aGVtZS5yZXNpemVJbmRpY2F0b3JDb2xvciB9KSxcbiAgICAgICAgLi4uKHRoZW1lLmhlYWRlckJvdHRvbUJvcmRlckNvbG9yID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgIDogeyBcIi0tZ2RnLWhlYWRlci1ib3R0b20tYm9yZGVyLWNvbG9yXCI6IHRoZW1lLmhlYWRlckJvdHRvbUJvcmRlckNvbG9yIH0pLFxuICAgICAgICAuLi4odGhlbWUucm91bmRpbmdSYWRpdXMgPT09IHVuZGVmaW5lZCA/IHt9IDogeyBcIi0tZ2RnLXJvdW5kaW5nLXJhZGl1c1wiOiBgJHt0aGVtZS5yb3VuZGluZ1JhZGl1c31weGAgfSksXG4gICAgfTtcbn1cbmNvbnN0IGRhdGFFZGl0b3JCYXNlVGhlbWUgPSB7XG4gICAgYWNjZW50Q29sb3I6IFwiIzRGNURGRlwiLFxuICAgIGFjY2VudEZnOiBcIiNGRkZGRkZcIixcbiAgICBhY2NlbnRMaWdodDogXCJyZ2JhKDYyLCAxMTYsIDI1MywgMC4xKVwiLFxuICAgIHRleHREYXJrOiBcIiMzMTMxMzlcIixcbiAgICB0ZXh0TWVkaXVtOiBcIiM3MzczODNcIixcbiAgICB0ZXh0TGlnaHQ6IFwiI0IyQjJDMFwiLFxuICAgIHRleHRCdWJibGU6IFwiIzMxMzEzOVwiLFxuICAgIGJnSWNvbkhlYWRlcjogXCIjNzM3MzgzXCIsXG4gICAgZmdJY29uSGVhZGVyOiBcIiNGRkZGRkZcIixcbiAgICB0ZXh0SGVhZGVyOiBcIiMzMTMxMzlcIixcbiAgICB0ZXh0R3JvdXBIZWFkZXI6IFwiIzMxMzEzOUJCXCIsXG4gICAgdGV4dEhlYWRlclNlbGVjdGVkOiBcIiNGRkZGRkZcIixcbiAgICBiZ0NlbGw6IFwiI0ZGRkZGRlwiLFxuICAgIGJnQ2VsbE1lZGl1bTogXCIjRkFGQUZCXCIsXG4gICAgYmdIZWFkZXI6IFwiI0Y3RjdGOFwiLFxuICAgIGJnSGVhZGVySGFzRm9jdXM6IFwiI0U5RTlFQlwiLFxuICAgIGJnSGVhZGVySG92ZXJlZDogXCIjRUZFRkYxXCIsXG4gICAgYmdCdWJibGU6IFwiI0VERURGM1wiLFxuICAgIGJnQnViYmxlU2VsZWN0ZWQ6IFwiI0ZGRkZGRlwiLFxuICAgIGJnU2VhcmNoUmVzdWx0OiBcIiNmZmY5ZTNcIixcbiAgICBib3JkZXJDb2xvcjogXCJyZ2JhKDExNSwgMTE2LCAxMzEsIDAuMTYpXCIsXG4gICAgZHJpbGxkb3duQm9yZGVyOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICBsaW5rQ29sb3I6IFwiIzM1M2ZiNVwiLFxuICAgIGNlbGxIb3Jpem9udGFsUGFkZGluZzogOCxcbiAgICBjZWxsVmVydGljYWxQYWRkaW5nOiAzLFxuICAgIGhlYWRlckljb25TaXplOiAxOCxcbiAgICBoZWFkZXJGb250U3R5bGU6IFwiNjAwIDEzcHhcIixcbiAgICBiYXNlRm9udFN0eWxlOiBcIjEzcHhcIixcbiAgICBtYXJrZXJGb250U3R5bGU6IFwiOXB4XCIsXG4gICAgZm9udEZhbWlseTogXCJJbnRlciwgUm9ib3RvLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIGF2ZW5pciBuZXh0LCBhdmVuaXIsIHNlZ29lIHVpLCBoZWx2ZXRpY2EgbmV1ZSwgaGVsdmV0aWNhLCBVYnVudHUsIG5vdG8sIGFyaWFsLCBzYW5zLXNlcmlmXCIsXG4gICAgZWRpdG9yRm9udFNpemU6IFwiMTNweFwiLFxuICAgIGxpbmVIZWlnaHQ6IDEuNCwgLy91bml0bGVzcyBzY2FsZXIgZGVwZW5kcyBvbiB5b3VyIGZvbnRcbn07XG4vKiogQGNhdGVnb3J5IFRoZW1lICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YUVkaXRvclRoZW1lKCkge1xuICAgIHJldHVybiBkYXRhRWRpdG9yQmFzZVRoZW1lO1xufVxuLyoqIEBjYXRlZ29yeSBUaGVtZSAqL1xuZXhwb3J0IGNvbnN0IFRoZW1lQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZGF0YUVkaXRvckJhc2VUaGVtZSk7XG4vKiogQGNhdGVnb3J5IEhvb2tzICovXG5leHBvcnQgZnVuY3Rpb24gdXNlVGhlbWUoKSB7XG4gICAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoVGhlbWVDb250ZXh0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFuZFJlYWxpemVUaGVtZSh0aGVtZSwgLi4ub3ZlcmxheXMpIHtcbiAgICBjb25zdCBtZXJnZWQgPSB7IC4uLnRoZW1lIH07XG4gICAgZm9yIChjb25zdCBvdmVybGF5IG9mIG92ZXJsYXlzKSB7XG4gICAgICAgIGlmIChvdmVybGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImJnQ2VsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRba2V5XSA9IGJsZW5kKG92ZXJsYXlba2V5XSwgbWVyZ2VkW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSBvdmVybGF5W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1lcmdlZC5oZWFkZXJGb250RnVsbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHRoZW1lLmZvbnRGYW1pbHkgIT09IG1lcmdlZC5mb250RmFtaWx5IHx8XG4gICAgICAgIHRoZW1lLmhlYWRlckZvbnRTdHlsZSAhPT0gbWVyZ2VkLmhlYWRlckZvbnRTdHlsZSkge1xuICAgICAgICBtZXJnZWQuaGVhZGVyRm9udEZ1bGwgPSBgJHttZXJnZWQuaGVhZGVyRm9udFN0eWxlfSAke21lcmdlZC5mb250RmFtaWx5fWA7XG4gICAgfVxuICAgIGlmIChtZXJnZWQuYmFzZUZvbnRGdWxsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgdGhlbWUuZm9udEZhbWlseSAhPT0gbWVyZ2VkLmZvbnRGYW1pbHkgfHxcbiAgICAgICAgdGhlbWUuYmFzZUZvbnRTdHlsZSAhPT0gbWVyZ2VkLmJhc2VGb250U3R5bGUpIHtcbiAgICAgICAgbWVyZ2VkLmJhc2VGb250RnVsbCA9IGAke21lcmdlZC5iYXNlRm9udFN0eWxlfSAke21lcmdlZC5mb250RmFtaWx5fWA7XG4gICAgfVxuICAgIGlmIChtZXJnZWQubWFya2VyRm9udEZ1bGwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICB0aGVtZS5mb250RmFtaWx5ICE9PSBtZXJnZWQuZm9udEZhbWlseSB8fFxuICAgICAgICB0aGVtZS5tYXJrZXJGb250U3R5bGUgIT09IG1lcmdlZC5tYXJrZXJGb250U3R5bGUpIHtcbiAgICAgICAgbWVyZ2VkLm1hcmtlckZvbnRGdWxsID0gYCR7bWVyZ2VkLm1hcmtlckZvbnRTdHlsZX0gJHttZXJnZWQuZm9udEZhbWlseX1gO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   maybe: () => (/* binding */ maybe),\n/* harmony export */   proveType: () => (/* binding */ proveType)\n/* harmony export */ });\nfunction proveType(_val) {\n    // do nothing, just prove the compiler thinks the types match\n}\nfunction panic(message = \"This should not happen\") {\n    throw new Error(message);\n}\nfunction assert(fact, message = \"Assertion failed\") {\n    if (fact)\n        return;\n    return panic(message);\n}\nfunction assertNever(_never, msg) {\n    return panic(msg ?? \"Hell froze over\");\n}\nfunction maybe(fn, defaultValue) {\n    try {\n        return fn();\n    }\n    catch {\n        return defaultValue;\n    }\n}\n// The following code is licensed under the MIT license to Luke Edwards\n// Original license and code can be found here: https://github.com/lukeed/dequal/blob/master/license\n// I have merely \"ported\" it to be TS (any any any) and directly included it for convenience.\nconst has = Object.prototype.hasOwnProperty;\n// eslint-disable-next-line sonarjs/cognitive-complexity\nfunction deepEqual(foo, bar) {\n    let ctor, len;\n    if (foo === bar)\n        return true;\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {\n        if (ctor === Date)\n            return foo.getTime() === bar.getTime();\n        if (ctor === RegExp)\n            return foo.toString() === bar.toString();\n        if (ctor === Array) {\n            if ((len = foo.length) === bar.length) {\n                while (len-- && deepEqual(foo[len], bar[len]))\n                    ;\n            }\n            return len === -1;\n        }\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        if (!ctor || typeof foo === \"object\") {\n            len = 0;\n            // eslint-disable-next-line guard-for-in\n            for (ctor in foo) {\n                if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))\n                    return false;\n                if (!(ctor in bar) || !deepEqual(foo[ctor], bar[ctor]))\n                    return false;\n            }\n            return Object.keys(bar).length === len;\n        }\n    }\n    return foo !== foo && bar !== bar;\n}\n//# sourceMappingURL=support.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL3N1cHBvcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9jb21tb24vc3VwcG9ydC5qcz83NDhhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBwcm92ZVR5cGUoX3ZhbCkge1xuICAgIC8vIGRvIG5vdGhpbmcsIGp1c3QgcHJvdmUgdGhlIGNvbXBpbGVyIHRoaW5rcyB0aGUgdHlwZXMgbWF0Y2hcbn1cbmZ1bmN0aW9uIHBhbmljKG1lc3NhZ2UgPSBcIlRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZmFjdCwgbWVzc2FnZSA9IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKSB7XG4gICAgaWYgKGZhY3QpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gcGFuaWMobWVzc2FnZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX25ldmVyLCBtc2cpIHtcbiAgICByZXR1cm4gcGFuaWMobXNnID8/IFwiSGVsbCBmcm96ZSBvdmVyXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlKGZuLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbn1cbi8vIFRoZSBmb2xsb3dpbmcgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgdG8gTHVrZSBFZHdhcmRzXG4vLyBPcmlnaW5hbCBsaWNlbnNlIGFuZCBjb2RlIGNhbiBiZSBmb3VuZCBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vbHVrZWVkL2RlcXVhbC9ibG9iL21hc3Rlci9saWNlbnNlXG4vLyBJIGhhdmUgbWVyZWx5IFwicG9ydGVkXCIgaXQgdG8gYmUgVFMgKGFueSBhbnkgYW55KSBhbmQgZGlyZWN0bHkgaW5jbHVkZWQgaXQgZm9yIGNvbnZlbmllbmNlLlxuY29uc3QgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb25hcmpzL2NvZ25pdGl2ZS1jb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZGVlcEVxdWFsKGZvbywgYmFyKSB7XG4gICAgbGV0IGN0b3IsIGxlbjtcbiAgICBpZiAoZm9vID09PSBiYXIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICBpZiAoZm9vICYmIGJhciAmJiAoY3RvciA9IGZvby5jb25zdHJ1Y3RvcikgPT09IGJhci5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAoY3RvciA9PT0gRGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmb28uZ2V0VGltZSgpID09PSBiYXIuZ2V0VGltZSgpO1xuICAgICAgICBpZiAoY3RvciA9PT0gUmVnRXhwKVxuICAgICAgICAgICAgcmV0dXJuIGZvby50b1N0cmluZygpID09PSBiYXIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoKGxlbiA9IGZvby5sZW5ndGgpID09PSBiYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxlbi0tICYmIGRlZXBFcXVhbChmb29bbGVuXSwgYmFyW2xlbl0pKVxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgIGlmICghY3RvciB8fCB0eXBlb2YgZm9vID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgZm9yIChjdG9yIGluIGZvbykge1xuICAgICAgICAgICAgICAgIGlmIChoYXMuY2FsbChmb28sIGN0b3IpICYmICsrbGVuICYmICFoYXMuY2FsbChiYXIsIGN0b3IpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCEoY3RvciBpbiBiYXIpIHx8ICFkZWVwRXF1YWwoZm9vW2N0b3JdLCBiYXJbY3Rvcl0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYmFyKS5sZW5ndGggPT09IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9vICE9PSBmb28gJiYgYmFyICE9PSBiYXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXBwb3J0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Checkmark: () => (/* binding */ Checkmark),\n/* harmony export */   EditPencil: () => (/* binding */ EditPencil),\n/* harmony export */   degreesToRadians: () => (/* binding */ degreesToRadians),\n/* harmony export */   direction: () => (/* binding */ direction),\n/* harmony export */   getScrollBarWidth: () => (/* binding */ getScrollBarWidth),\n/* harmony export */   getSquareBB: () => (/* binding */ getSquareBB),\n/* harmony export */   getSquareWidth: () => (/* binding */ getSquareWidth),\n/* harmony export */   getSquareXPosFromAlign: () => (/* binding */ getSquareXPosFromAlign),\n/* harmony export */   makeAccessibilityStringForArray: () => (/* binding */ makeAccessibilityStringForArray),\n/* harmony export */   pointIsWithinBB: () => (/* binding */ pointIsWithinBB),\n/* harmony export */   useDebouncedMemo: () => (/* binding */ useDebouncedMemo),\n/* harmony export */   useDeepMemo: () => (/* binding */ useDeepMemo),\n/* harmony export */   useEventListener: () => (/* binding */ useEventListener),\n/* harmony export */   useStateWithReactiveInput: () => (/* binding */ useStateWithReactiveInput),\n/* harmony export */   whenDefined: () => (/* binding */ whenDefined)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce.js */ \"(ssr)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var _support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n\n\n\nfunction useEventListener(eventName, handler, element, passive, capture = false) {\n    // Create a ref that stores handler\n    const savedHandler = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    // Update ref.current value if handler changes.\n    // This allows our effect below to always get latest handler ...\n    // ... without us needing to pass it in effect deps array ...\n    // ... and potentially cause effect to re-run every render.\n    savedHandler.current = handler;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        // Make sure element supports addEventListener\n        if (element === null || element.addEventListener === undefined)\n            return;\n        const el = element;\n        // Create event listener that calls handler function stored in ref\n        const eventListener = (event) => {\n            savedHandler.current?.call(el, event);\n        };\n        el.addEventListener(eventName, eventListener, { passive, capture });\n        // Remove event listener on cleanup\n        return () => {\n            el.removeEventListener(eventName, eventListener, { capture });\n        };\n    }, [eventName, element, passive, capture] // Re-run if eventName or element changes\n    );\n}\nfunction whenDefined(obj, result) {\n    return obj === undefined ? undefined : result;\n}\nconst PI = Math.PI;\nfunction degreesToRadians(degrees) {\n    return (degrees * PI) / 180;\n}\nconst getSquareBB = (posX, posY, squareSideLength) => ({\n    x1: posX - squareSideLength / 2,\n    y1: posY - squareSideLength / 2,\n    x2: posX + squareSideLength / 2,\n    y2: posY + squareSideLength / 2,\n});\nconst getSquareXPosFromAlign = (alignment, containerX, containerWidth, horizontalPadding, squareWidth) => {\n    switch (alignment) {\n        case \"left\":\n            return Math.floor(containerX) + horizontalPadding + squareWidth / 2;\n        case \"center\":\n            return Math.floor(containerX + containerWidth / 2);\n        case \"right\":\n            return Math.floor(containerX + containerWidth) - horizontalPadding - squareWidth / 2;\n    }\n};\nconst getSquareWidth = (maxSize, containerHeight, verticalPadding) => Math.min(maxSize, containerHeight - verticalPadding * 2);\nconst pointIsWithinBB = (x, y, bb) => bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\nconst EditPencil = (props) => {\n    const fg = props.fgColor ?? \"currentColor\";\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { viewBox: \"0 0 24 24\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M12.7073 7.05029C7.87391 11.8837 10.4544 9.30322 6.03024 13.7273C5.77392 13.9836 5.58981 14.3071 5.50189 14.6587L4.52521 18.5655C4.38789 19.1148 4.88543 19.6123 5.43472 19.475L9.34146 18.4983C9.69313 18.4104 10.0143 18.2286 10.2706 17.9722L16.9499 11.2929\", stroke: fg, strokeWidth: \"1.5\", strokeLinecap: \"round\", strokeLinejoin: \"round\", fill: \"none\", vectorEffect: \"non-scaling-stroke\" }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M20.4854 4.92901L19.0712 3.5148C18.2901 2.73375 17.0238 2.73375 16.2428 3.5148L14.475 5.28257C15.5326 7.71912 16.4736 8.6278 18.7176 9.52521L20.4854 7.75744C21.2665 6.97639 21.2665 5.71006 20.4854 4.92901Z\", stroke: fg, strokeWidth: \"1.5\", strokeLinecap: \"round\", strokeLinejoin: \"round\", fill: \"none\", vectorEffect: \"non-scaling-stroke\" })));\n};\nconst Checkmark = (props) => {\n    const fg = props.fgColor ?? \"currentColor\";\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { viewBox: \"0 0 24 24\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M19 6L10.3802 17L5.34071 11.8758\", vectorEffect: \"non-scaling-stroke\", stroke: fg, strokeWidth: \"1.5\", strokeLinecap: \"round\", strokeLinejoin: \"round\" })));\n};\nfunction useDebouncedMemo(factory, deps, time) {\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(factory);\n    const mountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => () => {\n        mountedRef.current = false;\n    }, []);\n    const debouncedSetState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_1__(x => {\n        if (mountedRef.current) {\n            setState(x);\n        }\n    }, time));\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (mountedRef.current) {\n            debouncedSetState.current(() => factory());\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n    return state;\n}\n// Shamelessly inline direction to avoid conflicts with 1.0 and 2.0.\nconst rtlRange = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst ltrRange = \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\" +\n    \"\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C\" +\n    \"\\uFE00-\\uFE6F\\uFEFD-\\uFFFF\";\n/* eslint-disable no-misleading-character-class */\nconst rtl = new RegExp(\"^[^\" + ltrRange + \"]*[\" + rtlRange + \"]\");\n/* eslint-enable no-misleading-character-class */\nfunction direction(value) {\n    return rtl.test(value) ? \"rtl\" : \"not-rtl\";\n}\nlet scrollbarWidthCache = undefined;\nfunction getScrollBarWidth() {\n    if (typeof document === \"undefined\")\n        return 0;\n    if (scrollbarWidthCache !== undefined)\n        return scrollbarWidthCache;\n    const inner = document.createElement(\"p\");\n    inner.style.width = \"100%\";\n    inner.style.height = \"200px\";\n    const outer = document.createElement(\"div\");\n    outer.id = \"testScrollbar\";\n    outer.style.position = \"absolute\";\n    outer.style.top = \"0px\";\n    outer.style.left = \"0px\";\n    outer.style.visibility = \"hidden\";\n    outer.style.width = \"200px\";\n    outer.style.height = \"150px\";\n    outer.style.overflow = \"hidden\";\n    outer.append(inner);\n    document.body.append(outer);\n    const w1 = inner.offsetWidth;\n    outer.style.overflow = \"scroll\";\n    let w2 = inner.offsetWidth;\n    if (w1 === w2) {\n        w2 = outer.clientWidth;\n    }\n    outer.remove();\n    scrollbarWidthCache = w1 - w2;\n    return scrollbarWidthCache;\n}\n// Dear future reader,\n// This dumb hook is to make sure if the inputState changes, that effectively behaves like an instant \"setState\" call.\n// This is useful in a wide variety of situations. I'm too dumb to know if this is a good idea or a really dumb one.\n// I can't tell. It's like poes law but for code.\n//\n// I'm sorry.\nconst empty = Symbol();\nfunction useStateWithReactiveInput(inputState) {\n    // When [0] is not empty we will return it, [1] is always the last value we saw\n    const inputStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([empty, inputState]);\n    if (inputStateRef.current[1] !== inputState) {\n        // it changed, we must use thee!\n        inputStateRef.current[0] = inputState;\n    }\n    inputStateRef.current[1] = inputState;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(inputState);\n    // crimes against humanity here\n    const [, forceRender] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const setStateOuter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(nv => {\n        // this takes care of the case where the inputState was set, then setState gets called again but back to what\n        // the state was before the inputState changed. Since the useState effect wont trigger a render in this case\n        // we need to be very naughty and force it to see the change. Technically this may not be needed some chunk of\n        // the time (in fact most of it) but checking for it is likely to be more expensive than just over-doing it\n        const s = inputStateRef.current[0];\n        if (s !== empty) {\n            nv = typeof nv === \"function\" ? nv(s) : nv;\n            if (nv === s)\n                return; // they are setting it to what the inputState is anyway so we can just do nothing\n        }\n        if (s !== empty)\n            forceRender({});\n        setState(pv => {\n            if (typeof nv === \"function\") {\n                return nv(s === empty ? pv : s);\n            }\n            return nv;\n        });\n        inputStateRef.current[0] = empty;\n    }, []);\n    const onEmpty = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        inputStateRef.current[0] = empty;\n        forceRender({});\n    }, []);\n    return [inputStateRef.current[0] === empty ? state : inputStateRef.current[0], setStateOuter, onEmpty];\n}\nfunction makeAccessibilityStringForArray(arr) {\n    // this is basically just .join(\", \") but checks to make sure it is not going to allocate\n    // a string that is so large it might crash the browser\n    if (arr.length === 0) {\n        return \"\";\n    }\n    let index = 0;\n    let count = 0;\n    for (const str of arr) {\n        count += str.length;\n        if (count > 10000)\n            break;\n        index++;\n    }\n    return arr.slice(0, index).join(\", \");\n}\nfunction useDeepMemo(value) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n    if (!(0,_support_js__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(value, ref.current)) {\n        ref.current = value;\n    }\n    return ref.current;\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vY29tbW9uL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNXO0FBQ0Q7QUFDbEM7QUFDUDtBQUNBLHlCQUF5Qix5Q0FBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ0EsWUFBWSxnREFBbUIsVUFBVSx5RUFBeUU7QUFDbEgsUUFBUSxnREFBbUIsV0FBVyx5WUFBeVk7QUFDL2EsUUFBUSxnREFBbUIsV0FBVyx1VkFBdVY7QUFDN1g7QUFDTztBQUNQO0FBQ0EsWUFBWSxnREFBbUIsVUFBVSx5RUFBeUU7QUFDbEgsUUFBUSxnREFBbUIsV0FBVyw0SkFBNEo7QUFDbE07QUFDTztBQUNQLDhCQUE4QiwyQ0FBYztBQUM1Qyx1QkFBdUIseUNBQVk7QUFDbkMsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBLEtBQUs7QUFDTCw4QkFBOEIseUNBQVksQ0FBQywrQ0FBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxrREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwwQkFBMEIseUNBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBYztBQUM1QztBQUNBLDRCQUE0QiwyQ0FBYztBQUMxQywwQkFBMEIsOENBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiw4Q0FBaUI7QUFDckM7QUFDQSxzQkFBc0I7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLHlDQUFZO0FBQzVCLFNBQVMsc0RBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2NvbW1vbi91dGlscy5qcz9kOTFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCJsb2Rhc2gvZGVib3VuY2UuanNcIjtcbmltcG9ydCB7IGRlZXBFcXVhbCB9IGZyb20gXCIuL3N1cHBvcnQuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZWxlbWVudCwgcGFzc2l2ZSwgY2FwdHVyZSA9IGZhbHNlKSB7XG4gICAgLy8gQ3JlYXRlIGEgcmVmIHRoYXQgc3RvcmVzIGhhbmRsZXJcbiAgICBjb25zdCBzYXZlZEhhbmRsZXIgPSBSZWFjdC51c2VSZWYoKTtcbiAgICAvLyBVcGRhdGUgcmVmLmN1cnJlbnQgdmFsdWUgaWYgaGFuZGxlciBjaGFuZ2VzLlxuICAgIC8vIFRoaXMgYWxsb3dzIG91ciBlZmZlY3QgYmVsb3cgdG8gYWx3YXlzIGdldCBsYXRlc3QgaGFuZGxlciAuLi5cbiAgICAvLyAuLi4gd2l0aG91dCB1cyBuZWVkaW5nIHRvIHBhc3MgaXQgaW4gZWZmZWN0IGRlcHMgYXJyYXkgLi4uXG4gICAgLy8gLi4uIGFuZCBwb3RlbnRpYWxseSBjYXVzZSBlZmZlY3QgdG8gcmUtcnVuIGV2ZXJ5IHJlbmRlci5cbiAgICBzYXZlZEhhbmRsZXIuY3VycmVudCA9IGhhbmRsZXI7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGVsZW1lbnQgc3VwcG9ydHMgYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZWwgPSBlbGVtZW50O1xuICAgICAgICAvLyBDcmVhdGUgZXZlbnQgbGlzdGVuZXIgdGhhdCBjYWxscyBoYW5kbGVyIGZ1bmN0aW9uIHN0b3JlZCBpbiByZWZcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgc2F2ZWRIYW5kbGVyLmN1cnJlbnQ/LmNhbGwoZWwsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIHsgcGFzc2l2ZSwgY2FwdHVyZSB9KTtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIG9uIGNsZWFudXBcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCB7IGNhcHR1cmUgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW2V2ZW50TmFtZSwgZWxlbWVudCwgcGFzc2l2ZSwgY2FwdHVyZV0gLy8gUmUtcnVuIGlmIGV2ZW50TmFtZSBvciBlbGVtZW50IGNoYW5nZXNcbiAgICApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5EZWZpbmVkKG9iaiwgcmVzdWx0KSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVzdWx0O1xufVxuY29uc3QgUEkgPSBNYXRoLlBJO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlcykge1xuICAgIHJldHVybiAoZGVncmVlcyAqIFBJKSAvIDE4MDtcbn1cbmV4cG9ydCBjb25zdCBnZXRTcXVhcmVCQiA9IChwb3NYLCBwb3NZLCBzcXVhcmVTaWRlTGVuZ3RoKSA9PiAoe1xuICAgIHgxOiBwb3NYIC0gc3F1YXJlU2lkZUxlbmd0aCAvIDIsXG4gICAgeTE6IHBvc1kgLSBzcXVhcmVTaWRlTGVuZ3RoIC8gMixcbiAgICB4MjogcG9zWCArIHNxdWFyZVNpZGVMZW5ndGggLyAyLFxuICAgIHkyOiBwb3NZICsgc3F1YXJlU2lkZUxlbmd0aCAvIDIsXG59KTtcbmV4cG9ydCBjb25zdCBnZXRTcXVhcmVYUG9zRnJvbUFsaWduID0gKGFsaWdubWVudCwgY29udGFpbmVyWCwgY29udGFpbmVyV2lkdGgsIGhvcml6b250YWxQYWRkaW5nLCBzcXVhcmVXaWR0aCkgPT4ge1xuICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb250YWluZXJYKSArIGhvcml6b250YWxQYWRkaW5nICsgc3F1YXJlV2lkdGggLyAyO1xuICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb250YWluZXJYICsgY29udGFpbmVyV2lkdGggLyAyKTtcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb250YWluZXJYICsgY29udGFpbmVyV2lkdGgpIC0gaG9yaXpvbnRhbFBhZGRpbmcgLSBzcXVhcmVXaWR0aCAvIDI7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBnZXRTcXVhcmVXaWR0aCA9IChtYXhTaXplLCBjb250YWluZXJIZWlnaHQsIHZlcnRpY2FsUGFkZGluZykgPT4gTWF0aC5taW4obWF4U2l6ZSwgY29udGFpbmVySGVpZ2h0IC0gdmVydGljYWxQYWRkaW5nICogMik7XG5leHBvcnQgY29uc3QgcG9pbnRJc1dpdGhpbkJCID0gKHgsIHksIGJiKSA9PiBiYi54MSA8PSB4ICYmIHggPD0gYmIueDIgJiYgYmIueTEgPD0geSAmJiB5IDw9IGJiLnkyO1xuZXhwb3J0IGNvbnN0IEVkaXRQZW5jaWwgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBmZyA9IHByb3BzLmZnQ29sb3IgPz8gXCJjdXJyZW50Q29sb3JcIjtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTEyLjcwNzMgNy4wNTAyOUM3Ljg3MzkxIDExLjg4MzcgMTAuNDU0NCA5LjMwMzIyIDYuMDMwMjQgMTMuNzI3M0M1Ljc3MzkyIDEzLjk4MzYgNS41ODk4MSAxNC4zMDcxIDUuNTAxODkgMTQuNjU4N0w0LjUyNTIxIDE4LjU2NTVDNC4zODc4OSAxOS4xMTQ4IDQuODg1NDMgMTkuNjEyMyA1LjQzNDcyIDE5LjQ3NUw5LjM0MTQ2IDE4LjQ5ODNDOS42OTMxMyAxOC40MTA0IDEwLjAxNDMgMTguMjI4NiAxMC4yNzA2IDE3Ljk3MjJMMTYuOTQ5OSAxMS4yOTI5XCIsIHN0cm9rZTogZmcsIHN0cm9rZVdpZHRoOiBcIjEuNVwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIGZpbGw6IFwibm9uZVwiLCB2ZWN0b3JFZmZlY3Q6IFwibm9uLXNjYWxpbmctc3Ryb2tlXCIgfSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMjAuNDg1NCA0LjkyOTAxTDE5LjA3MTIgMy41MTQ4QzE4LjI5MDEgMi43MzM3NSAxNy4wMjM4IDIuNzMzNzUgMTYuMjQyOCAzLjUxNDhMMTQuNDc1IDUuMjgyNTdDMTUuNTMyNiA3LjcxOTEyIDE2LjQ3MzYgOC42Mjc4IDE4LjcxNzYgOS41MjUyMUwyMC40ODU0IDcuNzU3NDRDMjEuMjY2NSA2Ljk3NjM5IDIxLjI2NjUgNS43MTAwNiAyMC40ODU0IDQuOTI5MDFaXCIsIHN0cm9rZTogZmcsIHN0cm9rZVdpZHRoOiBcIjEuNVwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIGZpbGw6IFwibm9uZVwiLCB2ZWN0b3JFZmZlY3Q6IFwibm9uLXNjYWxpbmctc3Ryb2tlXCIgfSkpKTtcbn07XG5leHBvcnQgY29uc3QgQ2hlY2ttYXJrID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmcgPSBwcm9wcy5mZ0NvbG9yID8/IFwiY3VycmVudENvbG9yXCI7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xOSA2TDEwLjM4MDIgMTdMNS4zNDA3MSAxMS44NzU4XCIsIHZlY3RvckVmZmVjdDogXCJub24tc2NhbGluZy1zdHJva2VcIiwgc3Ryb2tlOiBmZywgc3Ryb2tlV2lkdGg6IFwiMS41XCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9KSkpO1xufTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWJvdW5jZWRNZW1vKGZhY3RvcnksIGRlcHMsIHRpbWUpIHtcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGZhY3RvcnkpO1xuICAgIGNvbnN0IG1vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+ICgpID0+IHtcbiAgICAgICAgbW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGRlYm91bmNlZFNldFN0YXRlID0gUmVhY3QudXNlUmVmKGRlYm91bmNlKHggPT4ge1xuICAgICAgICBpZiAobW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh4KTtcbiAgICAgICAgfVxuICAgIH0sIHRpbWUpKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkZWJvdW5jZWRTZXRTdGF0ZS5jdXJyZW50KCgpID0+IGZhY3RvcnkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIGRlcHMpO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbi8vIFNoYW1lbGVzc2x5IGlubGluZSBkaXJlY3Rpb24gdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggMS4wIGFuZCAyLjAuXG5jb25zdCBydGxSYW5nZSA9IFwiXFx1MDU5MS1cXHUwN0ZGXFx1RkIxRC1cXHVGREZEXFx1RkU3MC1cXHVGRUZDXCI7XG5jb25zdCBsdHJSYW5nZSA9IFwiQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XCIgK1xuICAgIFwiXFx1MDBGOC1cXHUwMkI4XFx1MDMwMC1cXHUwNTkwXFx1MDgwMC1cXHUxRkZGXFx1MjAwRVxcdTJDMDAtXFx1RkIxQ1wiICtcbiAgICBcIlxcdUZFMDAtXFx1RkU2RlxcdUZFRkQtXFx1RkZGRlwiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3MgKi9cbmNvbnN0IHJ0bCA9IG5ldyBSZWdFeHAoXCJeW15cIiArIGx0clJhbmdlICsgXCJdKltcIiArIHJ0bFJhbmdlICsgXCJdXCIpO1xuLyogZXNsaW50LWVuYWJsZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpcmVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBydGwudGVzdCh2YWx1ZSkgPyBcInJ0bFwiIDogXCJub3QtcnRsXCI7XG59XG5sZXQgc2Nyb2xsYmFyV2lkdGhDYWNoZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxCYXJXaWR0aCgpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGhDYWNoZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGhDYWNoZTtcbiAgICBjb25zdCBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgIGlubmVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gXCIyMDBweFwiO1xuICAgIGNvbnN0IG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBvdXRlci5pZCA9IFwidGVzdFNjcm9sbGJhclwiO1xuICAgIG91dGVyLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIG91dGVyLnN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgb3V0ZXIuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgb3V0ZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgb3V0ZXIuc3R5bGUud2lkdGggPSBcIjIwMHB4XCI7XG4gICAgb3V0ZXIuc3R5bGUuaGVpZ2h0ID0gXCIxNTBweFwiO1xuICAgIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICBvdXRlci5hcHBlbmQoaW5uZXIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKG91dGVyKTtcbiAgICBjb25zdCB3MSA9IGlubmVyLm9mZnNldFdpZHRoO1xuICAgIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gXCJzY3JvbGxcIjtcbiAgICBsZXQgdzIgPSBpbm5lci5vZmZzZXRXaWR0aDtcbiAgICBpZiAodzEgPT09IHcyKSB7XG4gICAgICAgIHcyID0gb3V0ZXIuY2xpZW50V2lkdGg7XG4gICAgfVxuICAgIG91dGVyLnJlbW92ZSgpO1xuICAgIHNjcm9sbGJhcldpZHRoQ2FjaGUgPSB3MSAtIHcyO1xuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aENhY2hlO1xufVxuLy8gRGVhciBmdXR1cmUgcmVhZGVyLFxuLy8gVGhpcyBkdW1iIGhvb2sgaXMgdG8gbWFrZSBzdXJlIGlmIHRoZSBpbnB1dFN0YXRlIGNoYW5nZXMsIHRoYXQgZWZmZWN0aXZlbHkgYmVoYXZlcyBsaWtlIGFuIGluc3RhbnQgXCJzZXRTdGF0ZVwiIGNhbGwuXG4vLyBUaGlzIGlzIHVzZWZ1bCBpbiBhIHdpZGUgdmFyaWV0eSBvZiBzaXR1YXRpb25zLiBJJ20gdG9vIGR1bWIgdG8ga25vdyBpZiB0aGlzIGlzIGEgZ29vZCBpZGVhIG9yIGEgcmVhbGx5IGR1bWIgb25lLlxuLy8gSSBjYW4ndCB0ZWxsLiBJdCdzIGxpa2UgcG9lcyBsYXcgYnV0IGZvciBjb2RlLlxuLy9cbi8vIEknbSBzb3JyeS5cbmNvbnN0IGVtcHR5ID0gU3ltYm9sKCk7XG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGVXaXRoUmVhY3RpdmVJbnB1dChpbnB1dFN0YXRlKSB7XG4gICAgLy8gV2hlbiBbMF0gaXMgbm90IGVtcHR5IHdlIHdpbGwgcmV0dXJuIGl0LCBbMV0gaXMgYWx3YXlzIHRoZSBsYXN0IHZhbHVlIHdlIHNhd1xuICAgIGNvbnN0IGlucHV0U3RhdGVSZWYgPSBSZWFjdC51c2VSZWYoW2VtcHR5LCBpbnB1dFN0YXRlXSk7XG4gICAgaWYgKGlucHV0U3RhdGVSZWYuY3VycmVudFsxXSAhPT0gaW5wdXRTdGF0ZSkge1xuICAgICAgICAvLyBpdCBjaGFuZ2VkLCB3ZSBtdXN0IHVzZSB0aGVlIVxuICAgICAgICBpbnB1dFN0YXRlUmVmLmN1cnJlbnRbMF0gPSBpbnB1dFN0YXRlO1xuICAgIH1cbiAgICBpbnB1dFN0YXRlUmVmLmN1cnJlbnRbMV0gPSBpbnB1dFN0YXRlO1xuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoaW5wdXRTdGF0ZSk7XG4gICAgLy8gY3JpbWVzIGFnYWluc3QgaHVtYW5pdHkgaGVyZVxuICAgIGNvbnN0IFssIGZvcmNlUmVuZGVyXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgY29uc3Qgc2V0U3RhdGVPdXRlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG52ID0+IHtcbiAgICAgICAgLy8gdGhpcyB0YWtlcyBjYXJlIG9mIHRoZSBjYXNlIHdoZXJlIHRoZSBpbnB1dFN0YXRlIHdhcyBzZXQsIHRoZW4gc2V0U3RhdGUgZ2V0cyBjYWxsZWQgYWdhaW4gYnV0IGJhY2sgdG8gd2hhdFxuICAgICAgICAvLyB0aGUgc3RhdGUgd2FzIGJlZm9yZSB0aGUgaW5wdXRTdGF0ZSBjaGFuZ2VkLiBTaW5jZSB0aGUgdXNlU3RhdGUgZWZmZWN0IHdvbnQgdHJpZ2dlciBhIHJlbmRlciBpbiB0aGlzIGNhc2VcbiAgICAgICAgLy8gd2UgbmVlZCB0byBiZSB2ZXJ5IG5hdWdodHkgYW5kIGZvcmNlIGl0IHRvIHNlZSB0aGUgY2hhbmdlLiBUZWNobmljYWxseSB0aGlzIG1heSBub3QgYmUgbmVlZGVkIHNvbWUgY2h1bmsgb2ZcbiAgICAgICAgLy8gdGhlIHRpbWUgKGluIGZhY3QgbW9zdCBvZiBpdCkgYnV0IGNoZWNraW5nIGZvciBpdCBpcyBsaWtlbHkgdG8gYmUgbW9yZSBleHBlbnNpdmUgdGhhbiBqdXN0IG92ZXItZG9pbmcgaXRcbiAgICAgICAgY29uc3QgcyA9IGlucHV0U3RhdGVSZWYuY3VycmVudFswXTtcbiAgICAgICAgaWYgKHMgIT09IGVtcHR5KSB7XG4gICAgICAgICAgICBudiA9IHR5cGVvZiBudiA9PT0gXCJmdW5jdGlvblwiID8gbnYocykgOiBudjtcbiAgICAgICAgICAgIGlmIChudiA9PT0gcylcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHRoZXkgYXJlIHNldHRpbmcgaXQgdG8gd2hhdCB0aGUgaW5wdXRTdGF0ZSBpcyBhbnl3YXkgc28gd2UgY2FuIGp1c3QgZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGlmIChzICE9PSBlbXB0eSlcbiAgICAgICAgICAgIGZvcmNlUmVuZGVyKHt9KTtcbiAgICAgICAgc2V0U3RhdGUocHYgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG52KHMgPT09IGVtcHR5ID8gcHYgOiBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0U3RhdGVSZWYuY3VycmVudFswXSA9IGVtcHR5O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBvbkVtcHR5ID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpbnB1dFN0YXRlUmVmLmN1cnJlbnRbMF0gPSBlbXB0eTtcbiAgICAgICAgZm9yY2VSZW5kZXIoe30pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gW2lucHV0U3RhdGVSZWYuY3VycmVudFswXSA9PT0gZW1wdHkgPyBzdGF0ZSA6IGlucHV0U3RhdGVSZWYuY3VycmVudFswXSwgc2V0U3RhdGVPdXRlciwgb25FbXB0eV07XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUFjY2Vzc2liaWxpdHlTdHJpbmdGb3JBcnJheShhcnIpIHtcbiAgICAvLyB0aGlzIGlzIGJhc2ljYWxseSBqdXN0IC5qb2luKFwiLCBcIikgYnV0IGNoZWNrcyB0byBtYWtlIHN1cmUgaXQgaXMgbm90IGdvaW5nIHRvIGFsbG9jYXRlXG4gICAgLy8gYSBzdHJpbmcgdGhhdCBpcyBzbyBsYXJnZSBpdCBtaWdodCBjcmFzaCB0aGUgYnJvd3NlclxuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBzdHIgb2YgYXJyKSB7XG4gICAgICAgIGNvdW50ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA+IDEwMDAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBhcnIuc2xpY2UoMCwgaW5kZXgpLmpvaW4oXCIsIFwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWVwTWVtbyh2YWx1ZSkge1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gICAgaWYgKCFkZWVwRXF1YWwodmFsdWUsIHJlZi5jdXJyZW50KSkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor-all.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor-all.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataEditorAll: () => (/* binding */ DataEditorAll)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _data_editor_data_editor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data-editor/data-editor.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor.js\");\n/* harmony import */ var _cells_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cells/index.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/cells/index.js\");\n/* harmony import */ var _internal_data_grid_sprites_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/data-grid/sprites.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/sprites.js\");\n/* harmony import */ var _common_image_window_loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common/image-window-loader.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/image-window-loader.js\");\n\n\n\n\n\nconst DataEditorAllImpl = (p, ref) => {\n    const allSprites = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return { ..._internal_data_grid_sprites_js__WEBPACK_IMPORTED_MODULE_1__.sprites, ...p.headerIcons };\n    }, [p.headerIcons]);\n    const imageWindowLoader = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return p.imageWindowLoader ?? new _common_image_window_loader_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    }, [p.imageWindowLoader]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_editor_data_editor_js__WEBPACK_IMPORTED_MODULE_3__.DataEditor, { ...p, renderers: _cells_index_js__WEBPACK_IMPORTED_MODULE_4__.AllCellRenderers, headerIcons: allSprites, ref: ref, imageWindowLoader: imageWindowLoader }));\n};\nconst DataEditorAll = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DataEditorAllImpl);\n//# sourceMappingURL=data-editor-all.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3ItYWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQjtBQUMyQjtBQUNOO0FBQ007QUFDVTtBQUNwRTtBQUNBLHVCQUF1QiwwQ0FBYTtBQUNwQyxpQkFBaUIsR0FBRyxtRUFBTztBQUMzQixLQUFLO0FBQ0wsOEJBQThCLDBDQUFhO0FBQzNDLDBDQUEwQyxzRUFBcUI7QUFDL0QsS0FBSztBQUNMLFlBQVksZ0RBQW1CLENBQUMsbUVBQVUsSUFBSSxpQkFBaUIsNkRBQWdCLDJFQUEyRTtBQUMxSjtBQUNPLHNCQUFzQiw2Q0FBZ0I7QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9kYXRhLWVkaXRvci1hbGwuanM/OTIzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IERhdGFFZGl0b3IgfSBmcm9tIFwiLi9kYXRhLWVkaXRvci9kYXRhLWVkaXRvci5qc1wiO1xuaW1wb3J0IHsgQWxsQ2VsbFJlbmRlcmVycyB9IGZyb20gXCIuL2NlbGxzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzcHJpdGVzIH0gZnJvbSBcIi4vaW50ZXJuYWwvZGF0YS1ncmlkL3Nwcml0ZXMuanNcIjtcbmltcG9ydCBJbWFnZVdpbmRvd0xvYWRlckltcGwgZnJvbSBcIi4vY29tbW9uL2ltYWdlLXdpbmRvdy1sb2FkZXIuanNcIjtcbmNvbnN0IERhdGFFZGl0b3JBbGxJbXBsID0gKHAsIHJlZikgPT4ge1xuICAgIGNvbnN0IGFsbFNwcml0ZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3ByaXRlcywgLi4ucC5oZWFkZXJJY29ucyB9O1xuICAgIH0sIFtwLmhlYWRlckljb25zXSk7XG4gICAgY29uc3QgaW1hZ2VXaW5kb3dMb2FkZXIgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHAuaW1hZ2VXaW5kb3dMb2FkZXIgPz8gbmV3IEltYWdlV2luZG93TG9hZGVySW1wbCgpO1xuICAgIH0sIFtwLmltYWdlV2luZG93TG9hZGVyXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KERhdGFFZGl0b3IsIHsgLi4ucCwgcmVuZGVyZXJzOiBBbGxDZWxsUmVuZGVyZXJzLCBoZWFkZXJJY29uczogYWxsU3ByaXRlcywgcmVmOiByZWYsIGltYWdlV2luZG93TG9hZGVyOiBpbWFnZVdpbmRvd0xvYWRlciB9KSk7XG59O1xuZXhwb3J0IGNvbnN0IERhdGFFZGl0b3JBbGwgPSBSZWFjdC5mb3J3YXJkUmVmKERhdGFFZGl0b3JBbGxJbXBsKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtZWRpdG9yLWFsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor-all.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/copy-paste.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/copy-paste.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeHTML: () => (/* binding */ decodeHTML),\n/* harmony export */   getCopyBufferContents: () => (/* binding */ getCopyBufferContents)\n/* harmony export */ });\n/* harmony import */ var _common_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* eslint-disable sonarjs/no-duplicate-string */\n\n\nfunction convertCellToBuffer(cell) {\n    if (cell.copyData !== undefined) {\n        return {\n            formatted: cell.copyData,\n            rawValue: cell.copyData,\n            format: \"string\",\n        };\n    }\n    switch (cell.kind) {\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Boolean:\n            return {\n                formatted: cell.data === true\n                    ? \"TRUE\"\n                    : cell.data === false\n                        ? \"FALSE\"\n                        : cell.data === _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.BooleanIndeterminate\n                            ? \"INDETERMINATE\"\n                            : \"\",\n                rawValue: cell.data,\n                format: \"boolean\",\n            };\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Custom:\n            return {\n                formatted: cell.copyData,\n                rawValue: cell.copyData,\n                format: \"string\",\n            };\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Image:\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Bubble:\n            return {\n                formatted: cell.data,\n                rawValue: cell.data,\n                format: \"string-array\",\n            };\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Drilldown:\n            return {\n                formatted: cell.data.map(x => x.text),\n                rawValue: cell.data.map(x => x.text),\n                format: \"string-array\",\n            };\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Text:\n            return {\n                formatted: cell.displayData ?? cell.data,\n                rawValue: cell.data,\n                format: \"string\",\n            };\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Uri:\n            return {\n                formatted: cell.displayData ?? cell.data,\n                rawValue: cell.data,\n                format: \"url\",\n            };\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Markdown:\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.RowID:\n            return {\n                formatted: cell.data,\n                rawValue: cell.data,\n                format: \"string\",\n            };\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Number:\n            return {\n                formatted: cell.displayData,\n                rawValue: cell.data,\n                format: \"number\",\n            };\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Loading:\n            return {\n                formatted: \"#LOADING\",\n                rawValue: \"\",\n                format: \"string\",\n            };\n        case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Protected:\n            return {\n                formatted: \"************\",\n                rawValue: \"\",\n                format: \"string\",\n            };\n        default:\n            (0,_common_support_js__WEBPACK_IMPORTED_MODULE_1__.assertNever)(cell);\n    }\n}\nfunction createBufferFromGridCells(cells, columnIndexes) {\n    const copyBuffer = cells.map((row, index) => {\n        const mappedIndex = columnIndexes[index];\n        return row.map(cell => {\n            if (cell.span !== undefined && cell.span[0] !== mappedIndex)\n                return {\n                    formatted: \"\",\n                    rawValue: \"\",\n                    format: \"string\",\n                };\n            return convertCellToBuffer(cell);\n        });\n    });\n    return copyBuffer;\n}\nfunction escapeIfNeeded(str, withComma) {\n    if ((withComma ? /[\\t\\n\",]/ : /[\\t\\n\"]/).test(str)) {\n        str = `\"${str.replace(/\"/g, '\"\"')}\"`;\n    }\n    return str;\n}\nfunction createTextBuffer(copyBuffer) {\n    const lines = [];\n    for (const row of copyBuffer) {\n        const line = [];\n        for (const cell of row) {\n            if (cell.format === \"url\") {\n                line.push(cell.rawValue?.toString() ?? \"\");\n            }\n            else if (cell.format === \"string-array\") {\n                line.push(cell.formatted.map(x => escapeIfNeeded(x, true)).join(\",\"));\n            }\n            else {\n                line.push(escapeIfNeeded(cell.formatted, false));\n            }\n        }\n        lines.push(line.join(\"\\t\"));\n    }\n    return lines.join(\"\\n\");\n}\nfunction formatHtmlTextContent(text) {\n    // The following formatting for the `html` variable ensures that when pasting,\n    // spaces are preserved in both Google Sheets and Excel. This is done by:\n    // 1. Replacing tabs with four spaces for consistency. Also google sheets disallows any tabs.\n    // 2. Wrapping each space with a span element to prevent them from being collapsed or ignored during the\n    //    paste operation\n    return text.replace(/\\t/g, \"    \").replace(/ {2,}/g, match => \"<span> </span>\".repeat(match.length));\n}\nfunction formatHtmlAttributeContent(attrText) {\n    // Escape all quotes, lt, gt, and other special characters\n    return ('\"' + attrText.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\") + '\"');\n}\nfunction restoreHtmlEntities(str) {\n    // Unescape all quotes, lt, gt, and other special characters\n    return str\n        .replace(/&quot;/g, '\"')\n        .replace(/&lt;/g, \"<\")\n        .replace(/&gt;/g, \">\")\n        .replace(/&amp;/g, \"&\");\n}\nfunction createHtmlBuffer(copyBuffer) {\n    const lines = [];\n    lines.push(`<style type=\"text/css\"><!--br {mso-data-placement:same-cell;}--></style>`, \"<table><tbody>\");\n    for (const row of copyBuffer) {\n        lines.push(\"<tr>\");\n        for (const cell of row) {\n            const formatStr = `gdg-format=\"${cell.format}\"`;\n            if (cell.format === \"url\") {\n                lines.push(`<td ${formatStr}><a href=\"${cell.rawValue}\">${formatHtmlTextContent(cell.formatted)}</a></td>`);\n            }\n            else {\n                if (cell.format === \"string-array\") {\n                    lines.push(`<td ${formatStr}><ol>${cell.formatted\n                        .map((x, ind) => `<li gdg-raw-value=${formatHtmlAttributeContent(cell.rawValue[ind])}>` +\n                        formatHtmlTextContent(x) +\n                        \"</li>\")\n                        .join(\"\")}</ol></td>`);\n                }\n                else {\n                    lines.push(`<td gdg-raw-value=${formatHtmlAttributeContent(cell.rawValue?.toString() ?? \"\")} ${formatStr}>${formatHtmlTextContent(cell.formatted)}</td>`);\n                }\n            }\n        }\n        lines.push(\"</tr>\");\n    }\n    lines.push(\"</tbody></table>\");\n    return lines.join(\"\");\n}\n// This function encodes grid cells to a table object.\n// Each td in the table contains one of 3 things\n// - A string directly and the td has a `gdg-raw-value` attribute with the raw value\n// - An anchor tag with a href and the text is the formatted value\n// - An ordered list with each item containing a `gdg-raw-value` attribute with the raw value\nfunction getCopyBufferContents(cells, columnIndexes) {\n    const copyBuffer = createBufferFromGridCells(cells, columnIndexes);\n    const textPlain = createTextBuffer(copyBuffer);\n    const textHtml = createHtmlBuffer(copyBuffer);\n    return {\n        textPlain,\n        textHtml,\n    };\n}\nfunction decodeHTML(html) {\n    const fragment = document.createElement(\"html\");\n    // we dont want to retain the pasted non-breaking spaces\n    fragment.innerHTML = html.replace(/&nbsp;/g, \" \");\n    const tableEl = fragment.querySelector(\"table\");\n    if (tableEl === null)\n        return undefined;\n    const walkEl = [tableEl];\n    const result = [];\n    let current;\n    while (walkEl.length > 0) {\n        const el = walkEl.pop();\n        if (el === undefined)\n            break;\n        if (el instanceof HTMLTableElement || el.nodeName === \"TBODY\") {\n            walkEl.push(...[...el.children].reverse());\n        }\n        else if (el instanceof HTMLTableRowElement) {\n            if (current !== undefined) {\n                result.push(current);\n            }\n            current = [];\n            walkEl.push(...[...el.children].reverse());\n        }\n        else if (el instanceof HTMLTableCellElement) {\n            // be careful not to use innerText here as its behavior is not well defined for non DOM attached nodes\n            const clone = el.cloneNode(true);\n            // Apple numbers seems to always wrap the cell in a p tag and a font tag. It also puts both <br> and \\n\n            // linebreak markers in the code. This is both unneeded and causes issues with the paste code.\n            const firstTagIsPara = clone.children.length === 1 && clone.children[0].nodeName === \"P\";\n            const para = firstTagIsPara ? clone.children[0] : null;\n            const isAppleNumbers = para?.children.length === 1 && para.children[0].nodeName === \"FONT\";\n            const brs = clone.querySelectorAll(\"br\");\n            for (const br of brs) {\n                br.replaceWith(\"\\n\");\n            }\n            const attributeValue = clone.getAttribute(\"gdg-raw-value\");\n            const formatValue = (clone.getAttribute(\"gdg-format\") ?? \"string\"); // fix me at some point\n            if (clone.querySelector(\"a\") !== null) {\n                current?.push({\n                    // raw value is the href\n                    rawValue: clone.querySelector(\"a\")?.getAttribute(\"href\") ?? \"\",\n                    formatted: clone.textContent ?? \"\",\n                    format: formatValue,\n                });\n            }\n            else if (clone.querySelector(\"ol\") !== null) {\n                const rawValues = clone.querySelectorAll(\"li\");\n                current?.push({\n                    rawValue: [...rawValues].map(x => x.getAttribute(\"gdg-raw-value\") ?? \"\"),\n                    formatted: [...rawValues].map(x => x.textContent ?? \"\"),\n                    format: \"string-array\",\n                });\n            }\n            else if (attributeValue !== null) {\n                current?.push({\n                    rawValue: restoreHtmlEntities(attributeValue),\n                    formatted: clone.textContent ?? \"\",\n                    format: formatValue,\n                });\n            }\n            else {\n                let textContent = clone.textContent ?? \"\";\n                if (isAppleNumbers) {\n                    // replace any newline not preceded by a newline\n                    textContent = textContent.replace(/\\n(?!\\n)/g, \"\");\n                }\n                current?.push({\n                    rawValue: textContent ?? \"\",\n                    formatted: textContent ?? \"\",\n                    format: formatValue,\n                });\n            }\n        }\n    }\n    if (current !== undefined) {\n        result.push(current);\n    }\n    return result;\n}\n//# sourceMappingURL=copy-paste.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvY29weS1wYXN0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDbUQ7QUFDMEQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnRkFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdGQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnRkFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnRkFBWTtBQUN6QixhQUFhLGdGQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdGQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdGQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdGQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdGQUFZO0FBQ3pCLGFBQWEsZ0ZBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0ZBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0ZBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0ZBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdCQUF3QixzQkFBc0Isc0JBQXNCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw4QkFBOEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQSxrQ0FBa0MsVUFBVSxZQUFZLGNBQWMsSUFBSSxzQ0FBc0M7QUFDaEg7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsT0FBTztBQUN2RCw4REFBOEQsK0NBQStDO0FBQzdHO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG9EQUFvRCw2REFBNkQsRUFBRSxVQUFVLEdBQUcsc0NBQXNDO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvY29weS1wYXN0ZS5qcz9iNWY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHNvbmFyanMvbm8tZHVwbGljYXRlLXN0cmluZyAqL1xuaW1wb3J0IHsgYXNzZXJ0TmV2ZXIgfSBmcm9tIFwiLi4vY29tbW9uL3N1cHBvcnQuanNcIjtcbmltcG9ydCB7IEdyaWRDZWxsS2luZCwgQm9vbGVhbkVtcHR5LCBCb29sZWFuSW5kZXRlcm1pbmF0ZSwgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlcy5qc1wiO1xuZnVuY3Rpb24gY29udmVydENlbGxUb0J1ZmZlcihjZWxsKSB7XG4gICAgaWYgKGNlbGwuY29weURhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0dGVkOiBjZWxsLmNvcHlEYXRhLFxuICAgICAgICAgICAgcmF3VmFsdWU6IGNlbGwuY29weURhdGEsXG4gICAgICAgICAgICBmb3JtYXQ6IFwic3RyaW5nXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN3aXRjaCAoY2VsbC5raW5kKSB7XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLkJvb2xlYW46XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogY2VsbC5kYXRhID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgID8gXCJUUlVFXCJcbiAgICAgICAgICAgICAgICAgICAgOiBjZWxsLmRhdGEgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiRkFMU0VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjZWxsLmRhdGEgPT09IEJvb2xlYW5JbmRldGVybWluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIklOREVURVJNSU5BVEVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgICAgICByYXdWYWx1ZTogY2VsbC5kYXRhLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJib29sZWFuXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5DdXN0b206XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogY2VsbC5jb3B5RGF0YSxcbiAgICAgICAgICAgICAgICByYXdWYWx1ZTogY2VsbC5jb3B5RGF0YSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5JbWFnZTpcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQnViYmxlOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQ6IGNlbGwuZGF0YSxcbiAgICAgICAgICAgICAgICByYXdWYWx1ZTogY2VsbC5kYXRhLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJzdHJpbmctYXJyYXlcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLkRyaWxsZG93bjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiBjZWxsLmRhdGEubWFwKHggPT4geC50ZXh0KSxcbiAgICAgICAgICAgICAgICByYXdWYWx1ZTogY2VsbC5kYXRhLm1hcCh4ID0+IHgudGV4dCksXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcInN0cmluZy1hcnJheVwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVGV4dDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiBjZWxsLmRpc3BsYXlEYXRhID8/IGNlbGwuZGF0YSxcbiAgICAgICAgICAgICAgICByYXdWYWx1ZTogY2VsbC5kYXRhLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlVyaTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiBjZWxsLmRpc3BsYXlEYXRhID8/IGNlbGwuZGF0YSxcbiAgICAgICAgICAgICAgICByYXdWYWx1ZTogY2VsbC5kYXRhLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJ1cmxcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk1hcmtkb3duOlxuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5Sb3dJRDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiBjZWxsLmRhdGEsXG4gICAgICAgICAgICAgICAgcmF3VmFsdWU6IGNlbGwuZGF0YSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5OdW1iZXI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogY2VsbC5kaXNwbGF5RGF0YSxcbiAgICAgICAgICAgICAgICByYXdWYWx1ZTogY2VsbC5kYXRhLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJudW1iZXJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLkxvYWRpbmc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogXCIjTE9BRElOR1wiLFxuICAgICAgICAgICAgICAgIHJhd1ZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlByb3RlY3RlZDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiBcIioqKioqKioqKioqKlwiLFxuICAgICAgICAgICAgICAgIHJhd1ZhbHVlOiBcIlwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhc3NlcnROZXZlcihjZWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCdWZmZXJGcm9tR3JpZENlbGxzKGNlbGxzLCBjb2x1bW5JbmRleGVzKSB7XG4gICAgY29uc3QgY29weUJ1ZmZlciA9IGNlbGxzLm1hcCgocm93LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBtYXBwZWRJbmRleCA9IGNvbHVtbkluZGV4ZXNbaW5kZXhdO1xuICAgICAgICByZXR1cm4gcm93Lm1hcChjZWxsID0+IHtcbiAgICAgICAgICAgIGlmIChjZWxsLnNwYW4gIT09IHVuZGVmaW5lZCAmJiBjZWxsLnNwYW5bMF0gIT09IG1hcHBlZEluZGV4KVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRDZWxsVG9CdWZmZXIoY2VsbCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3B5QnVmZmVyO1xufVxuZnVuY3Rpb24gZXNjYXBlSWZOZWVkZWQoc3RyLCB3aXRoQ29tbWEpIHtcbiAgICBpZiAoKHdpdGhDb21tYSA/IC9bXFx0XFxuXCIsXS8gOiAvW1xcdFxcblwiXS8pLnRlc3Qoc3RyKSkge1xuICAgICAgICBzdHIgPSBgXCIke3N0ci5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRCdWZmZXIoY29weUJ1ZmZlcikge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgZm9yIChjb25zdCByb3cgb2YgY29weUJ1ZmZlcikge1xuICAgICAgICBjb25zdCBsaW5lID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cpIHtcbiAgICAgICAgICAgIGlmIChjZWxsLmZvcm1hdCA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIGxpbmUucHVzaChjZWxsLnJhd1ZhbHVlPy50b1N0cmluZygpID8/IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2VsbC5mb3JtYXQgPT09IFwic3RyaW5nLWFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICBsaW5lLnB1c2goY2VsbC5mb3JtYXR0ZWQubWFwKHggPT4gZXNjYXBlSWZOZWVkZWQoeCwgdHJ1ZSkpLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUucHVzaChlc2NhcGVJZk5lZWRlZChjZWxsLmZvcm1hdHRlZCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lcy5wdXNoKGxpbmUuam9pbihcIlxcdFwiKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuZnVuY3Rpb24gZm9ybWF0SHRtbFRleHRDb250ZW50KHRleHQpIHtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGZvcm1hdHRpbmcgZm9yIHRoZSBgaHRtbGAgdmFyaWFibGUgZW5zdXJlcyB0aGF0IHdoZW4gcGFzdGluZyxcbiAgICAvLyBzcGFjZXMgYXJlIHByZXNlcnZlZCBpbiBib3RoIEdvb2dsZSBTaGVldHMgYW5kIEV4Y2VsLiBUaGlzIGlzIGRvbmUgYnk6XG4gICAgLy8gMS4gUmVwbGFjaW5nIHRhYnMgd2l0aCBmb3VyIHNwYWNlcyBmb3IgY29uc2lzdGVuY3kuIEFsc28gZ29vZ2xlIHNoZWV0cyBkaXNhbGxvd3MgYW55IHRhYnMuXG4gICAgLy8gMi4gV3JhcHBpbmcgZWFjaCBzcGFjZSB3aXRoIGEgc3BhbiBlbGVtZW50IHRvIHByZXZlbnQgdGhlbSBmcm9tIGJlaW5nIGNvbGxhcHNlZCBvciBpZ25vcmVkIGR1cmluZyB0aGVcbiAgICAvLyAgICBwYXN0ZSBvcGVyYXRpb25cbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHQvZywgXCIgICAgXCIpLnJlcGxhY2UoLyB7Mix9L2csIG1hdGNoID0+IFwiPHNwYW4+IDwvc3Bhbj5cIi5yZXBlYXQobWF0Y2gubGVuZ3RoKSk7XG59XG5mdW5jdGlvbiBmb3JtYXRIdG1sQXR0cmlidXRlQ29udGVudChhdHRyVGV4dCkge1xuICAgIC8vIEVzY2FwZSBhbGwgcXVvdGVzLCBsdCwgZ3QsIGFuZCBvdGhlciBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICByZXR1cm4gKCdcIicgKyBhdHRyVGV4dC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIikgKyAnXCInKTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVIdG1sRW50aXRpZXMoc3RyKSB7XG4gICAgLy8gVW5lc2NhcGUgYWxsIHF1b3RlcywgbHQsIGd0LCBhbmQgb3RoZXIgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIHN0clxuICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXG4gICAgICAgIC5yZXBsYWNlKC8mbHQ7L2csIFwiPFwiKVxuICAgICAgICAucmVwbGFjZSgvJmd0Oy9nLCBcIj5cIilcbiAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh0bWxCdWZmZXIoY29weUJ1ZmZlcikge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgbGluZXMucHVzaChgPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPjwhLS1iciB7bXNvLWRhdGEtcGxhY2VtZW50OnNhbWUtY2VsbDt9LS0+PC9zdHlsZT5gLCBcIjx0YWJsZT48dGJvZHk+XCIpO1xuICAgIGZvciAoY29uc3Qgcm93IG9mIGNvcHlCdWZmZXIpIHtcbiAgICAgICAgbGluZXMucHVzaChcIjx0cj5cIik7XG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdFN0ciA9IGBnZGctZm9ybWF0PVwiJHtjZWxsLmZvcm1hdH1cImA7XG4gICAgICAgICAgICBpZiAoY2VsbC5mb3JtYXQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGA8dGQgJHtmb3JtYXRTdHJ9PjxhIGhyZWY9XCIke2NlbGwucmF3VmFsdWV9XCI+JHtmb3JtYXRIdG1sVGV4dENvbnRlbnQoY2VsbC5mb3JtYXR0ZWQpfTwvYT48L3RkPmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuZm9ybWF0ID09PSBcInN0cmluZy1hcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYDx0ZCAke2Zvcm1hdFN0cn0+PG9sPiR7Y2VsbC5mb3JtYXR0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHgsIGluZCkgPT4gYDxsaSBnZGctcmF3LXZhbHVlPSR7Zm9ybWF0SHRtbEF0dHJpYnV0ZUNvbnRlbnQoY2VsbC5yYXdWYWx1ZVtpbmRdKX0+YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRIdG1sVGV4dENvbnRlbnQoeCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCI8L2xpPlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCJcIil9PC9vbD48L3RkPmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChgPHRkIGdkZy1yYXctdmFsdWU9JHtmb3JtYXRIdG1sQXR0cmlidXRlQ29udGVudChjZWxsLnJhd1ZhbHVlPy50b1N0cmluZygpID8/IFwiXCIpfSAke2Zvcm1hdFN0cn0+JHtmb3JtYXRIdG1sVGV4dENvbnRlbnQoY2VsbC5mb3JtYXR0ZWQpfTwvdGQ+YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmVzLnB1c2goXCI8L3RyPlwiKTtcbiAgICB9XG4gICAgbGluZXMucHVzaChcIjwvdGJvZHk+PC90YWJsZT5cIik7XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcIik7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIGVuY29kZXMgZ3JpZCBjZWxscyB0byBhIHRhYmxlIG9iamVjdC5cbi8vIEVhY2ggdGQgaW4gdGhlIHRhYmxlIGNvbnRhaW5zIG9uZSBvZiAzIHRoaW5nc1xuLy8gLSBBIHN0cmluZyBkaXJlY3RseSBhbmQgdGhlIHRkIGhhcyBhIGBnZGctcmF3LXZhbHVlYCBhdHRyaWJ1dGUgd2l0aCB0aGUgcmF3IHZhbHVlXG4vLyAtIEFuIGFuY2hvciB0YWcgd2l0aCBhIGhyZWYgYW5kIHRoZSB0ZXh0IGlzIHRoZSBmb3JtYXR0ZWQgdmFsdWVcbi8vIC0gQW4gb3JkZXJlZCBsaXN0IHdpdGggZWFjaCBpdGVtIGNvbnRhaW5pbmcgYSBgZ2RnLXJhdy12YWx1ZWAgYXR0cmlidXRlIHdpdGggdGhlIHJhdyB2YWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIGdldENvcHlCdWZmZXJDb250ZW50cyhjZWxscywgY29sdW1uSW5kZXhlcykge1xuICAgIGNvbnN0IGNvcHlCdWZmZXIgPSBjcmVhdGVCdWZmZXJGcm9tR3JpZENlbGxzKGNlbGxzLCBjb2x1bW5JbmRleGVzKTtcbiAgICBjb25zdCB0ZXh0UGxhaW4gPSBjcmVhdGVUZXh0QnVmZmVyKGNvcHlCdWZmZXIpO1xuICAgIGNvbnN0IHRleHRIdG1sID0gY3JlYXRlSHRtbEJ1ZmZlcihjb3B5QnVmZmVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0UGxhaW4sXG4gICAgICAgIHRleHRIdG1sLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSFRNTChodG1sKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaHRtbFwiKTtcbiAgICAvLyB3ZSBkb250IHdhbnQgdG8gcmV0YWluIHRoZSBwYXN0ZWQgbm9uLWJyZWFraW5nIHNwYWNlc1xuICAgIGZyYWdtZW50LmlubmVySFRNTCA9IGh0bWwucmVwbGFjZSgvJm5ic3A7L2csIFwiIFwiKTtcbiAgICBjb25zdCB0YWJsZUVsID0gZnJhZ21lbnQucXVlcnlTZWxlY3RvcihcInRhYmxlXCIpO1xuICAgIGlmICh0YWJsZUVsID09PSBudWxsKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHdhbGtFbCA9IFt0YWJsZUVsXTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgY3VycmVudDtcbiAgICB3aGlsZSAod2Fsa0VsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZWwgPSB3YWxrRWwucG9wKCk7XG4gICAgICAgIGlmIChlbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxUYWJsZUVsZW1lbnQgfHwgZWwubm9kZU5hbWUgPT09IFwiVEJPRFlcIikge1xuICAgICAgICAgICAgd2Fsa0VsLnB1c2goLi4uWy4uLmVsLmNoaWxkcmVuXS5yZXZlcnNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgSFRNTFRhYmxlUm93RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgd2Fsa0VsLnB1c2goLi4uWy4uLmVsLmNoaWxkcmVuXS5yZXZlcnNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgSFRNTFRhYmxlQ2VsbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGJlIGNhcmVmdWwgbm90IHRvIHVzZSBpbm5lclRleHQgaGVyZSBhcyBpdHMgYmVoYXZpb3IgaXMgbm90IHdlbGwgZGVmaW5lZCBmb3Igbm9uIERPTSBhdHRhY2hlZCBub2Rlc1xuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAvLyBBcHBsZSBudW1iZXJzIHNlZW1zIHRvIGFsd2F5cyB3cmFwIHRoZSBjZWxsIGluIGEgcCB0YWcgYW5kIGEgZm9udCB0YWcuIEl0IGFsc28gcHV0cyBib3RoIDxicj4gYW5kIFxcblxuICAgICAgICAgICAgLy8gbGluZWJyZWFrIG1hcmtlcnMgaW4gdGhlIGNvZGUuIFRoaXMgaXMgYm90aCB1bm5lZWRlZCBhbmQgY2F1c2VzIGlzc3VlcyB3aXRoIHRoZSBwYXN0ZSBjb2RlLlxuICAgICAgICAgICAgY29uc3QgZmlyc3RUYWdJc1BhcmEgPSBjbG9uZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2xvbmUuY2hpbGRyZW5bMF0ubm9kZU5hbWUgPT09IFwiUFwiO1xuICAgICAgICAgICAgY29uc3QgcGFyYSA9IGZpcnN0VGFnSXNQYXJhID8gY2xvbmUuY2hpbGRyZW5bMF0gOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgaXNBcHBsZU51bWJlcnMgPSBwYXJhPy5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgcGFyYS5jaGlsZHJlblswXS5ub2RlTmFtZSA9PT0gXCJGT05UXCI7XG4gICAgICAgICAgICBjb25zdCBicnMgPSBjbG9uZS5xdWVyeVNlbGVjdG9yQWxsKFwiYnJcIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJyIG9mIGJycykge1xuICAgICAgICAgICAgICAgIGJyLnJlcGxhY2VXaXRoKFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlVmFsdWUgPSBjbG9uZS5nZXRBdHRyaWJ1dGUoXCJnZGctcmF3LXZhbHVlXCIpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0VmFsdWUgPSAoY2xvbmUuZ2V0QXR0cmlidXRlKFwiZ2RnLWZvcm1hdFwiKSA/PyBcInN0cmluZ1wiKTsgLy8gZml4IG1lIGF0IHNvbWUgcG9pbnRcbiAgICAgICAgICAgIGlmIChjbG9uZS5xdWVyeVNlbGVjdG9yKFwiYVwiKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ/LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAvLyByYXcgdmFsdWUgaXMgdGhlIGhyZWZcbiAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWU6IGNsb25lLnF1ZXJ5U2VsZWN0b3IoXCJhXCIpPy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogY2xvbmUudGV4dENvbnRlbnQgPz8gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb25lLnF1ZXJ5U2VsZWN0b3IoXCJvbFwiKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlcyA9IGNsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaVwiKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Py5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWU6IFsuLi5yYXdWYWx1ZXNdLm1hcCh4ID0+IHguZ2V0QXR0cmlidXRlKFwiZ2RnLXJhdy12YWx1ZVwiKSA/PyBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkOiBbLi4ucmF3VmFsdWVzXS5tYXAoeCA9PiB4LnRleHRDb250ZW50ID8/IFwiXCIpLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwic3RyaW5nLWFycmF5XCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhdHRyaWJ1dGVWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ/LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZTogcmVzdG9yZUh0bWxFbnRpdGllcyhhdHRyaWJ1dGVWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogY2xvbmUudGV4dENvbnRlbnQgPz8gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0Q29udGVudCA9IGNsb25lLnRleHRDb250ZW50ID8/IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXBwbGVOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgYW55IG5ld2xpbmUgbm90IHByZWNlZGVkIGJ5IGEgbmV3bGluZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnJlcGxhY2UoL1xcbig/IVxcbikvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQ/LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZTogdGV4dENvbnRlbnQgPz8gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkOiB0ZXh0Q29udGVudCA/PyBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdFZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5LXBhc3RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/copy-paste.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor-fns.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor-fns.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   copyToClipboard: () => (/* binding */ copyToClipboard),\n/* harmony export */   expandSelection: () => (/* binding */ expandSelection),\n/* harmony export */   toggleBoolean: () => (/* binding */ toggleBoolean),\n/* harmony export */   unquote: () => (/* binding */ unquote)\n/* harmony export */ });\n/* harmony import */ var _copy_paste_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./copy-paste.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/copy-paste.js\");\n\n\nfunction expandSelection(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortController) {\n    const origVal = newVal;\n    if (spanRangeBehavior === \"allowPartial\" || newVal.current === undefined || getCellsForSelection === undefined)\n        return newVal;\n    let isFilled = false;\n    do {\n        if (newVal?.current === undefined)\n            break;\n        const r = newVal.current?.range;\n        const cells = [];\n        if (r.width > 2) {\n            const leftCells = getCellsForSelection({\n                x: r.x,\n                y: r.y,\n                width: 1,\n                height: r.height,\n            }, abortController.signal);\n            if (typeof leftCells === \"function\") {\n                return origVal;\n            }\n            cells.push(...leftCells);\n            const rightCells = getCellsForSelection({\n                x: r.x + r.width - 1,\n                y: r.y,\n                width: 1,\n                height: r.height,\n            }, abortController.signal);\n            if (typeof rightCells === \"function\") {\n                return origVal;\n            }\n            cells.push(...rightCells);\n        }\n        else {\n            const rCells = getCellsForSelection({\n                x: r.x,\n                y: r.y,\n                width: r.width,\n                height: r.height,\n            }, abortController.signal);\n            if (typeof rCells === \"function\") {\n                return origVal;\n            }\n            cells.push(...rCells);\n        }\n        let left = r.x - rowMarkerOffset;\n        let right = r.x + r.width - 1 - rowMarkerOffset;\n        for (const row of cells) {\n            for (const cell of row) {\n                if (cell.span === undefined)\n                    continue;\n                left = Math.min(cell.span[0], left);\n                right = Math.max(cell.span[1], right);\n            }\n        }\n        if (left === r.x - rowMarkerOffset && right === r.x + r.width - 1 - rowMarkerOffset) {\n            isFilled = true;\n        }\n        else {\n            newVal = {\n                current: {\n                    cell: newVal.current.cell ?? [0, 0],\n                    range: {\n                        x: left + rowMarkerOffset,\n                        y: r.y,\n                        width: right - left + 1,\n                        height: r.height,\n                    },\n                    rangeStack: newVal.current.rangeStack,\n                },\n                columns: newVal.columns,\n                rows: newVal.rows,\n            };\n        }\n    } while (!isFilled);\n    return newVal;\n}\nfunction descape(s) {\n    if (s.startsWith('\"') && s.endsWith('\"')) {\n        s = s.slice(1, -1).replace(/\"\"/g, '\"');\n    }\n    return s;\n}\nfunction unquote(str) {\n    let State;\n    (function (State) {\n        State[State[\"None\"] = 0] = \"None\";\n        State[State[\"inString\"] = 1] = \"inString\";\n        State[State[\"inStringPostQuote\"] = 2] = \"inStringPostQuote\";\n    })(State || (State = {}));\n    const result = [];\n    let current = [];\n    let start = 0;\n    let state = State.None;\n    str = str.replace(/\\r\\n/g, \"\\n\");\n    let index = 0;\n    for (const char of str) {\n        switch (state) {\n            case State.None:\n                if (char === \"\\t\" || char === \"\\n\") {\n                    current.push(str.slice(start, index));\n                    start = index + 1;\n                    if (char === \"\\n\") {\n                        result.push(current);\n                        current = [];\n                    }\n                }\n                else if (char === `\"`) {\n                    state = State.inString;\n                }\n                break;\n            case State.inString:\n                if (char === `\"`) {\n                    state = State.inStringPostQuote;\n                }\n                break;\n            case State.inStringPostQuote:\n                if (char === '\"') {\n                    state = State.inString;\n                }\n                else if (char === \"\\t\" || char === \"\\n\") {\n                    current.push(descape(str.slice(start, index)));\n                    start = index + 1;\n                    if (char === \"\\n\") {\n                        result.push(current);\n                        current = [];\n                    }\n                    state = State.None;\n                }\n                else {\n                    state = State.None;\n                }\n                break;\n        }\n        index++;\n    }\n    if (start < str.length) {\n        current.push(descape(str.slice(start, str.length)));\n    }\n    result.push(current);\n    return result.map(r => r.map(c => ({ rawValue: c, formatted: c, format: \"string\" })));\n}\nfunction copyToClipboard(cells, columnIndexes, e) {\n    const copyBuffer = (0,_copy_paste_js__WEBPACK_IMPORTED_MODULE_0__.getCopyBufferContents)(cells, columnIndexes);\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    const copyWithWriteText = (s) => {\n        void window.navigator.clipboard?.writeText(s);\n    };\n    const copyWithWrite = (s, html) => {\n        if (window.navigator.clipboard?.write === undefined)\n            return false;\n        void window.navigator.clipboard.write([\n            new ClipboardItem({\n                // eslint-disable-next-line sonarjs/no-duplicate-string\n                \"text/plain\": new Blob([s], { type: \"text/plain\" }),\n                \"text/html\": new Blob([html], {\n                    type: \"text/html\",\n                }),\n            }),\n        ]);\n        return true;\n    };\n    const copyWithClipboardData = (s, html) => {\n        try {\n            if (e === undefined || e.clipboardData === null)\n                throw new Error(\"No clipboard data\");\n            // This might fail if we had to await the thunk\n            e?.clipboardData?.setData(\"text/plain\", s);\n            e?.clipboardData?.setData(\"text/html\", html);\n        }\n        catch {\n            if (!copyWithWrite(s, html)) {\n                copyWithWriteText(s);\n            }\n        }\n    };\n    if (window.navigator.clipboard?.write !== undefined || e?.clipboardData !== undefined) {\n        void copyWithClipboardData(copyBuffer.textPlain, copyBuffer.textHtml);\n    }\n    else {\n        void copyWithWriteText(copyBuffer.textPlain);\n    }\n    e?.preventDefault();\n}\n/**\n * Checkbox behavior:\n *\n * true + click -> unchecked\n * false + click -> checked\n * indeterminate + click -> checked\n * empty + click -> checked\n */\nfunction toggleBoolean(data) {\n    return data !== true;\n}\n//# sourceMappingURL=data-editor-fns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvZGF0YS1lZGl0b3ItZm5zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBEO0FBQ0Y7QUFDakQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNCQUFzQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDZDQUE2QztBQUN0RjtBQUNPO0FBQ1AsdUJBQXVCLHFFQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0I7QUFDbEU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9kYXRhLWVkaXRvci9kYXRhLWVkaXRvci1mbnMuanM/ZWE0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge30gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmltcG9ydCB7IGdldENvcHlCdWZmZXJDb250ZW50cyB9IGZyb20gXCIuL2NvcHktcGFzdGUuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRTZWxlY3Rpb24obmV3VmFsLCBnZXRDZWxsc0ZvclNlbGVjdGlvbiwgcm93TWFya2VyT2Zmc2V0LCBzcGFuUmFuZ2VCZWhhdmlvciwgYWJvcnRDb250cm9sbGVyKSB7XG4gICAgY29uc3Qgb3JpZ1ZhbCA9IG5ld1ZhbDtcbiAgICBpZiAoc3BhblJhbmdlQmVoYXZpb3IgPT09IFwiYWxsb3dQYXJ0aWFsXCIgfHwgbmV3VmFsLmN1cnJlbnQgPT09IHVuZGVmaW5lZCB8fCBnZXRDZWxsc0ZvclNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbmV3VmFsO1xuICAgIGxldCBpc0ZpbGxlZCA9IGZhbHNlO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKG5ld1ZhbD8uY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnN0IHIgPSBuZXdWYWwuY3VycmVudD8ucmFuZ2U7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgICAgIGlmIChyLndpZHRoID4gMikge1xuICAgICAgICAgICAgY29uc3QgbGVmdENlbGxzID0gZ2V0Q2VsbHNGb3JTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgIHg6IHIueCxcbiAgICAgICAgICAgICAgICB5OiByLnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByLmhlaWdodCxcbiAgICAgICAgICAgIH0sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZWZ0Q2VsbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbHMucHVzaCguLi5sZWZ0Q2VsbHMpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRDZWxscyA9IGdldENlbGxzRm9yU2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICB4OiByLnggKyByLndpZHRoIC0gMSxcbiAgICAgICAgICAgICAgICB5OiByLnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByLmhlaWdodCxcbiAgICAgICAgICAgIH0sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByaWdodENlbGxzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ1ZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxzLnB1c2goLi4ucmlnaHRDZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByQ2VsbHMgPSBnZXRDZWxsc0ZvclNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgeDogci54LFxuICAgICAgICAgICAgICAgIHk6IHIueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogci53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0LFxuICAgICAgICAgICAgfSwgYWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJDZWxscyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxscy5wdXNoKC4uLnJDZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlZnQgPSByLnggLSByb3dNYXJrZXJPZmZzZXQ7XG4gICAgICAgIGxldCByaWdodCA9IHIueCArIHIud2lkdGggLSAxIC0gcm93TWFya2VyT2Zmc2V0O1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBjZWxscykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdykge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLnNwYW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGNlbGwuc3BhblswXSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChjZWxsLnNwYW5bMV0sIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCA9PT0gci54IC0gcm93TWFya2VyT2Zmc2V0ICYmIHJpZ2h0ID09PSByLnggKyByLndpZHRoIC0gMSAtIHJvd01hcmtlck9mZnNldCkge1xuICAgICAgICAgICAgaXNGaWxsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsID0ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbDogbmV3VmFsLmN1cnJlbnQuY2VsbCA/PyBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBsZWZ0ICsgcm93TWFya2VyT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogci55LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByYW5nZVN0YWNrOiBuZXdWYWwuY3VycmVudC5yYW5nZVN0YWNrLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29sdW1uczogbmV3VmFsLmNvbHVtbnMsXG4gICAgICAgICAgICAgICAgcm93czogbmV3VmFsLnJvd3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoIWlzRmlsbGVkKTtcbiAgICByZXR1cm4gbmV3VmFsO1xufVxuZnVuY3Rpb24gZGVzY2FwZShzKSB7XG4gICAgaWYgKHMuc3RhcnRzV2l0aCgnXCInKSAmJiBzLmVuZHNXaXRoKCdcIicpKSB7XG4gICAgICAgIHMgPSBzLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cIlwiL2csICdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnF1b3RlKHN0cikge1xuICAgIGxldCBTdGF0ZTtcbiAgICAoZnVuY3Rpb24gKFN0YXRlKSB7XG4gICAgICAgIFN0YXRlW1N0YXRlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgICAgIFN0YXRlW1N0YXRlW1wiaW5TdHJpbmdcIl0gPSAxXSA9IFwiaW5TdHJpbmdcIjtcbiAgICAgICAgU3RhdGVbU3RhdGVbXCJpblN0cmluZ1Bvc3RRdW90ZVwiXSA9IDJdID0gXCJpblN0cmluZ1Bvc3RRdW90ZVwiO1xuICAgIH0pKFN0YXRlIHx8IChTdGF0ZSA9IHt9KSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSBbXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBzdGF0ZSA9IFN0YXRlLk5vbmU7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgY2hhciBvZiBzdHIpIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBTdGF0ZS5Ob25lOlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBcIlxcdFwiIHx8IGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5wdXNoKHN0ci5zbGljZShzdGFydCwgaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBgXCJgKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU3RhdGUuaW5TdHJpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0ZS5pblN0cmluZzpcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gYFwiYCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFN0YXRlLmluU3RyaW5nUG9zdFF1b3RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3RhdGUuaW5TdHJpbmdQb3N0UXVvdGU6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTdGF0ZS5pblN0cmluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJcXHRcIiB8fCBjaGFyID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQucHVzaChkZXNjYXBlKHN0ci5zbGljZShzdGFydCwgaW5kZXgpKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTdGF0ZS5Ob25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTdGF0ZS5Ob25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpbmRleCsrO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIGN1cnJlbnQucHVzaChkZXNjYXBlKHN0ci5zbGljZShzdGFydCwgc3RyLmxlbmd0aCkpKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgcmV0dXJuIHJlc3VsdC5tYXAociA9PiByLm1hcChjID0+ICh7IHJhd1ZhbHVlOiBjLCBmb3JtYXR0ZWQ6IGMsIGZvcm1hdDogXCJzdHJpbmdcIiB9KSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlUb0NsaXBib2FyZChjZWxscywgY29sdW1uSW5kZXhlcywgZSkge1xuICAgIGNvbnN0IGNvcHlCdWZmZXIgPSBnZXRDb3B5QnVmZmVyQ29udGVudHMoY2VsbHMsIGNvbHVtbkluZGV4ZXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2NvbnNpc3RlbnQtZnVuY3Rpb24tc2NvcGluZ1xuICAgIGNvbnN0IGNvcHlXaXRoV3JpdGVUZXh0ID0gKHMpID0+IHtcbiAgICAgICAgdm9pZCB3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZD8ud3JpdGVUZXh0KHMpO1xuICAgIH07XG4gICAgY29uc3QgY29weVdpdGhXcml0ZSA9IChzLCBodG1sKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZD8ud3JpdGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdm9pZCB3aW5kb3cubmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZShbXG4gICAgICAgICAgICBuZXcgQ2xpcGJvYXJkSXRlbSh7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNvbmFyanMvbm8tZHVwbGljYXRlLXN0cmluZ1xuICAgICAgICAgICAgICAgIFwidGV4dC9wbGFpblwiOiBuZXcgQmxvYihbc10sIHsgdHlwZTogXCJ0ZXh0L3BsYWluXCIgfSksXG4gICAgICAgICAgICAgICAgXCJ0ZXh0L2h0bWxcIjogbmV3IEJsb2IoW2h0bWxdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC9odG1sXCIsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgY29weVdpdGhDbGlwYm9hcmREYXRhID0gKHMsIGh0bWwpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChlID09PSB1bmRlZmluZWQgfHwgZS5jbGlwYm9hcmREYXRhID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsaXBib2FyZCBkYXRhXCIpO1xuICAgICAgICAgICAgLy8gVGhpcyBtaWdodCBmYWlsIGlmIHdlIGhhZCB0byBhd2FpdCB0aGUgdGh1bmtcbiAgICAgICAgICAgIGU/LmNsaXBib2FyZERhdGE/LnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHMpO1xuICAgICAgICAgICAgZT8uY2xpcGJvYXJkRGF0YT8uc2V0RGF0YShcInRleHQvaHRtbFwiLCBodG1sKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICBpZiAoIWNvcHlXaXRoV3JpdGUocywgaHRtbCkpIHtcbiAgICAgICAgICAgICAgICBjb3B5V2l0aFdyaXRlVGV4dChzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IuY2xpcGJvYXJkPy53cml0ZSAhPT0gdW5kZWZpbmVkIHx8IGU/LmNsaXBib2FyZERhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2b2lkIGNvcHlXaXRoQ2xpcGJvYXJkRGF0YShjb3B5QnVmZmVyLnRleHRQbGFpbiwgY29weUJ1ZmZlci50ZXh0SHRtbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2b2lkIGNvcHlXaXRoV3JpdGVUZXh0KGNvcHlCdWZmZXIudGV4dFBsYWluKTtcbiAgICB9XG4gICAgZT8ucHJldmVudERlZmF1bHQoKTtcbn1cbi8qKlxuICogQ2hlY2tib3ggYmVoYXZpb3I6XG4gKlxuICogdHJ1ZSArIGNsaWNrIC0+IHVuY2hlY2tlZFxuICogZmFsc2UgKyBjbGljayAtPiBjaGVja2VkXG4gKiBpbmRldGVybWluYXRlICsgY2xpY2sgLT4gY2hlY2tlZFxuICogZW1wdHkgKyBjbGljayAtPiBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVCb29sZWFuKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSAhPT0gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtZWRpdG9yLWZucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor-fns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor-keybindings.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor-keybindings.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keybindingDefaults: () => (/* binding */ keybindingDefaults),\n/* harmony export */   realizeKeybinds: () => (/* binding */ realizeKeybinds),\n/* harmony export */   useKeybindingsWithDefaults: () => (/* binding */ useKeybindingsWithDefaults)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/browser-detect.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/browser-detect.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n\n\n\nconst keybindingDefaults = {\n    downFill: false,\n    rightFill: false,\n    clear: true,\n    closeOverlay: true,\n    acceptOverlayDown: true,\n    acceptOverlayUp: true,\n    acceptOverlayLeft: true,\n    acceptOverlayRight: true,\n    copy: true,\n    paste: true,\n    cut: true,\n    search: false,\n    delete: true,\n    activateCell: true,\n    scrollToSelectedCell: true,\n    goToFirstCell: true,\n    goToFirstColumn: true,\n    goToFirstRow: true,\n    goToLastCell: true,\n    goToLastColumn: true,\n    goToLastRow: true,\n    goToNextPage: true,\n    goToPreviousPage: true,\n    selectToFirstCell: true,\n    selectToFirstColumn: true,\n    selectToFirstRow: true,\n    selectToLastCell: true,\n    selectToLastColumn: true,\n    selectToLastRow: true,\n    selectAll: true,\n    selectRow: true,\n    selectColumn: true,\n    goUpCell: true,\n    goRightCell: true,\n    goDownCell: true,\n    goLeftCell: true,\n    goUpCellRetainSelection: true,\n    goRightCellRetainSelection: true,\n    goDownCellRetainSelection: true,\n    goLeftCellRetainSelection: true,\n    selectGrowUp: true,\n    selectGrowRight: true,\n    selectGrowDown: true,\n    selectGrowLeft: true,\n};\nfunction realizeKeybind(keybind, defaultVal) {\n    if (keybind === true)\n        return defaultVal;\n    if (keybind === false)\n        return \"\";\n    return keybind;\n}\nfunction realizeKeybinds(keybinds) {\n    const isOSX = _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_1__.browserIsOSX.value;\n    return {\n        activateCell: realizeKeybind(keybinds.activateCell, \" |Enter|shift+Enter\"),\n        clear: realizeKeybind(keybinds.clear, \"any+Escape\"),\n        closeOverlay: realizeKeybind(keybinds.closeOverlay, \"any+Escape\"),\n        acceptOverlayDown: realizeKeybind(keybinds.acceptOverlayDown, \"Enter\"),\n        acceptOverlayUp: realizeKeybind(keybinds.acceptOverlayUp, \"shift+Enter\"),\n        acceptOverlayLeft: realizeKeybind(keybinds.acceptOverlayLeft, \"shift+Tab\"),\n        acceptOverlayRight: realizeKeybind(keybinds.acceptOverlayRight, \"Tab\"),\n        copy: keybinds.copy,\n        cut: keybinds.cut,\n        delete: realizeKeybind(keybinds.delete, isOSX ? \"Backspace|Delete\" : \"Delete\"),\n        downFill: realizeKeybind(keybinds.downFill, \"primary+_68\"),\n        scrollToSelectedCell: realizeKeybind(keybinds.scrollToSelectedCell, \"primary+Enter\"),\n        goDownCell: realizeKeybind(keybinds.goDownCell, \"ArrowDown\"),\n        goDownCellRetainSelection: realizeKeybind(keybinds.goDownCellRetainSelection, \"alt+ArrowDown\"),\n        goLeftCell: realizeKeybind(keybinds.goLeftCell, \"ArrowLeft|shift+Tab\"),\n        goLeftCellRetainSelection: realizeKeybind(keybinds.goLeftCellRetainSelection, \"alt+ArrowLeft\"),\n        goRightCell: realizeKeybind(keybinds.goRightCell, \"ArrowRight|Tab\"),\n        goRightCellRetainSelection: realizeKeybind(keybinds.goRightCellRetainSelection, \"alt+ArrowRight\"),\n        goUpCell: realizeKeybind(keybinds.goUpCell, \"ArrowUp\"),\n        goUpCellRetainSelection: realizeKeybind(keybinds.goUpCellRetainSelection, \"alt+ArrowUp\"),\n        goToFirstCell: realizeKeybind(keybinds.goToFirstCell, \"primary+Home\"),\n        goToFirstColumn: realizeKeybind(keybinds.goToFirstColumn, \"Home|primary+ArrowLeft\"),\n        goToFirstRow: realizeKeybind(keybinds.goToFirstRow, \"primary+ArrowUp\"),\n        goToLastCell: realizeKeybind(keybinds.goToLastCell, \"primary+End\"),\n        goToLastColumn: realizeKeybind(keybinds.goToLastColumn, \"End|primary+ArrowRight\"),\n        goToLastRow: realizeKeybind(keybinds.goToLastRow, \"primary+ArrowDown\"),\n        goToNextPage: realizeKeybind(keybinds.goToNextPage, \"PageDown\"),\n        goToPreviousPage: realizeKeybind(keybinds.goToPreviousPage, \"PageUp\"),\n        paste: keybinds.paste,\n        rightFill: realizeKeybind(keybinds.rightFill, \"primary+_82\"),\n        search: realizeKeybind(keybinds.search, \"primary+f\"),\n        selectAll: realizeKeybind(keybinds.selectAll, \"primary+a\"),\n        selectColumn: realizeKeybind(keybinds.selectColumn, \"ctrl+ \"),\n        selectGrowDown: realizeKeybind(keybinds.selectGrowDown, \"shift+ArrowDown\"),\n        selectGrowLeft: realizeKeybind(keybinds.selectGrowLeft, \"shift+ArrowLeft\"),\n        selectGrowRight: realizeKeybind(keybinds.selectGrowRight, \"shift+ArrowRight\"),\n        selectGrowUp: realizeKeybind(keybinds.selectGrowUp, \"shift+ArrowUp\"),\n        selectRow: realizeKeybind(keybinds.selectRow, \"shift+ \"),\n        selectToFirstCell: realizeKeybind(keybinds.selectToFirstCell, \"primary+shift+Home\"),\n        selectToFirstColumn: realizeKeybind(keybinds.selectToFirstColumn, \"primary+shift+ArrowLeft\"),\n        selectToFirstRow: realizeKeybind(keybinds.selectToFirstRow, \"primary+shift+ArrowUp\"),\n        selectToLastCell: realizeKeybind(keybinds.selectToLastCell, \"primary+shift+End\"),\n        selectToLastColumn: realizeKeybind(keybinds.selectToLastColumn, \"primary+shift+ArrowRight\"),\n        selectToLastRow: realizeKeybind(keybinds.selectToLastRow, \"primary+shift+ArrowDown\"),\n    };\n}\nfunction useKeybindingsWithDefaults(keybindingsIn) {\n    const keys = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_2__.useDeepMemo)(keybindingsIn);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (keys === undefined)\n            return realizeKeybinds(keybindingDefaults);\n        const withBackCompatApplied = {\n            ...keys,\n            goToNextPage: keys?.goToNextPage ?? keys?.pageDown ?? keybindingDefaults.goToNextPage,\n            goToPreviousPage: keys?.goToPreviousPage ?? keys?.pageUp ?? keybindingDefaults.goToPreviousPage,\n            goToFirstCell: keys?.goToFirstCell ?? keys?.first ?? keybindingDefaults.goToFirstCell,\n            goToLastCell: keys?.goToLastCell ?? keys?.last ?? keybindingDefaults.goToLastCell,\n            selectToFirstCell: keys?.selectToFirstCell ?? keys?.first ?? keybindingDefaults.selectToFirstCell,\n            selectToLastCell: keys?.selectToLastCell ?? keys?.last ?? keybindingDefaults.selectToLastCell,\n        };\n        return realizeKeybinds({\n            ...keybindingDefaults,\n            ...withBackCompatApplied,\n        });\n    }, [keys]);\n}\n//# sourceMappingURL=data-editor-keybindings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvZGF0YS1lZGl0b3Ita2V5YmluZGluZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTBCO0FBQ2lDO0FBQ1Y7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLG1FQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQiw2REFBVztBQUM1QixXQUFXLDBDQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9kYXRhLWVkaXRvci9kYXRhLWVkaXRvci1rZXliaW5kaW5ncy5qcz82YjMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGJyb3dzZXJJc09TWCB9IGZyb20gXCIuLi9jb21tb24vYnJvd3Nlci1kZXRlY3QuanNcIjtcbmltcG9ydCB7IHVzZURlZXBNZW1vIH0gZnJvbSBcIi4uL2NvbW1vbi91dGlscy5qc1wiO1xuZXhwb3J0IGNvbnN0IGtleWJpbmRpbmdEZWZhdWx0cyA9IHtcbiAgICBkb3duRmlsbDogZmFsc2UsXG4gICAgcmlnaHRGaWxsOiBmYWxzZSxcbiAgICBjbGVhcjogdHJ1ZSxcbiAgICBjbG9zZU92ZXJsYXk6IHRydWUsXG4gICAgYWNjZXB0T3ZlcmxheURvd246IHRydWUsXG4gICAgYWNjZXB0T3ZlcmxheVVwOiB0cnVlLFxuICAgIGFjY2VwdE92ZXJsYXlMZWZ0OiB0cnVlLFxuICAgIGFjY2VwdE92ZXJsYXlSaWdodDogdHJ1ZSxcbiAgICBjb3B5OiB0cnVlLFxuICAgIHBhc3RlOiB0cnVlLFxuICAgIGN1dDogdHJ1ZSxcbiAgICBzZWFyY2g6IGZhbHNlLFxuICAgIGRlbGV0ZTogdHJ1ZSxcbiAgICBhY3RpdmF0ZUNlbGw6IHRydWUsXG4gICAgc2Nyb2xsVG9TZWxlY3RlZENlbGw6IHRydWUsXG4gICAgZ29Ub0ZpcnN0Q2VsbDogdHJ1ZSxcbiAgICBnb1RvRmlyc3RDb2x1bW46IHRydWUsXG4gICAgZ29Ub0ZpcnN0Um93OiB0cnVlLFxuICAgIGdvVG9MYXN0Q2VsbDogdHJ1ZSxcbiAgICBnb1RvTGFzdENvbHVtbjogdHJ1ZSxcbiAgICBnb1RvTGFzdFJvdzogdHJ1ZSxcbiAgICBnb1RvTmV4dFBhZ2U6IHRydWUsXG4gICAgZ29Ub1ByZXZpb3VzUGFnZTogdHJ1ZSxcbiAgICBzZWxlY3RUb0ZpcnN0Q2VsbDogdHJ1ZSxcbiAgICBzZWxlY3RUb0ZpcnN0Q29sdW1uOiB0cnVlLFxuICAgIHNlbGVjdFRvRmlyc3RSb3c6IHRydWUsXG4gICAgc2VsZWN0VG9MYXN0Q2VsbDogdHJ1ZSxcbiAgICBzZWxlY3RUb0xhc3RDb2x1bW46IHRydWUsXG4gICAgc2VsZWN0VG9MYXN0Um93OiB0cnVlLFxuICAgIHNlbGVjdEFsbDogdHJ1ZSxcbiAgICBzZWxlY3RSb3c6IHRydWUsXG4gICAgc2VsZWN0Q29sdW1uOiB0cnVlLFxuICAgIGdvVXBDZWxsOiB0cnVlLFxuICAgIGdvUmlnaHRDZWxsOiB0cnVlLFxuICAgIGdvRG93bkNlbGw6IHRydWUsXG4gICAgZ29MZWZ0Q2VsbDogdHJ1ZSxcbiAgICBnb1VwQ2VsbFJldGFpblNlbGVjdGlvbjogdHJ1ZSxcbiAgICBnb1JpZ2h0Q2VsbFJldGFpblNlbGVjdGlvbjogdHJ1ZSxcbiAgICBnb0Rvd25DZWxsUmV0YWluU2VsZWN0aW9uOiB0cnVlLFxuICAgIGdvTGVmdENlbGxSZXRhaW5TZWxlY3Rpb246IHRydWUsXG4gICAgc2VsZWN0R3Jvd1VwOiB0cnVlLFxuICAgIHNlbGVjdEdyb3dSaWdodDogdHJ1ZSxcbiAgICBzZWxlY3RHcm93RG93bjogdHJ1ZSxcbiAgICBzZWxlY3RHcm93TGVmdDogdHJ1ZSxcbn07XG5mdW5jdGlvbiByZWFsaXplS2V5YmluZChrZXliaW5kLCBkZWZhdWx0VmFsKSB7XG4gICAgaWYgKGtleWJpbmQgPT09IHRydWUpXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsO1xuICAgIGlmIChrZXliaW5kID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgcmV0dXJuIGtleWJpbmQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhbGl6ZUtleWJpbmRzKGtleWJpbmRzKSB7XG4gICAgY29uc3QgaXNPU1ggPSBicm93c2VySXNPU1gudmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aXZhdGVDZWxsOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5hY3RpdmF0ZUNlbGwsIFwiIHxFbnRlcnxzaGlmdCtFbnRlclwiKSxcbiAgICAgICAgY2xlYXI6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLmNsZWFyLCBcImFueStFc2NhcGVcIiksXG4gICAgICAgIGNsb3NlT3ZlcmxheTogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuY2xvc2VPdmVybGF5LCBcImFueStFc2NhcGVcIiksXG4gICAgICAgIGFjY2VwdE92ZXJsYXlEb3duOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5hY2NlcHRPdmVybGF5RG93biwgXCJFbnRlclwiKSxcbiAgICAgICAgYWNjZXB0T3ZlcmxheVVwOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5hY2NlcHRPdmVybGF5VXAsIFwic2hpZnQrRW50ZXJcIiksXG4gICAgICAgIGFjY2VwdE92ZXJsYXlMZWZ0OiByZWFsaXplS2V5YmluZChrZXliaW5kcy5hY2NlcHRPdmVybGF5TGVmdCwgXCJzaGlmdCtUYWJcIiksXG4gICAgICAgIGFjY2VwdE92ZXJsYXlSaWdodDogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuYWNjZXB0T3ZlcmxheVJpZ2h0LCBcIlRhYlwiKSxcbiAgICAgICAgY29weToga2V5YmluZHMuY29weSxcbiAgICAgICAgY3V0OiBrZXliaW5kcy5jdXQsXG4gICAgICAgIGRlbGV0ZTogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuZGVsZXRlLCBpc09TWCA/IFwiQmFja3NwYWNlfERlbGV0ZVwiIDogXCJEZWxldGVcIiksXG4gICAgICAgIGRvd25GaWxsOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5kb3duRmlsbCwgXCJwcmltYXJ5K182OFwiKSxcbiAgICAgICAgc2Nyb2xsVG9TZWxlY3RlZENlbGw6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLnNjcm9sbFRvU2VsZWN0ZWRDZWxsLCBcInByaW1hcnkrRW50ZXJcIiksXG4gICAgICAgIGdvRG93bkNlbGw6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLmdvRG93bkNlbGwsIFwiQXJyb3dEb3duXCIpLFxuICAgICAgICBnb0Rvd25DZWxsUmV0YWluU2VsZWN0aW9uOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5nb0Rvd25DZWxsUmV0YWluU2VsZWN0aW9uLCBcImFsdCtBcnJvd0Rvd25cIiksXG4gICAgICAgIGdvTGVmdENlbGw6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLmdvTGVmdENlbGwsIFwiQXJyb3dMZWZ0fHNoaWZ0K1RhYlwiKSxcbiAgICAgICAgZ29MZWZ0Q2VsbFJldGFpblNlbGVjdGlvbjogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuZ29MZWZ0Q2VsbFJldGFpblNlbGVjdGlvbiwgXCJhbHQrQXJyb3dMZWZ0XCIpLFxuICAgICAgICBnb1JpZ2h0Q2VsbDogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuZ29SaWdodENlbGwsIFwiQXJyb3dSaWdodHxUYWJcIiksXG4gICAgICAgIGdvUmlnaHRDZWxsUmV0YWluU2VsZWN0aW9uOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5nb1JpZ2h0Q2VsbFJldGFpblNlbGVjdGlvbiwgXCJhbHQrQXJyb3dSaWdodFwiKSxcbiAgICAgICAgZ29VcENlbGw6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLmdvVXBDZWxsLCBcIkFycm93VXBcIiksXG4gICAgICAgIGdvVXBDZWxsUmV0YWluU2VsZWN0aW9uOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5nb1VwQ2VsbFJldGFpblNlbGVjdGlvbiwgXCJhbHQrQXJyb3dVcFwiKSxcbiAgICAgICAgZ29Ub0ZpcnN0Q2VsbDogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuZ29Ub0ZpcnN0Q2VsbCwgXCJwcmltYXJ5K0hvbWVcIiksXG4gICAgICAgIGdvVG9GaXJzdENvbHVtbjogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuZ29Ub0ZpcnN0Q29sdW1uLCBcIkhvbWV8cHJpbWFyeStBcnJvd0xlZnRcIiksXG4gICAgICAgIGdvVG9GaXJzdFJvdzogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuZ29Ub0ZpcnN0Um93LCBcInByaW1hcnkrQXJyb3dVcFwiKSxcbiAgICAgICAgZ29Ub0xhc3RDZWxsOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5nb1RvTGFzdENlbGwsIFwicHJpbWFyeStFbmRcIiksXG4gICAgICAgIGdvVG9MYXN0Q29sdW1uOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5nb1RvTGFzdENvbHVtbiwgXCJFbmR8cHJpbWFyeStBcnJvd1JpZ2h0XCIpLFxuICAgICAgICBnb1RvTGFzdFJvdzogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuZ29Ub0xhc3RSb3csIFwicHJpbWFyeStBcnJvd0Rvd25cIiksXG4gICAgICAgIGdvVG9OZXh0UGFnZTogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuZ29Ub05leHRQYWdlLCBcIlBhZ2VEb3duXCIpLFxuICAgICAgICBnb1RvUHJldmlvdXNQYWdlOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5nb1RvUHJldmlvdXNQYWdlLCBcIlBhZ2VVcFwiKSxcbiAgICAgICAgcGFzdGU6IGtleWJpbmRzLnBhc3RlLFxuICAgICAgICByaWdodEZpbGw6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLnJpZ2h0RmlsbCwgXCJwcmltYXJ5K184MlwiKSxcbiAgICAgICAgc2VhcmNoOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5zZWFyY2gsIFwicHJpbWFyeStmXCIpLFxuICAgICAgICBzZWxlY3RBbGw6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLnNlbGVjdEFsbCwgXCJwcmltYXJ5K2FcIiksXG4gICAgICAgIHNlbGVjdENvbHVtbjogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuc2VsZWN0Q29sdW1uLCBcImN0cmwrIFwiKSxcbiAgICAgICAgc2VsZWN0R3Jvd0Rvd246IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLnNlbGVjdEdyb3dEb3duLCBcInNoaWZ0K0Fycm93RG93blwiKSxcbiAgICAgICAgc2VsZWN0R3Jvd0xlZnQ6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLnNlbGVjdEdyb3dMZWZ0LCBcInNoaWZ0K0Fycm93TGVmdFwiKSxcbiAgICAgICAgc2VsZWN0R3Jvd1JpZ2h0OiByZWFsaXplS2V5YmluZChrZXliaW5kcy5zZWxlY3RHcm93UmlnaHQsIFwic2hpZnQrQXJyb3dSaWdodFwiKSxcbiAgICAgICAgc2VsZWN0R3Jvd1VwOiByZWFsaXplS2V5YmluZChrZXliaW5kcy5zZWxlY3RHcm93VXAsIFwic2hpZnQrQXJyb3dVcFwiKSxcbiAgICAgICAgc2VsZWN0Um93OiByZWFsaXplS2V5YmluZChrZXliaW5kcy5zZWxlY3RSb3csIFwic2hpZnQrIFwiKSxcbiAgICAgICAgc2VsZWN0VG9GaXJzdENlbGw6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLnNlbGVjdFRvRmlyc3RDZWxsLCBcInByaW1hcnkrc2hpZnQrSG9tZVwiKSxcbiAgICAgICAgc2VsZWN0VG9GaXJzdENvbHVtbjogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuc2VsZWN0VG9GaXJzdENvbHVtbiwgXCJwcmltYXJ5K3NoaWZ0K0Fycm93TGVmdFwiKSxcbiAgICAgICAgc2VsZWN0VG9GaXJzdFJvdzogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuc2VsZWN0VG9GaXJzdFJvdywgXCJwcmltYXJ5K3NoaWZ0K0Fycm93VXBcIiksXG4gICAgICAgIHNlbGVjdFRvTGFzdENlbGw6IHJlYWxpemVLZXliaW5kKGtleWJpbmRzLnNlbGVjdFRvTGFzdENlbGwsIFwicHJpbWFyeStzaGlmdCtFbmRcIiksXG4gICAgICAgIHNlbGVjdFRvTGFzdENvbHVtbjogcmVhbGl6ZUtleWJpbmQoa2V5YmluZHMuc2VsZWN0VG9MYXN0Q29sdW1uLCBcInByaW1hcnkrc2hpZnQrQXJyb3dSaWdodFwiKSxcbiAgICAgICAgc2VsZWN0VG9MYXN0Um93OiByZWFsaXplS2V5YmluZChrZXliaW5kcy5zZWxlY3RUb0xhc3RSb3csIFwicHJpbWFyeStzaGlmdCtBcnJvd0Rvd25cIiksXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VLZXliaW5kaW5nc1dpdGhEZWZhdWx0cyhrZXliaW5kaW5nc0luKSB7XG4gICAgY29uc3Qga2V5cyA9IHVzZURlZXBNZW1vKGtleWJpbmRpbmdzSW4pO1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGtleXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiByZWFsaXplS2V5YmluZHMoa2V5YmluZGluZ0RlZmF1bHRzKTtcbiAgICAgICAgY29uc3Qgd2l0aEJhY2tDb21wYXRBcHBsaWVkID0ge1xuICAgICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICAgIGdvVG9OZXh0UGFnZToga2V5cz8uZ29Ub05leHRQYWdlID8/IGtleXM/LnBhZ2VEb3duID8/IGtleWJpbmRpbmdEZWZhdWx0cy5nb1RvTmV4dFBhZ2UsXG4gICAgICAgICAgICBnb1RvUHJldmlvdXNQYWdlOiBrZXlzPy5nb1RvUHJldmlvdXNQYWdlID8/IGtleXM/LnBhZ2VVcCA/PyBrZXliaW5kaW5nRGVmYXVsdHMuZ29Ub1ByZXZpb3VzUGFnZSxcbiAgICAgICAgICAgIGdvVG9GaXJzdENlbGw6IGtleXM/LmdvVG9GaXJzdENlbGwgPz8ga2V5cz8uZmlyc3QgPz8ga2V5YmluZGluZ0RlZmF1bHRzLmdvVG9GaXJzdENlbGwsXG4gICAgICAgICAgICBnb1RvTGFzdENlbGw6IGtleXM/LmdvVG9MYXN0Q2VsbCA/PyBrZXlzPy5sYXN0ID8/IGtleWJpbmRpbmdEZWZhdWx0cy5nb1RvTGFzdENlbGwsXG4gICAgICAgICAgICBzZWxlY3RUb0ZpcnN0Q2VsbDoga2V5cz8uc2VsZWN0VG9GaXJzdENlbGwgPz8ga2V5cz8uZmlyc3QgPz8ga2V5YmluZGluZ0RlZmF1bHRzLnNlbGVjdFRvRmlyc3RDZWxsLFxuICAgICAgICAgICAgc2VsZWN0VG9MYXN0Q2VsbDoga2V5cz8uc2VsZWN0VG9MYXN0Q2VsbCA/PyBrZXlzPy5sYXN0ID8/IGtleWJpbmRpbmdEZWZhdWx0cy5zZWxlY3RUb0xhc3RDZWxsLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVhbGl6ZUtleWJpbmRzKHtcbiAgICAgICAgICAgIC4uLmtleWJpbmRpbmdEZWZhdWx0cyxcbiAgICAgICAgICAgIC4uLndpdGhCYWNrQ29tcGF0QXBwbGllZCxcbiAgICAgICAgfSk7XG4gICAgfSwgW2tleXNdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtZWRpdG9yLWtleWJpbmRpbmdzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor-keybindings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataEditor: () => (/* binding */ DataEditor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _common_support_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../common/support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n/* harmony import */ var lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/clamp.js */ \"(ssr)/./node_modules/lodash/clamp.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/range.js */ \"(ssr)/./node_modules/lodash/range.js\");\n/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/debounce.js */ \"(ssr)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _internal_data_grid_search_data_grid_search_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../internal/data-grid-search/data-grid-search.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-search/data-grid-search.js\");\n/* harmony import */ var _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../common/browser-detect.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/browser-detect.js\");\n/* harmony import */ var _common_styles_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../common/styles.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* harmony import */ var _internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../internal/data-grid/render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _group_rename_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./group-rename.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/group-rename.js\");\n/* harmony import */ var _use_column_sizer_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./use-column-sizer.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-column-sizer.js\");\n/* harmony import */ var _common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../common/is-hotkey.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/is-hotkey.js\");\n/* harmony import */ var _internal_data_grid_use_selection_behavior_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../internal/data-grid/use-selection-behavior.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/use-selection-behavior.js\");\n/* harmony import */ var _use_cells_for_selection_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./use-cells-for-selection.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-cells-for-selection.js\");\n/* harmony import */ var _data_editor_fns_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./data-editor-fns.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor-fns.js\");\n/* harmony import */ var _internal_data_editor_container_data_grid_container_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../internal/data-editor-container/data-grid-container.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-editor-container/data-grid-container.js\");\n/* harmony import */ var _use_autoscroll_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./use-autoscroll.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-autoscroll.js\");\n/* harmony import */ var _copy_paste_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./copy-paste.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/copy-paste.js\");\n/* harmony import */ var _use_rem_adjuster_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./use-rem-adjuster.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-rem-adjuster.js\");\n/* harmony import */ var _internal_data_grid_color_parser_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../internal/data-grid/color-parser.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\");\n/* harmony import */ var _common_math_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../common/math.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js\");\n/* harmony import */ var _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../internal/data-grid/event-args.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/event-args.js\");\n/* harmony import */ var _data_editor_keybindings_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data-editor-keybindings.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor-keybindings.js\");\n/* eslint-disable sonarjs/no-duplicate-string */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst DataGridOverlayEditor = react__WEBPACK_IMPORTED_MODULE_0__.lazy(async () => await __webpack_require__.e(/*! import() */ \"vendor-chunks/@glideapps\").then(__webpack_require__.bind(__webpack_require__, /*! ../internal/data-grid-overlay-editor/data-grid-overlay-editor.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor.js\")));\n// There must be a better way\nlet idCounter = 0;\nfunction getSpanStops(cells) {\n    return lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_3__(cells)\n        .filter(c => c.span !== undefined)\n        .map(c => lodash_range_js__WEBPACK_IMPORTED_MODULE_4__((c.span?.[0] ?? 0) + 1, (c.span?.[1] ?? 0) + 1))));\n}\nfunction shiftSelection(input, offset) {\n    if (input === undefined || offset === 0 || (input.columns.length === 0 && input.current === undefined))\n        return input;\n    return {\n        current: input.current === undefined\n            ? undefined\n            : {\n                cell: [input.current.cell[0] + offset, input.current.cell[1]],\n                range: {\n                    ...input.current.range,\n                    x: input.current.range.x + offset,\n                },\n                rangeStack: input.current.rangeStack.map(r => ({\n                    ...r,\n                    x: r.x + offset,\n                })),\n            },\n        rows: input.rows,\n        columns: input.columns.offset(offset),\n    };\n}\nconst loadingCell = {\n    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Loading,\n    allowOverlay: false,\n};\nconst emptyGridSelection = {\n    columns: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.empty(),\n    rows: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.empty(),\n    current: undefined,\n};\nconst DataEditorImpl = (p, forwardedRef) => {\n    const [gridSelectionInner, setGridSelectionInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState(emptyGridSelection);\n    const [overlay, setOverlay] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const searchInputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [mouseState, setMouseState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const scrollRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const lastSent = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const safeWindow = typeof window === \"undefined\" ? null : window;\n    const { imageEditorOverride, getRowThemeOverride, markdownDivCreateNode, width, height, columns: columnsIn, rows, getCellContent, onCellClicked, onCellActivated, onFillPattern, onFinishedEditing, coercePasteValue, drawHeader: drawHeaderIn, drawCell: drawCellIn, editorBloom, onHeaderClicked, onColumnProposeMove, spanRangeBehavior = \"default\", onGroupHeaderClicked, onCellContextMenu, className, onHeaderContextMenu, getCellsForSelection: getCellsForSelectionIn, onGroupHeaderContextMenu, onGroupHeaderRenamed, onCellEdited, onCellsEdited, onSearchResultsChanged: onSearchResultsChangedIn, searchResults, onSearchValueChange, searchValue, onKeyDown: onKeyDownIn, onKeyUp: onKeyUpIn, keybindings: keybindingsIn, editOnType = true, onRowAppended, onColumnMoved, validateCell: validateCellIn, highlightRegions: highlightRegionsIn, rangeSelect = \"rect\", columnSelect = \"multi\", rowSelect = \"multi\", rangeSelectionBlending = \"exclusive\", columnSelectionBlending = \"exclusive\", rowSelectionBlending = \"exclusive\", onDelete: onDeleteIn, onDragStart, onMouseMove, onPaste, copyHeaders = false, freezeColumns = 0, cellActivationBehavior = \"second-click\", rowSelectionMode = \"auto\", onHeaderMenuClick, getGroupDetails, onSearchClose: onSearchCloseIn, onItemHovered, onSelectionCleared, showSearch: showSearchIn, onVisibleRegionChanged, gridSelection: gridSelectionOuter, onGridSelectionChange, minColumnWidth: minColumnWidthIn = 50, maxColumnWidth: maxColumnWidthIn = 500, maxColumnAutoWidth: maxColumnAutoWidthIn, provideEditor, trailingRowOptions, freezeTrailingRows = 0, allowedFillDirections = \"orthogonal\", scrollOffsetX, scrollOffsetY, verticalBorder, onDragOverCell, onDrop, onColumnResize: onColumnResizeIn, onColumnResizeEnd: onColumnResizeEndIn, onColumnResizeStart: onColumnResizeStartIn, customRenderers: additionalRenderers, fillHandle, drawFocusRing = true, experimental, fixedShadowX, fixedShadowY, headerIcons, imageWindowLoader, initialSize, isDraggable, onDragLeave, onRowMoved, overscrollX: overscrollXIn, overscrollY: overscrollYIn, preventDiagonalScrolling, rightElement, rightElementProps, trapFocus = false, smoothScrollX, smoothScrollY, scaleToRem = false, rowHeight: rowHeightIn = 34, headerHeight: headerHeightIn = 36, groupHeaderHeight: groupHeaderHeightIn = headerHeightIn, theme: themeIn, isOutsideClick, renderers, } = p;\n    const rowMarkersObj = typeof p.rowMarkers === \"string\" ? undefined : p.rowMarkers;\n    const rowMarkers = rowMarkersObj?.kind ?? p.rowMarkers ?? \"none\";\n    const rowMarkerWidthRaw = rowMarkersObj?.width ?? p.rowMarkerWidth;\n    const rowMarkerStartIndex = rowMarkersObj?.startIndex ?? p.rowMarkerStartIndex ?? 1;\n    const rowMarkerTheme = rowMarkersObj?.theme ?? p.rowMarkerTheme;\n    const rowMarkerCheckboxStyle = rowMarkersObj?.checkboxStyle ?? \"square\";\n    const minColumnWidth = Math.max(minColumnWidthIn, 20);\n    const maxColumnWidth = Math.max(maxColumnWidthIn, minColumnWidth);\n    const maxColumnAutoWidth = Math.max(maxColumnAutoWidthIn ?? maxColumnWidth, minColumnWidth);\n    const docStyle = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (typeof window === \"undefined\")\n            return { fontSize: \"16px\" };\n        return window.getComputedStyle(document.documentElement);\n    }, []);\n    const remSize = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => Number.parseFloat(docStyle.fontSize), [docStyle]);\n    const { rowHeight, headerHeight, groupHeaderHeight, theme, overscrollX, overscrollY } = (0,_use_rem_adjuster_js__WEBPACK_IMPORTED_MODULE_7__.useRemAdjuster)({\n        groupHeaderHeight: groupHeaderHeightIn,\n        headerHeight: headerHeightIn,\n        overscrollX: overscrollXIn,\n        overscrollY: overscrollYIn,\n        remSize,\n        rowHeight: rowHeightIn,\n        scaleToRem,\n        theme: themeIn,\n    });\n    const keybindings = (0,_data_editor_keybindings_js__WEBPACK_IMPORTED_MODULE_8__.useKeybindingsWithDefaults)(keybindingsIn);\n    const rowMarkerWidth = rowMarkerWidthRaw ?? (rows > 10000 ? 48 : rows > 1000 ? 44 : rows > 100 ? 36 : 32);\n    const hasRowMarkers = rowMarkers !== \"none\";\n    const rowMarkerOffset = hasRowMarkers ? 1 : 0;\n    const showTrailingBlankRow = onRowAppended !== undefined;\n    const lastRowSticky = trailingRowOptions?.sticky === true;\n    const [showSearchInner, setShowSearchInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const showSearch = showSearchIn ?? showSearchInner;\n    const onSearchClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        if (onSearchCloseIn !== undefined) {\n            onSearchCloseIn();\n        }\n        else {\n            setShowSearchInner(false);\n        }\n    }, [onSearchCloseIn]);\n    const gridSelectionOuterMangled = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return gridSelectionOuter === undefined ? undefined : shiftSelection(gridSelectionOuter, rowMarkerOffset);\n    }, [gridSelectionOuter, rowMarkerOffset]);\n    const gridSelection = gridSelectionOuterMangled ?? gridSelectionInner;\n    const abortControllerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (abortControllerRef.current === undefined)\n        abortControllerRef.current = new AbortController();\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => () => abortControllerRef?.current.abort(), []);\n    const [getCellsForSelection, getCellsForSeletionDirect] = (0,_use_cells_for_selection_js__WEBPACK_IMPORTED_MODULE_9__.useCellsForSelection)(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortControllerRef.current, rows);\n    const validateCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, newValue, prevValue) => {\n        if (validateCellIn === undefined)\n            return true;\n        const item = [cell[0] - rowMarkerOffset, cell[1]];\n        return validateCellIn?.(item, newValue, prevValue);\n    }, [rowMarkerOffset, validateCellIn]);\n    const expectedExternalGridSelection = react__WEBPACK_IMPORTED_MODULE_0__.useRef(gridSelectionOuter);\n    const setGridSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newVal, expand) => {\n        if (expand) {\n            newVal = (0,_data_editor_fns_js__WEBPACK_IMPORTED_MODULE_10__.expandSelection)(newVal, getCellsForSelection, rowMarkerOffset, spanRangeBehavior, abortControllerRef.current);\n        }\n        if (onGridSelectionChange !== undefined) {\n            expectedExternalGridSelection.current = shiftSelection(newVal, -rowMarkerOffset);\n            onGridSelectionChange(expectedExternalGridSelection.current);\n        }\n        else {\n            setGridSelectionInner(newVal);\n        }\n    }, [onGridSelectionChange, getCellsForSelection, rowMarkerOffset, spanRangeBehavior]);\n    const onColumnResize = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.whenDefined)(onColumnResizeIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {\n        onColumnResizeIn?.(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);\n    }, [onColumnResizeIn, rowMarkerOffset, columnsIn]));\n    const onColumnResizeEnd = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.whenDefined)(onColumnResizeEndIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {\n        onColumnResizeEndIn?.(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);\n    }, [onColumnResizeEndIn, rowMarkerOffset, columnsIn]));\n    const onColumnResizeStart = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.whenDefined)(onColumnResizeStartIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((_, w, ind, wg) => {\n        onColumnResizeStartIn?.(columnsIn[ind - rowMarkerOffset], w, ind - rowMarkerOffset, wg);\n    }, [onColumnResizeStartIn, rowMarkerOffset, columnsIn]));\n    const drawHeader = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.whenDefined)(drawHeaderIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, draw) => {\n        return drawHeaderIn?.({ ...args, columnIndex: args.columnIndex - rowMarkerOffset }, draw) ?? false;\n    }, [drawHeaderIn, rowMarkerOffset]));\n    const drawCell = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.whenDefined)(drawCellIn, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, draw) => {\n        return drawCellIn?.({ ...args, col: args.col - rowMarkerOffset }, draw) ?? false;\n    }, [drawCellIn, rowMarkerOffset]));\n    const onDelete = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(sel => {\n        if (onDeleteIn !== undefined) {\n            const result = onDeleteIn(shiftSelection(sel, -rowMarkerOffset));\n            if (typeof result === \"boolean\") {\n                return result;\n            }\n            return shiftSelection(result, rowMarkerOffset);\n        }\n        return true;\n    }, [onDeleteIn, rowMarkerOffset]);\n    const [setCurrent, setSelectedRows, setSelectedColumns] = (0,_internal_data_grid_use_selection_behavior_js__WEBPACK_IMPORTED_MODULE_12__.useSelectionBehavior)(gridSelection, setGridSelection, rangeSelectionBlending, columnSelectionBlending, rowSelectionBlending, rangeSelect);\n    const mergedTheme = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_13__.mergeAndRealizeTheme)((0,_common_styles_js__WEBPACK_IMPORTED_MODULE_13__.getDataEditorTheme)(), theme);\n    }, [theme]);\n    const [clientSize, setClientSize] = react__WEBPACK_IMPORTED_MODULE_0__.useState([0, 0, 0]);\n    const rendererMap = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (renderers === undefined)\n            return {};\n        const result = {};\n        for (const r of renderers) {\n            result[r.kind] = r;\n        }\n        return result;\n    }, [renderers]);\n    const getCellRenderer = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell) => {\n        if (cell.kind !== _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Custom) {\n            return rendererMap[cell.kind];\n        }\n        return additionalRenderers?.find(x => x.isMatch(cell));\n    }, [additionalRenderers, rendererMap]);\n    // eslint-disable-next-line prefer-const\n    let { sizedColumns: columns, nonGrowWidth } = (0,_use_column_sizer_js__WEBPACK_IMPORTED_MODULE_14__.useColumnSizer)(columnsIn, rows, getCellsForSeletionDirect, clientSize[0] - (rowMarkerOffset === 0 ? 0 : rowMarkerWidth) - clientSize[2], minColumnWidth, maxColumnAutoWidth, mergedTheme, getCellRenderer, abortControllerRef.current);\n    if (rowMarkers !== \"none\")\n        nonGrowWidth += rowMarkerWidth;\n    const enableGroups = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return columns.some(c => c.group !== undefined);\n    }, [columns]);\n    const totalHeaderHeight = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n    const numSelectedRows = gridSelection.rows.length;\n    const rowMarkerChecked = rowMarkers === \"none\" ? undefined : numSelectedRows === 0 ? false : numSelectedRows === rows ? true : undefined;\n    const mangledCols = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (rowMarkers === \"none\")\n            return columns;\n        return [\n            {\n                title: \"\",\n                width: rowMarkerWidth,\n                icon: undefined,\n                hasMenu: false,\n                style: \"normal\",\n                themeOverride: rowMarkerTheme,\n                rowMarker: rowMarkerCheckboxStyle,\n                rowMarkerChecked,\n            },\n            ...columns,\n        ];\n    }, [rowMarkers, columns, rowMarkerWidth, rowMarkerTheme, rowMarkerCheckboxStyle, rowMarkerChecked]);\n    const [visibleRegionY, visibleRegionTy] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return [\n            scrollOffsetY !== undefined && typeof rowHeight === \"number\" ? Math.floor(scrollOffsetY / rowHeight) : 0,\n            scrollOffsetY !== undefined && typeof rowHeight === \"number\" ? -(scrollOffsetY % rowHeight) : 0,\n        ];\n    }, [scrollOffsetY, rowHeight]);\n    const visibleRegionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        height: 1,\n        width: 1,\n        x: 0,\n        y: 0,\n    });\n    const visibleRegionInput = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n        x: visibleRegionRef.current.x,\n        y: visibleRegionY,\n        width: visibleRegionRef.current.width ?? 1,\n        height: visibleRegionRef.current.height ?? 1,\n        // tx: 'TODO',\n        ty: visibleRegionTy,\n    }), [visibleRegionTy, visibleRegionY]);\n    const hasJustScrolled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const [visibleRegion, setVisibleRegion, empty] = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.useStateWithReactiveInput)(visibleRegionInput);\n    visibleRegionRef.current = visibleRegion;\n    const vScrollReady = (visibleRegion.height ?? 1) > 1;\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (scrollOffsetY !== undefined && scrollRef.current !== null && vScrollReady) {\n            if (scrollRef.current.scrollTop === scrollOffsetY)\n                return;\n            scrollRef.current.scrollTop = scrollOffsetY;\n            if (scrollRef.current.scrollTop !== scrollOffsetY) {\n                empty();\n            }\n            hasJustScrolled.current = true;\n        }\n    }, [scrollOffsetY, vScrollReady, empty]);\n    const hScrollReady = (visibleRegion.width ?? 1) > 1;\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (scrollOffsetX !== undefined && scrollRef.current !== null && hScrollReady) {\n            if (scrollRef.current.scrollLeft === scrollOffsetX)\n                return;\n            scrollRef.current.scrollLeft = scrollOffsetX;\n            if (scrollRef.current.scrollLeft !== scrollOffsetX) {\n                empty();\n            }\n            hasJustScrolled.current = true;\n        }\n    }, [scrollOffsetX, hScrollReady, empty]);\n    const cellXOffset = visibleRegion.x + rowMarkerOffset;\n    const cellYOffset = visibleRegion.y;\n    const gridRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const focus = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((immediate) => {\n        if (immediate === true) {\n            gridRef.current?.focus();\n        }\n        else {\n            window.requestAnimationFrame(() => {\n                gridRef.current?.focus();\n            });\n        }\n    }, []);\n    const mangledRows = showTrailingBlankRow ? rows + 1 : rows;\n    const mangledOnCellsEdited = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((items) => {\n        const mangledItems = rowMarkerOffset === 0\n            ? items\n            : items.map(x => ({\n                ...x,\n                location: [x.location[0] - rowMarkerOffset, x.location[1]],\n            }));\n        const r = onCellsEdited?.(mangledItems);\n        if (r !== true) {\n            for (const i of mangledItems)\n                onCellEdited?.(i.location, i.value);\n        }\n        return r;\n    }, [onCellEdited, onCellsEdited, rowMarkerOffset]);\n    const [fillHighlightRegion, setFillHighlightRegion] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    // this will generally be undefined triggering the memo less often\n    const highlightRange = gridSelection.current !== undefined &&\n        gridSelection.current.range.width * gridSelection.current.range.height > 1\n        ? gridSelection.current.range\n        : undefined;\n    const highlightFocus = drawFocusRing ? gridSelection.current?.cell : undefined;\n    const highlightFocusCol = highlightFocus?.[0];\n    const highlightFocusRow = highlightFocus?.[1];\n    const highlightRegions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if ((highlightRegionsIn === undefined || highlightRegionsIn.length === 0) &&\n            (highlightRange ?? highlightFocusCol ?? highlightFocusRow ?? fillHighlightRegion) === undefined)\n            return undefined;\n        const regions = [];\n        if (highlightRegionsIn !== undefined) {\n            for (const r of highlightRegionsIn) {\n                const maxWidth = mangledCols.length - r.range.x - rowMarkerOffset;\n                if (maxWidth > 0) {\n                    regions.push({\n                        color: r.color,\n                        range: {\n                            ...r.range,\n                            x: r.range.x + rowMarkerOffset,\n                            width: Math.min(maxWidth, r.range.width),\n                        },\n                        style: r.style,\n                    });\n                }\n            }\n        }\n        if (fillHighlightRegion !== undefined) {\n            regions.push({\n                color: (0,_internal_data_grid_color_parser_js__WEBPACK_IMPORTED_MODULE_15__.withAlpha)(mergedTheme.accentColor, 0),\n                range: fillHighlightRegion,\n                style: \"dashed\",\n            });\n        }\n        if (highlightRange !== undefined) {\n            regions.push({\n                color: (0,_internal_data_grid_color_parser_js__WEBPACK_IMPORTED_MODULE_15__.withAlpha)(mergedTheme.accentColor, 0.5),\n                range: highlightRange,\n                style: \"solid-outline\",\n            });\n        }\n        if (highlightFocusCol !== undefined && highlightFocusRow !== undefined) {\n            regions.push({\n                color: mergedTheme.accentColor,\n                range: {\n                    x: highlightFocusCol,\n                    y: highlightFocusRow,\n                    width: 1,\n                    height: 1,\n                },\n                style: \"solid-outline\",\n            });\n        }\n        return regions.length > 0 ? regions : undefined;\n    }, [\n        fillHighlightRegion,\n        highlightRange,\n        highlightFocusCol,\n        highlightFocusRow,\n        highlightRegionsIn,\n        mangledCols.length,\n        mergedTheme.accentColor,\n        rowMarkerOffset,\n    ]);\n    const mangledColsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(mangledCols);\n    mangledColsRef.current = mangledCols;\n    const getMangledCellContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(([col, row], forceStrict = false) => {\n        const isTrailing = showTrailingBlankRow && row === mangledRows - 1;\n        const isRowMarkerCol = col === 0 && hasRowMarkers;\n        if (isRowMarkerCol) {\n            if (isTrailing) {\n                return loadingCell;\n            }\n            return {\n                kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.InnerGridCellKind.Marker,\n                allowOverlay: false,\n                checkboxStyle: rowMarkerCheckboxStyle,\n                checked: gridSelection?.rows.hasIndex(row) === true,\n                markerKind: rowMarkers === \"clickable-number\" ? \"number\" : rowMarkers,\n                row: rowMarkerStartIndex + row,\n                drawHandle: onRowMoved !== undefined,\n                cursor: rowMarkers === \"clickable-number\" ? \"pointer\" : undefined,\n            };\n        }\n        else if (isTrailing) {\n            //If the grid is empty, we will return text\n            const isFirst = col === rowMarkerOffset;\n            const maybeFirstColumnHint = isFirst ? trailingRowOptions?.hint ?? \"\" : \"\";\n            const c = mangledColsRef.current[col];\n            if (c?.trailingRowOptions?.disabled === true) {\n                return loadingCell;\n            }\n            else {\n                const hint = c?.trailingRowOptions?.hint ?? maybeFirstColumnHint;\n                const icon = c?.trailingRowOptions?.addIcon ?? trailingRowOptions?.addIcon;\n                return {\n                    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.InnerGridCellKind.NewRow,\n                    hint,\n                    allowOverlay: false,\n                    icon,\n                };\n            }\n        }\n        else {\n            const outerCol = col - rowMarkerOffset;\n            if (forceStrict || experimental?.strict === true) {\n                const vr = visibleRegionRef.current;\n                const isOutsideMainArea = vr.x > outerCol ||\n                    outerCol > vr.x + vr.width ||\n                    vr.y > row ||\n                    row > vr.y + vr.height ||\n                    row >= rowsRef.current;\n                const isSelected = outerCol === vr.extras?.selected?.[0] && row === vr.extras?.selected[1];\n                let isInFreezeArea = false;\n                if (vr.extras?.freezeRegions !== undefined) {\n                    for (const fr of vr.extras.freezeRegions) {\n                        if ((0,_common_math_js__WEBPACK_IMPORTED_MODULE_16__.pointInRect)(fr, outerCol, row)) {\n                            isInFreezeArea = true;\n                            break;\n                        }\n                    }\n                }\n                if (isOutsideMainArea && !isSelected && !isInFreezeArea) {\n                    return loadingCell;\n                }\n            }\n            let result = getCellContent([outerCol, row]);\n            if (rowMarkerOffset !== 0 && result.span !== undefined) {\n                result = {\n                    ...result,\n                    span: [result.span[0] + rowMarkerOffset, result.span[1] + rowMarkerOffset],\n                };\n            }\n            return result;\n        }\n    }, [\n        showTrailingBlankRow,\n        mangledRows,\n        hasRowMarkers,\n        rowMarkerCheckboxStyle,\n        gridSelection?.rows,\n        rowMarkers,\n        rowMarkerStartIndex,\n        onRowMoved,\n        rowMarkerOffset,\n        trailingRowOptions?.hint,\n        trailingRowOptions?.addIcon,\n        experimental?.strict,\n        getCellContent,\n    ]);\n    const mangledGetGroupDetails = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(group => {\n        let result = getGroupDetails?.(group) ?? { name: group };\n        if (onGroupHeaderRenamed !== undefined && group !== \"\") {\n            result = {\n                // FIXME: Mutate\n                icon: result.icon,\n                name: result.name,\n                overrideTheme: result.overrideTheme,\n                actions: [\n                    ...(result.actions ?? []),\n                    {\n                        title: \"Rename\",\n                        icon: \"renameIcon\",\n                        onClick: e => setRenameGroup({\n                            group: result.name,\n                            bounds: e.bounds,\n                        }),\n                    },\n                ],\n            };\n        }\n        return result;\n    }, [getGroupDetails, onGroupHeaderRenamed]);\n    const setOverlaySimple = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((val) => {\n        const [col, row] = val.cell;\n        const column = mangledCols[col];\n        const groupTheme = column?.group !== undefined ? mangledGetGroupDetails(column.group)?.overrideTheme : undefined;\n        const colTheme = column?.themeOverride;\n        const rowTheme = getRowThemeOverride?.(row);\n        setOverlay({\n            ...val,\n            theme: (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_13__.mergeAndRealizeTheme)(mergedTheme, groupTheme, colTheme, rowTheme, val.content.themeOverride),\n        });\n    }, [getRowThemeOverride, mangledCols, mangledGetGroupDetails, mergedTheme]);\n    const reselect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((bounds, fromKeyboard, initialValue) => {\n        if (gridSelection.current === undefined)\n            return;\n        const [col, row] = gridSelection.current.cell;\n        const c = getMangledCellContent([col, row]);\n        if (c.kind !== _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Boolean && c.allowOverlay) {\n            let content = c;\n            if (initialValue !== undefined) {\n                switch (content.kind) {\n                    case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Number: {\n                        const d = (0,_common_support_js__WEBPACK_IMPORTED_MODULE_17__.maybe)(() => (initialValue === \"-\" ? -0 : Number.parseFloat(initialValue)), 0);\n                        content = {\n                            ...content,\n                            data: Number.isNaN(d) ? 0 : d,\n                        };\n                        break;\n                    }\n                    case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Text:\n                    case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Markdown:\n                    case _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Uri:\n                        content = {\n                            ...content,\n                            data: initialValue,\n                        };\n                        break;\n                }\n            }\n            setOverlaySimple({\n                target: bounds,\n                content,\n                initialValue,\n                cell: [col, row],\n                highlight: initialValue === undefined,\n                forceEditMode: initialValue !== undefined,\n            });\n        }\n        else if (c.kind === _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Boolean && fromKeyboard && c.readonly !== true) {\n            mangledOnCellsEdited([\n                {\n                    location: gridSelection.current.cell,\n                    value: {\n                        ...c,\n                        data: (0,_data_editor_fns_js__WEBPACK_IMPORTED_MODULE_10__.toggleBoolean)(c.data),\n                    },\n                },\n            ]);\n            gridRef.current?.damage([{ cell: gridSelection.current.cell }]);\n        }\n    }, [getMangledCellContent, gridSelection, mangledOnCellsEdited, setOverlaySimple]);\n    const focusOnRowFromTrailingBlankRow = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, row) => {\n        const bounds = gridRef.current?.getBounds(col, row);\n        if (bounds === undefined || scrollRef.current === null) {\n            return;\n        }\n        const content = getMangledCellContent([col, row]);\n        if (!content.allowOverlay) {\n            return;\n        }\n        setOverlaySimple({\n            target: bounds,\n            content,\n            initialValue: undefined,\n            highlight: true,\n            cell: [col, row],\n            forceEditMode: true,\n        });\n    }, [getMangledCellContent, setOverlaySimple]);\n    const scrollTo = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, row, dir = \"both\", paddingX = 0, paddingY = 0, options = undefined) => {\n        if (scrollRef.current !== null) {\n            const grid = gridRef.current;\n            const canvas = canvasRef.current;\n            const trueCol = typeof col !== \"number\" ? (col.unit === \"cell\" ? col.amount : undefined) : col;\n            const trueRow = typeof row !== \"number\" ? (row.unit === \"cell\" ? row.amount : undefined) : row;\n            const desiredX = typeof col !== \"number\" && col.unit === \"px\" ? col.amount : undefined;\n            const desiredY = typeof row !== \"number\" && row.unit === \"px\" ? row.amount : undefined;\n            if (grid !== null && canvas !== null) {\n                let targetRect = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0,\n                };\n                let scrollX = 0;\n                let scrollY = 0;\n                if (trueCol !== undefined || trueRow !== undefined) {\n                    targetRect = grid.getBounds((trueCol ?? 0) + rowMarkerOffset, trueRow ?? 0) ?? targetRect;\n                    if (targetRect.width === 0 || targetRect.height === 0)\n                        return;\n                }\n                const scrollBounds = canvas.getBoundingClientRect();\n                const scale = scrollBounds.width / canvas.offsetWidth;\n                if (desiredX !== undefined) {\n                    targetRect = {\n                        ...targetRect,\n                        x: desiredX - scrollBounds.left - scrollRef.current.scrollLeft,\n                        width: 1,\n                    };\n                }\n                if (desiredY !== undefined) {\n                    targetRect = {\n                        ...targetRect,\n                        y: desiredY + scrollBounds.top - scrollRef.current.scrollTop,\n                        height: 1,\n                    };\n                }\n                if (targetRect !== undefined) {\n                    const bounds = {\n                        x: targetRect.x - paddingX,\n                        y: targetRect.y - paddingY,\n                        width: targetRect.width + 2 * paddingX,\n                        height: targetRect.height + 2 * paddingY,\n                    };\n                    let frozenWidth = 0;\n                    for (let i = 0; i < freezeColumns; i++) {\n                        frozenWidth += columns[i].width;\n                    }\n                    let trailingRowHeight = 0;\n                    const freezeTrailingRowsEffective = freezeTrailingRows + (lastRowSticky ? 1 : 0);\n                    if (freezeTrailingRowsEffective > 0) {\n                        trailingRowHeight = (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_18__.getFreezeTrailingHeight)(mangledRows, freezeTrailingRowsEffective, rowHeight);\n                    }\n                    // scrollBounds is already scaled\n                    let sLeft = frozenWidth * scale + scrollBounds.left + rowMarkerOffset * rowMarkerWidth * scale;\n                    let sRight = scrollBounds.right;\n                    let sTop = scrollBounds.top + totalHeaderHeight * scale;\n                    let sBottom = scrollBounds.bottom - trailingRowHeight * scale;\n                    const minx = targetRect.width + paddingX * 2;\n                    switch (options?.hAlign) {\n                        case \"start\":\n                            sRight = sLeft + minx;\n                            break;\n                        case \"end\":\n                            sLeft = sRight - minx;\n                            break;\n                        case \"center\":\n                            sLeft = Math.floor((sLeft + sRight) / 2) - minx / 2;\n                            sRight = sLeft + minx;\n                            break;\n                    }\n                    const miny = targetRect.height + paddingY * 2;\n                    switch (options?.vAlign) {\n                        case \"start\":\n                            sBottom = sTop + miny;\n                            break;\n                        case \"end\":\n                            sTop = sBottom - miny;\n                            break;\n                        case \"center\":\n                            sTop = Math.floor((sTop + sBottom) / 2) - miny / 2;\n                            sBottom = sTop + miny;\n                            break;\n                    }\n                    if (sLeft > bounds.x) {\n                        scrollX = bounds.x - sLeft;\n                    }\n                    else if (sRight < bounds.x + bounds.width) {\n                        scrollX = bounds.x + bounds.width - sRight;\n                    }\n                    if (sTop > bounds.y) {\n                        scrollY = bounds.y - sTop;\n                    }\n                    else if (sBottom < bounds.y + bounds.height) {\n                        scrollY = bounds.y + bounds.height - sBottom;\n                    }\n                    if (dir === \"vertical\" || (typeof col === \"number\" && col < freezeColumns)) {\n                        scrollX = 0;\n                    }\n                    else if (dir === \"horizontal\" ||\n                        (typeof row === \"number\" && row >= mangledRows - freezeTrailingRowsEffective)) {\n                        scrollY = 0;\n                    }\n                    if (scrollX !== 0 || scrollY !== 0) {\n                        // Remove scaling as scrollTo method is unaffected by transform scale.\n                        if (scale !== 1) {\n                            scrollX /= scale;\n                            scrollY /= scale;\n                        }\n                        scrollRef.current.scrollTo(scrollX + scrollRef.current.scrollLeft, scrollY + scrollRef.current.scrollTop);\n                    }\n                }\n            }\n        }\n    }, [\n        rowMarkerOffset,\n        freezeTrailingRows,\n        rowMarkerWidth,\n        totalHeaderHeight,\n        freezeColumns,\n        columns,\n        mangledRows,\n        lastRowSticky,\n        rowHeight,\n    ]);\n    const focusCallback = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusOnRowFromTrailingBlankRow);\n    const getCellContentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(getCellContent);\n    const rowsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(rows);\n    focusCallback.current = focusOnRowFromTrailingBlankRow;\n    getCellContentRef.current = getCellContent;\n    rowsRef.current = rows;\n    const appendRow = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (col, openOverlay = true) => {\n        const c = mangledCols[col];\n        if (c?.trailingRowOptions?.disabled === true) {\n            return;\n        }\n        const appendResult = onRowAppended?.();\n        let r = undefined;\n        let bottom = true;\n        if (appendResult !== undefined) {\n            r = await appendResult;\n            if (r === \"top\")\n                bottom = false;\n            if (typeof r === \"number\")\n                bottom = false;\n        }\n        let backoff = 0;\n        const doFocus = () => {\n            if (rowsRef.current <= rows) {\n                if (backoff < 500) {\n                    window.setTimeout(doFocus, backoff);\n                }\n                backoff = 50 + backoff * 2;\n                return;\n            }\n            const row = typeof r === \"number\" ? r : bottom ? rows : 0;\n            scrollToRef.current(col - rowMarkerOffset, row);\n            setCurrent({\n                cell: [col, row],\n                range: {\n                    x: col,\n                    y: row,\n                    width: 1,\n                    height: 1,\n                },\n            }, false, false, \"edit\");\n            const cell = getCellContentRef.current([col - rowMarkerOffset, row]);\n            if (cell.allowOverlay && (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isReadWriteCell)(cell) && cell.readonly !== true && openOverlay) {\n                // wait for scroll to have a chance to process\n                window.setTimeout(() => {\n                    focusCallback.current(col, row);\n                }, 0);\n            }\n        };\n        // Queue up to allow the consumer to react to the event and let us check if they did\n        doFocus();\n    }, [mangledCols, onRowAppended, rowMarkerOffset, rows, setCurrent]);\n    const getCustomNewRowTargetColumn = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col) => {\n        const customTargetColumn = columns[col]?.trailingRowOptions?.targetColumn ?? trailingRowOptions?.targetColumn;\n        if (typeof customTargetColumn === \"number\") {\n            const customTargetOffset = hasRowMarkers ? 1 : 0;\n            return customTargetColumn + customTargetOffset;\n        }\n        if (typeof customTargetColumn === \"object\") {\n            const maybeIndex = columnsIn.indexOf(customTargetColumn);\n            if (maybeIndex >= 0) {\n                const customTargetOffset = hasRowMarkers ? 1 : 0;\n                return maybeIndex + customTargetOffset;\n            }\n        }\n        return undefined;\n    }, [columns, columnsIn, hasRowMarkers, trailingRowOptions?.targetColumn]);\n    const lastSelectedRowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const lastSelectedColRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const themeForCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell, pos) => {\n        const [col, row] = pos;\n        return (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_13__.mergeAndRealizeTheme)(mergedTheme, mangledCols[col]?.themeOverride, getRowThemeOverride?.(row), cell.themeOverride);\n    }, [getRowThemeOverride, mangledCols, mergedTheme]);\n    const handleSelect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args) => {\n        const isMultiKey = _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_19__.browserIsOSX.value ? args.metaKey : args.ctrlKey;\n        const isMultiRow = isMultiKey && rowSelect === \"multi\";\n        const isMultiCol = isMultiKey && columnSelect === \"multi\";\n        const [col, row] = args.location;\n        const selectedColumns = gridSelection.columns;\n        const selectedRows = gridSelection.rows;\n        const [cellCol, cellRow] = gridSelection.current?.cell ?? [];\n        // eslint-disable-next-line unicorn/prefer-switch\n        if (args.kind === \"cell\") {\n            lastSelectedColRef.current = undefined;\n            lastMouseSelectLocation.current = [col, row];\n            if (col === 0 && hasRowMarkers) {\n                if ((showTrailingBlankRow === true && row === rows) ||\n                    rowMarkers === \"number\" ||\n                    rowSelect === \"none\")\n                    return;\n                const markerCell = getMangledCellContent(args.location);\n                if (markerCell.kind !== _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.InnerGridCellKind.Marker) {\n                    return;\n                }\n                if (onRowMoved !== undefined) {\n                    const renderer = getCellRenderer(markerCell);\n                    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_17__.assert)(renderer?.kind === _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.InnerGridCellKind.Marker);\n                    const postClick = renderer?.onClick?.({\n                        ...args,\n                        cell: markerCell,\n                        posX: args.localEventX,\n                        posY: args.localEventY,\n                        bounds: args.bounds,\n                        theme: themeForCell(markerCell, args.location),\n                        preventDefault: () => undefined,\n                    });\n                    if (postClick === undefined || postClick.checked === markerCell.checked)\n                        return;\n                }\n                setOverlay(undefined);\n                focus();\n                const isSelected = selectedRows.hasIndex(row);\n                const lastHighlighted = lastSelectedRowRef.current;\n                if (rowSelect === \"multi\" &&\n                    (args.shiftKey || args.isLongTouch === true) &&\n                    lastHighlighted !== undefined &&\n                    selectedRows.hasIndex(lastHighlighted)) {\n                    const newSlice = [Math.min(lastHighlighted, row), Math.max(lastHighlighted, row) + 1];\n                    if (isMultiRow || rowSelectionMode === \"multi\") {\n                        setSelectedRows(undefined, newSlice, true);\n                    }\n                    else {\n                        setSelectedRows(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection(newSlice), undefined, isMultiRow);\n                    }\n                }\n                else if (isMultiRow || args.isTouch || rowSelectionMode === \"multi\") {\n                    if (isSelected) {\n                        setSelectedRows(selectedRows.remove(row), undefined, true);\n                    }\n                    else {\n                        setSelectedRows(undefined, row, true);\n                        lastSelectedRowRef.current = row;\n                    }\n                }\n                else if (isSelected && selectedRows.length === 1) {\n                    setSelectedRows(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.empty(), undefined, isMultiKey);\n                }\n                else {\n                    setSelectedRows(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection(row), undefined, isMultiKey);\n                    lastSelectedRowRef.current = row;\n                }\n            }\n            else if (col >= rowMarkerOffset && showTrailingBlankRow && row === rows) {\n                const customTargetColumn = getCustomNewRowTargetColumn(col);\n                void appendRow(customTargetColumn ?? col);\n            }\n            else {\n                if (cellCol !== col || cellRow !== row) {\n                    const cell = getMangledCellContent(args.location);\n                    const renderer = getCellRenderer(cell);\n                    if (renderer?.onSelect !== undefined) {\n                        let prevented = false;\n                        renderer.onSelect({\n                            ...args,\n                            cell,\n                            posX: args.localEventX,\n                            posY: args.localEventY,\n                            bounds: args.bounds,\n                            preventDefault: () => (prevented = true),\n                            theme: themeForCell(cell, args.location),\n                        });\n                        if (prevented) {\n                            return;\n                        }\n                    }\n                    const isLastStickyRow = lastRowSticky && row === rows;\n                    const startedFromLastSticky = lastRowSticky && gridSelection !== undefined && gridSelection.current?.cell[1] === rows;\n                    if ((args.shiftKey || args.isLongTouch === true) &&\n                        cellCol !== undefined &&\n                        cellRow !== undefined &&\n                        gridSelection.current !== undefined &&\n                        !startedFromLastSticky) {\n                        if (isLastStickyRow) {\n                            // If we're making a selection and shift click in to the last sticky row,\n                            // just drop the event. Don't kill the selection.\n                            return;\n                        }\n                        const left = Math.min(col, cellCol);\n                        const right = Math.max(col, cellCol);\n                        const top = Math.min(row, cellRow);\n                        const bottom = Math.max(row, cellRow);\n                        setCurrent({\n                            ...gridSelection.current,\n                            range: {\n                                x: left,\n                                y: top,\n                                width: right - left + 1,\n                                height: bottom - top + 1,\n                            },\n                        }, true, isMultiKey, \"click\");\n                        lastSelectedRowRef.current = undefined;\n                        focus();\n                    }\n                    else {\n                        setCurrent({\n                            cell: [col, row],\n                            range: { x: col, y: row, width: 1, height: 1 },\n                        }, true, isMultiKey, \"click\");\n                        lastSelectedRowRef.current = undefined;\n                        setOverlay(undefined);\n                        focus();\n                    }\n                }\n            }\n        }\n        else if (args.kind === \"header\") {\n            lastMouseSelectLocation.current = [col, row];\n            setOverlay(undefined);\n            if (hasRowMarkers && col === 0) {\n                lastSelectedRowRef.current = undefined;\n                lastSelectedColRef.current = undefined;\n                if (rowSelect === \"multi\") {\n                    if (selectedRows.length !== rows) {\n                        setSelectedRows(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection([0, rows]), undefined, isMultiKey);\n                    }\n                    else {\n                        setSelectedRows(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.empty(), undefined, isMultiKey);\n                    }\n                    focus();\n                }\n            }\n            else {\n                const lastCol = lastSelectedColRef.current;\n                if (columnSelect === \"multi\" &&\n                    (args.shiftKey || args.isLongTouch === true) &&\n                    lastCol !== undefined &&\n                    selectedColumns.hasIndex(lastCol)) {\n                    const newSlice = [Math.min(lastCol, col), Math.max(lastCol, col) + 1];\n                    if (isMultiCol) {\n                        setSelectedColumns(undefined, newSlice, isMultiKey);\n                    }\n                    else {\n                        setSelectedColumns(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection(newSlice), undefined, isMultiKey);\n                    }\n                }\n                else if (isMultiCol) {\n                    if (selectedColumns.hasIndex(col)) {\n                        setSelectedColumns(selectedColumns.remove(col), undefined, isMultiKey);\n                    }\n                    else {\n                        setSelectedColumns(undefined, col, isMultiKey);\n                    }\n                    lastSelectedColRef.current = col;\n                }\n                else if (columnSelect !== \"none\") {\n                    setSelectedColumns(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection(col), undefined, isMultiKey);\n                    lastSelectedColRef.current = col;\n                }\n                lastSelectedRowRef.current = undefined;\n                focus();\n            }\n        }\n        else if (args.kind === _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.groupHeaderKind) {\n            lastMouseSelectLocation.current = [col, row];\n        }\n        else if (args.kind === _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.outOfBoundsKind && !args.isMaybeScrollbar) {\n            setGridSelection(emptyGridSelection, false);\n            setOverlay(undefined);\n            focus();\n            onSelectionCleared?.();\n            lastSelectedRowRef.current = undefined;\n            lastSelectedColRef.current = undefined;\n        }\n    }, [\n        appendRow,\n        columnSelect,\n        focus,\n        getCellRenderer,\n        getCustomNewRowTargetColumn,\n        getMangledCellContent,\n        gridSelection,\n        hasRowMarkers,\n        lastRowSticky,\n        onSelectionCleared,\n        onRowMoved,\n        rowMarkerOffset,\n        rowMarkers,\n        rowSelect,\n        rowSelectionMode,\n        rows,\n        setCurrent,\n        setGridSelection,\n        setSelectedColumns,\n        setSelectedRows,\n        showTrailingBlankRow,\n        themeForCell,\n    ]);\n    const isActivelyDraggingHeader = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const lastMouseSelectLocation = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const touchDownArgs = react__WEBPACK_IMPORTED_MODULE_0__.useRef(visibleRegion);\n    const mouseDownData = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const onMouseDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args) => {\n        isPrevented.current = false;\n        touchDownArgs.current = visibleRegionRef.current;\n        if (args.button !== 0 && args.button !== 1) {\n            mouseDownData.current = undefined;\n            return;\n        }\n        const time = performance.now();\n        mouseDownData.current = {\n            button: args.button,\n            time,\n            location: args.location,\n        };\n        if (args?.kind === \"header\") {\n            isActivelyDraggingHeader.current = true;\n        }\n        const fh = args.kind === \"cell\" && args.isFillHandle;\n        if (!fh && args.kind !== \"cell\" && args.isEdge)\n            return;\n        setMouseState({\n            previousSelection: gridSelection,\n            fillHandle: fh,\n        });\n        lastMouseSelectLocation.current = undefined;\n        if (!args.isTouch && args.button === 0 && !fh) {\n            handleSelect(args);\n        }\n        else if (!args.isTouch && args.button === 1) {\n            lastMouseSelectLocation.current = args.location;\n        }\n    }, [gridSelection, handleSelect]);\n    const [renameGroup, setRenameGroup] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const handleGroupHeaderSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args) => {\n        if (args.kind !== _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.groupHeaderKind || columnSelect !== \"multi\") {\n            return;\n        }\n        const isMultiKey = _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_19__.browserIsOSX.value ? args.metaKey : args.ctrlKey;\n        const [col] = args.location;\n        const selectedColumns = gridSelection.columns;\n        if (col < rowMarkerOffset)\n            return;\n        const needle = mangledCols[col];\n        let start = col;\n        let end = col;\n        for (let i = col - 1; i >= rowMarkerOffset; i--) {\n            if (!(0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_18__.isGroupEqual)(needle.group, mangledCols[i].group))\n                break;\n            start--;\n        }\n        for (let i = col + 1; i < mangledCols.length; i++) {\n            if (!(0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_18__.isGroupEqual)(needle.group, mangledCols[i].group))\n                break;\n            end++;\n        }\n        focus();\n        if (isMultiKey) {\n            if (selectedColumns.hasAll([start, end + 1])) {\n                let newVal = selectedColumns;\n                for (let index = start; index <= end; index++) {\n                    newVal = newVal.remove(index);\n                }\n                setSelectedColumns(newVal, undefined, isMultiKey);\n            }\n            else {\n                setSelectedColumns(undefined, [start, end + 1], isMultiKey);\n            }\n        }\n        else {\n            setSelectedColumns(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection([start, end + 1]), undefined, isMultiKey);\n        }\n    }, [columnSelect, focus, gridSelection.columns, mangledCols, rowMarkerOffset, setSelectedColumns]);\n    const isPrevented = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const normalSizeColumn = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (col) => {\n        if (getCellsForSelection !== undefined && onColumnResize !== undefined) {\n            const start = visibleRegionRef.current.y;\n            const end = visibleRegionRef.current.height;\n            let cells = getCellsForSelection({\n                x: col,\n                y: start,\n                width: 1,\n                height: Math.min(end, rows - start),\n            }, abortControllerRef.current.signal);\n            if (typeof cells !== \"object\") {\n                cells = await cells();\n            }\n            const inputCol = columns[col - rowMarkerOffset];\n            const offscreen = document.createElement(\"canvas\");\n            const ctx = offscreen.getContext(\"2d\", { alpha: false });\n            if (ctx !== null) {\n                ctx.font = mergedTheme.baseFontFull;\n                const newCol = (0,_use_column_sizer_js__WEBPACK_IMPORTED_MODULE_14__.measureColumn)(ctx, mergedTheme, inputCol, 0, cells, minColumnWidth, maxColumnWidth, false, getCellRenderer);\n                onColumnResize?.(inputCol, newCol.width, col, newCol.width);\n            }\n        }\n    }, [\n        columns,\n        getCellsForSelection,\n        maxColumnWidth,\n        mergedTheme,\n        minColumnWidth,\n        onColumnResize,\n        rowMarkerOffset,\n        rows,\n        getCellRenderer,\n    ]);\n    const [scrollDir, setScrollDir] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const fillPattern = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (previousSelection, currentSelection) => {\n        const patternRange = previousSelection.current?.range;\n        if (patternRange === undefined ||\n            getCellsForSelection === undefined ||\n            currentSelection.current === undefined) {\n            return;\n        }\n        const currentRange = currentSelection.current.range;\n        if (onFillPattern !== undefined) {\n            let canceled = false;\n            onFillPattern({\n                fillDestination: { ...currentRange, x: currentRange.x - rowMarkerOffset },\n                patternSource: { ...patternRange, x: patternRange.x - rowMarkerOffset },\n                preventDefault: () => (canceled = true),\n            });\n            if (canceled)\n                return;\n        }\n        let cells = getCellsForSelection(patternRange, abortControllerRef.current.signal);\n        if (typeof cells !== \"object\")\n            cells = await cells();\n        const pattern = cells;\n        // loop through all cells in currentSelection.current.range\n        const editItemList = [];\n        for (let x = 0; x < currentRange.width; x++) {\n            for (let y = 0; y < currentRange.height; y++) {\n                const cell = [currentRange.x + x, currentRange.y + y];\n                if ((0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_18__.itemIsInRect)(cell, patternRange))\n                    continue;\n                const patternCell = pattern[y % patternRange.height][x % patternRange.width];\n                if ((0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isInnerOnlyCell)(patternCell) || !(0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isReadWriteCell)(patternCell))\n                    continue;\n                editItemList.push({\n                    location: cell,\n                    value: { ...patternCell },\n                });\n            }\n        }\n        mangledOnCellsEdited(editItemList);\n        gridRef.current?.damage(editItemList.map(c => ({\n            cell: c.location,\n        })));\n    }, [getCellsForSelection, mangledOnCellsEdited, onFillPattern, rowMarkerOffset]);\n    const fillRight = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        if (gridSelection.current === undefined || gridSelection.current.range.width <= 1)\n            return;\n        const firstColSelection = {\n            ...gridSelection,\n            current: {\n                ...gridSelection.current,\n                range: {\n                    ...gridSelection.current.range,\n                    width: 1,\n                },\n            },\n        };\n        void fillPattern(firstColSelection, gridSelection);\n    }, [fillPattern, gridSelection]);\n    const fillDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        if (gridSelection.current === undefined || gridSelection.current.range.height <= 1)\n            return;\n        const firstRowSelection = {\n            ...gridSelection,\n            current: {\n                ...gridSelection.current,\n                range: {\n                    ...gridSelection.current.range,\n                    height: 1,\n                },\n            },\n        };\n        void fillPattern(firstRowSelection, gridSelection);\n    }, [fillPattern, gridSelection]);\n    const onMouseUp = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, isOutside) => {\n        const mouse = mouseState;\n        setMouseState(undefined);\n        setFillHighlightRegion(undefined);\n        setScrollDir(undefined);\n        isActivelyDraggingHeader.current = false;\n        if (isOutside)\n            return;\n        if (mouse?.fillHandle === true &&\n            gridSelection.current !== undefined &&\n            mouse.previousSelection?.current !== undefined) {\n            if (fillHighlightRegion === undefined)\n                return;\n            const newRange = {\n                ...gridSelection,\n                current: {\n                    ...gridSelection.current,\n                    range: (0,_common_math_js__WEBPACK_IMPORTED_MODULE_16__.combineRects)(mouse.previousSelection.current.range, fillHighlightRegion),\n                },\n            };\n            void fillPattern(mouse.previousSelection, newRange);\n            setGridSelection(newRange, true);\n            return;\n        }\n        const [col, row] = args.location;\n        const [lastMouseDownCol, lastMouseDownRow] = lastMouseSelectLocation.current ?? [];\n        const preventDefault = () => {\n            isPrevented.current = true;\n        };\n        const handleMaybeClick = (a) => {\n            const isValidClick = a.isTouch || (lastMouseDownCol === col && lastMouseDownRow === row);\n            if (isValidClick) {\n                onCellClicked?.([col - rowMarkerOffset, row], {\n                    ...a,\n                    preventDefault,\n                });\n            }\n            if (a.button === 1)\n                return !isPrevented.current;\n            if (!isPrevented.current) {\n                const c = getMangledCellContent(args.location);\n                const r = getCellRenderer(c);\n                if (r !== undefined && r.onClick !== undefined && isValidClick) {\n                    const newVal = r.onClick({\n                        ...a,\n                        cell: c,\n                        posX: a.localEventX,\n                        posY: a.localEventY,\n                        bounds: a.bounds,\n                        theme: themeForCell(c, args.location),\n                        preventDefault,\n                    });\n                    if (newVal !== undefined && !(0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isInnerOnlyCell)(newVal) && (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isEditableGridCell)(newVal)) {\n                        mangledOnCellsEdited([{ location: a.location, value: newVal }]);\n                        gridRef.current?.damage([\n                            {\n                                cell: a.location,\n                            },\n                        ]);\n                    }\n                }\n                if (isPrevented.current || gridSelection.current === undefined)\n                    return false;\n                let shouldActivate = false;\n                switch (c.activationBehaviorOverride ?? cellActivationBehavior) {\n                    case \"double-click\":\n                    case \"second-click\": {\n                        if (mouse?.previousSelection?.current?.cell === undefined)\n                            break;\n                        const [selectedCol, selectedRow] = gridSelection.current.cell;\n                        const [prevCol, prevRow] = mouse.previousSelection.current.cell;\n                        const isClickOnSelected = col === selectedCol && col === prevCol && row === selectedRow && row === prevRow;\n                        shouldActivate =\n                            isClickOnSelected &&\n                                (a.isDoubleClick === true || cellActivationBehavior === \"second-click\");\n                        break;\n                    }\n                    case \"single-click\": {\n                        shouldActivate = true;\n                        break;\n                    }\n                }\n                if (shouldActivate) {\n                    onCellActivated?.([col - rowMarkerOffset, row]);\n                    reselect(a.bounds, false);\n                    return true;\n                }\n            }\n            return false;\n        };\n        const clickLocation = args.location[0] - rowMarkerOffset;\n        if (args.isTouch) {\n            const vr = visibleRegionRef.current;\n            const touchVr = touchDownArgs.current;\n            if (vr.x !== touchVr.x || vr.y !== touchVr.y) {\n                // we scrolled, abort\n                return;\n            }\n            // take care of context menus first if long pressed item is already selected\n            if (args.isLongTouch === true) {\n                if (args.kind === \"cell\" && (0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_18__.itemsAreEqual)(gridSelection.current?.cell, args.location)) {\n                    onCellContextMenu?.([clickLocation, args.location[1]], {\n                        ...args,\n                        preventDefault,\n                    });\n                    return;\n                }\n                else if (args.kind === \"header\" && gridSelection.columns.hasIndex(col)) {\n                    onHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n                    return;\n                }\n                else if (args.kind === _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.groupHeaderKind) {\n                    if (clickLocation < 0) {\n                        return;\n                    }\n                    onGroupHeaderContextMenu?.(clickLocation, { ...args, preventDefault });\n                    return;\n                }\n            }\n            if (args.kind === \"cell\") {\n                // click that cell\n                if (!handleMaybeClick(args)) {\n                    handleSelect(args);\n                }\n            }\n            else if (args.kind === _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.groupHeaderKind) {\n                onGroupHeaderClicked?.(clickLocation, { ...args, preventDefault });\n            }\n            else {\n                if (args.kind === _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.headerKind) {\n                    onHeaderClicked?.(clickLocation, {\n                        ...args,\n                        preventDefault,\n                    });\n                }\n                handleSelect(args);\n            }\n            return;\n        }\n        if (args.kind === \"header\") {\n            if (clickLocation < 0) {\n                return;\n            }\n            if (args.isEdge) {\n                if (args.isDoubleClick === true) {\n                    void normalSizeColumn(col);\n                }\n            }\n            else if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {\n                onHeaderClicked?.(clickLocation, { ...args, preventDefault });\n            }\n        }\n        if (args.kind === _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.groupHeaderKind) {\n            if (clickLocation < 0) {\n                return;\n            }\n            if (args.button === 0 && col === lastMouseDownCol && row === lastMouseDownRow) {\n                onGroupHeaderClicked?.(clickLocation, { ...args, preventDefault });\n                if (!isPrevented.current) {\n                    handleGroupHeaderSelection(args);\n                }\n            }\n        }\n        if (args.kind === \"cell\" && (args.button === 0 || args.button === 1)) {\n            handleMaybeClick(args);\n        }\n        lastMouseSelectLocation.current = undefined;\n    }, [\n        mouseState,\n        gridSelection,\n        rowMarkerOffset,\n        fillHighlightRegion,\n        fillPattern,\n        setGridSelection,\n        onCellClicked,\n        getMangledCellContent,\n        getCellRenderer,\n        cellActivationBehavior,\n        themeForCell,\n        mangledOnCellsEdited,\n        onCellActivated,\n        reselect,\n        onCellContextMenu,\n        onHeaderContextMenu,\n        onGroupHeaderContextMenu,\n        handleSelect,\n        onGroupHeaderClicked,\n        onHeaderClicked,\n        normalSizeColumn,\n        handleGroupHeaderSelection,\n    ]);\n    const onMouseMoveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args) => {\n        const a = {\n            ...args,\n            location: [args.location[0] - rowMarkerOffset, args.location[1]],\n        };\n        onMouseMove?.(a);\n        if (mouseState !== undefined && args.buttons === 0) {\n            setMouseState(undefined);\n            setFillHighlightRegion(undefined);\n            setScrollDir(undefined);\n            isActivelyDraggingHeader.current = false;\n        }\n        setScrollDir(cv => {\n            if (isActivelyDraggingHeader.current)\n                return [args.scrollEdge[0], 0];\n            if (args.scrollEdge[0] === cv?.[0] && args.scrollEdge[1] === cv[1])\n                return cv;\n            return mouseState === undefined || (mouseDownData.current?.location[0] ?? 0) < rowMarkerOffset\n                ? undefined\n                : args.scrollEdge;\n        });\n    }, [mouseState, onMouseMove, rowMarkerOffset]);\n    const onHeaderMenuClickInner = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, screenPosition) => {\n        onHeaderMenuClick?.(col - rowMarkerOffset, screenPosition);\n    }, [onHeaderMenuClick, rowMarkerOffset]);\n    const currentCell = gridSelection?.current?.cell;\n    const onVisibleRegionChangedImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((region, clientWidth, clientHeight, rightElWidth, tx, ty) => {\n        hasJustScrolled.current = false;\n        let selected = currentCell;\n        if (selected !== undefined) {\n            selected = [selected[0] - rowMarkerOffset, selected[1]];\n        }\n        const freezeRegion = freezeColumns === 0\n            ? undefined\n            : {\n                x: 0,\n                y: region.y,\n                width: freezeColumns,\n                height: region.height,\n            };\n        const freezeRegions = [];\n        if (freezeRegion !== undefined)\n            freezeRegions.push(freezeRegion);\n        if (freezeTrailingRows > 0) {\n            freezeRegions.push({\n                x: region.x - rowMarkerOffset,\n                y: rows - freezeTrailingRows,\n                width: region.width,\n                height: freezeTrailingRows,\n            });\n            if (freezeColumns > 0) {\n                freezeRegions.push({\n                    x: 0,\n                    y: rows - freezeTrailingRows,\n                    width: freezeColumns,\n                    height: freezeTrailingRows,\n                });\n            }\n        }\n        const newRegion = {\n            x: region.x - rowMarkerOffset,\n            y: region.y,\n            width: region.width,\n            height: showTrailingBlankRow && region.y + region.height >= rows ? region.height - 1 : region.height,\n            tx,\n            ty,\n            extras: {\n                selected,\n                freezeRegion,\n                freezeRegions,\n            },\n        };\n        visibleRegionRef.current = newRegion;\n        setVisibleRegion(newRegion);\n        setClientSize([clientWidth, clientHeight, rightElWidth]);\n        onVisibleRegionChanged?.(newRegion, newRegion.tx, newRegion.ty, newRegion.extras);\n    }, [\n        currentCell,\n        rowMarkerOffset,\n        showTrailingBlankRow,\n        rows,\n        freezeColumns,\n        freezeTrailingRows,\n        setVisibleRegion,\n        onVisibleRegionChanged,\n    ]);\n    const onColumnMovedImpl = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.whenDefined)(onColumnMoved, react__WEBPACK_IMPORTED_MODULE_0__.useCallback((startIndex, endIndex) => {\n        onColumnMoved?.(startIndex - rowMarkerOffset, endIndex - rowMarkerOffset);\n        if (columnSelect !== \"none\") {\n            setSelectedColumns(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection(endIndex), undefined, true);\n        }\n    }, [columnSelect, onColumnMoved, rowMarkerOffset, setSelectedColumns]));\n    const isActivelyDragging = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args) => {\n        if (args.location[0] === 0 && rowMarkerOffset > 0) {\n            args.preventDefault();\n            return;\n        }\n        onDragStart?.({\n            ...args,\n            location: [args.location[0] - rowMarkerOffset, args.location[1]],\n        });\n        if (!args.defaultPrevented()) {\n            isActivelyDragging.current = true;\n        }\n        setMouseState(undefined);\n    }, [onDragStart, rowMarkerOffset]);\n    const onDragEnd = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        isActivelyDragging.current = false;\n    }, []);\n    const hoveredRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const onItemHoveredImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args) => {\n        // make sure we still have a button down\n        if ((0,_internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.mouseEventArgsAreEqual)(args, hoveredRef.current))\n            return;\n        hoveredRef.current = args;\n        if (mouseDownData?.current?.button !== undefined && mouseDownData.current.button >= 1)\n            return;\n        if (args.buttons !== 0 &&\n            mouseState !== undefined &&\n            mouseDownData.current?.location[0] === 0 &&\n            args.location[0] === 0 &&\n            rowMarkerOffset === 1 &&\n            rowSelect === \"multi\" &&\n            mouseState.previousSelection &&\n            !mouseState.previousSelection.rows.hasIndex(mouseDownData.current.location[1]) &&\n            gridSelection.rows.hasIndex(mouseDownData.current.location[1])) {\n            const start = Math.min(mouseDownData.current.location[1], args.location[1]);\n            const end = Math.max(mouseDownData.current.location[1], args.location[1]) + 1;\n            setSelectedRows(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection([start, end]), undefined, false);\n        }\n        if (args.buttons !== 0 &&\n            mouseState !== undefined &&\n            gridSelection.current !== undefined &&\n            !isActivelyDragging.current &&\n            !isActivelyDraggingHeader.current &&\n            (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\")) {\n            const [selectedCol, selectedRow] = gridSelection.current.cell;\n            // eslint-disable-next-line prefer-const\n            let [col, row] = args.location;\n            if (row < 0) {\n                row = visibleRegionRef.current.y;\n            }\n            if (mouseState.fillHandle === true && mouseState.previousSelection?.current !== undefined) {\n                const prevRange = mouseState.previousSelection.current.range;\n                row = Math.min(row, showTrailingBlankRow ? rows - 1 : rows);\n                const rect = (0,_common_math_js__WEBPACK_IMPORTED_MODULE_16__.getClosestRect)(prevRange, col, row, allowedFillDirections);\n                setFillHighlightRegion(rect);\n            }\n            else {\n                const startedFromLastStickyRow = showTrailingBlankRow && selectedRow === rows;\n                if (startedFromLastStickyRow)\n                    return;\n                const landedOnLastStickyRow = showTrailingBlankRow && row === rows;\n                if (landedOnLastStickyRow) {\n                    if (args.kind === _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.outOfBoundsKind)\n                        row--;\n                    else\n                        return;\n                }\n                col = Math.max(col, rowMarkerOffset);\n                const deltaX = col - selectedCol;\n                const deltaY = row - selectedRow;\n                const newRange = {\n                    x: deltaX >= 0 ? selectedCol : col,\n                    y: deltaY >= 0 ? selectedRow : row,\n                    width: Math.abs(deltaX) + 1,\n                    height: Math.abs(deltaY) + 1,\n                };\n                setCurrent({\n                    ...gridSelection.current,\n                    range: newRange,\n                }, true, false, \"drag\");\n            }\n        }\n        onItemHovered?.({ ...args, location: [args.location[0] - rowMarkerOffset, args.location[1]] });\n    }, [\n        allowedFillDirections,\n        mouseState,\n        rowMarkerOffset,\n        rowSelect,\n        gridSelection,\n        rangeSelect,\n        onItemHovered,\n        setSelectedRows,\n        showTrailingBlankRow,\n        rows,\n        setCurrent,\n    ]);\n    const adjustSelectionOnScroll = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        const args = hoveredRef.current;\n        if (args === undefined)\n            return;\n        const [xDir, yDir] = args.scrollEdge;\n        let [col, row] = args.location;\n        const visible = visibleRegionRef.current;\n        if (xDir === -1) {\n            col = visible.extras?.freezeRegion?.x ?? visible.x;\n        }\n        else if (xDir === 1) {\n            col = visible.x + visible.width;\n        }\n        if (yDir === -1) {\n            row = Math.max(0, visible.y);\n        }\n        else if (yDir === 1) {\n            row = Math.min(rows - 1, visible.y + visible.height);\n        }\n        col = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(col, 0, mangledCols.length - 1);\n        row = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(row, 0, rows - 1);\n        onItemHoveredImpl({\n            ...args,\n            location: [col, row],\n        });\n    }, [mangledCols.length, onItemHoveredImpl, rows]);\n    (0,_use_autoscroll_js__WEBPACK_IMPORTED_MODULE_21__.useAutoscroll)(scrollDir, scrollRef, adjustSelectionOnScroll);\n    // 1 === move one\n    // 2 === move to end\n    const adjustSelection = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((direction) => {\n        if (gridSelection.current === undefined)\n            return;\n        const [x, y] = direction;\n        const [col, row] = gridSelection.current.cell;\n        const old = gridSelection.current.range;\n        let left = old.x;\n        let right = old.x + old.width;\n        let top = old.y;\n        let bottom = old.y + old.height;\n        // take care of vertical first in case new spans come in\n        if (y !== 0) {\n            switch (y) {\n                case 2: {\n                    // go to end\n                    bottom = rows;\n                    top = row;\n                    scrollTo(0, bottom, \"vertical\");\n                    break;\n                }\n                case -2: {\n                    // go to start\n                    top = 0;\n                    bottom = row + 1;\n                    scrollTo(0, top, \"vertical\");\n                    break;\n                }\n                case 1: {\n                    // motion down\n                    if (top < row) {\n                        top++;\n                        scrollTo(0, top, \"vertical\");\n                    }\n                    else {\n                        bottom = Math.min(rows, bottom + 1);\n                        scrollTo(0, bottom, \"vertical\");\n                    }\n                    break;\n                }\n                case -1: {\n                    // motion up\n                    if (bottom > row + 1) {\n                        bottom--;\n                        scrollTo(0, bottom, \"vertical\");\n                    }\n                    else {\n                        top = Math.max(0, top - 1);\n                        scrollTo(0, top, \"vertical\");\n                    }\n                    break;\n                }\n                default: {\n                    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_17__.assertNever)(y);\n                }\n            }\n        }\n        if (x !== 0) {\n            if (x === 2) {\n                right = mangledCols.length;\n                left = col;\n                scrollTo(right - 1 - rowMarkerOffset, 0, \"horizontal\");\n            }\n            else if (x === -2) {\n                left = rowMarkerOffset;\n                right = col + 1;\n                scrollTo(left - rowMarkerOffset, 0, \"horizontal\");\n            }\n            else {\n                let disallowed = [];\n                if (getCellsForSelection !== undefined) {\n                    const cells = getCellsForSelection({\n                        x: left,\n                        y: top,\n                        width: right - left - rowMarkerOffset,\n                        height: bottom - top,\n                    }, abortControllerRef.current.signal);\n                    if (typeof cells === \"object\") {\n                        disallowed = getSpanStops(cells);\n                    }\n                }\n                if (x === 1) {\n                    // motion right\n                    let done = false;\n                    if (left < col) {\n                        if (disallowed.length > 0) {\n                            const target = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(left + 1, col + 1).find(n => !disallowed.includes(n - rowMarkerOffset));\n                            if (target !== undefined) {\n                                left = target;\n                                done = true;\n                            }\n                        }\n                        else {\n                            left++;\n                            done = true;\n                        }\n                        if (done)\n                            scrollTo(left, 0, \"horizontal\");\n                    }\n                    if (!done) {\n                        right = Math.min(mangledCols.length, right + 1);\n                        scrollTo(right - 1 - rowMarkerOffset, 0, \"horizontal\");\n                    }\n                }\n                else if (x === -1) {\n                    // motion left\n                    let done = false;\n                    if (right > col + 1) {\n                        if (disallowed.length > 0) {\n                            const target = lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(right - 1, col, -1).find(n => !disallowed.includes(n - rowMarkerOffset));\n                            if (target !== undefined) {\n                                right = target;\n                                done = true;\n                            }\n                        }\n                        else {\n                            right--;\n                            done = true;\n                        }\n                        if (done)\n                            scrollTo(right - rowMarkerOffset, 0, \"horizontal\");\n                    }\n                    if (!done) {\n                        left = Math.max(rowMarkerOffset, left - 1);\n                        scrollTo(left - rowMarkerOffset, 0, \"horizontal\");\n                    }\n                }\n                else {\n                    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_17__.assertNever)(x);\n                }\n            }\n        }\n        setCurrent({\n            cell: gridSelection.current.cell,\n            range: {\n                x: left,\n                y: top,\n                width: right - left,\n                height: bottom - top,\n            },\n        }, true, false, \"keyboard-select\");\n    }, [getCellsForSelection, gridSelection, mangledCols.length, rowMarkerOffset, rows, scrollTo, setCurrent]);\n    const updateSelectedCell = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col, row, fromEditingTrailingRow, freeMove) => {\n        const rowMax = mangledRows - (fromEditingTrailingRow ? 0 : 1);\n        col = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(col, rowMarkerOffset, columns.length - 1 + rowMarkerOffset);\n        row = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(row, 0, rowMax);\n        if (col === currentCell?.[0] && row === currentCell?.[1])\n            return false;\n        if (freeMove && gridSelection.current !== undefined) {\n            const newStack = [...gridSelection.current.rangeStack];\n            if (gridSelection.current.range.width > 1 || gridSelection.current.range.height > 1) {\n                newStack.push(gridSelection.current.range);\n            }\n            setGridSelection({\n                ...gridSelection,\n                current: {\n                    cell: [col, row],\n                    range: { x: col, y: row, width: 1, height: 1 },\n                    rangeStack: newStack,\n                },\n            }, true);\n        }\n        else {\n            setCurrent({\n                cell: [col, row],\n                range: { x: col, y: row, width: 1, height: 1 },\n            }, true, false, \"keyboard-nav\");\n        }\n        if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {\n            lastSent.current = undefined;\n        }\n        scrollTo(col - rowMarkerOffset, row);\n        return true;\n    }, [\n        mangledRows,\n        rowMarkerOffset,\n        columns.length,\n        currentCell,\n        gridSelection,\n        scrollTo,\n        setGridSelection,\n        setCurrent,\n    ]);\n    const onFinishEditing = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newValue, movement) => {\n        if (overlay?.cell !== undefined && newValue !== undefined && (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isEditableGridCell)(newValue)) {\n            mangledOnCellsEdited([{ location: overlay.cell, value: newValue }]);\n            window.requestAnimationFrame(() => {\n                gridRef.current?.damage([\n                    {\n                        cell: overlay.cell,\n                    },\n                ]);\n            });\n        }\n        focus(true);\n        setOverlay(undefined);\n        const [movX, movY] = movement;\n        if (gridSelection.current !== undefined && (movX !== 0 || movY !== 0)) {\n            const isEditingTrailingRow = gridSelection.current.cell[1] === mangledRows - 1 && newValue !== undefined;\n            updateSelectedCell(lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(gridSelection.current.cell[0] + movX, 0, mangledCols.length - 1), lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(gridSelection.current.cell[1] + movY, 0, mangledRows - 1), isEditingTrailingRow, false);\n        }\n        onFinishedEditing?.(newValue, movement);\n    }, [\n        overlay?.cell,\n        focus,\n        gridSelection,\n        onFinishedEditing,\n        mangledOnCellsEdited,\n        mangledRows,\n        updateSelectedCell,\n        mangledCols.length,\n    ]);\n    const overlayID = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return `gdg-overlay-${idCounter++}`;\n    }, []);\n    const deleteRange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((r) => {\n        focus();\n        const editList = [];\n        for (let x = r.x; x < r.x + r.width; x++) {\n            for (let y = r.y; y < r.y + r.height; y++) {\n                const cellValue = getCellContent([x - rowMarkerOffset, y]);\n                if (!cellValue.allowOverlay && cellValue.kind !== _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Boolean)\n                    continue;\n                let newVal = undefined;\n                if (cellValue.kind === _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Custom) {\n                    const toDelete = getCellRenderer(cellValue);\n                    const editor = toDelete?.provideEditor?.(cellValue);\n                    if (toDelete?.onDelete !== undefined) {\n                        newVal = toDelete.onDelete(cellValue);\n                    }\n                    else if ((0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isObjectEditorCallbackResult)(editor)) {\n                        newVal = editor?.deletedValue?.(cellValue);\n                    }\n                }\n                else if (((0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isEditableGridCell)(cellValue) && cellValue.allowOverlay) ||\n                    cellValue.kind === _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Boolean) {\n                    const toDelete = getCellRenderer(cellValue);\n                    newVal = toDelete?.onDelete?.(cellValue);\n                }\n                if (newVal !== undefined && !(0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isInnerOnlyCell)(newVal) && (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isEditableGridCell)(newVal)) {\n                    editList.push({ location: [x, y], value: newVal });\n                }\n            }\n        }\n        mangledOnCellsEdited(editList);\n        gridRef.current?.damage(editList.map(x => ({ cell: x.location })));\n    }, [focus, getCellContent, getCellRenderer, mangledOnCellsEdited, rowMarkerOffset]);\n    const overlayOpen = overlay !== undefined;\n    const handleFixedKeybindings = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {\n        const cancel = () => {\n            event.stopPropagation();\n            event.preventDefault();\n        };\n        const details = {\n            didMatch: false,\n        };\n        const { bounds } = event;\n        const selectedColumns = gridSelection.columns;\n        const selectedRows = gridSelection.rows;\n        const keys = keybindings;\n        if (!overlayOpen && (0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.clear, event, details)) {\n            setGridSelection(emptyGridSelection, false);\n            onSelectionCleared?.();\n        }\n        else if (!overlayOpen && (0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectAll, event, details)) {\n            setGridSelection({\n                columns: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.empty(),\n                rows: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.empty(),\n                current: {\n                    cell: gridSelection.current?.cell ?? [rowMarkerOffset, 0],\n                    range: {\n                        x: rowMarkerOffset,\n                        y: 0,\n                        width: columnsIn.length,\n                        height: rows,\n                    },\n                    rangeStack: [],\n                },\n            }, false);\n        }\n        else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.search, event, details)) {\n            searchInputRef?.current?.focus({ preventScroll: true });\n            setShowSearchInner(true);\n        }\n        else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.delete, event, details)) {\n            const callbackResult = onDelete?.(gridSelection) ?? true;\n            if (callbackResult !== false) {\n                const toDelete = callbackResult === true ? gridSelection : callbackResult;\n                // delete order:\n                // 1) primary range\n                // 2) secondary ranges\n                // 3) columns\n                // 4) rows\n                if (toDelete.current !== undefined) {\n                    deleteRange(toDelete.current.range);\n                    for (const r of toDelete.current.rangeStack) {\n                        deleteRange(r);\n                    }\n                }\n                for (const r of toDelete.rows) {\n                    deleteRange({\n                        x: rowMarkerOffset,\n                        y: r,\n                        width: columnsIn.length,\n                        height: 1,\n                    });\n                }\n                for (const col of toDelete.columns) {\n                    deleteRange({\n                        x: col,\n                        y: 0,\n                        width: 1,\n                        height: rows,\n                    });\n                }\n            }\n        }\n        if (details.didMatch) {\n            cancel();\n            return true;\n        }\n        if (gridSelection.current === undefined)\n            return false;\n        let [col, row] = gridSelection.current.cell;\n        let freeMove = false;\n        let cancelOnlyOnMove = false;\n        if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.scrollToSelectedCell, event, details)) {\n            scrollToRef.current(col - rowMarkerOffset, row);\n        }\n        else if (columnSelect !== \"none\" && (0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectColumn, event, details)) {\n            if (selectedColumns.hasIndex(col)) {\n                setSelectedColumns(selectedColumns.remove(col), undefined, true);\n            }\n            else {\n                if (columnSelect === \"single\") {\n                    setSelectedColumns(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection(col), undefined, true);\n                }\n                else {\n                    setSelectedColumns(undefined, col, true);\n                }\n            }\n        }\n        else if (rowSelect !== \"none\" && (0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectRow, event, details)) {\n            if (selectedRows.hasIndex(row)) {\n                setSelectedRows(selectedRows.remove(row), undefined, true);\n            }\n            else {\n                if (rowSelect === \"single\") {\n                    setSelectedRows(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection(row), undefined, true);\n                }\n                else {\n                    setSelectedRows(undefined, row, true);\n                }\n            }\n        }\n        else if (!overlayOpen && bounds !== undefined && (0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.activateCell, event, details)) {\n            if (row === rows && showTrailingBlankRow) {\n                window.setTimeout(() => {\n                    const customTargetColumn = getCustomNewRowTargetColumn(col);\n                    void appendRow(customTargetColumn ?? col);\n                }, 0);\n            }\n            else {\n                onCellActivated?.([col - rowMarkerOffset, row]);\n                reselect(bounds, true);\n            }\n        }\n        else if (gridSelection.current.range.height > 1 && (0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.downFill, event, details)) {\n            fillDown();\n        }\n        else if (gridSelection.current.range.width > 1 && (0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.rightFill, event, details)) {\n            fillRight();\n        }\n        else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goToNextPage, event, details)) {\n            row += Math.max(1, visibleRegionRef.current.height - 4); // partial cell accounting\n        }\n        else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goToPreviousPage, event, details)) {\n            row -= Math.max(1, visibleRegionRef.current.height - 4); // partial cell accounting\n        }\n        else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goToFirstCell, event, details)) {\n            setOverlay(undefined);\n            row = 0;\n            col = 0;\n        }\n        else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goToLastCell, event, details)) {\n            setOverlay(undefined);\n            row = Number.MAX_SAFE_INTEGER;\n            col = Number.MAX_SAFE_INTEGER;\n        }\n        else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectToFirstCell, event, details)) {\n            setOverlay(undefined);\n            adjustSelection([-2, -2]);\n        }\n        else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectToLastCell, event, details)) {\n            setOverlay(undefined);\n            adjustSelection([2, 2]);\n        }\n        else if (!overlayOpen) {\n            if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goDownCell, event, details)) {\n                row += 1;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goUpCell, event, details)) {\n                row -= 1;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goRightCell, event, details)) {\n                col += 1;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goLeftCell, event, details)) {\n                col -= 1;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goDownCellRetainSelection, event, details)) {\n                row += 1;\n                freeMove = true;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goUpCellRetainSelection, event, details)) {\n                row -= 1;\n                freeMove = true;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goRightCellRetainSelection, event, details)) {\n                col += 1;\n                freeMove = true;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goLeftCellRetainSelection, event, details)) {\n                col -= 1;\n                freeMove = true;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goToLastRow, event, details)) {\n                row = rows - 1;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goToFirstRow, event, details)) {\n                row = Number.MIN_SAFE_INTEGER;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goToLastColumn, event, details)) {\n                col = Number.MAX_SAFE_INTEGER;\n            }\n            else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.goToFirstColumn, event, details)) {\n                col = Number.MIN_SAFE_INTEGER;\n            }\n            else if (rangeSelect === \"rect\" || rangeSelect === \"multi-rect\") {\n                if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectGrowDown, event, details)) {\n                    adjustSelection([0, 1]);\n                }\n                else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectGrowUp, event, details)) {\n                    adjustSelection([0, -1]);\n                }\n                else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectGrowRight, event, details)) {\n                    adjustSelection([1, 0]);\n                }\n                else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectGrowLeft, event, details)) {\n                    adjustSelection([-1, 0]);\n                }\n                else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectToLastRow, event, details)) {\n                    adjustSelection([0, 2]);\n                }\n                else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectToFirstRow, event, details)) {\n                    adjustSelection([0, -2]);\n                }\n                else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectToLastColumn, event, details)) {\n                    adjustSelection([2, 0]);\n                }\n                else if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.selectToFirstColumn, event, details)) {\n                    adjustSelection([-2, 0]);\n                }\n            }\n            cancelOnlyOnMove = details.didMatch;\n        }\n        else {\n            if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.closeOverlay, event, details)) {\n                setOverlay(undefined);\n            }\n            if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.acceptOverlayDown, event, details)) {\n                setOverlay(undefined);\n                row++;\n            }\n            if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.acceptOverlayUp, event, details)) {\n                setOverlay(undefined);\n                row--;\n            }\n            if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.acceptOverlayLeft, event, details)) {\n                setOverlay(undefined);\n                col--;\n            }\n            if ((0,_common_is_hotkey_js__WEBPACK_IMPORTED_MODULE_22__.isHotkey)(keys.acceptOverlayRight, event, details)) {\n                setOverlay(undefined);\n                col++;\n            }\n        }\n        // #endregion\n        const moved = updateSelectedCell(col, row, false, freeMove);\n        const didMatch = details.didMatch;\n        if (didMatch && (moved || !cancelOnlyOnMove || trapFocus)) {\n            cancel();\n        }\n        return didMatch;\n    }, [\n        overlayOpen,\n        gridSelection,\n        keybindings,\n        columnSelect,\n        rowSelect,\n        rangeSelect,\n        rowMarkerOffset,\n        rows,\n        updateSelectedCell,\n        setGridSelection,\n        onSelectionCleared,\n        columnsIn.length,\n        onDelete,\n        trapFocus,\n        deleteRange,\n        setSelectedColumns,\n        setSelectedRows,\n        showTrailingBlankRow,\n        getCustomNewRowTargetColumn,\n        appendRow,\n        onCellActivated,\n        reselect,\n        fillDown,\n        fillRight,\n        adjustSelection,\n    ]);\n    const onKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {\n        let cancelled = false;\n        if (onKeyDownIn !== undefined) {\n            onKeyDownIn({\n                ...event,\n                cancel: () => {\n                    cancelled = true;\n                },\n            });\n        }\n        if (cancelled)\n            return;\n        if (handleFixedKeybindings(event))\n            return;\n        if (gridSelection.current === undefined)\n            return;\n        const [col, row] = gridSelection.current.cell;\n        const vr = visibleRegionRef.current;\n        if (editOnType &&\n            !event.metaKey &&\n            !event.ctrlKey &&\n            gridSelection.current !== undefined &&\n            event.key.length === 1 &&\n            /[ -~]/g.test(event.key) &&\n            event.bounds !== undefined &&\n            (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isReadWriteCell)(getCellContent([col - rowMarkerOffset, Math.max(0, Math.min(row, rows - 1))]))) {\n            if ((!showTrailingBlankRow || row !== rows) &&\n                (vr.y > row || row > vr.y + vr.height || vr.x > col || col > vr.x + vr.width)) {\n                return;\n            }\n            reselect(event.bounds, true, event.key);\n            event.stopPropagation();\n            event.preventDefault();\n        }\n    }, [\n        editOnType,\n        onKeyDownIn,\n        handleFixedKeybindings,\n        gridSelection,\n        getCellContent,\n        rowMarkerOffset,\n        rows,\n        showTrailingBlankRow,\n        reselect,\n    ]);\n    const onContextMenu = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args, preventDefault) => {\n        const adjustedCol = args.location[0] - rowMarkerOffset;\n        if (args.kind === \"header\") {\n            onHeaderContextMenu?.(adjustedCol, { ...args, preventDefault });\n        }\n        if (args.kind === _internal_data_grid_event_args_js__WEBPACK_IMPORTED_MODULE_20__.groupHeaderKind) {\n            if (adjustedCol < 0) {\n                return;\n            }\n            onGroupHeaderContextMenu?.(adjustedCol, { ...args, preventDefault });\n        }\n        if (args.kind === \"cell\") {\n            const [col, row] = args.location;\n            onCellContextMenu?.([adjustedCol, row], {\n                ...args,\n                preventDefault,\n            });\n            if (!(0,_internal_data_grid_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_18__.gridSelectionHasItem)(gridSelection, args.location)) {\n                updateSelectedCell(col, row, false, false);\n            }\n        }\n    }, [\n        gridSelection,\n        onCellContextMenu,\n        onGroupHeaderContextMenu,\n        onHeaderContextMenu,\n        rowMarkerOffset,\n        updateSelectedCell,\n    ]);\n    const onPasteInternal = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (e) => {\n        if (!keybindings.paste)\n            return;\n        function pasteToCell(inner, target, rawValue, formatted) {\n            const stringifiedRawValue = typeof rawValue === \"object\" ? rawValue?.join(\"\\n\") ?? \"\" : rawValue?.toString() ?? \"\";\n            if (!(0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isInnerOnlyCell)(inner) && (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isReadWriteCell)(inner) && inner.readonly !== true) {\n                const coerced = coercePasteValue?.(stringifiedRawValue, inner);\n                if (coerced !== undefined && (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.isEditableGridCell)(coerced)) {\n                    if ( true && coerced.kind !== inner.kind) {\n                        // eslint-disable-next-line no-console\n                        console.warn(\"Coercion should not change cell kind.\");\n                    }\n                    return {\n                        location: target,\n                        value: coerced,\n                    };\n                }\n                const r = getCellRenderer(inner);\n                if (r === undefined)\n                    return undefined;\n                if (r.kind === _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Custom) {\n                    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_17__.assert)(inner.kind === _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Custom);\n                    const newVal = r.onPaste?.(stringifiedRawValue, inner.data);\n                    if (newVal === undefined)\n                        return undefined;\n                    return {\n                        location: target,\n                        value: {\n                            ...inner,\n                            data: newVal,\n                        },\n                    };\n                }\n                else {\n                    const newVal = r.onPaste?.(stringifiedRawValue, inner, {\n                        formatted,\n                        formattedString: typeof formatted === \"string\" ? formatted : formatted?.join(\"\\n\"),\n                        rawValue,\n                    });\n                    if (newVal === undefined)\n                        return undefined;\n                    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_17__.assert)(newVal.kind === inner.kind);\n                    return {\n                        location: target,\n                        value: newVal,\n                    };\n                }\n            }\n            return undefined;\n        }\n        const selectedColumns = gridSelection.columns;\n        const selectedRows = gridSelection.rows;\n        const focused = scrollRef.current?.contains(document.activeElement) === true ||\n            canvasRef.current?.contains(document.activeElement) === true;\n        let target;\n        if (gridSelection.current !== undefined) {\n            target = [gridSelection.current.range.x, gridSelection.current.range.y];\n        }\n        else if (selectedColumns.length === 1) {\n            target = [selectedColumns.first() ?? 0, 0];\n        }\n        else if (selectedRows.length === 1) {\n            target = [rowMarkerOffset, selectedRows.first() ?? 0];\n        }\n        if (focused && target !== undefined) {\n            let data;\n            let text;\n            const textPlain = \"text/plain\";\n            const textHtml = \"text/html\";\n            if (navigator.clipboard.read !== undefined) {\n                const clipboardContent = await navigator.clipboard.read();\n                for (const item of clipboardContent) {\n                    if (item.types.includes(textHtml)) {\n                        const htmlBlob = await item.getType(textHtml);\n                        const html = await htmlBlob.text();\n                        const decoded = (0,_copy_paste_js__WEBPACK_IMPORTED_MODULE_23__.decodeHTML)(html);\n                        if (decoded !== undefined) {\n                            data = decoded;\n                            break;\n                        }\n                    }\n                    if (item.types.includes(textPlain)) {\n                        // eslint-disable-next-line unicorn/no-await-expression-member\n                        text = await (await item.getType(textPlain)).text();\n                    }\n                }\n            }\n            else if (navigator.clipboard.readText !== undefined) {\n                text = await navigator.clipboard.readText();\n            }\n            else if (e !== undefined && e?.clipboardData !== null) {\n                if (e.clipboardData.types.includes(textHtml)) {\n                    const html = e.clipboardData.getData(textHtml);\n                    data = (0,_copy_paste_js__WEBPACK_IMPORTED_MODULE_23__.decodeHTML)(html);\n                }\n                if (data === undefined && e.clipboardData.types.includes(textPlain)) {\n                    text = e.clipboardData.getData(textPlain);\n                }\n            }\n            else {\n                return; // I didn't want to read that paste value anyway\n            }\n            const [targetCol, targetRow] = target;\n            const editList = [];\n            do {\n                if (onPaste === undefined) {\n                    const cellData = getMangledCellContent(target);\n                    const rawValue = text ?? data?.map(r => r.map(cb => cb.rawValue).join(\"\\t\")).join(\"\\t\") ?? \"\";\n                    const newVal = pasteToCell(cellData, target, rawValue, undefined);\n                    if (newVal !== undefined) {\n                        editList.push(newVal);\n                    }\n                    break;\n                }\n                if (data === undefined) {\n                    if (text === undefined)\n                        return;\n                    data = (0,_data_editor_fns_js__WEBPACK_IMPORTED_MODULE_10__.unquote)(text);\n                }\n                if (onPaste === false ||\n                    (typeof onPaste === \"function\" &&\n                        onPaste?.([target[0] - rowMarkerOffset, target[1]], data.map(r => r.map(cb => cb.rawValue?.toString() ?? \"\"))) !== true)) {\n                    return;\n                }\n                for (const [row, dataRow] of data.entries()) {\n                    if (row + targetRow >= rows)\n                        break;\n                    for (const [col, dataItem] of dataRow.entries()) {\n                        const index = [col + targetCol, row + targetRow];\n                        const [writeCol, writeRow] = index;\n                        if (writeCol >= mangledCols.length)\n                            continue;\n                        if (writeRow >= mangledRows)\n                            continue;\n                        const cellData = getMangledCellContent(index);\n                        const newVal = pasteToCell(cellData, index, dataItem.rawValue, dataItem.formatted);\n                        if (newVal !== undefined) {\n                            editList.push(newVal);\n                        }\n                    }\n                }\n                // eslint-disable-next-line no-constant-condition\n            } while (false);\n            mangledOnCellsEdited(editList);\n            gridRef.current?.damage(editList.map(c => ({\n                cell: c.location,\n            })));\n        }\n    }, [\n        coercePasteValue,\n        getCellRenderer,\n        getMangledCellContent,\n        gridSelection,\n        keybindings.paste,\n        mangledCols.length,\n        mangledOnCellsEdited,\n        mangledRows,\n        onPaste,\n        rowMarkerOffset,\n        rows,\n    ]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.useEventListener)(\"paste\", onPasteInternal, safeWindow, false, true);\n    // While this function is async, we deeply prefer not to await if we don't have to. This will lead to unpacking\n    // promises in rather awkward ways when possible to avoid awaiting. We have to use fallback copy mechanisms when\n    // an await has happened.\n    const onCopy = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (e, ignoreFocus) => {\n        if (!keybindings.copy)\n            return;\n        const focused = ignoreFocus === true ||\n            scrollRef.current?.contains(document.activeElement) === true ||\n            canvasRef.current?.contains(document.activeElement) === true;\n        const selectedColumns = gridSelection.columns;\n        const selectedRows = gridSelection.rows;\n        const copyToClipboardWithHeaders = (cells, columnIndexes) => {\n            if (!copyHeaders) {\n                (0,_data_editor_fns_js__WEBPACK_IMPORTED_MODULE_10__.copyToClipboard)(cells, columnIndexes, e);\n            }\n            else {\n                const headers = columnIndexes.map(index => ({\n                    kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridCellKind.Text,\n                    data: columnsIn[index].title,\n                    displayData: columnsIn[index].title,\n                    allowOverlay: false,\n                }));\n                (0,_data_editor_fns_js__WEBPACK_IMPORTED_MODULE_10__.copyToClipboard)([headers, ...cells], columnIndexes, e);\n            }\n        };\n        if (focused && getCellsForSelection !== undefined) {\n            if (gridSelection.current !== undefined) {\n                let thunk = getCellsForSelection(gridSelection.current.range, abortControllerRef.current.signal);\n                if (typeof thunk !== \"object\") {\n                    thunk = await thunk();\n                }\n                copyToClipboardWithHeaders(thunk, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(gridSelection.current.range.x - rowMarkerOffset, gridSelection.current.range.x + gridSelection.current.range.width - rowMarkerOffset));\n            }\n            else if (selectedRows !== undefined && selectedRows.length > 0) {\n                const toCopy = [...selectedRows];\n                const cells = toCopy.map(rowIndex => {\n                    const thunk = getCellsForSelection({\n                        x: rowMarkerOffset,\n                        y: rowIndex,\n                        width: columnsIn.length,\n                        height: 1,\n                    }, abortControllerRef.current.signal);\n                    if (typeof thunk === \"object\") {\n                        return thunk[0];\n                    }\n                    return thunk().then(v => v[0]);\n                });\n                if (cells.some(x => x instanceof Promise)) {\n                    const settled = await Promise.all(cells);\n                    copyToClipboardWithHeaders(settled, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(columnsIn.length));\n                }\n                else {\n                    copyToClipboardWithHeaders(cells, lodash_range_js__WEBPACK_IMPORTED_MODULE_4__(columnsIn.length));\n                }\n            }\n            else if (selectedColumns.length > 0) {\n                const results = [];\n                const cols = [];\n                for (const col of selectedColumns) {\n                    let thunk = getCellsForSelection({\n                        x: col,\n                        y: 0,\n                        width: 1,\n                        height: rows,\n                    }, abortControllerRef.current.signal);\n                    if (typeof thunk !== \"object\") {\n                        thunk = await thunk();\n                    }\n                    results.push(thunk);\n                    cols.push(col - rowMarkerOffset);\n                }\n                if (results.length === 1) {\n                    copyToClipboardWithHeaders(results[0], cols);\n                }\n                else {\n                    // FIXME: this is dumb\n                    const toCopy = results.reduce((pv, cv) => pv.map((row, index) => [...row, ...cv[index]]));\n                    copyToClipboardWithHeaders(toCopy, cols);\n                }\n            }\n        }\n    }, [columnsIn, getCellsForSelection, gridSelection, keybindings.copy, rowMarkerOffset, rows, copyHeaders]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.useEventListener)(\"copy\", onCopy, safeWindow, false, false);\n    const onCut = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (e) => {\n        if (!keybindings.cut)\n            return;\n        const focused = scrollRef.current?.contains(document.activeElement) === true ||\n            canvasRef.current?.contains(document.activeElement) === true;\n        if (!focused)\n            return;\n        await onCopy(e);\n        if (gridSelection.current !== undefined) {\n            let effectiveSelection = {\n                current: {\n                    cell: gridSelection.current.cell,\n                    range: gridSelection.current.range,\n                    rangeStack: [],\n                },\n                rows: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.empty(),\n                columns: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.empty(),\n            };\n            const onDeleteResult = onDelete?.(effectiveSelection);\n            if (onDeleteResult === false)\n                return;\n            effectiveSelection = onDeleteResult === true ? effectiveSelection : onDeleteResult;\n            if (effectiveSelection.current === undefined)\n                return;\n            deleteRange(effectiveSelection.current.range);\n        }\n    }, [deleteRange, gridSelection, keybindings.cut, onCopy, onDelete]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.useEventListener)(\"cut\", onCut, safeWindow, false, false);\n    const onSearchResultsChanged = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((results, navIndex) => {\n        if (onSearchResultsChangedIn !== undefined) {\n            if (rowMarkerOffset !== 0) {\n                results = results.map(item => [item[0] - rowMarkerOffset, item[1]]);\n            }\n            onSearchResultsChangedIn(results, navIndex);\n            return;\n        }\n        if (results.length === 0 || navIndex === -1)\n            return;\n        const [col, row] = results[navIndex];\n        if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {\n            return;\n        }\n        lastSent.current = [col, row];\n        updateSelectedCell(col, row, false, false);\n    }, [onSearchResultsChangedIn, rowMarkerOffset, updateSelectedCell]);\n    // this effects purpose in life is to scroll the newly selected cell into view when and ONLY when that cell\n    // is from an external gridSelection change. Also note we want the unmangled out selection because scrollTo\n    // expects unmangled indexes\n    const [outCol, outRow] = gridSelectionOuter?.current?.cell ?? [];\n    const scrollToRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(scrollTo);\n    scrollToRef.current = scrollTo;\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (!hasJustScrolled.current &&\n            outCol !== undefined &&\n            outRow !== undefined &&\n            (outCol !== expectedExternalGridSelection.current?.current?.cell[0] ||\n                outRow !== expectedExternalGridSelection.current?.current?.cell[1])) {\n            scrollToRef.current(outCol, outRow);\n        }\n        hasJustScrolled.current = false; //only allow skipping a single scroll\n    }, [outCol, outRow]);\n    const selectionOutOfBounds = gridSelection.current !== undefined &&\n        (gridSelection.current.cell[0] >= mangledCols.length || gridSelection.current.cell[1] >= mangledRows);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (selectionOutOfBounds) {\n            setGridSelection(emptyGridSelection, false);\n        }\n    }, [selectionOutOfBounds, setGridSelection]);\n    const disabledRows = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (showTrailingBlankRow === true && trailingRowOptions?.tint === true) {\n            return _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection(mangledRows - 1);\n        }\n        return _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.empty();\n    }, [mangledRows, showTrailingBlankRow, trailingRowOptions?.tint]);\n    const mangledVerticalBorder = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((col) => {\n        return typeof verticalBorder === \"boolean\"\n            ? verticalBorder\n            : verticalBorder?.(col - rowMarkerOffset) ?? true;\n    }, [rowMarkerOffset, verticalBorder]);\n    const renameGroupNode = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (renameGroup === undefined || canvasRef.current === null)\n            return null;\n        const { bounds, group } = renameGroup;\n        const canvasBounds = canvasRef.current.getBoundingClientRect();\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_group_rename_js__WEBPACK_IMPORTED_MODULE_24__.GroupRename, { bounds: bounds, group: group, canvasBounds: canvasBounds, onClose: () => setRenameGroup(undefined), onFinish: newVal => {\n                setRenameGroup(undefined);\n                onGroupHeaderRenamed?.(group, newVal);\n            } }));\n    }, [onGroupHeaderRenamed, renameGroup]);\n    const mangledFreezeColumns = Math.min(mangledCols.length, freezeColumns + (hasRowMarkers ? 1 : 0));\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(forwardedRef, () => ({\n        appendRow: (col, openOverlay) => appendRow(col + rowMarkerOffset, openOverlay),\n        updateCells: damageList => {\n            if (rowMarkerOffset !== 0) {\n                damageList = damageList.map(x => ({ cell: [x.cell[0] + rowMarkerOffset, x.cell[1]] }));\n            }\n            return gridRef.current?.damage(damageList);\n        },\n        getBounds: (col, row) => {\n            if (canvasRef?.current === null || scrollRef?.current === null) {\n                return undefined;\n            }\n            if (col === undefined && row === undefined) {\n                // Return the bounds of the entire scroll area:\n                const rect = canvasRef.current.getBoundingClientRect();\n                const scale = rect.width / scrollRef.current.clientWidth;\n                return {\n                    x: rect.x - scrollRef.current.scrollLeft * scale,\n                    y: rect.y - scrollRef.current.scrollTop * scale,\n                    width: scrollRef.current.scrollWidth * scale,\n                    height: scrollRef.current.scrollHeight * scale,\n                };\n            }\n            return gridRef.current?.getBounds((col ?? 0) + rowMarkerOffset, row);\n        },\n        focus: () => gridRef.current?.focus(),\n        emit: async (e) => {\n            switch (e) {\n                case \"delete\":\n                    onKeyDown({\n                        bounds: undefined,\n                        cancel: () => undefined,\n                        stopPropagation: () => undefined,\n                        preventDefault: () => undefined,\n                        ctrlKey: false,\n                        key: \"Delete\",\n                        keyCode: 46,\n                        metaKey: false,\n                        shiftKey: false,\n                        altKey: false,\n                        rawEvent: undefined,\n                        location: undefined,\n                    });\n                    break;\n                case \"fill-right\":\n                    onKeyDown({\n                        bounds: undefined,\n                        cancel: () => undefined,\n                        stopPropagation: () => undefined,\n                        preventDefault: () => undefined,\n                        ctrlKey: true,\n                        key: \"r\",\n                        keyCode: 82,\n                        metaKey: false,\n                        shiftKey: false,\n                        altKey: false,\n                        rawEvent: undefined,\n                        location: undefined,\n                    });\n                    break;\n                case \"fill-down\":\n                    onKeyDown({\n                        bounds: undefined,\n                        cancel: () => undefined,\n                        stopPropagation: () => undefined,\n                        preventDefault: () => undefined,\n                        ctrlKey: true,\n                        key: \"d\",\n                        keyCode: 68,\n                        metaKey: false,\n                        shiftKey: false,\n                        altKey: false,\n                        rawEvent: undefined,\n                        location: undefined,\n                    });\n                    break;\n                case \"copy\":\n                    await onCopy(undefined, true);\n                    break;\n                case \"paste\":\n                    await onPasteInternal();\n                    break;\n            }\n        },\n        scrollTo,\n        remeasureColumns: cols => {\n            for (const col of cols) {\n                void normalSizeColumn(col + rowMarkerOffset);\n            }\n        },\n    }), [appendRow, normalSizeColumn, onCopy, onKeyDown, onPasteInternal, rowMarkerOffset, scrollTo]);\n    const [selCol, selRow] = currentCell ?? [];\n    const onCellFocused = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cell) => {\n        const [col, row] = cell;\n        if (row === -1) {\n            if (columnSelect !== \"none\") {\n                setSelectedColumns(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.CompactSelection.fromSingleSelection(col), undefined, false);\n                focus();\n            }\n            return;\n        }\n        if (selCol === col && selRow === row)\n            return;\n        setCurrent({\n            cell,\n            range: { x: col, y: row, width: 1, height: 1 },\n        }, true, false, \"keyboard-nav\");\n        scrollTo(col, row);\n    }, [columnSelect, focus, scrollTo, selCol, selRow, setCurrent, setSelectedColumns]);\n    const [isFocused, setIsFocused] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const setIsFocusedDebounced = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lodash_debounce_js__WEBPACK_IMPORTED_MODULE_5__((val) => {\n        setIsFocused(val);\n    }, 5));\n    const onCanvasFocused = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        setIsFocusedDebounced.current(true);\n        // check for mouse state, don't do anything if the user is clicked to focus.\n        if (gridSelection.current === undefined &&\n            gridSelection.columns.length === 0 &&\n            gridSelection.rows.length === 0 &&\n            mouseState === undefined) {\n            setCurrent({\n                cell: [rowMarkerOffset, cellYOffset],\n                range: {\n                    x: rowMarkerOffset,\n                    y: cellYOffset,\n                    width: 1,\n                    height: 1,\n                },\n            }, true, false, \"keyboard-select\");\n        }\n    }, [cellYOffset, gridSelection, mouseState, rowMarkerOffset, setCurrent]);\n    const onFocusOut = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        setIsFocusedDebounced.current(false);\n    }, []);\n    const [idealWidth, idealHeight] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        let h;\n        const scrollbarWidth = experimental?.scrollbarWidthOverride ?? (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_11__.getScrollBarWidth)();\n        const rowsCountWithTrailingRow = rows + (showTrailingBlankRow ? 1 : 0);\n        if (typeof rowHeight === \"number\") {\n            h = totalHeaderHeight + rowsCountWithTrailingRow * rowHeight;\n        }\n        else {\n            let avg = 0;\n            const toAverage = Math.min(rowsCountWithTrailingRow, 10);\n            for (let i = 0; i < toAverage; i++) {\n                avg += rowHeight(i);\n            }\n            avg = Math.floor(avg / toAverage);\n            h = totalHeaderHeight + rowsCountWithTrailingRow * avg;\n        }\n        h += scrollbarWidth;\n        const w = mangledCols.reduce((acc, x) => x.width + acc, 0) + scrollbarWidth;\n        // We need to set a reasonable cap here as some browsers will just ignore huge values\n        // rather than treat them as huge values.\n        return [`${Math.min(100000, w)}px`, `${Math.min(100000, h)}px`];\n    }, [mangledCols, experimental?.scrollbarWidthOverride, rowHeight, rows, showTrailingBlankRow, totalHeaderHeight]);\n    const cssStyle = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_13__.makeCSSStyle)(mergedTheme);\n    }, [mergedTheme]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_common_styles_js__WEBPACK_IMPORTED_MODULE_13__.ThemeContext.Provider, { value: mergedTheme },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_data_editor_container_data_grid_container_js__WEBPACK_IMPORTED_MODULE_25__.DataEditorContainer, { style: cssStyle, className: className, inWidth: width ?? idealWidth, inHeight: height ?? idealHeight },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_data_grid_search_data_grid_search_js__WEBPACK_IMPORTED_MODULE_26__[\"default\"], { fillHandle: fillHandle, drawFocusRing: drawFocusRing, experimental: experimental, fixedShadowX: fixedShadowX, fixedShadowY: fixedShadowY, getRowThemeOverride: getRowThemeOverride, headerIcons: headerIcons, imageWindowLoader: imageWindowLoader, initialSize: initialSize, isDraggable: isDraggable, onDragLeave: onDragLeave, onRowMoved: onRowMoved, overscrollX: overscrollX, overscrollY: overscrollY, preventDiagonalScrolling: preventDiagonalScrolling, rightElement: rightElement, rightElementProps: rightElementProps, smoothScrollX: smoothScrollX, smoothScrollY: smoothScrollY, className: className, enableGroups: enableGroups, onCanvasFocused: onCanvasFocused, onCanvasBlur: onFocusOut, canvasRef: canvasRef, onContextMenu: onContextMenu, theme: mergedTheme, cellXOffset: cellXOffset, cellYOffset: cellYOffset, accessibilityHeight: visibleRegion.height, onDragEnd: onDragEnd, columns: mangledCols, nonGrowWidth: nonGrowWidth, drawHeader: drawHeader, onColumnProposeMove: onColumnProposeMove, drawCell: drawCell, disabledRows: disabledRows, freezeColumns: mangledFreezeColumns, lockColumns: rowMarkerOffset, firstColAccessible: rowMarkerOffset === 0, getCellContent: getMangledCellContent, minColumnWidth: minColumnWidth, maxColumnWidth: maxColumnWidth, searchInputRef: searchInputRef, showSearch: showSearch, onSearchClose: onSearchClose, highlightRegions: highlightRegions, getCellsForSelection: getCellsForSelection, getGroupDetails: mangledGetGroupDetails, headerHeight: headerHeight, isFocused: isFocused, groupHeaderHeight: enableGroups ? groupHeaderHeight : 0, freezeTrailingRows: freezeTrailingRows + (showTrailingBlankRow && trailingRowOptions?.sticky === true ? 1 : 0), hasAppendRow: showTrailingBlankRow, onColumnResize: onColumnResize, onColumnResizeEnd: onColumnResizeEnd, onColumnResizeStart: onColumnResizeStart, onCellFocused: onCellFocused, onColumnMoved: onColumnMovedImpl, onDragStart: onDragStartImpl, onHeaderMenuClick: onHeaderMenuClickInner, onItemHovered: onItemHoveredImpl, isFilling: mouseState?.fillHandle === true, onMouseMove: onMouseMoveImpl, onKeyDown: onKeyDown, onKeyUp: onKeyUpIn, onMouseDown: onMouseDown, onMouseUp: onMouseUp, onDragOverCell: onDragOverCell, onDrop: onDrop, onSearchResultsChanged: onSearchResultsChanged, onVisibleRegionChanged: onVisibleRegionChangedImpl, clientSize: clientSize, rowHeight: rowHeight, searchResults: searchResults, searchValue: searchValue, onSearchValueChange: onSearchValueChange, rows: mangledRows, scrollRef: scrollRef, selection: gridSelection, translateX: visibleRegion.tx, translateY: visibleRegion.ty, verticalBorder: mangledVerticalBorder, gridRef: gridRef, getCellRenderer: getCellRenderer }),\n            renameGroupNode,\n            overlay !== undefined && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: null },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataGridOverlayEditor, { ...overlay, validateCell: validateCell, bloom: editorBloom, id: overlayID, getCellRenderer: getCellRenderer, className: experimental?.isSubGrid === true ? \"click-outside-ignore\" : undefined, provideEditor: provideEditor, imageEditorOverride: imageEditorOverride, onFinishEditing: onFinishEditing, markdownDivCreateNode: markdownDivCreateNode, isOutsideClick: isOutsideClick }))))));\n};\n/**\n * The primary component of Glide Data Grid.\n * @category DataEditor\n * @param {DataEditorProps} props\n */\nconst DataEditor = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DataEditorImpl);\n//# sourceMappingURL=data-editor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvZGF0YS1lZGl0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQytCO0FBQ21DO0FBQzlCO0FBQ0Y7QUFDTTtBQUNKO0FBQ007QUFDNEw7QUFDcEo7QUFDdkI7QUFDaUQ7QUFDSztBQUN5QztBQUMxRztBQUNzQjtBQUNwQjtBQUNxQztBQUNuQjtBQUM0QjtBQUNEO0FBQzNDO0FBQ1A7QUFDVTtBQUNXO0FBQ1k7QUFDOEM7QUFDbEQ7QUFDMUUsOEJBQThCLHVDQUFVLG1CQUFtQix1VEFBMEU7QUFDckk7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBSSxDQUFDLDhDQUFPLENBQUMsOENBQU87QUFDL0I7QUFDQSxrQkFBa0IsNENBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0ZBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvRkFBZ0I7QUFDN0IsVUFBVSxvRkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDJDQUFjO0FBQ3RFLGtDQUFrQywyQ0FBYztBQUNoRCwyQkFBMkIseUNBQVk7QUFDdkMsc0JBQXNCLHlDQUFZO0FBQ2xDLHdDQUF3QywyQ0FBYztBQUN0RCxzQkFBc0IseUNBQVk7QUFDbEMscUJBQXFCLHlDQUFZO0FBQ2pDO0FBQ0EsWUFBWSx5eEVBQXl4RTtBQUNyeUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFhO0FBQ2xDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSztBQUNMLG9CQUFvQiwwQ0FBYTtBQUNqQyxZQUFZLDhFQUE4RSxFQUFFLG9FQUFjO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLHVGQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDJDQUFjO0FBQ2hFO0FBQ0EsMEJBQTBCLDhDQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0NBQXNDLDBDQUFhO0FBQ25EO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCLHlDQUFZO0FBQzNDO0FBQ0E7QUFDQSxJQUFJLDRDQUFlO0FBQ25CLDhEQUE4RCxpRkFBb0I7QUFDbEYseUJBQXlCLDhDQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQ0FBMEMseUNBQVk7QUFDdEQsNkJBQTZCLDhDQUFpQjtBQUM5QztBQUNBLHFCQUFxQixxRUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQiw4REFBVyxtQkFBbUIsOENBQWlCO0FBQzFFO0FBQ0EsS0FBSztBQUNMLDhCQUE4Qiw4REFBVyxzQkFBc0IsOENBQWlCO0FBQ2hGO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyw4REFBVyx3QkFBd0IsOENBQWlCO0FBQ3BGO0FBQ0EsS0FBSztBQUNMLHVCQUF1Qiw4REFBVyxlQUFlLDhDQUFpQjtBQUNsRSxnQ0FBZ0MsMERBQTBEO0FBQzFGLEtBQUs7QUFDTCxxQkFBcUIsOERBQVcsYUFBYSw4Q0FBaUI7QUFDOUQsOEJBQThCLDBDQUEwQztBQUN4RSxLQUFLO0FBQ0wscUJBQXFCLDhDQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhEQUE4RCxvR0FBb0I7QUFDbEYsd0JBQXdCLDBDQUFhO0FBQ3JDLGVBQWUsd0VBQW9CLENBQUMsc0VBQWtCO0FBQ3RELEtBQUs7QUFDTCx3Q0FBd0MsMkNBQWM7QUFDdEQsd0JBQXdCLDBDQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRCQUE0Qiw4Q0FBaUI7QUFDN0MsMEJBQTBCLGdGQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsc0NBQXNDLEVBQUUscUVBQWM7QUFDaEU7QUFDQTtBQUNBLHlCQUF5QiwwQ0FBYTtBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOENBQThDLDBDQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2Qix5Q0FBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsMENBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRCQUE0Qix5Q0FBWTtBQUN4QyxxREFBcUQsNEVBQXlCO0FBQzlFO0FBQ0E7QUFDQSxJQUFJLGtEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGtEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQix5Q0FBWTtBQUNoQyxrQkFBa0IsOENBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBLGlDQUFpQyw4Q0FBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMERBQTBELDJDQUFjO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMENBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtFQUFTO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtFQUFTO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlDQUFZO0FBQ3ZDO0FBQ0Esa0NBQWtDLDhDQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxRkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFGQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4Q0FBaUI7QUFDcEQsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2Qiw4Q0FBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0VBQW9CO0FBQ3ZDLFNBQVM7QUFDVCxLQUFLO0FBQ0wscUJBQXFCLDhDQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnRkFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0ZBQVk7QUFDckMsa0NBQWtDLDBEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnRkFBWTtBQUNyQyx5QkFBeUIsZ0ZBQVk7QUFDckMseUJBQXlCLGdGQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEIsZ0ZBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtRUFBYTtBQUMzQyxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBLEtBQUs7QUFDTCwyQ0FBMkMsOENBQWlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wscUJBQXFCLDhDQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUdBQXVCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUNBQVk7QUFDdEMsOEJBQThCLHlDQUFZO0FBQzFDLG9CQUFvQix5Q0FBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOENBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EscUNBQXFDLHVGQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsOENBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQix5Q0FBWTtBQUMzQywrQkFBK0IseUNBQVk7QUFDM0MseUJBQXlCLDhDQUFpQjtBQUMxQztBQUNBLGVBQWUsd0VBQW9CO0FBQ25DLEtBQUs7QUFDTCx5QkFBeUIsOENBQWlCO0FBQzFDLDJCQUEyQixvRUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxRkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQU0sb0JBQW9CLHFGQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9GQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msb0ZBQWdCO0FBQ3BEO0FBQ0E7QUFDQSxvQ0FBb0Msb0ZBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQ0FBcUM7QUFDMUUseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvRkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLHdDQUF3QyxvRkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9GQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0ZBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrRUFBZTtBQUM5QztBQUNBO0FBQ0EsK0JBQStCLCtFQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUNBQVk7QUFDakQsb0NBQW9DLHlDQUFZO0FBQ2hELDBCQUEwQix5Q0FBWTtBQUN0QywwQkFBMEIseUNBQVk7QUFDdEMsd0JBQXdCLDhDQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMENBQTBDLDJDQUFjO0FBQ3hELHVDQUF1Qyw4Q0FBaUI7QUFDeEQsMEJBQTBCLCtFQUFlO0FBQ3pDO0FBQ0E7QUFDQSwyQkFBMkIsb0VBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCO0FBQ3BELGlCQUFpQiwwRkFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3RELGlCQUFpQiwwRkFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvRkFBZ0I7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLHlDQUFZO0FBQ3BDLDZCQUE2Qiw4Q0FBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBLCtCQUErQixvRUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkNBQWM7QUFDcEQsd0JBQXdCLDhDQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzREFBc0Q7QUFDekYsaUNBQWlDLHNEQUFzRDtBQUN2RjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hELDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQSxvQkFBb0IsMEZBQVk7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQix1RkFBZSxrQkFBa0IsdUZBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsc0JBQXNCLDhDQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLDhDQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLDhDQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4REFBWTtBQUN2QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlEQUFpRCx1RkFBZSxZQUFZLDBGQUFrQjtBQUM5RixnREFBZ0QscUNBQXFDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMkZBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx5QkFBeUI7QUFDcEY7QUFDQTtBQUNBLHVDQUF1QywrRUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UseUJBQXlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrRUFBZTtBQUNsRCx3REFBd0QseUJBQXlCO0FBQ2pGO0FBQ0E7QUFDQSxrQ0FBa0MsMEVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5QkFBeUI7QUFDNUU7QUFDQTtBQUNBLDBCQUEwQiwrRUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOENBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxtQ0FBbUMsOENBQWlCO0FBQ3BEO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDLDhDQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOERBQVcsZ0JBQWdCLDhDQUFpQjtBQUMxRTtBQUNBO0FBQ0EsK0JBQStCLG9GQUFnQjtBQUMvQztBQUNBLEtBQUs7QUFDTCwrQkFBK0IseUNBQVk7QUFDM0MsNEJBQTRCLDhDQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsOENBQWlCO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMLHVCQUF1Qix5Q0FBWTtBQUNuQyw4QkFBOEIsOENBQWlCO0FBQy9DO0FBQ0EsWUFBWSwwRkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9GQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnRUFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtFQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQkFBMEIsMkVBQTJFO0FBQ3JHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNENBQUs7QUFDbkIsY0FBYyw0Q0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLElBQUksa0VBQWE7QUFDakI7QUFDQTtBQUNBLDRCQUE0Qiw4Q0FBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdFQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0Q0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0Q0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTCwrQkFBK0IsOENBQWlCO0FBQ2hEO0FBQ0EsY0FBYyw0Q0FBSztBQUNuQixjQUFjLDRDQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUNBQXFDO0FBQ2xFO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOENBQWlCO0FBQzdDLHFFQUFxRSwwRkFBa0I7QUFDdkYsb0NBQW9DLHlDQUF5QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNENBQUssbUVBQW1FLDRDQUFLO0FBQzVHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUFhO0FBQ25DLDhCQUE4QixZQUFZO0FBQzFDLEtBQUs7QUFDTCx3QkFBd0IsOENBQWlCO0FBQ3pDO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQSxrRUFBa0UsZ0ZBQVk7QUFDOUU7QUFDQTtBQUNBLHVDQUF1QyxnRkFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9HQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEZBQWtCO0FBQzVDLHVDQUF1QyxnRkFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUZBQWUsWUFBWSwwRkFBa0I7QUFDMUYsb0NBQW9DLGlDQUFpQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0I7QUFDdkUsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLDhDQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0RBQVE7QUFDekM7QUFDQSx5QkFBeUIsb0ZBQWdCO0FBQ3pDLHNCQUFzQixvRkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCLCtEQUFRO0FBQ3pCLDZDQUE2QyxxQkFBcUI7QUFDbEU7QUFDQTtBQUNBLGlCQUFpQiwrREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQVE7QUFDcEI7QUFDQTtBQUNBLDRDQUE0QywrREFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9GQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0RBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvRkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELCtEQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwrREFBUTtBQUNuRTtBQUNBO0FBQ0EsMERBQTBELCtEQUFRO0FBQ2xFO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQVE7QUFDekIscUVBQXFFO0FBQ3JFO0FBQ0EsaUJBQWlCLCtEQUFRO0FBQ3pCLHFFQUFxRTtBQUNyRTtBQUNBLGlCQUFpQiwrREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrREFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQVE7QUFDeEI7QUFDQTtBQUNBLHFCQUFxQiwrREFBUTtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCLCtEQUFRO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQVE7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQiwrREFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrREFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQVE7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQiwrREFBUTtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCLCtEQUFRO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUIsK0RBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFRO0FBQzVCO0FBQ0E7QUFDQSx5QkFBeUIsK0RBQVE7QUFDakM7QUFDQTtBQUNBLHlCQUF5QiwrREFBUTtBQUNqQztBQUNBO0FBQ0EseUJBQXlCLCtEQUFRO0FBQ2pDO0FBQ0E7QUFDQSx5QkFBeUIsK0RBQVE7QUFDakM7QUFDQTtBQUNBLHlCQUF5QiwrREFBUTtBQUNqQztBQUNBO0FBQ0EseUJBQXlCLCtEQUFRO0FBQ2pDO0FBQ0E7QUFDQSx5QkFBeUIsK0RBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFRO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhDQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1RkFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFpQjtBQUMzQztBQUNBO0FBQ0EsaURBQWlELHlCQUF5QjtBQUMxRTtBQUNBLDBCQUEwQiwrRUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixpQkFBaUIsa0dBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4Q0FBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUZBQWUsV0FBVyx1RkFBZTtBQUMxRDtBQUNBLDZDQUE2QywwRkFBa0I7QUFDL0Qsd0JBQXdCLEtBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0ZBQVk7QUFDM0Msb0JBQW9CLDJEQUFNLGdCQUFnQixnRkFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJEQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkRBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZEQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtRUFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdGQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0IscUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw0Q0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdEQUF3RCw0Q0FBSztBQUM3RDtBQUNBO0FBQ0Esc0RBQXNELDRDQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxtRUFBZ0I7QUFDcEIsa0JBQWtCLDhDQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0Isb0ZBQWdCO0FBQ3RDLHlCQUF5QixvRkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksbUVBQWdCO0FBQ3BCLG1DQUFtQyw4Q0FBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlDQUFZO0FBQ3BDO0FBQ0EsSUFBSSxrREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLGtEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLDBDQUFhO0FBQ3RDO0FBQ0EsbUJBQW1CLG9GQUFnQjtBQUNuQztBQUNBLGVBQWUsb0ZBQWdCO0FBQy9CLEtBQUs7QUFDTCxrQ0FBa0MsOENBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsMENBQWE7QUFDekM7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQSxnQkFBZ0IsZ0RBQW1CLENBQUMsMERBQVcsSUFBSTtBQUNuRDtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDtBQUNBLElBQUksc0RBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnREFBZ0Q7QUFDcEc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLDBCQUEwQiw4Q0FBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9GQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsc0NBQXNDLDJDQUFjO0FBQ3BELGtDQUFrQyx5Q0FBWSxDQUFDLCtDQUFRO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMLDRCQUE0Qiw4Q0FBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLHVCQUF1Qiw4Q0FBaUI7QUFDeEM7QUFDQSxLQUFLO0FBQ0wsc0NBQXNDLDBDQUFhO0FBQ25EO0FBQ0EsdUVBQXVFLG9FQUFpQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0IsUUFBUSxvQkFBb0I7QUFDbkUsS0FBSztBQUNMLHFCQUFxQiwwQ0FBYTtBQUNsQyxlQUFlLGdFQUFZO0FBQzNCLEtBQUs7QUFDTCxZQUFZLGdEQUFtQixDQUFDLDREQUFZLGFBQWEsb0JBQW9CO0FBQzdFLFFBQVEsZ0RBQW1CLENBQUMsd0dBQW1CLElBQUksc0dBQXNHO0FBQ3pKLFlBQVksZ0RBQW1CLENBQUMsdUZBQWMsSUFBSSwrbUZBQSttRjtBQUNqcUY7QUFDQSxzQ0FBc0MsZ0RBQW1CLENBQUMsMkNBQWMsSUFBSSxnQkFBZ0I7QUFDNUYsZ0JBQWdCLGdEQUFtQiwwQkFBMEIsdVhBQXVYO0FBQ3BiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDTyxtQkFBbUIsNkNBQWdCO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvZGF0YS1lZGl0b3IuanM/Y2ZmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBzb25hcmpzL25vLWR1cGxpY2F0ZS1zdHJpbmcgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnROZXZlciwgbWF5YmUgfSBmcm9tIFwiLi4vY29tbW9uL3N1cHBvcnQuanNcIjtcbmltcG9ydCBjbGFtcCBmcm9tIFwibG9kYXNoL2NsYW1wLmpzXCI7XG5pbXBvcnQgdW5pcSBmcm9tIFwibG9kYXNoL3VuaXEuanNcIjtcbmltcG9ydCBmbGF0dGVuIGZyb20gXCJsb2Rhc2gvZmxhdHRlbi5qc1wiO1xuaW1wb3J0IHJhbmdlIGZyb20gXCJsb2Rhc2gvcmFuZ2UuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwibG9kYXNoL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgeyBHcmlkQ2VsbEtpbmQsIGlzRWRpdGFibGVHcmlkQ2VsbCwgaXNSZWFkV3JpdGVDZWxsLCBJbm5lckdyaWRDZWxsS2luZCwgQ29tcGFjdFNlbGVjdGlvbiwgaXNJbm5lck9ubHlDZWxsLCBpc09iamVjdEVkaXRvckNhbGxiYWNrUmVzdWx0LCBCb29sZWFuRW1wdHksIEJvb2xlYW5JbmRldGVybWluYXRlLCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5pbXBvcnQgRGF0YUdyaWRTZWFyY2gsIHt9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQtc2VhcmNoL2RhdGEtZ3JpZC1zZWFyY2guanNcIjtcbmltcG9ydCB7IGJyb3dzZXJJc09TWCB9IGZyb20gXCIuLi9jb21tb24vYnJvd3Nlci1kZXRlY3QuanNcIjtcbmltcG9ydCB7IGdldERhdGFFZGl0b3JUaGVtZSwgbWFrZUNTU1N0eWxlLCBUaGVtZUNvbnRleHQsIG1lcmdlQW5kUmVhbGl6ZVRoZW1lLCB9IGZyb20gXCIuLi9jb21tb24vc3R5bGVzLmpzXCI7XG5pbXBvcnQgeyBnZXRTY3JvbGxCYXJXaWR0aCwgdXNlRXZlbnRMaXN0ZW5lciwgdXNlU3RhdGVXaXRoUmVhY3RpdmVJbnB1dCwgd2hlbkRlZmluZWQgfSBmcm9tIFwiLi4vY29tbW9uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBpc0dyb3VwRXF1YWwsIGl0ZW1zQXJlRXF1YWwsIGl0ZW1Jc0luUmVjdCwgZ3JpZFNlbGVjdGlvbkhhc0l0ZW0sIGdldEZyZWV6ZVRyYWlsaW5nSGVpZ2h0LCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RhdGEtZ3JpZC1saWIuanNcIjtcbmltcG9ydCB7IEdyb3VwUmVuYW1lIH0gZnJvbSBcIi4vZ3JvdXAtcmVuYW1lLmpzXCI7XG5pbXBvcnQgeyBtZWFzdXJlQ29sdW1uLCB1c2VDb2x1bW5TaXplciB9IGZyb20gXCIuL3VzZS1jb2x1bW4tc2l6ZXIuanNcIjtcbmltcG9ydCB7IGlzSG90a2V5IH0gZnJvbSBcIi4uL2NvbW1vbi9pcy1ob3RrZXkuanNcIjtcbmltcG9ydCB7IHVzZVNlbGVjdGlvbkJlaGF2aW9yIH0gZnJvbSBcIi4uL2ludGVybmFsL2RhdGEtZ3JpZC91c2Utc2VsZWN0aW9uLWJlaGF2aW9yLmpzXCI7XG5pbXBvcnQgeyB1c2VDZWxsc0ZvclNlbGVjdGlvbiB9IGZyb20gXCIuL3VzZS1jZWxscy1mb3Itc2VsZWN0aW9uLmpzXCI7XG5pbXBvcnQgeyB1bnF1b3RlLCBleHBhbmRTZWxlY3Rpb24sIGNvcHlUb0NsaXBib2FyZCwgdG9nZ2xlQm9vbGVhbiB9IGZyb20gXCIuL2RhdGEtZWRpdG9yLWZucy5qc1wiO1xuaW1wb3J0IHsgRGF0YUVkaXRvckNvbnRhaW5lciB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWVkaXRvci1jb250YWluZXIvZGF0YS1ncmlkLWNvbnRhaW5lci5qc1wiO1xuaW1wb3J0IHsgdXNlQXV0b3Njcm9sbCB9IGZyb20gXCIuL3VzZS1hdXRvc2Nyb2xsLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVIVE1MIH0gZnJvbSBcIi4vY29weS1wYXN0ZS5qc1wiO1xuaW1wb3J0IHsgdXNlUmVtQWRqdXN0ZXIgfSBmcm9tIFwiLi91c2UtcmVtLWFkanVzdGVyLmpzXCI7XG5pbXBvcnQgeyB3aXRoQWxwaGEgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL2NvbG9yLXBhcnNlci5qc1wiO1xuaW1wb3J0IHsgY29tYmluZVJlY3RzLCBnZXRDbG9zZXN0UmVjdCwgcG9pbnRJblJlY3QgfSBmcm9tIFwiLi4vY29tbW9uL21hdGguanNcIjtcbmltcG9ydCB7IGdyb3VwSGVhZGVyS2luZCwgb3V0T2ZCb3VuZHNLaW5kLCBoZWFkZXJLaW5kLCBtb3VzZUV2ZW50QXJnc0FyZUVxdWFsLCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvZXZlbnQtYXJncy5qc1wiO1xuaW1wb3J0IHsgdXNlS2V5YmluZGluZ3NXaXRoRGVmYXVsdHMgfSBmcm9tIFwiLi9kYXRhLWVkaXRvci1rZXliaW5kaW5ncy5qc1wiO1xuY29uc3QgRGF0YUdyaWRPdmVybGF5RWRpdG9yID0gUmVhY3QubGF6eShhc3luYyAoKSA9PiBhd2FpdCBpbXBvcnQoXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yLmpzXCIpKTtcbi8vIFRoZXJlIG11c3QgYmUgYSBiZXR0ZXIgd2F5XG5sZXQgaWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIGdldFNwYW5TdG9wcyhjZWxscykge1xuICAgIHJldHVybiB1bmlxKGZsYXR0ZW4oZmxhdHRlbihjZWxscylcbiAgICAgICAgLmZpbHRlcihjID0+IGMuc3BhbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAubWFwKGMgPT4gcmFuZ2UoKGMuc3Bhbj8uWzBdID8/IDApICsgMSwgKGMuc3Bhbj8uWzFdID8/IDApICsgMSkpKSk7XG59XG5mdW5jdGlvbiBzaGlmdFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0KSB7XG4gICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQgfHwgb2Zmc2V0ID09PSAwIHx8IChpbnB1dC5jb2x1bW5zLmxlbmd0aCA9PT0gMCAmJiBpbnB1dC5jdXJyZW50ID09PSB1bmRlZmluZWQpKVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudDogaW5wdXQuY3VycmVudCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgY2VsbDogW2lucHV0LmN1cnJlbnQuY2VsbFswXSArIG9mZnNldCwgaW5wdXQuY3VycmVudC5jZWxsWzFdXSxcbiAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5pbnB1dC5jdXJyZW50LnJhbmdlLFxuICAgICAgICAgICAgICAgICAgICB4OiBpbnB1dC5jdXJyZW50LnJhbmdlLnggKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByYW5nZVN0YWNrOiBpbnB1dC5jdXJyZW50LnJhbmdlU3RhY2subWFwKHIgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucixcbiAgICAgICAgICAgICAgICAgICAgeDogci54ICsgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHJvd3M6IGlucHV0LnJvd3MsXG4gICAgICAgIGNvbHVtbnM6IGlucHV0LmNvbHVtbnMub2Zmc2V0KG9mZnNldCksXG4gICAgfTtcbn1cbmNvbnN0IGxvYWRpbmdDZWxsID0ge1xuICAgIGtpbmQ6IEdyaWRDZWxsS2luZC5Mb2FkaW5nLFxuICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG59O1xuY29uc3QgZW1wdHlHcmlkU2VsZWN0aW9uID0ge1xuICAgIGNvbHVtbnM6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgY3VycmVudDogdW5kZWZpbmVkLFxufTtcbmNvbnN0IERhdGFFZGl0b3JJbXBsID0gKHAsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IFtncmlkU2VsZWN0aW9uSW5uZXIsIHNldEdyaWRTZWxlY3Rpb25Jbm5lcl0gPSBSZWFjdC51c2VTdGF0ZShlbXB0eUdyaWRTZWxlY3Rpb24pO1xuICAgIGNvbnN0IFtvdmVybGF5LCBzZXRPdmVybGF5XSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgY29uc3Qgc2VhcmNoSW5wdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY2FudmFzUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IFttb3VzZVN0YXRlLCBzZXRNb3VzZVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgY29uc3Qgc2Nyb2xsUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGxhc3RTZW50ID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3Qgc2FmZVdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogd2luZG93O1xuICAgIGNvbnN0IHsgaW1hZ2VFZGl0b3JPdmVycmlkZSwgZ2V0Um93VGhlbWVPdmVycmlkZSwgbWFya2Rvd25EaXZDcmVhdGVOb2RlLCB3aWR0aCwgaGVpZ2h0LCBjb2x1bW5zOiBjb2x1bW5zSW4sIHJvd3MsIGdldENlbGxDb250ZW50LCBvbkNlbGxDbGlja2VkLCBvbkNlbGxBY3RpdmF0ZWQsIG9uRmlsbFBhdHRlcm4sIG9uRmluaXNoZWRFZGl0aW5nLCBjb2VyY2VQYXN0ZVZhbHVlLCBkcmF3SGVhZGVyOiBkcmF3SGVhZGVySW4sIGRyYXdDZWxsOiBkcmF3Q2VsbEluLCBlZGl0b3JCbG9vbSwgb25IZWFkZXJDbGlja2VkLCBvbkNvbHVtblByb3Bvc2VNb3ZlLCBzcGFuUmFuZ2VCZWhhdmlvciA9IFwiZGVmYXVsdFwiLCBvbkdyb3VwSGVhZGVyQ2xpY2tlZCwgb25DZWxsQ29udGV4dE1lbnUsIGNsYXNzTmFtZSwgb25IZWFkZXJDb250ZXh0TWVudSwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb246IGdldENlbGxzRm9yU2VsZWN0aW9uSW4sIG9uR3JvdXBIZWFkZXJDb250ZXh0TWVudSwgb25Hcm91cEhlYWRlclJlbmFtZWQsIG9uQ2VsbEVkaXRlZCwgb25DZWxsc0VkaXRlZCwgb25TZWFyY2hSZXN1bHRzQ2hhbmdlZDogb25TZWFyY2hSZXN1bHRzQ2hhbmdlZEluLCBzZWFyY2hSZXN1bHRzLCBvblNlYXJjaFZhbHVlQ2hhbmdlLCBzZWFyY2hWYWx1ZSwgb25LZXlEb3duOiBvbktleURvd25Jbiwgb25LZXlVcDogb25LZXlVcEluLCBrZXliaW5kaW5nczoga2V5YmluZGluZ3NJbiwgZWRpdE9uVHlwZSA9IHRydWUsIG9uUm93QXBwZW5kZWQsIG9uQ29sdW1uTW92ZWQsIHZhbGlkYXRlQ2VsbDogdmFsaWRhdGVDZWxsSW4sIGhpZ2hsaWdodFJlZ2lvbnM6IGhpZ2hsaWdodFJlZ2lvbnNJbiwgcmFuZ2VTZWxlY3QgPSBcInJlY3RcIiwgY29sdW1uU2VsZWN0ID0gXCJtdWx0aVwiLCByb3dTZWxlY3QgPSBcIm11bHRpXCIsIHJhbmdlU2VsZWN0aW9uQmxlbmRpbmcgPSBcImV4Y2x1c2l2ZVwiLCBjb2x1bW5TZWxlY3Rpb25CbGVuZGluZyA9IFwiZXhjbHVzaXZlXCIsIHJvd1NlbGVjdGlvbkJsZW5kaW5nID0gXCJleGNsdXNpdmVcIiwgb25EZWxldGU6IG9uRGVsZXRlSW4sIG9uRHJhZ1N0YXJ0LCBvbk1vdXNlTW92ZSwgb25QYXN0ZSwgY29weUhlYWRlcnMgPSBmYWxzZSwgZnJlZXplQ29sdW1ucyA9IDAsIGNlbGxBY3RpdmF0aW9uQmVoYXZpb3IgPSBcInNlY29uZC1jbGlja1wiLCByb3dTZWxlY3Rpb25Nb2RlID0gXCJhdXRvXCIsIG9uSGVhZGVyTWVudUNsaWNrLCBnZXRHcm91cERldGFpbHMsIG9uU2VhcmNoQ2xvc2U6IG9uU2VhcmNoQ2xvc2VJbiwgb25JdGVtSG92ZXJlZCwgb25TZWxlY3Rpb25DbGVhcmVkLCBzaG93U2VhcmNoOiBzaG93U2VhcmNoSW4sIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQsIGdyaWRTZWxlY3Rpb246IGdyaWRTZWxlY3Rpb25PdXRlciwgb25HcmlkU2VsZWN0aW9uQ2hhbmdlLCBtaW5Db2x1bW5XaWR0aDogbWluQ29sdW1uV2lkdGhJbiA9IDUwLCBtYXhDb2x1bW5XaWR0aDogbWF4Q29sdW1uV2lkdGhJbiA9IDUwMCwgbWF4Q29sdW1uQXV0b1dpZHRoOiBtYXhDb2x1bW5BdXRvV2lkdGhJbiwgcHJvdmlkZUVkaXRvciwgdHJhaWxpbmdSb3dPcHRpb25zLCBmcmVlemVUcmFpbGluZ1Jvd3MgPSAwLCBhbGxvd2VkRmlsbERpcmVjdGlvbnMgPSBcIm9ydGhvZ29uYWxcIiwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSwgdmVydGljYWxCb3JkZXIsIG9uRHJhZ092ZXJDZWxsLCBvbkRyb3AsIG9uQ29sdW1uUmVzaXplOiBvbkNvbHVtblJlc2l6ZUluLCBvbkNvbHVtblJlc2l6ZUVuZDogb25Db2x1bW5SZXNpemVFbmRJbiwgb25Db2x1bW5SZXNpemVTdGFydDogb25Db2x1bW5SZXNpemVTdGFydEluLCBjdXN0b21SZW5kZXJlcnM6IGFkZGl0aW9uYWxSZW5kZXJlcnMsIGZpbGxIYW5kbGUsIGRyYXdGb2N1c1JpbmcgPSB0cnVlLCBleHBlcmltZW50YWwsIGZpeGVkU2hhZG93WCwgZml4ZWRTaGFkb3dZLCBoZWFkZXJJY29ucywgaW1hZ2VXaW5kb3dMb2FkZXIsIGluaXRpYWxTaXplLCBpc0RyYWdnYWJsZSwgb25EcmFnTGVhdmUsIG9uUm93TW92ZWQsIG92ZXJzY3JvbGxYOiBvdmVyc2Nyb2xsWEluLCBvdmVyc2Nyb2xsWTogb3ZlcnNjcm9sbFlJbiwgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCByaWdodEVsZW1lbnQsIHJpZ2h0RWxlbWVudFByb3BzLCB0cmFwRm9jdXMgPSBmYWxzZSwgc21vb3RoU2Nyb2xsWCwgc21vb3RoU2Nyb2xsWSwgc2NhbGVUb1JlbSA9IGZhbHNlLCByb3dIZWlnaHQ6IHJvd0hlaWdodEluID0gMzQsIGhlYWRlckhlaWdodDogaGVhZGVySGVpZ2h0SW4gPSAzNiwgZ3JvdXBIZWFkZXJIZWlnaHQ6IGdyb3VwSGVhZGVySGVpZ2h0SW4gPSBoZWFkZXJIZWlnaHRJbiwgdGhlbWU6IHRoZW1lSW4sIGlzT3V0c2lkZUNsaWNrLCByZW5kZXJlcnMsIH0gPSBwO1xuICAgIGNvbnN0IHJvd01hcmtlcnNPYmogPSB0eXBlb2YgcC5yb3dNYXJrZXJzID09PSBcInN0cmluZ1wiID8gdW5kZWZpbmVkIDogcC5yb3dNYXJrZXJzO1xuICAgIGNvbnN0IHJvd01hcmtlcnMgPSByb3dNYXJrZXJzT2JqPy5raW5kID8/IHAucm93TWFya2VycyA/PyBcIm5vbmVcIjtcbiAgICBjb25zdCByb3dNYXJrZXJXaWR0aFJhdyA9IHJvd01hcmtlcnNPYmo/LndpZHRoID8/IHAucm93TWFya2VyV2lkdGg7XG4gICAgY29uc3Qgcm93TWFya2VyU3RhcnRJbmRleCA9IHJvd01hcmtlcnNPYmo/LnN0YXJ0SW5kZXggPz8gcC5yb3dNYXJrZXJTdGFydEluZGV4ID8/IDE7XG4gICAgY29uc3Qgcm93TWFya2VyVGhlbWUgPSByb3dNYXJrZXJzT2JqPy50aGVtZSA/PyBwLnJvd01hcmtlclRoZW1lO1xuICAgIGNvbnN0IHJvd01hcmtlckNoZWNrYm94U3R5bGUgPSByb3dNYXJrZXJzT2JqPy5jaGVja2JveFN0eWxlID8/IFwic3F1YXJlXCI7XG4gICAgY29uc3QgbWluQ29sdW1uV2lkdGggPSBNYXRoLm1heChtaW5Db2x1bW5XaWR0aEluLCAyMCk7XG4gICAgY29uc3QgbWF4Q29sdW1uV2lkdGggPSBNYXRoLm1heChtYXhDb2x1bW5XaWR0aEluLCBtaW5Db2x1bW5XaWR0aCk7XG4gICAgY29uc3QgbWF4Q29sdW1uQXV0b1dpZHRoID0gTWF0aC5tYXgobWF4Q29sdW1uQXV0b1dpZHRoSW4gPz8gbWF4Q29sdW1uV2lkdGgsIG1pbkNvbHVtbldpZHRoKTtcbiAgICBjb25zdCBkb2NTdHlsZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybiB7IGZvbnRTaXplOiBcIjE2cHhcIiB9O1xuICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgcmVtU2l6ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gTnVtYmVyLnBhcnNlRmxvYXQoZG9jU3R5bGUuZm9udFNpemUpLCBbZG9jU3R5bGVdKTtcbiAgICBjb25zdCB7IHJvd0hlaWdodCwgaGVhZGVySGVpZ2h0LCBncm91cEhlYWRlckhlaWdodCwgdGhlbWUsIG92ZXJzY3JvbGxYLCBvdmVyc2Nyb2xsWSB9ID0gdXNlUmVtQWRqdXN0ZXIoe1xuICAgICAgICBncm91cEhlYWRlckhlaWdodDogZ3JvdXBIZWFkZXJIZWlnaHRJbixcbiAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRJbixcbiAgICAgICAgb3ZlcnNjcm9sbFg6IG92ZXJzY3JvbGxYSW4sXG4gICAgICAgIG92ZXJzY3JvbGxZOiBvdmVyc2Nyb2xsWUluLFxuICAgICAgICByZW1TaXplLFxuICAgICAgICByb3dIZWlnaHQ6IHJvd0hlaWdodEluLFxuICAgICAgICBzY2FsZVRvUmVtLFxuICAgICAgICB0aGVtZTogdGhlbWVJbixcbiAgICB9KTtcbiAgICBjb25zdCBrZXliaW5kaW5ncyA9IHVzZUtleWJpbmRpbmdzV2l0aERlZmF1bHRzKGtleWJpbmRpbmdzSW4pO1xuICAgIGNvbnN0IHJvd01hcmtlcldpZHRoID0gcm93TWFya2VyV2lkdGhSYXcgPz8gKHJvd3MgPiAxMDAwMCA/IDQ4IDogcm93cyA+IDEwMDAgPyA0NCA6IHJvd3MgPiAxMDAgPyAzNiA6IDMyKTtcbiAgICBjb25zdCBoYXNSb3dNYXJrZXJzID0gcm93TWFya2VycyAhPT0gXCJub25lXCI7XG4gICAgY29uc3Qgcm93TWFya2VyT2Zmc2V0ID0gaGFzUm93TWFya2VycyA/IDEgOiAwO1xuICAgIGNvbnN0IHNob3dUcmFpbGluZ0JsYW5rUm93ID0gb25Sb3dBcHBlbmRlZCAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxhc3RSb3dTdGlja3kgPSB0cmFpbGluZ1Jvd09wdGlvbnM/LnN0aWNreSA9PT0gdHJ1ZTtcbiAgICBjb25zdCBbc2hvd1NlYXJjaElubmVyLCBzZXRTaG93U2VhcmNoSW5uZXJdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHNob3dTZWFyY2ggPSBzaG93U2VhcmNoSW4gPz8gc2hvd1NlYXJjaElubmVyO1xuICAgIGNvbnN0IG9uU2VhcmNoQ2xvc2UgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChvblNlYXJjaENsb3NlSW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb25TZWFyY2hDbG9zZUluKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRTaG93U2VhcmNoSW5uZXIoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgW29uU2VhcmNoQ2xvc2VJbl0pO1xuICAgIGNvbnN0IGdyaWRTZWxlY3Rpb25PdXRlck1hbmdsZWQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGdyaWRTZWxlY3Rpb25PdXRlciA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2hpZnRTZWxlY3Rpb24oZ3JpZFNlbGVjdGlvbk91dGVyLCByb3dNYXJrZXJPZmZzZXQpO1xuICAgIH0sIFtncmlkU2VsZWN0aW9uT3V0ZXIsIHJvd01hcmtlck9mZnNldF0pO1xuICAgIGNvbnN0IGdyaWRTZWxlY3Rpb24gPSBncmlkU2VsZWN0aW9uT3V0ZXJNYW5nbGVkID8/IGdyaWRTZWxlY3Rpb25Jbm5lcjtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXJSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+ICgpID0+IGFib3J0Q29udHJvbGxlclJlZj8uY3VycmVudC5hYm9ydCgpLCBbXSk7XG4gICAgY29uc3QgW2dldENlbGxzRm9yU2VsZWN0aW9uLCBnZXRDZWxsc0ZvclNlbGV0aW9uRGlyZWN0XSA9IHVzZUNlbGxzRm9yU2VsZWN0aW9uKGdldENlbGxzRm9yU2VsZWN0aW9uSW4sIGdldENlbGxDb250ZW50LCByb3dNYXJrZXJPZmZzZXQsIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LCByb3dzKTtcbiAgICBjb25zdCB2YWxpZGF0ZUNlbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoY2VsbCwgbmV3VmFsdWUsIHByZXZWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsaWRhdGVDZWxsSW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBpdGVtID0gW2NlbGxbMF0gLSByb3dNYXJrZXJPZmZzZXQsIGNlbGxbMV1dO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVDZWxsSW4/LihpdGVtLCBuZXdWYWx1ZSwgcHJldlZhbHVlKTtcbiAgICB9LCBbcm93TWFya2VyT2Zmc2V0LCB2YWxpZGF0ZUNlbGxJbl0pO1xuICAgIGNvbnN0IGV4cGVjdGVkRXh0ZXJuYWxHcmlkU2VsZWN0aW9uID0gUmVhY3QudXNlUmVmKGdyaWRTZWxlY3Rpb25PdXRlcik7XG4gICAgY29uc3Qgc2V0R3JpZFNlbGVjdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdWYWwsIGV4cGFuZCkgPT4ge1xuICAgICAgICBpZiAoZXhwYW5kKSB7XG4gICAgICAgICAgICBuZXdWYWwgPSBleHBhbmRTZWxlY3Rpb24obmV3VmFsLCBnZXRDZWxsc0ZvclNlbGVjdGlvbiwgcm93TWFya2VyT2Zmc2V0LCBzcGFuUmFuZ2VCZWhhdmlvciwgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkdyaWRTZWxlY3Rpb25DaGFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRFeHRlcm5hbEdyaWRTZWxlY3Rpb24uY3VycmVudCA9IHNoaWZ0U2VsZWN0aW9uKG5ld1ZhbCwgLXJvd01hcmtlck9mZnNldCk7XG4gICAgICAgICAgICBvbkdyaWRTZWxlY3Rpb25DaGFuZ2UoZXhwZWN0ZWRFeHRlcm5hbEdyaWRTZWxlY3Rpb24uY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRHcmlkU2VsZWN0aW9uSW5uZXIobmV3VmFsKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkdyaWRTZWxlY3Rpb25DaGFuZ2UsIGdldENlbGxzRm9yU2VsZWN0aW9uLCByb3dNYXJrZXJPZmZzZXQsIHNwYW5SYW5nZUJlaGF2aW9yXSk7XG4gICAgY29uc3Qgb25Db2x1bW5SZXNpemUgPSB3aGVuRGVmaW5lZChvbkNvbHVtblJlc2l6ZUluLCBSZWFjdC51c2VDYWxsYmFjaygoXywgdywgaW5kLCB3ZykgPT4ge1xuICAgICAgICBvbkNvbHVtblJlc2l6ZUluPy4oY29sdW1uc0luW2luZCAtIHJvd01hcmtlck9mZnNldF0sIHcsIGluZCAtIHJvd01hcmtlck9mZnNldCwgd2cpO1xuICAgIH0sIFtvbkNvbHVtblJlc2l6ZUluLCByb3dNYXJrZXJPZmZzZXQsIGNvbHVtbnNJbl0pKTtcbiAgICBjb25zdCBvbkNvbHVtblJlc2l6ZUVuZCA9IHdoZW5EZWZpbmVkKG9uQ29sdW1uUmVzaXplRW5kSW4sIFJlYWN0LnVzZUNhbGxiYWNrKChfLCB3LCBpbmQsIHdnKSA9PiB7XG4gICAgICAgIG9uQ29sdW1uUmVzaXplRW5kSW4/Lihjb2x1bW5zSW5baW5kIC0gcm93TWFya2VyT2Zmc2V0XSwgdywgaW5kIC0gcm93TWFya2VyT2Zmc2V0LCB3Zyk7XG4gICAgfSwgW29uQ29sdW1uUmVzaXplRW5kSW4sIHJvd01hcmtlck9mZnNldCwgY29sdW1uc0luXSkpO1xuICAgIGNvbnN0IG9uQ29sdW1uUmVzaXplU3RhcnQgPSB3aGVuRGVmaW5lZChvbkNvbHVtblJlc2l6ZVN0YXJ0SW4sIFJlYWN0LnVzZUNhbGxiYWNrKChfLCB3LCBpbmQsIHdnKSA9PiB7XG4gICAgICAgIG9uQ29sdW1uUmVzaXplU3RhcnRJbj8uKGNvbHVtbnNJbltpbmQgLSByb3dNYXJrZXJPZmZzZXRdLCB3LCBpbmQgLSByb3dNYXJrZXJPZmZzZXQsIHdnKTtcbiAgICB9LCBbb25Db2x1bW5SZXNpemVTdGFydEluLCByb3dNYXJrZXJPZmZzZXQsIGNvbHVtbnNJbl0pKTtcbiAgICBjb25zdCBkcmF3SGVhZGVyID0gd2hlbkRlZmluZWQoZHJhd0hlYWRlckluLCBSZWFjdC51c2VDYWxsYmFjaygoYXJncywgZHJhdykgPT4ge1xuICAgICAgICByZXR1cm4gZHJhd0hlYWRlckluPy4oeyAuLi5hcmdzLCBjb2x1bW5JbmRleDogYXJncy5jb2x1bW5JbmRleCAtIHJvd01hcmtlck9mZnNldCB9LCBkcmF3KSA/PyBmYWxzZTtcbiAgICB9LCBbZHJhd0hlYWRlckluLCByb3dNYXJrZXJPZmZzZXRdKSk7XG4gICAgY29uc3QgZHJhd0NlbGwgPSB3aGVuRGVmaW5lZChkcmF3Q2VsbEluLCBSZWFjdC51c2VDYWxsYmFjaygoYXJncywgZHJhdykgPT4ge1xuICAgICAgICByZXR1cm4gZHJhd0NlbGxJbj8uKHsgLi4uYXJncywgY29sOiBhcmdzLmNvbCAtIHJvd01hcmtlck9mZnNldCB9LCBkcmF3KSA/PyBmYWxzZTtcbiAgICB9LCBbZHJhd0NlbGxJbiwgcm93TWFya2VyT2Zmc2V0XSkpO1xuICAgIGNvbnN0IG9uRGVsZXRlID0gUmVhY3QudXNlQ2FsbGJhY2soc2VsID0+IHtcbiAgICAgICAgaWYgKG9uRGVsZXRlSW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb25EZWxldGVJbihzaGlmdFNlbGVjdGlvbihzZWwsIC1yb3dNYXJrZXJPZmZzZXQpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2hpZnRTZWxlY3Rpb24ocmVzdWx0LCByb3dNYXJrZXJPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIFtvbkRlbGV0ZUluLCByb3dNYXJrZXJPZmZzZXRdKTtcbiAgICBjb25zdCBbc2V0Q3VycmVudCwgc2V0U2VsZWN0ZWRSb3dzLCBzZXRTZWxlY3RlZENvbHVtbnNdID0gdXNlU2VsZWN0aW9uQmVoYXZpb3IoZ3JpZFNlbGVjdGlvbiwgc2V0R3JpZFNlbGVjdGlvbiwgcmFuZ2VTZWxlY3Rpb25CbGVuZGluZywgY29sdW1uU2VsZWN0aW9uQmxlbmRpbmcsIHJvd1NlbGVjdGlvbkJsZW5kaW5nLCByYW5nZVNlbGVjdCk7XG4gICAgY29uc3QgbWVyZ2VkVGhlbWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG1lcmdlQW5kUmVhbGl6ZVRoZW1lKGdldERhdGFFZGl0b3JUaGVtZSgpLCB0aGVtZSk7XG4gICAgfSwgW3RoZW1lXSk7XG4gICAgY29uc3QgW2NsaWVudFNpemUsIHNldENsaWVudFNpemVdID0gUmVhY3QudXNlU3RhdGUoWzAsIDAsIDBdKTtcbiAgICBjb25zdCByZW5kZXJlck1hcCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAocmVuZGVyZXJzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHIgb2YgcmVuZGVyZXJzKSB7XG4gICAgICAgICAgICByZXN1bHRbci5raW5kXSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbcmVuZGVyZXJzXSk7XG4gICAgY29uc3QgZ2V0Q2VsbFJlbmRlcmVyID0gUmVhY3QudXNlQ2FsbGJhY2soKGNlbGwpID0+IHtcbiAgICAgICAgaWYgKGNlbGwua2luZCAhPT0gR3JpZENlbGxLaW5kLkN1c3RvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyTWFwW2NlbGwua2luZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWxSZW5kZXJlcnM/LmZpbmQoeCA9PiB4LmlzTWF0Y2goY2VsbCkpO1xuICAgIH0sIFthZGRpdGlvbmFsUmVuZGVyZXJzLCByZW5kZXJlck1hcF0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQgeyBzaXplZENvbHVtbnM6IGNvbHVtbnMsIG5vbkdyb3dXaWR0aCB9ID0gdXNlQ29sdW1uU2l6ZXIoY29sdW1uc0luLCByb3dzLCBnZXRDZWxsc0ZvclNlbGV0aW9uRGlyZWN0LCBjbGllbnRTaXplWzBdIC0gKHJvd01hcmtlck9mZnNldCA9PT0gMCA/IDAgOiByb3dNYXJrZXJXaWR0aCkgLSBjbGllbnRTaXplWzJdLCBtaW5Db2x1bW5XaWR0aCwgbWF4Q29sdW1uQXV0b1dpZHRoLCBtZXJnZWRUaGVtZSwgZ2V0Q2VsbFJlbmRlcmVyLCBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCk7XG4gICAgaWYgKHJvd01hcmtlcnMgIT09IFwibm9uZVwiKVxuICAgICAgICBub25Hcm93V2lkdGggKz0gcm93TWFya2VyV2lkdGg7XG4gICAgY29uc3QgZW5hYmxlR3JvdXBzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLnNvbWUoYyA9PiBjLmdyb3VwICE9PSB1bmRlZmluZWQpO1xuICAgIH0sIFtjb2x1bW5zXSk7XG4gICAgY29uc3QgdG90YWxIZWFkZXJIZWlnaHQgPSBlbmFibGVHcm91cHMgPyBoZWFkZXJIZWlnaHQgKyBncm91cEhlYWRlckhlaWdodCA6IGhlYWRlckhlaWdodDtcbiAgICBjb25zdCBudW1TZWxlY3RlZFJvd3MgPSBncmlkU2VsZWN0aW9uLnJvd3MubGVuZ3RoO1xuICAgIGNvbnN0IHJvd01hcmtlckNoZWNrZWQgPSByb3dNYXJrZXJzID09PSBcIm5vbmVcIiA/IHVuZGVmaW5lZCA6IG51bVNlbGVjdGVkUm93cyA9PT0gMCA/IGZhbHNlIDogbnVtU2VsZWN0ZWRSb3dzID09PSByb3dzID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBtYW5nbGVkQ29scyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAocm93TWFya2VycyA9PT0gXCJub25lXCIpXG4gICAgICAgICAgICByZXR1cm4gY29sdW1ucztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogcm93TWFya2VyV2lkdGgsXG4gICAgICAgICAgICAgICAgaWNvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGhhc01lbnU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIHRoZW1lT3ZlcnJpZGU6IHJvd01hcmtlclRoZW1lLFxuICAgICAgICAgICAgICAgIHJvd01hcmtlcjogcm93TWFya2VyQ2hlY2tib3hTdHlsZSxcbiAgICAgICAgICAgICAgICByb3dNYXJrZXJDaGVja2VkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLmNvbHVtbnMsXG4gICAgICAgIF07XG4gICAgfSwgW3Jvd01hcmtlcnMsIGNvbHVtbnMsIHJvd01hcmtlcldpZHRoLCByb3dNYXJrZXJUaGVtZSwgcm93TWFya2VyQ2hlY2tib3hTdHlsZSwgcm93TWFya2VyQ2hlY2tlZF0pO1xuICAgIGNvbnN0IFt2aXNpYmxlUmVnaW9uWSwgdmlzaWJsZVJlZ2lvblR5XSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2Nyb2xsT2Zmc2V0WSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIgPyBNYXRoLmZsb29yKHNjcm9sbE9mZnNldFkgLyByb3dIZWlnaHQpIDogMCxcbiAgICAgICAgICAgIHNjcm9sbE9mZnNldFkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygcm93SGVpZ2h0ID09PSBcIm51bWJlclwiID8gLShzY3JvbGxPZmZzZXRZICUgcm93SGVpZ2h0KSA6IDAsXG4gICAgICAgIF07XG4gICAgfSwgW3Njcm9sbE9mZnNldFksIHJvd0hlaWdodF0pO1xuICAgIGNvbnN0IHZpc2libGVSZWdpb25SZWYgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgIH0pO1xuICAgIGNvbnN0IHZpc2libGVSZWdpb25JbnB1dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgeDogdmlzaWJsZVJlZ2lvblJlZi5jdXJyZW50LngsXG4gICAgICAgIHk6IHZpc2libGVSZWdpb25ZLFxuICAgICAgICB3aWR0aDogdmlzaWJsZVJlZ2lvblJlZi5jdXJyZW50LndpZHRoID8/IDEsXG4gICAgICAgIGhlaWdodDogdmlzaWJsZVJlZ2lvblJlZi5jdXJyZW50LmhlaWdodCA/PyAxLFxuICAgICAgICAvLyB0eDogJ1RPRE8nLFxuICAgICAgICB0eTogdmlzaWJsZVJlZ2lvblR5LFxuICAgIH0pLCBbdmlzaWJsZVJlZ2lvblR5LCB2aXNpYmxlUmVnaW9uWV0pO1xuICAgIGNvbnN0IGhhc0p1c3RTY3JvbGxlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgW3Zpc2libGVSZWdpb24sIHNldFZpc2libGVSZWdpb24sIGVtcHR5XSA9IHVzZVN0YXRlV2l0aFJlYWN0aXZlSW5wdXQodmlzaWJsZVJlZ2lvbklucHV0KTtcbiAgICB2aXNpYmxlUmVnaW9uUmVmLmN1cnJlbnQgPSB2aXNpYmxlUmVnaW9uO1xuICAgIGNvbnN0IHZTY3JvbGxSZWFkeSA9ICh2aXNpYmxlUmVnaW9uLmhlaWdodCA/PyAxKSA+IDE7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNjcm9sbE9mZnNldFkgIT09IHVuZGVmaW5lZCAmJiBzY3JvbGxSZWYuY3VycmVudCAhPT0gbnVsbCAmJiB2U2Nyb2xsUmVhZHkpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxUb3AgPT09IHNjcm9sbE9mZnNldFkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsT2Zmc2V0WTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxUb3AgIT09IHNjcm9sbE9mZnNldFkpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzSnVzdFNjcm9sbGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgW3Njcm9sbE9mZnNldFksIHZTY3JvbGxSZWFkeSwgZW1wdHldKTtcbiAgICBjb25zdCBoU2Nyb2xsUmVhZHkgPSAodmlzaWJsZVJlZ2lvbi53aWR0aCA/PyAxKSA+IDE7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNjcm9sbE9mZnNldFggIT09IHVuZGVmaW5lZCAmJiBzY3JvbGxSZWYuY3VycmVudCAhPT0gbnVsbCAmJiBoU2Nyb2xsUmVhZHkpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxMZWZ0ID09PSBzY3JvbGxPZmZzZXRYKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbExlZnQgPSBzY3JvbGxPZmZzZXRYO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbExlZnQgIT09IHNjcm9sbE9mZnNldFgpIHtcbiAgICAgICAgICAgICAgICBlbXB0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzSnVzdFNjcm9sbGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgW3Njcm9sbE9mZnNldFgsIGhTY3JvbGxSZWFkeSwgZW1wdHldKTtcbiAgICBjb25zdCBjZWxsWE9mZnNldCA9IHZpc2libGVSZWdpb24ueCArIHJvd01hcmtlck9mZnNldDtcbiAgICBjb25zdCBjZWxsWU9mZnNldCA9IHZpc2libGVSZWdpb24ueTtcbiAgICBjb25zdCBncmlkUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGZvY3VzID0gUmVhY3QudXNlQ2FsbGJhY2soKGltbWVkaWF0ZSkgPT4ge1xuICAgICAgICBpZiAoaW1tZWRpYXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBncmlkUmVmLmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBncmlkUmVmLmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBtYW5nbGVkUm93cyA9IHNob3dUcmFpbGluZ0JsYW5rUm93ID8gcm93cyArIDEgOiByb3dzO1xuICAgIGNvbnN0IG1hbmdsZWRPbkNlbGxzRWRpdGVkID0gUmVhY3QudXNlQ2FsbGJhY2soKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hbmdsZWRJdGVtcyA9IHJvd01hcmtlck9mZnNldCA9PT0gMFxuICAgICAgICAgICAgPyBpdGVtc1xuICAgICAgICAgICAgOiBpdGVtcy5tYXAoeCA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLngsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IFt4LmxvY2F0aW9uWzBdIC0gcm93TWFya2VyT2Zmc2V0LCB4LmxvY2F0aW9uWzFdXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgciA9IG9uQ2VsbHNFZGl0ZWQ/LihtYW5nbGVkSXRlbXMpO1xuICAgICAgICBpZiAociAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIG1hbmdsZWRJdGVtcylcbiAgICAgICAgICAgICAgICBvbkNlbGxFZGl0ZWQ/LihpLmxvY2F0aW9uLCBpLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9LCBbb25DZWxsRWRpdGVkLCBvbkNlbGxzRWRpdGVkLCByb3dNYXJrZXJPZmZzZXRdKTtcbiAgICBjb25zdCBbZmlsbEhpZ2hsaWdodFJlZ2lvbiwgc2V0RmlsbEhpZ2hsaWdodFJlZ2lvbl0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICAgIC8vIHRoaXMgd2lsbCBnZW5lcmFsbHkgYmUgdW5kZWZpbmVkIHRyaWdnZXJpbmcgdGhlIG1lbW8gbGVzcyBvZnRlblxuICAgIGNvbnN0IGhpZ2hsaWdodFJhbmdlID0gZ3JpZFNlbGVjdGlvbi5jdXJyZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlLndpZHRoICogZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlLmhlaWdodCA+IDFcbiAgICAgICAgPyBncmlkU2VsZWN0aW9uLmN1cnJlbnQucmFuZ2VcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGlnaGxpZ2h0Rm9jdXMgPSBkcmF3Rm9jdXNSaW5nID8gZ3JpZFNlbGVjdGlvbi5jdXJyZW50Py5jZWxsIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGhpZ2hsaWdodEZvY3VzQ29sID0gaGlnaGxpZ2h0Rm9jdXM/LlswXTtcbiAgICBjb25zdCBoaWdobGlnaHRGb2N1c1JvdyA9IGhpZ2hsaWdodEZvY3VzPy5bMV07XG4gICAgY29uc3QgaGlnaGxpZ2h0UmVnaW9ucyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoKGhpZ2hsaWdodFJlZ2lvbnNJbiA9PT0gdW5kZWZpbmVkIHx8IGhpZ2hsaWdodFJlZ2lvbnNJbi5sZW5ndGggPT09IDApICYmXG4gICAgICAgICAgICAoaGlnaGxpZ2h0UmFuZ2UgPz8gaGlnaGxpZ2h0Rm9jdXNDb2wgPz8gaGlnaGxpZ2h0Rm9jdXNSb3cgPz8gZmlsbEhpZ2hsaWdodFJlZ2lvbikgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHJlZ2lvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhpZ2hsaWdodFJlZ2lvbnNJbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgaGlnaGxpZ2h0UmVnaW9uc0luKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4V2lkdGggPSBtYW5nbGVkQ29scy5sZW5ndGggLSByLnJhbmdlLnggLSByb3dNYXJrZXJPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKG1heFdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWdpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHIuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnIucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogci5yYW5nZS54ICsgcm93TWFya2VyT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbihtYXhXaWR0aCwgci5yYW5nZS53aWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHIuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsbEhpZ2hsaWdodFJlZ2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWdpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbG9yOiB3aXRoQWxwaGEobWVyZ2VkVGhlbWUuYWNjZW50Q29sb3IsIDApLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBmaWxsSGlnaGxpZ2h0UmVnaW9uLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcImRhc2hlZFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hsaWdodFJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZ2lvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29sb3I6IHdpdGhBbHBoYShtZXJnZWRUaGVtZS5hY2NlbnRDb2xvciwgMC41KSxcbiAgICAgICAgICAgICAgICByYW5nZTogaGlnaGxpZ2h0UmFuZ2UsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwic29saWQtb3V0bGluZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hsaWdodEZvY3VzQ29sICE9PSB1bmRlZmluZWQgJiYgaGlnaGxpZ2h0Rm9jdXNSb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVnaW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogbWVyZ2VkVGhlbWUuYWNjZW50Q29sb3IsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgeDogaGlnaGxpZ2h0Rm9jdXNDb2wsXG4gICAgICAgICAgICAgICAgICAgIHk6IGhpZ2hsaWdodEZvY3VzUm93LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwic29saWQtb3V0bGluZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZ2lvbnMubGVuZ3RoID4gMCA/IHJlZ2lvbnMgOiB1bmRlZmluZWQ7XG4gICAgfSwgW1xuICAgICAgICBmaWxsSGlnaGxpZ2h0UmVnaW9uLFxuICAgICAgICBoaWdobGlnaHRSYW5nZSxcbiAgICAgICAgaGlnaGxpZ2h0Rm9jdXNDb2wsXG4gICAgICAgIGhpZ2hsaWdodEZvY3VzUm93LFxuICAgICAgICBoaWdobGlnaHRSZWdpb25zSW4sXG4gICAgICAgIG1hbmdsZWRDb2xzLmxlbmd0aCxcbiAgICAgICAgbWVyZ2VkVGhlbWUuYWNjZW50Q29sb3IsXG4gICAgICAgIHJvd01hcmtlck9mZnNldCxcbiAgICBdKTtcbiAgICBjb25zdCBtYW5nbGVkQ29sc1JlZiA9IFJlYWN0LnVzZVJlZihtYW5nbGVkQ29scyk7XG4gICAgbWFuZ2xlZENvbHNSZWYuY3VycmVudCA9IG1hbmdsZWRDb2xzO1xuICAgIGNvbnN0IGdldE1hbmdsZWRDZWxsQ29udGVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKChbY29sLCByb3ddLCBmb3JjZVN0cmljdCA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVHJhaWxpbmcgPSBzaG93VHJhaWxpbmdCbGFua1JvdyAmJiByb3cgPT09IG1hbmdsZWRSb3dzIC0gMTtcbiAgICAgICAgY29uc3QgaXNSb3dNYXJrZXJDb2wgPSBjb2wgPT09IDAgJiYgaGFzUm93TWFya2VycztcbiAgICAgICAgaWYgKGlzUm93TWFya2VyQ29sKSB7XG4gICAgICAgICAgICBpZiAoaXNUcmFpbGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkaW5nQ2VsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2luZDogSW5uZXJHcmlkQ2VsbEtpbmQuTWFya2VyLFxuICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hlY2tib3hTdHlsZTogcm93TWFya2VyQ2hlY2tib3hTdHlsZSxcbiAgICAgICAgICAgICAgICBjaGVja2VkOiBncmlkU2VsZWN0aW9uPy5yb3dzLmhhc0luZGV4KHJvdykgPT09IHRydWUsXG4gICAgICAgICAgICAgICAgbWFya2VyS2luZDogcm93TWFya2VycyA9PT0gXCJjbGlja2FibGUtbnVtYmVyXCIgPyBcIm51bWJlclwiIDogcm93TWFya2VycyxcbiAgICAgICAgICAgICAgICByb3c6IHJvd01hcmtlclN0YXJ0SW5kZXggKyByb3csXG4gICAgICAgICAgICAgICAgZHJhd0hhbmRsZTogb25Sb3dNb3ZlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGN1cnNvcjogcm93TWFya2VycyA9PT0gXCJjbGlja2FibGUtbnVtYmVyXCIgPyBcInBvaW50ZXJcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUcmFpbGluZykge1xuICAgICAgICAgICAgLy9JZiB0aGUgZ3JpZCBpcyBlbXB0eSwgd2Ugd2lsbCByZXR1cm4gdGV4dFxuICAgICAgICAgICAgY29uc3QgaXNGaXJzdCA9IGNvbCA9PT0gcm93TWFya2VyT2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgbWF5YmVGaXJzdENvbHVtbkhpbnQgPSBpc0ZpcnN0ID8gdHJhaWxpbmdSb3dPcHRpb25zPy5oaW50ID8/IFwiXCIgOiBcIlwiO1xuICAgICAgICAgICAgY29uc3QgYyA9IG1hbmdsZWRDb2xzUmVmLmN1cnJlbnRbY29sXTtcbiAgICAgICAgICAgIGlmIChjPy50cmFpbGluZ1Jvd09wdGlvbnM/LmRpc2FibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmdDZWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGludCA9IGM/LnRyYWlsaW5nUm93T3B0aW9ucz8uaGludCA/PyBtYXliZUZpcnN0Q29sdW1uSGludDtcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uID0gYz8udHJhaWxpbmdSb3dPcHRpb25zPy5hZGRJY29uID8/IHRyYWlsaW5nUm93T3B0aW9ucz8uYWRkSWNvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBJbm5lckdyaWRDZWxsS2luZC5OZXdSb3csXG4gICAgICAgICAgICAgICAgICAgIGhpbnQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG91dGVyQ29sID0gY29sIC0gcm93TWFya2VyT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGZvcmNlU3RyaWN0IHx8IGV4cGVyaW1lbnRhbD8uc3RyaWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdnIgPSB2aXNpYmxlUmVnaW9uUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNPdXRzaWRlTWFpbkFyZWEgPSB2ci54ID4gb3V0ZXJDb2wgfHxcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJDb2wgPiB2ci54ICsgdnIud2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgdnIueSA+IHJvdyB8fFxuICAgICAgICAgICAgICAgICAgICByb3cgPiB2ci55ICsgdnIuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgIHJvdyA+PSByb3dzUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IG91dGVyQ29sID09PSB2ci5leHRyYXM/LnNlbGVjdGVkPy5bMF0gJiYgcm93ID09PSB2ci5leHRyYXM/LnNlbGVjdGVkWzFdO1xuICAgICAgICAgICAgICAgIGxldCBpc0luRnJlZXplQXJlYSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh2ci5leHRyYXM/LmZyZWV6ZVJlZ2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZyIG9mIHZyLmV4dHJhcy5mcmVlemVSZWdpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRJblJlY3QoZnIsIG91dGVyQ29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbkZyZWV6ZUFyZWEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc091dHNpZGVNYWluQXJlYSAmJiAhaXNTZWxlY3RlZCAmJiAhaXNJbkZyZWV6ZUFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmdDZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBnZXRDZWxsQ29udGVudChbb3V0ZXJDb2wsIHJvd10pO1xuICAgICAgICAgICAgaWYgKHJvd01hcmtlck9mZnNldCAhPT0gMCAmJiByZXN1bHQuc3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IFtyZXN1bHQuc3BhblswXSArIHJvd01hcmtlck9mZnNldCwgcmVzdWx0LnNwYW5bMV0gKyByb3dNYXJrZXJPZmZzZXRdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBzaG93VHJhaWxpbmdCbGFua1JvdyxcbiAgICAgICAgbWFuZ2xlZFJvd3MsXG4gICAgICAgIGhhc1Jvd01hcmtlcnMsXG4gICAgICAgIHJvd01hcmtlckNoZWNrYm94U3R5bGUsXG4gICAgICAgIGdyaWRTZWxlY3Rpb24/LnJvd3MsXG4gICAgICAgIHJvd01hcmtlcnMsXG4gICAgICAgIHJvd01hcmtlclN0YXJ0SW5kZXgsXG4gICAgICAgIG9uUm93TW92ZWQsXG4gICAgICAgIHJvd01hcmtlck9mZnNldCxcbiAgICAgICAgdHJhaWxpbmdSb3dPcHRpb25zPy5oaW50LFxuICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM/LmFkZEljb24sXG4gICAgICAgIGV4cGVyaW1lbnRhbD8uc3RyaWN0LFxuICAgICAgICBnZXRDZWxsQ29udGVudCxcbiAgICBdKTtcbiAgICBjb25zdCBtYW5nbGVkR2V0R3JvdXBEZXRhaWxzID0gUmVhY3QudXNlQ2FsbGJhY2soZ3JvdXAgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZ2V0R3JvdXBEZXRhaWxzPy4oZ3JvdXApID8/IHsgbmFtZTogZ3JvdXAgfTtcbiAgICAgICAgaWYgKG9uR3JvdXBIZWFkZXJSZW5hbWVkICE9PSB1bmRlZmluZWQgJiYgZ3JvdXAgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogTXV0YXRlXG4gICAgICAgICAgICAgICAgaWNvbjogcmVzdWx0Lmljb24sXG4gICAgICAgICAgICAgICAgbmFtZTogcmVzdWx0Lm5hbWUsXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVUaGVtZTogcmVzdWx0Lm92ZXJyaWRlVGhlbWUsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAuLi4ocmVzdWx0LmFjdGlvbnMgPz8gW10pLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJSZW5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb246IFwicmVuYW1lSWNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljazogZSA9PiBzZXRSZW5hbWVHcm91cCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IHJlc3VsdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kczogZS5ib3VuZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtnZXRHcm91cERldGFpbHMsIG9uR3JvdXBIZWFkZXJSZW5hbWVkXSk7XG4gICAgY29uc3Qgc2V0T3ZlcmxheVNpbXBsZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCh2YWwpID0+IHtcbiAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IHZhbC5jZWxsO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBtYW5nbGVkQ29sc1tjb2xdO1xuICAgICAgICBjb25zdCBncm91cFRoZW1lID0gY29sdW1uPy5ncm91cCAhPT0gdW5kZWZpbmVkID8gbWFuZ2xlZEdldEdyb3VwRGV0YWlscyhjb2x1bW4uZ3JvdXApPy5vdmVycmlkZVRoZW1lIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBjb2xUaGVtZSA9IGNvbHVtbj8udGhlbWVPdmVycmlkZTtcbiAgICAgICAgY29uc3Qgcm93VGhlbWUgPSBnZXRSb3dUaGVtZU92ZXJyaWRlPy4ocm93KTtcbiAgICAgICAgc2V0T3ZlcmxheSh7XG4gICAgICAgICAgICAuLi52YWwsXG4gICAgICAgICAgICB0aGVtZTogbWVyZ2VBbmRSZWFsaXplVGhlbWUobWVyZ2VkVGhlbWUsIGdyb3VwVGhlbWUsIGNvbFRoZW1lLCByb3dUaGVtZSwgdmFsLmNvbnRlbnQudGhlbWVPdmVycmlkZSksXG4gICAgICAgIH0pO1xuICAgIH0sIFtnZXRSb3dUaGVtZU92ZXJyaWRlLCBtYW5nbGVkQ29scywgbWFuZ2xlZEdldEdyb3VwRGV0YWlscywgbWVyZ2VkVGhlbWVdKTtcbiAgICBjb25zdCByZXNlbGVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKChib3VuZHMsIGZyb21LZXlib2FyZCwgaW5pdGlhbFZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChncmlkU2VsZWN0aW9uLmN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGdyaWRTZWxlY3Rpb24uY3VycmVudC5jZWxsO1xuICAgICAgICBjb25zdCBjID0gZ2V0TWFuZ2xlZENlbGxDb250ZW50KFtjb2wsIHJvd10pO1xuICAgICAgICBpZiAoYy5raW5kICE9PSBHcmlkQ2VsbEtpbmQuQm9vbGVhbiAmJiBjLmFsbG93T3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBjO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb250ZW50LmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuTnVtYmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gbWF5YmUoKCkgPT4gKGluaXRpYWxWYWx1ZSA9PT0gXCItXCIgPyAtMCA6IE51bWJlci5wYXJzZUZsb2F0KGluaXRpYWxWYWx1ZSkpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBOdW1iZXIuaXNOYU4oZCkgPyAwIDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5UZXh0OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5NYXJrZG93bjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVXJpOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGluaXRpYWxWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRPdmVybGF5U2ltcGxlKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZSxcbiAgICAgICAgICAgICAgICBjZWxsOiBbY29sLCByb3ddLFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodDogaW5pdGlhbFZhbHVlID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZm9yY2VFZGl0TW9kZTogaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjLmtpbmQgPT09IEdyaWRDZWxsS2luZC5Cb29sZWFuICYmIGZyb21LZXlib2FyZCAmJiBjLnJlYWRvbmx5ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBtYW5nbGVkT25DZWxsc0VkaXRlZChbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGwsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdG9nZ2xlQm9vbGVhbihjLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGdyaWRSZWYuY3VycmVudD8uZGFtYWdlKFt7IGNlbGw6IGdyaWRTZWxlY3Rpb24uY3VycmVudC5jZWxsIH1dKTtcbiAgICAgICAgfVxuICAgIH0sIFtnZXRNYW5nbGVkQ2VsbENvbnRlbnQsIGdyaWRTZWxlY3Rpb24sIG1hbmdsZWRPbkNlbGxzRWRpdGVkLCBzZXRPdmVybGF5U2ltcGxlXSk7XG4gICAgY29uc3QgZm9jdXNPblJvd0Zyb21UcmFpbGluZ0JsYW5rUm93ID0gUmVhY3QudXNlQ2FsbGJhY2soKGNvbCwgcm93KSA9PiB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGdyaWRSZWYuY3VycmVudD8uZ2V0Qm91bmRzKGNvbCwgcm93KTtcbiAgICAgICAgaWYgKGJvdW5kcyA9PT0gdW5kZWZpbmVkIHx8IHNjcm9sbFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudCA9IGdldE1hbmdsZWRDZWxsQ29udGVudChbY29sLCByb3ddKTtcbiAgICAgICAgaWYgKCFjb250ZW50LmFsbG93T3ZlcmxheSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldE92ZXJsYXlTaW1wbGUoe1xuICAgICAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgaW5pdGlhbFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgICAgICAgICBjZWxsOiBbY29sLCByb3ddLFxuICAgICAgICAgICAgZm9yY2VFZGl0TW9kZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW2dldE1hbmdsZWRDZWxsQ29udGVudCwgc2V0T3ZlcmxheVNpbXBsZV0pO1xuICAgIGNvbnN0IHNjcm9sbFRvID0gUmVhY3QudXNlQ2FsbGJhY2soKGNvbCwgcm93LCBkaXIgPSBcImJvdGhcIiwgcGFkZGluZ1ggPSAwLCBwYWRkaW5nWSA9IDAsIG9wdGlvbnMgPSB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKHNjcm9sbFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBncmlkID0gZ3JpZFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCB0cnVlQ29sID0gdHlwZW9mIGNvbCAhPT0gXCJudW1iZXJcIiA/IChjb2wudW5pdCA9PT0gXCJjZWxsXCIgPyBjb2wuYW1vdW50IDogdW5kZWZpbmVkKSA6IGNvbDtcbiAgICAgICAgICAgIGNvbnN0IHRydWVSb3cgPSB0eXBlb2Ygcm93ICE9PSBcIm51bWJlclwiID8gKHJvdy51bml0ID09PSBcImNlbGxcIiA/IHJvdy5hbW91bnQgOiB1bmRlZmluZWQpIDogcm93O1xuICAgICAgICAgICAgY29uc3QgZGVzaXJlZFggPSB0eXBlb2YgY29sICE9PSBcIm51bWJlclwiICYmIGNvbC51bml0ID09PSBcInB4XCIgPyBjb2wuYW1vdW50IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgZGVzaXJlZFkgPSB0eXBlb2Ygcm93ICE9PSBcIm51bWJlclwiICYmIHJvdy51bml0ID09PSBcInB4XCIgPyByb3cuYW1vdW50IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGdyaWQgIT09IG51bGwgJiYgY2FudmFzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFJlY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsZXQgc2Nyb2xsWCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbFkgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0cnVlQ29sICE9PSB1bmRlZmluZWQgfHwgdHJ1ZVJvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFJlY3QgPSBncmlkLmdldEJvdW5kcygodHJ1ZUNvbCA/PyAwKSArIHJvd01hcmtlck9mZnNldCwgdHJ1ZVJvdyA/PyAwKSA/PyB0YXJnZXRSZWN0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0UmVjdC53aWR0aCA9PT0gMCB8fCB0YXJnZXRSZWN0LmhlaWdodCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQm91bmRzID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gc2Nyb2xsQm91bmRzLndpZHRoIC8gY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChkZXNpcmVkWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFJlY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50YXJnZXRSZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogZGVzaXJlZFggLSBzY3JvbGxCb3VuZHMubGVmdCAtIHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlc2lyZWRZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRhcmdldFJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBkZXNpcmVkWSArIHNjcm9sbEJvdW5kcy50b3AgLSBzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRSZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogdGFyZ2V0UmVjdC54IC0gcGFkZGluZ1gsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB0YXJnZXRSZWN0LnkgLSBwYWRkaW5nWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0YXJnZXRSZWN0LndpZHRoICsgMiAqIHBhZGRpbmdYLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0YXJnZXRSZWN0LmhlaWdodCArIDIgKiBwYWRkaW5nWSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb3plbldpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmVlemVDb2x1bW5zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb3plbldpZHRoICs9IGNvbHVtbnNbaV0ud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWlsaW5nUm93SGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJlZXplVHJhaWxpbmdSb3dzRWZmZWN0aXZlID0gZnJlZXplVHJhaWxpbmdSb3dzICsgKGxhc3RSb3dTdGlja3kgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmVlemVUcmFpbGluZ1Jvd3NFZmZlY3RpdmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1Jvd0hlaWdodCA9IGdldEZyZWV6ZVRyYWlsaW5nSGVpZ2h0KG1hbmdsZWRSb3dzLCBmcmVlemVUcmFpbGluZ1Jvd3NFZmZlY3RpdmUsIHJvd0hlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsQm91bmRzIGlzIGFscmVhZHkgc2NhbGVkXG4gICAgICAgICAgICAgICAgICAgIGxldCBzTGVmdCA9IGZyb3plbldpZHRoICogc2NhbGUgKyBzY3JvbGxCb3VuZHMubGVmdCArIHJvd01hcmtlck9mZnNldCAqIHJvd01hcmtlcldpZHRoICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzUmlnaHQgPSBzY3JvbGxCb3VuZHMucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzVG9wID0gc2Nyb2xsQm91bmRzLnRvcCArIHRvdGFsSGVhZGVySGVpZ2h0ICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzQm90dG9tID0gc2Nyb2xsQm91bmRzLmJvdHRvbSAtIHRyYWlsaW5nUm93SGVpZ2h0ICogc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbnggPSB0YXJnZXRSZWN0LndpZHRoICsgcGFkZGluZ1ggKiAyO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnM/LmhBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc1JpZ2h0ID0gc0xlZnQgKyBtaW54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNMZWZ0ID0gc1JpZ2h0IC0gbWlueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzTGVmdCA9IE1hdGguZmxvb3IoKHNMZWZ0ICsgc1JpZ2h0KSAvIDIpIC0gbWlueCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc1JpZ2h0ID0gc0xlZnQgKyBtaW54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbnkgPSB0YXJnZXRSZWN0LmhlaWdodCArIHBhZGRpbmdZICogMjtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zPy52QWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNCb3R0b20gPSBzVG9wICsgbWlueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzVG9wID0gc0JvdHRvbSAtIG1pbnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc1RvcCA9IE1hdGguZmxvb3IoKHNUb3AgKyBzQm90dG9tKSAvIDIpIC0gbWlueSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc0JvdHRvbSA9IHNUb3AgKyBtaW55O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzTGVmdCA+IGJvdW5kcy54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYID0gYm91bmRzLnggLSBzTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzUmlnaHQgPCBib3VuZHMueCArIGJvdW5kcy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWCA9IGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC0gc1JpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzVG9wID4gYm91bmRzLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFkgPSBib3VuZHMueSAtIHNUb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc0JvdHRvbSA8IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWSA9IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCAtIHNCb3R0b207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA9PT0gXCJ2ZXJ0aWNhbFwiIHx8ICh0eXBlb2YgY29sID09PSBcIm51bWJlclwiICYmIGNvbCA8IGZyZWV6ZUNvbHVtbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXIgPT09IFwiaG9yaXpvbnRhbFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJvdyA9PT0gXCJudW1iZXJcIiAmJiByb3cgPj0gbWFuZ2xlZFJvd3MgLSBmcmVlemVUcmFpbGluZ1Jvd3NFZmZlY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsWCAhPT0gMCB8fCBzY3JvbGxZICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2NhbGluZyBhcyBzY3JvbGxUbyBtZXRob2QgaXMgdW5hZmZlY3RlZCBieSB0cmFuc2Zvcm0gc2NhbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYIC89IHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFkgLz0gc2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxUbyhzY3JvbGxYICsgc2Nyb2xsUmVmLmN1cnJlbnQuc2Nyb2xsTGVmdCwgc2Nyb2xsWSArIHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHJvd01hcmtlck9mZnNldCxcbiAgICAgICAgZnJlZXplVHJhaWxpbmdSb3dzLFxuICAgICAgICByb3dNYXJrZXJXaWR0aCxcbiAgICAgICAgdG90YWxIZWFkZXJIZWlnaHQsXG4gICAgICAgIGZyZWV6ZUNvbHVtbnMsXG4gICAgICAgIGNvbHVtbnMsXG4gICAgICAgIG1hbmdsZWRSb3dzLFxuICAgICAgICBsYXN0Um93U3RpY2t5LFxuICAgICAgICByb3dIZWlnaHQsXG4gICAgXSk7XG4gICAgY29uc3QgZm9jdXNDYWxsYmFjayA9IFJlYWN0LnVzZVJlZihmb2N1c09uUm93RnJvbVRyYWlsaW5nQmxhbmtSb3cpO1xuICAgIGNvbnN0IGdldENlbGxDb250ZW50UmVmID0gUmVhY3QudXNlUmVmKGdldENlbGxDb250ZW50KTtcbiAgICBjb25zdCByb3dzUmVmID0gUmVhY3QudXNlUmVmKHJvd3MpO1xuICAgIGZvY3VzQ2FsbGJhY2suY3VycmVudCA9IGZvY3VzT25Sb3dGcm9tVHJhaWxpbmdCbGFua1JvdztcbiAgICBnZXRDZWxsQ29udGVudFJlZi5jdXJyZW50ID0gZ2V0Q2VsbENvbnRlbnQ7XG4gICAgcm93c1JlZi5jdXJyZW50ID0gcm93cztcbiAgICBjb25zdCBhcHBlbmRSb3cgPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAoY29sLCBvcGVuT3ZlcmxheSA9IHRydWUpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IG1hbmdsZWRDb2xzW2NvbF07XG4gICAgICAgIGlmIChjPy50cmFpbGluZ1Jvd09wdGlvbnM/LmRpc2FibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwZW5kUmVzdWx0ID0gb25Sb3dBcHBlbmRlZD8uKCk7XG4gICAgICAgIGxldCByID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYm90dG9tID0gdHJ1ZTtcbiAgICAgICAgaWYgKGFwcGVuZFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByID0gYXdhaXQgYXBwZW5kUmVzdWx0O1xuICAgICAgICAgICAgaWYgKHIgPT09IFwidG9wXCIpXG4gICAgICAgICAgICAgICAgYm90dG9tID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgYm90dG9tID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJhY2tvZmYgPSAwO1xuICAgICAgICBjb25zdCBkb0ZvY3VzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJvd3NSZWYuY3VycmVudCA8PSByb3dzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2tvZmYgPCA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZG9Gb2N1cywgYmFja29mZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhY2tvZmYgPSA1MCArIGJhY2tvZmYgKiAyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IHR5cGVvZiByID09PSBcIm51bWJlclwiID8gciA6IGJvdHRvbSA/IHJvd3MgOiAwO1xuICAgICAgICAgICAgc2Nyb2xsVG9SZWYuY3VycmVudChjb2wgLSByb3dNYXJrZXJPZmZzZXQsIHJvdyk7XG4gICAgICAgICAgICBzZXRDdXJyZW50KHtcbiAgICAgICAgICAgICAgICBjZWxsOiBbY29sLCByb3ddLFxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgeTogcm93LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCBmYWxzZSwgZmFsc2UsIFwiZWRpdFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBnZXRDZWxsQ29udGVudFJlZi5jdXJyZW50KFtjb2wgLSByb3dNYXJrZXJPZmZzZXQsIHJvd10pO1xuICAgICAgICAgICAgaWYgKGNlbGwuYWxsb3dPdmVybGF5ICYmIGlzUmVhZFdyaXRlQ2VsbChjZWxsKSAmJiBjZWxsLnJlYWRvbmx5ICE9PSB0cnVlICYmIG9wZW5PdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgLy8gd2FpdCBmb3Igc2Nyb2xsIHRvIGhhdmUgYSBjaGFuY2UgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNDYWxsYmFjay5jdXJyZW50KGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gUXVldWUgdXAgdG8gYWxsb3cgdGhlIGNvbnN1bWVyIHRvIHJlYWN0IHRvIHRoZSBldmVudCBhbmQgbGV0IHVzIGNoZWNrIGlmIHRoZXkgZGlkXG4gICAgICAgIGRvRm9jdXMoKTtcbiAgICB9LCBbbWFuZ2xlZENvbHMsIG9uUm93QXBwZW5kZWQsIHJvd01hcmtlck9mZnNldCwgcm93cywgc2V0Q3VycmVudF0pO1xuICAgIGNvbnN0IGdldEN1c3RvbU5ld1Jvd1RhcmdldENvbHVtbiA9IFJlYWN0LnVzZUNhbGxiYWNrKChjb2wpID0+IHtcbiAgICAgICAgY29uc3QgY3VzdG9tVGFyZ2V0Q29sdW1uID0gY29sdW1uc1tjb2xdPy50cmFpbGluZ1Jvd09wdGlvbnM/LnRhcmdldENvbHVtbiA/PyB0cmFpbGluZ1Jvd09wdGlvbnM/LnRhcmdldENvbHVtbjtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21UYXJnZXRDb2x1bW4gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbVRhcmdldE9mZnNldCA9IGhhc1Jvd01hcmtlcnMgPyAxIDogMDtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21UYXJnZXRDb2x1bW4gKyBjdXN0b21UYXJnZXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21UYXJnZXRDb2x1bW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlSW5kZXggPSBjb2x1bW5zSW4uaW5kZXhPZihjdXN0b21UYXJnZXRDb2x1bW4pO1xuICAgICAgICAgICAgaWYgKG1heWJlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1c3RvbVRhcmdldE9mZnNldCA9IGhhc1Jvd01hcmtlcnMgPyAxIDogMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVJbmRleCArIGN1c3RvbVRhcmdldE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sIFtjb2x1bW5zLCBjb2x1bW5zSW4sIGhhc1Jvd01hcmtlcnMsIHRyYWlsaW5nUm93T3B0aW9ucz8udGFyZ2V0Q29sdW1uXSk7XG4gICAgY29uc3QgbGFzdFNlbGVjdGVkUm93UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgbGFzdFNlbGVjdGVkQ29sUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgdGhlbWVGb3JDZWxsID0gUmVhY3QudXNlQ2FsbGJhY2soKGNlbGwsIHBvcykgPT4ge1xuICAgICAgICBjb25zdCBbY29sLCByb3ddID0gcG9zO1xuICAgICAgICByZXR1cm4gbWVyZ2VBbmRSZWFsaXplVGhlbWUobWVyZ2VkVGhlbWUsIG1hbmdsZWRDb2xzW2NvbF0/LnRoZW1lT3ZlcnJpZGUsIGdldFJvd1RoZW1lT3ZlcnJpZGU/Lihyb3cpLCBjZWxsLnRoZW1lT3ZlcnJpZGUpO1xuICAgIH0sIFtnZXRSb3dUaGVtZU92ZXJyaWRlLCBtYW5nbGVkQ29scywgbWVyZ2VkVGhlbWVdKTtcbiAgICBjb25zdCBoYW5kbGVTZWxlY3QgPSBSZWFjdC51c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICBjb25zdCBpc011bHRpS2V5ID0gYnJvd3NlcklzT1NYLnZhbHVlID8gYXJncy5tZXRhS2V5IDogYXJncy5jdHJsS2V5O1xuICAgICAgICBjb25zdCBpc011bHRpUm93ID0gaXNNdWx0aUtleSAmJiByb3dTZWxlY3QgPT09IFwibXVsdGlcIjtcbiAgICAgICAgY29uc3QgaXNNdWx0aUNvbCA9IGlzTXVsdGlLZXkgJiYgY29sdW1uU2VsZWN0ID09PSBcIm11bHRpXCI7XG4gICAgICAgIGNvbnN0IFtjb2wsIHJvd10gPSBhcmdzLmxvY2F0aW9uO1xuICAgICAgICBjb25zdCBzZWxlY3RlZENvbHVtbnMgPSBncmlkU2VsZWN0aW9uLmNvbHVtbnM7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUm93cyA9IGdyaWRTZWxlY3Rpb24ucm93cztcbiAgICAgICAgY29uc3QgW2NlbGxDb2wsIGNlbGxSb3ddID0gZ3JpZFNlbGVjdGlvbi5jdXJyZW50Py5jZWxsID8/IFtdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItc3dpdGNoXG4gICAgICAgIGlmIChhcmdzLmtpbmQgPT09IFwiY2VsbFwiKSB7XG4gICAgICAgICAgICBsYXN0U2VsZWN0ZWRDb2xSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxhc3RNb3VzZVNlbGVjdExvY2F0aW9uLmN1cnJlbnQgPSBbY29sLCByb3ddO1xuICAgICAgICAgICAgaWYgKGNvbCA9PT0gMCAmJiBoYXNSb3dNYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzaG93VHJhaWxpbmdCbGFua1JvdyA9PT0gdHJ1ZSAmJiByb3cgPT09IHJvd3MpIHx8XG4gICAgICAgICAgICAgICAgICAgIHJvd01hcmtlcnMgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgcm93U2VsZWN0ID09PSBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlckNlbGwgPSBnZXRNYW5nbGVkQ2VsbENvbnRlbnQoYXJncy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlckNlbGwua2luZCAhPT0gSW5uZXJHcmlkQ2VsbEtpbmQuTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9uUm93TW92ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IGdldENlbGxSZW5kZXJlcihtYXJrZXJDZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KHJlbmRlcmVyPy5raW5kID09PSBJbm5lckdyaWRDZWxsS2luZC5NYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3N0Q2xpY2sgPSByZW5kZXJlcj8ub25DbGljaz8uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsOiBtYXJrZXJDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zWDogYXJncy5sb2NhbEV2ZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc1k6IGFyZ3MubG9jYWxFdmVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZHM6IGFyZ3MuYm91bmRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU6IHRoZW1lRm9yQ2VsbChtYXJrZXJDZWxsLCBhcmdzLmxvY2F0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zdENsaWNrID09PSB1bmRlZmluZWQgfHwgcG9zdENsaWNrLmNoZWNrZWQgPT09IG1hcmtlckNlbGwuY2hlY2tlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0T3ZlcmxheSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGZvY3VzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbGVjdGVkUm93cy5oYXNJbmRleChyb3cpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RIaWdobGlnaHRlZCA9IGxhc3RTZWxlY3RlZFJvd1JlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChyb3dTZWxlY3QgPT09IFwibXVsdGlcIiAmJlxuICAgICAgICAgICAgICAgICAgICAoYXJncy5zaGlmdEtleSB8fCBhcmdzLmlzTG9uZ1RvdWNoID09PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgICBsYXN0SGlnaGxpZ2h0ZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJvd3MuaGFzSW5kZXgobGFzdEhpZ2hsaWdodGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTbGljZSA9IFtNYXRoLm1pbihsYXN0SGlnaGxpZ2h0ZWQsIHJvdyksIE1hdGgubWF4KGxhc3RIaWdobGlnaHRlZCwgcm93KSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNdWx0aVJvdyB8fCByb3dTZWxlY3Rpb25Nb2RlID09PSBcIm11bHRpXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkUm93cyh1bmRlZmluZWQsIG5ld1NsaWNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkUm93cyhDb21wYWN0U2VsZWN0aW9uLmZyb21TaW5nbGVTZWxlY3Rpb24obmV3U2xpY2UpLCB1bmRlZmluZWQsIGlzTXVsdGlSb3cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTXVsdGlSb3cgfHwgYXJncy5pc1RvdWNoIHx8IHJvd1NlbGVjdGlvbk1vZGUgPT09IFwibXVsdGlcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRSb3dzKHNlbGVjdGVkUm93cy5yZW1vdmUocm93KSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkUm93cyh1bmRlZmluZWQsIHJvdywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2VsZWN0ZWRSb3dSZWYuY3VycmVudCA9IHJvdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1NlbGVjdGVkICYmIHNlbGVjdGVkUm93cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRSb3dzKENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSwgdW5kZWZpbmVkLCBpc011bHRpS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkUm93cyhDb21wYWN0U2VsZWN0aW9uLmZyb21TaW5nbGVTZWxlY3Rpb24ocm93KSwgdW5kZWZpbmVkLCBpc011bHRpS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNlbGVjdGVkUm93UmVmLmN1cnJlbnQgPSByb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29sID49IHJvd01hcmtlck9mZnNldCAmJiBzaG93VHJhaWxpbmdCbGFua1JvdyAmJiByb3cgPT09IHJvd3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXN0b21UYXJnZXRDb2x1bW4gPSBnZXRDdXN0b21OZXdSb3dUYXJnZXRDb2x1bW4oY29sKTtcbiAgICAgICAgICAgICAgICB2b2lkIGFwcGVuZFJvdyhjdXN0b21UYXJnZXRDb2x1bW4gPz8gY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsQ29sICE9PSBjb2wgfHwgY2VsbFJvdyAhPT0gcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBnZXRNYW5nbGVkQ2VsbENvbnRlbnQoYXJncy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gZ2V0Q2VsbFJlbmRlcmVyKGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXI/Lm9uU2VsZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLm9uU2VsZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zWDogYXJncy5sb2NhbEV2ZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NZOiBhcmdzLmxvY2FsRXZlbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kczogYXJncy5ib3VuZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IChwcmV2ZW50ZWQgPSB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZTogdGhlbWVGb3JDZWxsKGNlbGwsIGFyZ3MubG9jYXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTGFzdFN0aWNreVJvdyA9IGxhc3RSb3dTdGlja3kgJiYgcm93ID09PSByb3dzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydGVkRnJvbUxhc3RTdGlja3kgPSBsYXN0Um93U3RpY2t5ICYmIGdyaWRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBncmlkU2VsZWN0aW9uLmN1cnJlbnQ/LmNlbGxbMV0gPT09IHJvd3M7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoYXJncy5zaGlmdEtleSB8fCBhcmdzLmlzTG9uZ1RvdWNoID09PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbENvbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsUm93ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRTZWxlY3Rpb24uY3VycmVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhc3RhcnRlZEZyb21MYXN0U3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMYXN0U3RpY2t5Um93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgbWFraW5nIGEgc2VsZWN0aW9uIGFuZCBzaGlmdCBjbGljayBpbiB0byB0aGUgbGFzdCBzdGlja3kgcm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgZHJvcCB0aGUgZXZlbnQuIERvbid0IGtpbGwgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oY29sLCBjZWxsQ29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoY29sLCBjZWxsQ29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvcCA9IE1hdGgubWluKHJvdywgY2VsbFJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3R0b20gPSBNYXRoLm1heChyb3csIGNlbGxSb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZ3JpZFNlbGVjdGlvbi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSwgaXNNdWx0aUtleSwgXCJjbGlja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWxlY3RlZFJvd1JlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGw6IFtjb2wsIHJvd10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHsgeDogY29sLCB5OiByb3csIHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUsIGlzTXVsdGlLZXksIFwiY2xpY2tcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2VsZWN0ZWRSb3dSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE92ZXJsYXkodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJncy5raW5kID09PSBcImhlYWRlclwiKSB7XG4gICAgICAgICAgICBsYXN0TW91c2VTZWxlY3RMb2NhdGlvbi5jdXJyZW50ID0gW2NvbCwgcm93XTtcbiAgICAgICAgICAgIHNldE92ZXJsYXkodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlmIChoYXNSb3dNYXJrZXJzICYmIGNvbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RTZWxlY3RlZFJvd1JlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxhc3RTZWxlY3RlZENvbFJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChyb3dTZWxlY3QgPT09IFwibXVsdGlcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRSb3dzLmxlbmd0aCAhPT0gcm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRSb3dzKENvbXBhY3RTZWxlY3Rpb24uZnJvbVNpbmdsZVNlbGVjdGlvbihbMCwgcm93c10pLCB1bmRlZmluZWQsIGlzTXVsdGlLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRSb3dzKENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSwgdW5kZWZpbmVkLCBpc011bHRpS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDb2wgPSBsYXN0U2VsZWN0ZWRDb2xSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uU2VsZWN0ID09PSBcIm11bHRpXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyZ3Muc2hpZnRLZXkgfHwgYXJncy5pc0xvbmdUb3VjaCA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQ29sdW1ucy5oYXNJbmRleChsYXN0Q29sKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTbGljZSA9IFtNYXRoLm1pbihsYXN0Q29sLCBjb2wpLCBNYXRoLm1heChsYXN0Q29sLCBjb2wpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc011bHRpQ29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZENvbHVtbnModW5kZWZpbmVkLCBuZXdTbGljZSwgaXNNdWx0aUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZENvbHVtbnMoQ29tcGFjdFNlbGVjdGlvbi5mcm9tU2luZ2xlU2VsZWN0aW9uKG5ld1NsaWNlKSwgdW5kZWZpbmVkLCBpc011bHRpS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc011bHRpQ29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZENvbHVtbnMuaGFzSW5kZXgoY29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zKHNlbGVjdGVkQ29sdW1ucy5yZW1vdmUoY29sKSwgdW5kZWZpbmVkLCBpc011bHRpS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkQ29sdW1ucyh1bmRlZmluZWQsIGNvbCwgaXNNdWx0aUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFNlbGVjdGVkQ29sUmVmLmN1cnJlbnQgPSBjb2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtblNlbGVjdCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zKENvbXBhY3RTZWxlY3Rpb24uZnJvbVNpbmdsZVNlbGVjdGlvbihjb2wpLCB1bmRlZmluZWQsIGlzTXVsdGlLZXkpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VsZWN0ZWRDb2xSZWYuY3VycmVudCA9IGNvbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdGVkUm93UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmdzLmtpbmQgPT09IGdyb3VwSGVhZGVyS2luZCkge1xuICAgICAgICAgICAgbGFzdE1vdXNlU2VsZWN0TG9jYXRpb24uY3VycmVudCA9IFtjb2wsIHJvd107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJncy5raW5kID09PSBvdXRPZkJvdW5kc0tpbmQgJiYgIWFyZ3MuaXNNYXliZVNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2V0R3JpZFNlbGVjdGlvbihlbXB0eUdyaWRTZWxlY3Rpb24sIGZhbHNlKTtcbiAgICAgICAgICAgIHNldE92ZXJsYXkodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGZvY3VzKCk7XG4gICAgICAgICAgICBvblNlbGVjdGlvbkNsZWFyZWQ/LigpO1xuICAgICAgICAgICAgbGFzdFNlbGVjdGVkUm93UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsYXN0U2VsZWN0ZWRDb2xSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYXBwZW5kUm93LFxuICAgICAgICBjb2x1bW5TZWxlY3QsXG4gICAgICAgIGZvY3VzLFxuICAgICAgICBnZXRDZWxsUmVuZGVyZXIsXG4gICAgICAgIGdldEN1c3RvbU5ld1Jvd1RhcmdldENvbHVtbixcbiAgICAgICAgZ2V0TWFuZ2xlZENlbGxDb250ZW50LFxuICAgICAgICBncmlkU2VsZWN0aW9uLFxuICAgICAgICBoYXNSb3dNYXJrZXJzLFxuICAgICAgICBsYXN0Um93U3RpY2t5LFxuICAgICAgICBvblNlbGVjdGlvbkNsZWFyZWQsXG4gICAgICAgIG9uUm93TW92ZWQsXG4gICAgICAgIHJvd01hcmtlck9mZnNldCxcbiAgICAgICAgcm93TWFya2VycyxcbiAgICAgICAgcm93U2VsZWN0LFxuICAgICAgICByb3dTZWxlY3Rpb25Nb2RlLFxuICAgICAgICByb3dzLFxuICAgICAgICBzZXRDdXJyZW50LFxuICAgICAgICBzZXRHcmlkU2VsZWN0aW9uLFxuICAgICAgICBzZXRTZWxlY3RlZENvbHVtbnMsXG4gICAgICAgIHNldFNlbGVjdGVkUm93cyxcbiAgICAgICAgc2hvd1RyYWlsaW5nQmxhbmtSb3csXG4gICAgICAgIHRoZW1lRm9yQ2VsbCxcbiAgICBdKTtcbiAgICBjb25zdCBpc0FjdGl2ZWx5RHJhZ2dpbmdIZWFkZXIgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGxhc3RNb3VzZVNlbGVjdExvY2F0aW9uID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgdG91Y2hEb3duQXJncyA9IFJlYWN0LnVzZVJlZih2aXNpYmxlUmVnaW9uKTtcbiAgICBjb25zdCBtb3VzZURvd25EYXRhID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSBSZWFjdC51c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICBpc1ByZXZlbnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHRvdWNoRG93bkFyZ3MuY3VycmVudCA9IHZpc2libGVSZWdpb25SZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGFyZ3MuYnV0dG9uICE9PSAwICYmIGFyZ3MuYnV0dG9uICE9PSAxKSB7XG4gICAgICAgICAgICBtb3VzZURvd25EYXRhLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBtb3VzZURvd25EYXRhLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICBidXR0b246IGFyZ3MuYnV0dG9uLFxuICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBhcmdzLmxvY2F0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJncz8ua2luZCA9PT0gXCJoZWFkZXJcIikge1xuICAgICAgICAgICAgaXNBY3RpdmVseURyYWdnaW5nSGVhZGVyLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZoID0gYXJncy5raW5kID09PSBcImNlbGxcIiAmJiBhcmdzLmlzRmlsbEhhbmRsZTtcbiAgICAgICAgaWYgKCFmaCAmJiBhcmdzLmtpbmQgIT09IFwiY2VsbFwiICYmIGFyZ3MuaXNFZGdlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZXRNb3VzZVN0YXRlKHtcbiAgICAgICAgICAgIHByZXZpb3VzU2VsZWN0aW9uOiBncmlkU2VsZWN0aW9uLFxuICAgICAgICAgICAgZmlsbEhhbmRsZTogZmgsXG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0TW91c2VTZWxlY3RMb2NhdGlvbi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIWFyZ3MuaXNUb3VjaCAmJiBhcmdzLmJ1dHRvbiA9PT0gMCAmJiAhZmgpIHtcbiAgICAgICAgICAgIGhhbmRsZVNlbGVjdChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYXJncy5pc1RvdWNoICYmIGFyZ3MuYnV0dG9uID09PSAxKSB7XG4gICAgICAgICAgICBsYXN0TW91c2VTZWxlY3RMb2NhdGlvbi5jdXJyZW50ID0gYXJncy5sb2NhdGlvbjtcbiAgICAgICAgfVxuICAgIH0sIFtncmlkU2VsZWN0aW9uLCBoYW5kbGVTZWxlY3RdKTtcbiAgICBjb25zdCBbcmVuYW1lR3JvdXAsIHNldFJlbmFtZUdyb3VwXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgY29uc3QgaGFuZGxlR3JvdXBIZWFkZXJTZWxlY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5raW5kICE9PSBncm91cEhlYWRlcktpbmQgfHwgY29sdW1uU2VsZWN0ICE9PSBcIm11bHRpXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc011bHRpS2V5ID0gYnJvd3NlcklzT1NYLnZhbHVlID8gYXJncy5tZXRhS2V5IDogYXJncy5jdHJsS2V5O1xuICAgICAgICBjb25zdCBbY29sXSA9IGFyZ3MubG9jYXRpb247XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ29sdW1ucyA9IGdyaWRTZWxlY3Rpb24uY29sdW1ucztcbiAgICAgICAgaWYgKGNvbCA8IHJvd01hcmtlck9mZnNldClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmVlZGxlID0gbWFuZ2xlZENvbHNbY29sXTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gY29sO1xuICAgICAgICBsZXQgZW5kID0gY29sO1xuICAgICAgICBmb3IgKGxldCBpID0gY29sIC0gMTsgaSA+PSByb3dNYXJrZXJPZmZzZXQ7IGktLSkge1xuICAgICAgICAgICAgaWYgKCFpc0dyb3VwRXF1YWwobmVlZGxlLmdyb3VwLCBtYW5nbGVkQ29sc1tpXS5ncm91cCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBjb2wgKyAxOyBpIDwgbWFuZ2xlZENvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghaXNHcm91cEVxdWFsKG5lZWRsZS5ncm91cCwgbWFuZ2xlZENvbHNbaV0uZ3JvdXApKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9jdXMoKTtcbiAgICAgICAgaWYgKGlzTXVsdGlLZXkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZENvbHVtbnMuaGFzQWxsKFtzdGFydCwgZW5kICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCA9IHNlbGVjdGVkQ29sdW1ucztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0OyBpbmRleCA8PSBlbmQ7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gbmV3VmFsLnJlbW92ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkQ29sdW1ucyhuZXdWYWwsIHVuZGVmaW5lZCwgaXNNdWx0aUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZENvbHVtbnModW5kZWZpbmVkLCBbc3RhcnQsIGVuZCArIDFdLCBpc011bHRpS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkQ29sdW1ucyhDb21wYWN0U2VsZWN0aW9uLmZyb21TaW5nbGVTZWxlY3Rpb24oW3N0YXJ0LCBlbmQgKyAxXSksIHVuZGVmaW5lZCwgaXNNdWx0aUtleSk7XG4gICAgICAgIH1cbiAgICB9LCBbY29sdW1uU2VsZWN0LCBmb2N1cywgZ3JpZFNlbGVjdGlvbi5jb2x1bW5zLCBtYW5nbGVkQ29scywgcm93TWFya2VyT2Zmc2V0LCBzZXRTZWxlY3RlZENvbHVtbnNdKTtcbiAgICBjb25zdCBpc1ByZXZlbnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgbm9ybWFsU2l6ZUNvbHVtbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGFzeW5jIChjb2wpID0+IHtcbiAgICAgICAgaWYgKGdldENlbGxzRm9yU2VsZWN0aW9uICE9PSB1bmRlZmluZWQgJiYgb25Db2x1bW5SZXNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB2aXNpYmxlUmVnaW9uUmVmLmN1cnJlbnQueTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHZpc2libGVSZWdpb25SZWYuY3VycmVudC5oZWlnaHQ7XG4gICAgICAgICAgICBsZXQgY2VsbHMgPSBnZXRDZWxsc0ZvclNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgeDogY29sLFxuICAgICAgICAgICAgICAgIHk6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5taW4oZW5kLCByb3dzIC0gc3RhcnQpLFxuICAgICAgICAgICAgfSwgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuc2lnbmFsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjZWxscyA9IGF3YWl0IGNlbGxzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnB1dENvbCA9IGNvbHVtbnNbY29sIC0gcm93TWFya2VyT2Zmc2V0XTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIsIHsgYWxwaGE6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGN0eCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gbWVyZ2VkVGhlbWUuYmFzZUZvbnRGdWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbCA9IG1lYXN1cmVDb2x1bW4oY3R4LCBtZXJnZWRUaGVtZSwgaW5wdXRDb2wsIDAsIGNlbGxzLCBtaW5Db2x1bW5XaWR0aCwgbWF4Q29sdW1uV2lkdGgsIGZhbHNlLCBnZXRDZWxsUmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPy4oaW5wdXRDb2wsIG5ld0NvbC53aWR0aCwgY29sLCBuZXdDb2wud2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBjb2x1bW5zLFxuICAgICAgICBnZXRDZWxsc0ZvclNlbGVjdGlvbixcbiAgICAgICAgbWF4Q29sdW1uV2lkdGgsXG4gICAgICAgIG1lcmdlZFRoZW1lLFxuICAgICAgICBtaW5Db2x1bW5XaWR0aCxcbiAgICAgICAgb25Db2x1bW5SZXNpemUsXG4gICAgICAgIHJvd01hcmtlck9mZnNldCxcbiAgICAgICAgcm93cyxcbiAgICAgICAgZ2V0Q2VsbFJlbmRlcmVyLFxuICAgIF0pO1xuICAgIGNvbnN0IFtzY3JvbGxEaXIsIHNldFNjcm9sbERpcl0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICAgIGNvbnN0IGZpbGxQYXR0ZXJuID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKHByZXZpb3VzU2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5SYW5nZSA9IHByZXZpb3VzU2VsZWN0aW9uLmN1cnJlbnQ/LnJhbmdlO1xuICAgICAgICBpZiAocGF0dGVyblJhbmdlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGdldENlbGxzRm9yU2VsZWN0aW9uID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFJhbmdlID0gY3VycmVudFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlO1xuICAgICAgICBpZiAob25GaWxsUGF0dGVybiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG9uRmlsbFBhdHRlcm4oe1xuICAgICAgICAgICAgICAgIGZpbGxEZXN0aW5hdGlvbjogeyAuLi5jdXJyZW50UmFuZ2UsIHg6IGN1cnJlbnRSYW5nZS54IC0gcm93TWFya2VyT2Zmc2V0IH0sXG4gICAgICAgICAgICAgICAgcGF0dGVyblNvdXJjZTogeyAuLi5wYXR0ZXJuUmFuZ2UsIHg6IHBhdHRlcm5SYW5nZS54IC0gcm93TWFya2VyT2Zmc2V0IH0sXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IChjYW5jZWxlZCA9IHRydWUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjZWxscyA9IGdldENlbGxzRm9yU2VsZWN0aW9uKHBhdHRlcm5SYW5nZSwgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuc2lnbmFsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjZWxscyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIGNlbGxzID0gYXdhaXQgY2VsbHMoKTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGNlbGxzO1xuICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGNlbGxzIGluIGN1cnJlbnRTZWxlY3Rpb24uY3VycmVudC5yYW5nZVxuICAgICAgICBjb25zdCBlZGl0SXRlbUxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjdXJyZW50UmFuZ2Uud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjdXJyZW50UmFuZ2UuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gW2N1cnJlbnRSYW5nZS54ICsgeCwgY3VycmVudFJhbmdlLnkgKyB5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUlzSW5SZWN0KGNlbGwsIHBhdHRlcm5SYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5DZWxsID0gcGF0dGVyblt5ICUgcGF0dGVyblJhbmdlLmhlaWdodF1beCAlIHBhdHRlcm5SYW5nZS53aWR0aF07XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5uZXJPbmx5Q2VsbChwYXR0ZXJuQ2VsbCkgfHwgIWlzUmVhZFdyaXRlQ2VsbChwYXR0ZXJuQ2VsbCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVkaXRJdGVtTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGNlbGwsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IC4uLnBhdHRlcm5DZWxsIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFuZ2xlZE9uQ2VsbHNFZGl0ZWQoZWRpdEl0ZW1MaXN0KTtcbiAgICAgICAgZ3JpZFJlZi5jdXJyZW50Py5kYW1hZ2UoZWRpdEl0ZW1MaXN0Lm1hcChjID0+ICh7XG4gICAgICAgICAgICBjZWxsOiBjLmxvY2F0aW9uLFxuICAgICAgICB9KSkpO1xuICAgIH0sIFtnZXRDZWxsc0ZvclNlbGVjdGlvbiwgbWFuZ2xlZE9uQ2VsbHNFZGl0ZWQsIG9uRmlsbFBhdHRlcm4sIHJvd01hcmtlck9mZnNldF0pO1xuICAgIGNvbnN0IGZpbGxSaWdodCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGdyaWRTZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkIHx8IGdyaWRTZWxlY3Rpb24uY3VycmVudC5yYW5nZS53aWR0aCA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmaXJzdENvbFNlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmdyaWRTZWxlY3Rpb24sXG4gICAgICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgICAgICAgLi4uZ3JpZFNlbGVjdGlvbi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdyaWRTZWxlY3Rpb24uY3VycmVudC5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHZvaWQgZmlsbFBhdHRlcm4oZmlyc3RDb2xTZWxlY3Rpb24sIGdyaWRTZWxlY3Rpb24pO1xuICAgIH0sIFtmaWxsUGF0dGVybiwgZ3JpZFNlbGVjdGlvbl0pO1xuICAgIGNvbnN0IGZpbGxEb3duID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAoZ3JpZFNlbGVjdGlvbi5jdXJyZW50ID09PSB1bmRlZmluZWQgfHwgZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlLmhlaWdodCA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmaXJzdFJvd1NlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmdyaWRTZWxlY3Rpb24sXG4gICAgICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgICAgICAgLi4uZ3JpZFNlbGVjdGlvbi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmdyaWRTZWxlY3Rpb24uY3VycmVudC5yYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB2b2lkIGZpbGxQYXR0ZXJuKGZpcnN0Um93U2VsZWN0aW9uLCBncmlkU2VsZWN0aW9uKTtcbiAgICB9LCBbZmlsbFBhdHRlcm4sIGdyaWRTZWxlY3Rpb25dKTtcbiAgICBjb25zdCBvbk1vdXNlVXAgPSBSZWFjdC51c2VDYWxsYmFjaygoYXJncywgaXNPdXRzaWRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdXNlID0gbW91c2VTdGF0ZTtcbiAgICAgICAgc2V0TW91c2VTdGF0ZSh1bmRlZmluZWQpO1xuICAgICAgICBzZXRGaWxsSGlnaGxpZ2h0UmVnaW9uKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldFNjcm9sbERpcih1bmRlZmluZWQpO1xuICAgICAgICBpc0FjdGl2ZWx5RHJhZ2dpbmdIZWFkZXIuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNPdXRzaWRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobW91c2U/LmZpbGxIYW5kbGUgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGdyaWRTZWxlY3Rpb24uY3VycmVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBtb3VzZS5wcmV2aW91c1NlbGVjdGlvbj8uY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZmlsbEhpZ2hsaWdodFJlZ2lvbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JhbmdlID0ge1xuICAgICAgICAgICAgICAgIC4uLmdyaWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgY3VycmVudDoge1xuICAgICAgICAgICAgICAgICAgICAuLi5ncmlkU2VsZWN0aW9uLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjb21iaW5lUmVjdHMobW91c2UucHJldmlvdXNTZWxlY3Rpb24uY3VycmVudC5yYW5nZSwgZmlsbEhpZ2hsaWdodFJlZ2lvbiksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2b2lkIGZpbGxQYXR0ZXJuKG1vdXNlLnByZXZpb3VzU2VsZWN0aW9uLCBuZXdSYW5nZSk7XG4gICAgICAgICAgICBzZXRHcmlkU2VsZWN0aW9uKG5ld1JhbmdlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbY29sLCByb3ddID0gYXJncy5sb2NhdGlvbjtcbiAgICAgICAgY29uc3QgW2xhc3RNb3VzZURvd25Db2wsIGxhc3RNb3VzZURvd25Sb3ddID0gbGFzdE1vdXNlU2VsZWN0TG9jYXRpb24uY3VycmVudCA/PyBbXTtcbiAgICAgICAgY29uc3QgcHJldmVudERlZmF1bHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpc1ByZXZlbnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlTWF5YmVDbGljayA9IChhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkQ2xpY2sgPSBhLmlzVG91Y2ggfHwgKGxhc3RNb3VzZURvd25Db2wgPT09IGNvbCAmJiBsYXN0TW91c2VEb3duUm93ID09PSByb3cpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRDbGljaykge1xuICAgICAgICAgICAgICAgIG9uQ2VsbENsaWNrZWQ/LihbY29sIC0gcm93TWFya2VyT2Zmc2V0LCByb3ddLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmEsXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEuYnV0dG9uID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiAhaXNQcmV2ZW50ZWQuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghaXNQcmV2ZW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBnZXRNYW5nbGVkQ2VsbENvbnRlbnQoYXJncy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGdldENlbGxSZW5kZXJlcihjKTtcbiAgICAgICAgICAgICAgICBpZiAociAhPT0gdW5kZWZpbmVkICYmIHIub25DbGljayAhPT0gdW5kZWZpbmVkICYmIGlzVmFsaWRDbGljaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSByLm9uQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGw6IGMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NYOiBhLmxvY2FsRXZlbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zWTogYS5sb2NhbEV2ZW50WSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kczogYS5ib3VuZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVtZTogdGhlbWVGb3JDZWxsKGMsIGFyZ3MubG9jYXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsICE9PSB1bmRlZmluZWQgJiYgIWlzSW5uZXJPbmx5Q2VsbChuZXdWYWwpICYmIGlzRWRpdGFibGVHcmlkQ2VsbChuZXdWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5nbGVkT25DZWxsc0VkaXRlZChbeyBsb2NhdGlvbjogYS5sb2NhdGlvbiwgdmFsdWU6IG5ld1ZhbCB9XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkUmVmLmN1cnJlbnQ/LmRhbWFnZShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsOiBhLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNQcmV2ZW50ZWQuY3VycmVudCB8fCBncmlkU2VsZWN0aW9uLmN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBzaG91bGRBY3RpdmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYy5hY3RpdmF0aW9uQmVoYXZpb3JPdmVycmlkZSA/PyBjZWxsQWN0aXZhdGlvbkJlaGF2aW9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkb3VibGUtY2xpY2tcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlY29uZC1jbGlja1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW91c2U/LnByZXZpb3VzU2VsZWN0aW9uPy5jdXJyZW50Py5jZWxsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2VsZWN0ZWRDb2wsIHNlbGVjdGVkUm93XSA9IGdyaWRTZWxlY3Rpb24uY3VycmVudC5jZWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3ByZXZDb2wsIHByZXZSb3ddID0gbW91c2UucHJldmlvdXNTZWxlY3Rpb24uY3VycmVudC5jZWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDbGlja09uU2VsZWN0ZWQgPSBjb2wgPT09IHNlbGVjdGVkQ29sICYmIGNvbCA9PT0gcHJldkNvbCAmJiByb3cgPT09IHNlbGVjdGVkUm93ICYmIHJvdyA9PT0gcHJldlJvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEFjdGl2YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NsaWNrT25TZWxlY3RlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYS5pc0RvdWJsZUNsaWNrID09PSB0cnVlIHx8IGNlbGxBY3RpdmF0aW9uQmVoYXZpb3IgPT09IFwic2Vjb25kLWNsaWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNpbmdsZS1jbGlja1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRBY3RpdmF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWN0aXZhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DZWxsQWN0aXZhdGVkPy4oW2NvbCAtIHJvd01hcmtlck9mZnNldCwgcm93XSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc2VsZWN0KGEuYm91bmRzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xpY2tMb2NhdGlvbiA9IGFyZ3MubG9jYXRpb25bMF0gLSByb3dNYXJrZXJPZmZzZXQ7XG4gICAgICAgIGlmIChhcmdzLmlzVG91Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHZyID0gdmlzaWJsZVJlZ2lvblJlZi5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgdG91Y2hWciA9IHRvdWNoRG93bkFyZ3MuY3VycmVudDtcbiAgICAgICAgICAgIGlmICh2ci54ICE9PSB0b3VjaFZyLnggfHwgdnIueSAhPT0gdG91Y2hWci55KSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2Nyb2xsZWQsIGFib3J0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGFrZSBjYXJlIG9mIGNvbnRleHQgbWVudXMgZmlyc3QgaWYgbG9uZyBwcmVzc2VkIGl0ZW0gaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgICAgaWYgKGFyZ3MuaXNMb25nVG91Y2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5raW5kID09PSBcImNlbGxcIiAmJiBpdGVtc0FyZUVxdWFsKGdyaWRTZWxlY3Rpb24uY3VycmVudD8uY2VsbCwgYXJncy5sb2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DZWxsQ29udGV4dE1lbnU/LihbY2xpY2tMb2NhdGlvbiwgYXJncy5sb2NhdGlvblsxXV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJncy5raW5kID09PSBcImhlYWRlclwiICYmIGdyaWRTZWxlY3Rpb24uY29sdW1ucy5oYXNJbmRleChjb2wpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uSGVhZGVyQ29udGV4dE1lbnU/LihjbGlja0xvY2F0aW9uLCB7IC4uLmFyZ3MsIHByZXZlbnREZWZhdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3Mua2luZCA9PT0gZ3JvdXBIZWFkZXJLaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlja0xvY2F0aW9uIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uR3JvdXBIZWFkZXJDb250ZXh0TWVudT8uKGNsaWNrTG9jYXRpb24sIHsgLi4uYXJncywgcHJldmVudERlZmF1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJncy5raW5kID09PSBcImNlbGxcIikge1xuICAgICAgICAgICAgICAgIC8vIGNsaWNrIHRoYXQgY2VsbFxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlTWF5YmVDbGljayhhcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTZWxlY3QoYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJncy5raW5kID09PSBncm91cEhlYWRlcktpbmQpIHtcbiAgICAgICAgICAgICAgICBvbkdyb3VwSGVhZGVyQ2xpY2tlZD8uKGNsaWNrTG9jYXRpb24sIHsgLi4uYXJncywgcHJldmVudERlZmF1bHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5raW5kID09PSBoZWFkZXJLaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uSGVhZGVyQ2xpY2tlZD8uKGNsaWNrTG9jYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNlbGVjdChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5raW5kID09PSBcImhlYWRlclwiKSB7XG4gICAgICAgICAgICBpZiAoY2xpY2tMb2NhdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJncy5pc0VkZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5pc0RvdWJsZUNsaWNrID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgbm9ybWFsU2l6ZUNvbHVtbihjb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3MuYnV0dG9uID09PSAwICYmIGNvbCA9PT0gbGFzdE1vdXNlRG93bkNvbCAmJiByb3cgPT09IGxhc3RNb3VzZURvd25Sb3cpIHtcbiAgICAgICAgICAgICAgICBvbkhlYWRlckNsaWNrZWQ/LihjbGlja0xvY2F0aW9uLCB7IC4uLmFyZ3MsIHByZXZlbnREZWZhdWx0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmtpbmQgPT09IGdyb3VwSGVhZGVyS2luZCkge1xuICAgICAgICAgICAgaWYgKGNsaWNrTG9jYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3MuYnV0dG9uID09PSAwICYmIGNvbCA9PT0gbGFzdE1vdXNlRG93bkNvbCAmJiByb3cgPT09IGxhc3RNb3VzZURvd25Sb3cpIHtcbiAgICAgICAgICAgICAgICBvbkdyb3VwSGVhZGVyQ2xpY2tlZD8uKGNsaWNrTG9jYXRpb24sIHsgLi4uYXJncywgcHJldmVudERlZmF1bHQgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ByZXZlbnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUdyb3VwSGVhZGVyU2VsZWN0aW9uKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncy5raW5kID09PSBcImNlbGxcIiAmJiAoYXJncy5idXR0b24gPT09IDAgfHwgYXJncy5idXR0b24gPT09IDEpKSB7XG4gICAgICAgICAgICBoYW5kbGVNYXliZUNsaWNrKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RNb3VzZVNlbGVjdExvY2F0aW9uLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfSwgW1xuICAgICAgICBtb3VzZVN0YXRlLFxuICAgICAgICBncmlkU2VsZWN0aW9uLFxuICAgICAgICByb3dNYXJrZXJPZmZzZXQsXG4gICAgICAgIGZpbGxIaWdobGlnaHRSZWdpb24sXG4gICAgICAgIGZpbGxQYXR0ZXJuLFxuICAgICAgICBzZXRHcmlkU2VsZWN0aW9uLFxuICAgICAgICBvbkNlbGxDbGlja2VkLFxuICAgICAgICBnZXRNYW5nbGVkQ2VsbENvbnRlbnQsXG4gICAgICAgIGdldENlbGxSZW5kZXJlcixcbiAgICAgICAgY2VsbEFjdGl2YXRpb25CZWhhdmlvcixcbiAgICAgICAgdGhlbWVGb3JDZWxsLFxuICAgICAgICBtYW5nbGVkT25DZWxsc0VkaXRlZCxcbiAgICAgICAgb25DZWxsQWN0aXZhdGVkLFxuICAgICAgICByZXNlbGVjdCxcbiAgICAgICAgb25DZWxsQ29udGV4dE1lbnUsXG4gICAgICAgIG9uSGVhZGVyQ29udGV4dE1lbnUsXG4gICAgICAgIG9uR3JvdXBIZWFkZXJDb250ZXh0TWVudSxcbiAgICAgICAgaGFuZGxlU2VsZWN0LFxuICAgICAgICBvbkdyb3VwSGVhZGVyQ2xpY2tlZCxcbiAgICAgICAgb25IZWFkZXJDbGlja2VkLFxuICAgICAgICBub3JtYWxTaXplQ29sdW1uLFxuICAgICAgICBoYW5kbGVHcm91cEhlYWRlclNlbGVjdGlvbixcbiAgICBdKTtcbiAgICBjb25zdCBvbk1vdXNlTW92ZUltcGwgPSBSZWFjdC51c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICBjb25zdCBhID0ge1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBbYXJncy5sb2NhdGlvblswXSAtIHJvd01hcmtlck9mZnNldCwgYXJncy5sb2NhdGlvblsxXV0sXG4gICAgICAgIH07XG4gICAgICAgIG9uTW91c2VNb3ZlPy4oYSk7XG4gICAgICAgIGlmIChtb3VzZVN0YXRlICE9PSB1bmRlZmluZWQgJiYgYXJncy5idXR0b25zID09PSAwKSB7XG4gICAgICAgICAgICBzZXRNb3VzZVN0YXRlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBzZXRGaWxsSGlnaGxpZ2h0UmVnaW9uKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBzZXRTY3JvbGxEaXIodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGlzQWN0aXZlbHlEcmFnZ2luZ0hlYWRlci5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U2Nyb2xsRGlyKGN2ID0+IHtcbiAgICAgICAgICAgIGlmIChpc0FjdGl2ZWx5RHJhZ2dpbmdIZWFkZXIuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FyZ3Muc2Nyb2xsRWRnZVswXSwgMF07XG4gICAgICAgICAgICBpZiAoYXJncy5zY3JvbGxFZGdlWzBdID09PSBjdj8uWzBdICYmIGFyZ3Muc2Nyb2xsRWRnZVsxXSA9PT0gY3ZbMV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN2O1xuICAgICAgICAgICAgcmV0dXJuIG1vdXNlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCAobW91c2VEb3duRGF0YS5jdXJyZW50Py5sb2NhdGlvblswXSA/PyAwKSA8IHJvd01hcmtlck9mZnNldFxuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBhcmdzLnNjcm9sbEVkZ2U7XG4gICAgICAgIH0pO1xuICAgIH0sIFttb3VzZVN0YXRlLCBvbk1vdXNlTW92ZSwgcm93TWFya2VyT2Zmc2V0XSk7XG4gICAgY29uc3Qgb25IZWFkZXJNZW51Q2xpY2tJbm5lciA9IFJlYWN0LnVzZUNhbGxiYWNrKChjb2wsIHNjcmVlblBvc2l0aW9uKSA9PiB7XG4gICAgICAgIG9uSGVhZGVyTWVudUNsaWNrPy4oY29sIC0gcm93TWFya2VyT2Zmc2V0LCBzY3JlZW5Qb3NpdGlvbik7XG4gICAgfSwgW29uSGVhZGVyTWVudUNsaWNrLCByb3dNYXJrZXJPZmZzZXRdKTtcbiAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGdyaWRTZWxlY3Rpb24/LmN1cnJlbnQ/LmNlbGw7XG4gICAgY29uc3Qgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZEltcGwgPSBSZWFjdC51c2VDYWxsYmFjaygocmVnaW9uLCBjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0LCByaWdodEVsV2lkdGgsIHR4LCB0eSkgPT4ge1xuICAgICAgICBoYXNKdXN0U2Nyb2xsZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBjdXJyZW50Q2VsbDtcbiAgICAgICAgaWYgKHNlbGVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gW3NlbGVjdGVkWzBdIC0gcm93TWFya2VyT2Zmc2V0LCBzZWxlY3RlZFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJlZXplUmVnaW9uID0gZnJlZXplQ29sdW1ucyA9PT0gMFxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogcmVnaW9uLnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IGZyZWV6ZUNvbHVtbnMsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZWdpb24uaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZnJlZXplUmVnaW9ucyA9IFtdO1xuICAgICAgICBpZiAoZnJlZXplUmVnaW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBmcmVlemVSZWdpb25zLnB1c2goZnJlZXplUmVnaW9uKTtcbiAgICAgICAgaWYgKGZyZWV6ZVRyYWlsaW5nUm93cyA+IDApIHtcbiAgICAgICAgICAgIGZyZWV6ZVJlZ2lvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogcmVnaW9uLnggLSByb3dNYXJrZXJPZmZzZXQsXG4gICAgICAgICAgICAgICAgeTogcm93cyAtIGZyZWV6ZVRyYWlsaW5nUm93cyxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVnaW9uLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZnJlZXplVHJhaWxpbmdSb3dzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZnJlZXplQ29sdW1ucyA+IDApIHtcbiAgICAgICAgICAgICAgICBmcmVlemVSZWdpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiByb3dzIC0gZnJlZXplVHJhaWxpbmdSb3dzLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogZnJlZXplQ29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBmcmVlemVUcmFpbGluZ1Jvd3MsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3UmVnaW9uID0ge1xuICAgICAgICAgICAgeDogcmVnaW9uLnggLSByb3dNYXJrZXJPZmZzZXQsXG4gICAgICAgICAgICB5OiByZWdpb24ueSxcbiAgICAgICAgICAgIHdpZHRoOiByZWdpb24ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNob3dUcmFpbGluZ0JsYW5rUm93ICYmIHJlZ2lvbi55ICsgcmVnaW9uLmhlaWdodCA+PSByb3dzID8gcmVnaW9uLmhlaWdodCAtIDEgOiByZWdpb24uaGVpZ2h0LFxuICAgICAgICAgICAgdHgsXG4gICAgICAgICAgICB0eSxcbiAgICAgICAgICAgIGV4dHJhczoge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgIGZyZWV6ZVJlZ2lvbixcbiAgICAgICAgICAgICAgICBmcmVlemVSZWdpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmlzaWJsZVJlZ2lvblJlZi5jdXJyZW50ID0gbmV3UmVnaW9uO1xuICAgICAgICBzZXRWaXNpYmxlUmVnaW9uKG5ld1JlZ2lvbik7XG4gICAgICAgIHNldENsaWVudFNpemUoW2NsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQsIHJpZ2h0RWxXaWR0aF0pO1xuICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPy4obmV3UmVnaW9uLCBuZXdSZWdpb24udHgsIG5ld1JlZ2lvbi50eSwgbmV3UmVnaW9uLmV4dHJhcyk7XG4gICAgfSwgW1xuICAgICAgICBjdXJyZW50Q2VsbCxcbiAgICAgICAgcm93TWFya2VyT2Zmc2V0LFxuICAgICAgICBzaG93VHJhaWxpbmdCbGFua1JvdyxcbiAgICAgICAgcm93cyxcbiAgICAgICAgZnJlZXplQ29sdW1ucyxcbiAgICAgICAgZnJlZXplVHJhaWxpbmdSb3dzLFxuICAgICAgICBzZXRWaXNpYmxlUmVnaW9uLFxuICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkLFxuICAgIF0pO1xuICAgIGNvbnN0IG9uQ29sdW1uTW92ZWRJbXBsID0gd2hlbkRlZmluZWQob25Db2x1bW5Nb3ZlZCwgUmVhY3QudXNlQ2FsbGJhY2soKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSA9PiB7XG4gICAgICAgIG9uQ29sdW1uTW92ZWQ/LihzdGFydEluZGV4IC0gcm93TWFya2VyT2Zmc2V0LCBlbmRJbmRleCAtIHJvd01hcmtlck9mZnNldCk7XG4gICAgICAgIGlmIChjb2x1bW5TZWxlY3QgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZENvbHVtbnMoQ29tcGFjdFNlbGVjdGlvbi5mcm9tU2luZ2xlU2VsZWN0aW9uKGVuZEluZGV4KSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb2x1bW5TZWxlY3QsIG9uQ29sdW1uTW92ZWQsIHJvd01hcmtlck9mZnNldCwgc2V0U2VsZWN0ZWRDb2x1bW5zXSkpO1xuICAgIGNvbnN0IGlzQWN0aXZlbHlEcmFnZ2luZyA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgb25EcmFnU3RhcnRJbXBsID0gUmVhY3QudXNlQ2FsbGJhY2soKGFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MubG9jYXRpb25bMF0gPT09IDAgJiYgcm93TWFya2VyT2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgYXJncy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uRHJhZ1N0YXJ0Py4oe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBbYXJncy5sb2NhdGlvblswXSAtIHJvd01hcmtlck9mZnNldCwgYXJncy5sb2NhdGlvblsxXV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWFyZ3MuZGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICBpc0FjdGl2ZWx5RHJhZ2dpbmcuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0TW91c2VTdGF0ZSh1bmRlZmluZWQpO1xuICAgIH0sIFtvbkRyYWdTdGFydCwgcm93TWFya2VyT2Zmc2V0XSk7XG4gICAgY29uc3Qgb25EcmFnRW5kID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpc0FjdGl2ZWx5RHJhZ2dpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBob3ZlcmVkUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZEltcGwgPSBSZWFjdC51c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc3RpbGwgaGF2ZSBhIGJ1dHRvbiBkb3duXG4gICAgICAgIGlmIChtb3VzZUV2ZW50QXJnc0FyZUVxdWFsKGFyZ3MsIGhvdmVyZWRSZWYuY3VycmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhvdmVyZWRSZWYuY3VycmVudCA9IGFyZ3M7XG4gICAgICAgIGlmIChtb3VzZURvd25EYXRhPy5jdXJyZW50Py5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBtb3VzZURvd25EYXRhLmN1cnJlbnQuYnV0dG9uID49IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChhcmdzLmJ1dHRvbnMgIT09IDAgJiZcbiAgICAgICAgICAgIG1vdXNlU3RhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgbW91c2VEb3duRGF0YS5jdXJyZW50Py5sb2NhdGlvblswXSA9PT0gMCAmJlxuICAgICAgICAgICAgYXJncy5sb2NhdGlvblswXSA9PT0gMCAmJlxuICAgICAgICAgICAgcm93TWFya2VyT2Zmc2V0ID09PSAxICYmXG4gICAgICAgICAgICByb3dTZWxlY3QgPT09IFwibXVsdGlcIiAmJlxuICAgICAgICAgICAgbW91c2VTdGF0ZS5wcmV2aW91c1NlbGVjdGlvbiAmJlxuICAgICAgICAgICAgIW1vdXNlU3RhdGUucHJldmlvdXNTZWxlY3Rpb24ucm93cy5oYXNJbmRleChtb3VzZURvd25EYXRhLmN1cnJlbnQubG9jYXRpb25bMV0pICYmXG4gICAgICAgICAgICBncmlkU2VsZWN0aW9uLnJvd3MuaGFzSW5kZXgobW91c2VEb3duRGF0YS5jdXJyZW50LmxvY2F0aW9uWzFdKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihtb3VzZURvd25EYXRhLmN1cnJlbnQubG9jYXRpb25bMV0sIGFyZ3MubG9jYXRpb25bMV0pO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgobW91c2VEb3duRGF0YS5jdXJyZW50LmxvY2F0aW9uWzFdLCBhcmdzLmxvY2F0aW9uWzFdKSArIDE7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZFJvd3MoQ29tcGFjdFNlbGVjdGlvbi5mcm9tU2luZ2xlU2VsZWN0aW9uKFtzdGFydCwgZW5kXSksIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmJ1dHRvbnMgIT09IDAgJiZcbiAgICAgICAgICAgIG1vdXNlU3RhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZ3JpZFNlbGVjdGlvbi5jdXJyZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFpc0FjdGl2ZWx5RHJhZ2dpbmcuY3VycmVudCAmJlxuICAgICAgICAgICAgIWlzQWN0aXZlbHlEcmFnZ2luZ0hlYWRlci5jdXJyZW50ICYmXG4gICAgICAgICAgICAocmFuZ2VTZWxlY3QgPT09IFwicmVjdFwiIHx8IHJhbmdlU2VsZWN0ID09PSBcIm11bHRpLXJlY3RcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IFtzZWxlY3RlZENvbCwgc2VsZWN0ZWRSb3ddID0gZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGw7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgICAgICAgICBsZXQgW2NvbCwgcm93XSA9IGFyZ3MubG9jYXRpb247XG4gICAgICAgICAgICBpZiAocm93IDwgMCkge1xuICAgICAgICAgICAgICAgIHJvdyA9IHZpc2libGVSZWdpb25SZWYuY3VycmVudC55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlU3RhdGUuZmlsbEhhbmRsZSA9PT0gdHJ1ZSAmJiBtb3VzZVN0YXRlLnByZXZpb3VzU2VsZWN0aW9uPy5jdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2UmFuZ2UgPSBtb3VzZVN0YXRlLnByZXZpb3VzU2VsZWN0aW9uLmN1cnJlbnQucmFuZ2U7XG4gICAgICAgICAgICAgICAgcm93ID0gTWF0aC5taW4ocm93LCBzaG93VHJhaWxpbmdCbGFua1JvdyA/IHJvd3MgLSAxIDogcm93cyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGdldENsb3Nlc3RSZWN0KHByZXZSYW5nZSwgY29sLCByb3csIGFsbG93ZWRGaWxsRGlyZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgc2V0RmlsbEhpZ2hsaWdodFJlZ2lvbihyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ZWRGcm9tTGFzdFN0aWNreVJvdyA9IHNob3dUcmFpbGluZ0JsYW5rUm93ICYmIHNlbGVjdGVkUm93ID09PSByb3dzO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydGVkRnJvbUxhc3RTdGlja3lSb3cpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBsYW5kZWRPbkxhc3RTdGlja3lSb3cgPSBzaG93VHJhaWxpbmdCbGFua1JvdyAmJiByb3cgPT09IHJvd3M7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmRlZE9uTGFzdFN0aWNreVJvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5raW5kID09PSBvdXRPZkJvdW5kc0tpbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByb3ctLTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2wgPSBNYXRoLm1heChjb2wsIHJvd01hcmtlck9mZnNldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gY29sIC0gc2VsZWN0ZWRDb2w7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGFZID0gcm93IC0gc2VsZWN0ZWRSb3c7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGRlbHRhWCA+PSAwID8gc2VsZWN0ZWRDb2wgOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHk6IGRlbHRhWSA+PSAwID8gc2VsZWN0ZWRSb3cgOiByb3csXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLmFicyhkZWx0YVgpICsgMSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhkZWx0YVkpICsgMSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnQoe1xuICAgICAgICAgICAgICAgICAgICAuLi5ncmlkU2VsZWN0aW9uLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBuZXdSYW5nZSxcbiAgICAgICAgICAgICAgICB9LCB0cnVlLCBmYWxzZSwgXCJkcmFnXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uSXRlbUhvdmVyZWQ/Lih7IC4uLmFyZ3MsIGxvY2F0aW9uOiBbYXJncy5sb2NhdGlvblswXSAtIHJvd01hcmtlck9mZnNldCwgYXJncy5sb2NhdGlvblsxXV0gfSk7XG4gICAgfSwgW1xuICAgICAgICBhbGxvd2VkRmlsbERpcmVjdGlvbnMsXG4gICAgICAgIG1vdXNlU3RhdGUsXG4gICAgICAgIHJvd01hcmtlck9mZnNldCxcbiAgICAgICAgcm93U2VsZWN0LFxuICAgICAgICBncmlkU2VsZWN0aW9uLFxuICAgICAgICByYW5nZVNlbGVjdCxcbiAgICAgICAgb25JdGVtSG92ZXJlZCxcbiAgICAgICAgc2V0U2VsZWN0ZWRSb3dzLFxuICAgICAgICBzaG93VHJhaWxpbmdCbGFua1JvdyxcbiAgICAgICAgcm93cyxcbiAgICAgICAgc2V0Q3VycmVudCxcbiAgICBdKTtcbiAgICBjb25zdCBhZGp1c3RTZWxlY3Rpb25PblNjcm9sbCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgYXJncyA9IGhvdmVyZWRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgW3hEaXIsIHlEaXJdID0gYXJncy5zY3JvbGxFZGdlO1xuICAgICAgICBsZXQgW2NvbCwgcm93XSA9IGFyZ3MubG9jYXRpb247XG4gICAgICAgIGNvbnN0IHZpc2libGUgPSB2aXNpYmxlUmVnaW9uUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICh4RGlyID09PSAtMSkge1xuICAgICAgICAgICAgY29sID0gdmlzaWJsZS5leHRyYXM/LmZyZWV6ZVJlZ2lvbj8ueCA/PyB2aXNpYmxlLng7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeERpciA9PT0gMSkge1xuICAgICAgICAgICAgY29sID0gdmlzaWJsZS54ICsgdmlzaWJsZS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeURpciA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJvdyA9IE1hdGgubWF4KDAsIHZpc2libGUueSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeURpciA9PT0gMSkge1xuICAgICAgICAgICAgcm93ID0gTWF0aC5taW4ocm93cyAtIDEsIHZpc2libGUueSArIHZpc2libGUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb2wgPSBjbGFtcChjb2wsIDAsIG1hbmdsZWRDb2xzLmxlbmd0aCAtIDEpO1xuICAgICAgICByb3cgPSBjbGFtcChyb3csIDAsIHJvd3MgLSAxKTtcbiAgICAgICAgb25JdGVtSG92ZXJlZEltcGwoe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBbY29sLCByb3ddLFxuICAgICAgICB9KTtcbiAgICB9LCBbbWFuZ2xlZENvbHMubGVuZ3RoLCBvbkl0ZW1Ib3ZlcmVkSW1wbCwgcm93c10pO1xuICAgIHVzZUF1dG9zY3JvbGwoc2Nyb2xsRGlyLCBzY3JvbGxSZWYsIGFkanVzdFNlbGVjdGlvbk9uU2Nyb2xsKTtcbiAgICAvLyAxID09PSBtb3ZlIG9uZVxuICAgIC8vIDIgPT09IG1vdmUgdG8gZW5kXG4gICAgY29uc3QgYWRqdXN0U2VsZWN0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soKGRpcmVjdGlvbikgPT4ge1xuICAgICAgICBpZiAoZ3JpZFNlbGVjdGlvbi5jdXJyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IGRpcmVjdGlvbjtcbiAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGdyaWRTZWxlY3Rpb24uY3VycmVudC5jZWxsO1xuICAgICAgICBjb25zdCBvbGQgPSBncmlkU2VsZWN0aW9uLmN1cnJlbnQucmFuZ2U7XG4gICAgICAgIGxldCBsZWZ0ID0gb2xkLng7XG4gICAgICAgIGxldCByaWdodCA9IG9sZC54ICsgb2xkLndpZHRoO1xuICAgICAgICBsZXQgdG9wID0gb2xkLnk7XG4gICAgICAgIGxldCBib3R0b20gPSBvbGQueSArIG9sZC5oZWlnaHQ7XG4gICAgICAgIC8vIHRha2UgY2FyZSBvZiB2ZXJ0aWNhbCBmaXJzdCBpbiBjYXNlIG5ldyBzcGFucyBjb21lIGluXG4gICAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ28gdG8gZW5kXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHJvd3M7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHJvdztcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG8oMCwgYm90dG9tLCBcInZlcnRpY2FsXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAtMjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBnbyB0byBzdGFydFxuICAgICAgICAgICAgICAgICAgICB0b3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICBib3R0b20gPSByb3cgKyAxO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUbygwLCB0b3AsIFwidmVydGljYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW90aW9uIGRvd25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCA8IHJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUbygwLCB0b3AsIFwidmVydGljYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBNYXRoLm1pbihyb3dzLCBib3R0b20gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvKDAsIGJvdHRvbSwgXCJ2ZXJ0aWNhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAtMToge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3Rpb24gdXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbSA+IHJvdyArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG8oMCwgYm90dG9tLCBcInZlcnRpY2FsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgoMCwgdG9wIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUbygwLCB0b3AsIFwidmVydGljYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TmV2ZXIoeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWFuZ2xlZENvbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBjb2w7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVG8ocmlnaHQgLSAxIC0gcm93TWFya2VyT2Zmc2V0LCAwLCBcImhvcml6b250YWxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4ID09PSAtMikge1xuICAgICAgICAgICAgICAgIGxlZnQgPSByb3dNYXJrZXJPZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSBjb2wgKyAxO1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvKGxlZnQgLSByb3dNYXJrZXJPZmZzZXQsIDAsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkaXNhbGxvd2VkID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGdldENlbGxzRm9yU2VsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbHMgPSBnZXRDZWxsc0ZvclNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCAtIHJvd01hcmtlck9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wLFxuICAgICAgICAgICAgICAgICAgICB9LCBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5zaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNlbGxzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhbGxvd2VkID0gZ2V0U3BhblN0b3BzKGNlbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3Rpb24gcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPCBjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNhbGxvd2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSByYW5nZShsZWZ0ICsgMSwgY29sICsgMSkuZmluZChuID0+ICFkaXNhbGxvd2VkLmluY2x1ZGVzKG4gLSByb3dNYXJrZXJPZmZzZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG8obGVmdCwgMCwgXCJob3Jpem9udGFsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1pbihtYW5nbGVkQ29scy5sZW5ndGgsIHJpZ2h0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUbyhyaWdodCAtIDEgLSByb3dNYXJrZXJPZmZzZXQsIDAsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3Rpb24gbGVmdFxuICAgICAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQgPiBjb2wgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWxsb3dlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmFuZ2UocmlnaHQgLSAxLCBjb2wsIC0xKS5maW5kKG4gPT4gIWRpc2FsbG93ZWQuaW5jbHVkZXMobiAtIHJvd01hcmtlck9mZnNldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvKHJpZ2h0IC0gcm93TWFya2VyT2Zmc2V0LCAwLCBcImhvcml6b250YWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgocm93TWFya2VyT2Zmc2V0LCBsZWZ0IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUbyhsZWZ0IC0gcm93TWFya2VyT2Zmc2V0LCAwLCBcImhvcml6b250YWxcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE5ldmVyKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRDdXJyZW50KHtcbiAgICAgICAgICAgIGNlbGw6IGdyaWRTZWxlY3Rpb24uY3VycmVudC5jZWxsLFxuICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmlnaHQgLSBsZWZ0LFxuICAgICAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgdHJ1ZSwgZmFsc2UsIFwia2V5Ym9hcmQtc2VsZWN0XCIpO1xuICAgIH0sIFtnZXRDZWxsc0ZvclNlbGVjdGlvbiwgZ3JpZFNlbGVjdGlvbiwgbWFuZ2xlZENvbHMubGVuZ3RoLCByb3dNYXJrZXJPZmZzZXQsIHJvd3MsIHNjcm9sbFRvLCBzZXRDdXJyZW50XSk7XG4gICAgY29uc3QgdXBkYXRlU2VsZWN0ZWRDZWxsID0gUmVhY3QudXNlQ2FsbGJhY2soKGNvbCwgcm93LCBmcm9tRWRpdGluZ1RyYWlsaW5nUm93LCBmcmVlTW92ZSkgPT4ge1xuICAgICAgICBjb25zdCByb3dNYXggPSBtYW5nbGVkUm93cyAtIChmcm9tRWRpdGluZ1RyYWlsaW5nUm93ID8gMCA6IDEpO1xuICAgICAgICBjb2wgPSBjbGFtcChjb2wsIHJvd01hcmtlck9mZnNldCwgY29sdW1ucy5sZW5ndGggLSAxICsgcm93TWFya2VyT2Zmc2V0KTtcbiAgICAgICAgcm93ID0gY2xhbXAocm93LCAwLCByb3dNYXgpO1xuICAgICAgICBpZiAoY29sID09PSBjdXJyZW50Q2VsbD8uWzBdICYmIHJvdyA9PT0gY3VycmVudENlbGw/LlsxXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGZyZWVNb3ZlICYmIGdyaWRTZWxlY3Rpb24uY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGFjayA9IFsuLi5ncmlkU2VsZWN0aW9uLmN1cnJlbnQucmFuZ2VTdGFja107XG4gICAgICAgICAgICBpZiAoZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlLndpZHRoID4gMSB8fCBncmlkU2VsZWN0aW9uLmN1cnJlbnQucmFuZ2UuaGVpZ2h0ID4gMSkge1xuICAgICAgICAgICAgICAgIG5ld1N0YWNrLnB1c2goZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEdyaWRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgIC4uLmdyaWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgY3VycmVudDoge1xuICAgICAgICAgICAgICAgICAgICBjZWxsOiBbY29sLCByb3ddLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogeyB4OiBjb2wsIHk6IHJvdywgd2lkdGg6IDEsIGhlaWdodDogMSB9LFxuICAgICAgICAgICAgICAgICAgICByYW5nZVN0YWNrOiBuZXdTdGFjayxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50KHtcbiAgICAgICAgICAgICAgICBjZWxsOiBbY29sLCByb3ddLFxuICAgICAgICAgICAgICAgIHJhbmdlOiB7IHg6IGNvbCwgeTogcm93LCB3aWR0aDogMSwgaGVpZ2h0OiAxIH0sXG4gICAgICAgICAgICB9LCB0cnVlLCBmYWxzZSwgXCJrZXlib2FyZC1uYXZcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RTZW50LmN1cnJlbnQgIT09IHVuZGVmaW5lZCAmJiBsYXN0U2VudC5jdXJyZW50WzBdID09PSBjb2wgJiYgbGFzdFNlbnQuY3VycmVudFsxXSA9PT0gcm93KSB7XG4gICAgICAgICAgICBsYXN0U2VudC5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHNjcm9sbFRvKGNvbCAtIHJvd01hcmtlck9mZnNldCwgcm93KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgW1xuICAgICAgICBtYW5nbGVkUm93cyxcbiAgICAgICAgcm93TWFya2VyT2Zmc2V0LFxuICAgICAgICBjb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgY3VycmVudENlbGwsXG4gICAgICAgIGdyaWRTZWxlY3Rpb24sXG4gICAgICAgIHNjcm9sbFRvLFxuICAgICAgICBzZXRHcmlkU2VsZWN0aW9uLFxuICAgICAgICBzZXRDdXJyZW50LFxuICAgIF0pO1xuICAgIGNvbnN0IG9uRmluaXNoRWRpdGluZyA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdWYWx1ZSwgbW92ZW1lbnQpID0+IHtcbiAgICAgICAgaWYgKG92ZXJsYXk/LmNlbGwgIT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGlzRWRpdGFibGVHcmlkQ2VsbChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIG1hbmdsZWRPbkNlbGxzRWRpdGVkKFt7IGxvY2F0aW9uOiBvdmVybGF5LmNlbGwsIHZhbHVlOiBuZXdWYWx1ZSB9XSk7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBncmlkUmVmLmN1cnJlbnQ/LmRhbWFnZShbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGw6IG92ZXJsYXkuY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvY3VzKHRydWUpO1xuICAgICAgICBzZXRPdmVybGF5KHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IFttb3ZYLCBtb3ZZXSA9IG1vdmVtZW50O1xuICAgICAgICBpZiAoZ3JpZFNlbGVjdGlvbi5jdXJyZW50ICE9PSB1bmRlZmluZWQgJiYgKG1vdlggIT09IDAgfHwgbW92WSAhPT0gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRWRpdGluZ1RyYWlsaW5nUm93ID0gZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGxbMV0gPT09IG1hbmdsZWRSb3dzIC0gMSAmJiBuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdXBkYXRlU2VsZWN0ZWRDZWxsKGNsYW1wKGdyaWRTZWxlY3Rpb24uY3VycmVudC5jZWxsWzBdICsgbW92WCwgMCwgbWFuZ2xlZENvbHMubGVuZ3RoIC0gMSksIGNsYW1wKGdyaWRTZWxlY3Rpb24uY3VycmVudC5jZWxsWzFdICsgbW92WSwgMCwgbWFuZ2xlZFJvd3MgLSAxKSwgaXNFZGl0aW5nVHJhaWxpbmdSb3csIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBvbkZpbmlzaGVkRWRpdGluZz8uKG5ld1ZhbHVlLCBtb3ZlbWVudCk7XG4gICAgfSwgW1xuICAgICAgICBvdmVybGF5Py5jZWxsLFxuICAgICAgICBmb2N1cyxcbiAgICAgICAgZ3JpZFNlbGVjdGlvbixcbiAgICAgICAgb25GaW5pc2hlZEVkaXRpbmcsXG4gICAgICAgIG1hbmdsZWRPbkNlbGxzRWRpdGVkLFxuICAgICAgICBtYW5nbGVkUm93cyxcbiAgICAgICAgdXBkYXRlU2VsZWN0ZWRDZWxsLFxuICAgICAgICBtYW5nbGVkQ29scy5sZW5ndGgsXG4gICAgXSk7XG4gICAgY29uc3Qgb3ZlcmxheUlEID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBgZ2RnLW92ZXJsYXktJHtpZENvdW50ZXIrK31gO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBkZWxldGVSYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChyKSA9PiB7XG4gICAgICAgIGZvY3VzKCk7XG4gICAgICAgIGNvbnN0IGVkaXRMaXN0ID0gW107XG4gICAgICAgIGZvciAobGV0IHggPSByLng7IHggPCByLnggKyByLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSByLnk7IHkgPCByLnkgKyByLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbFZhbHVlID0gZ2V0Q2VsbENvbnRlbnQoW3ggLSByb3dNYXJrZXJPZmZzZXQsIHldKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNlbGxWYWx1ZS5hbGxvd092ZXJsYXkgJiYgY2VsbFZhbHVlLmtpbmQgIT09IEdyaWRDZWxsS2luZC5Cb29sZWFuKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3VmFsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsVmFsdWUua2luZCA9PT0gR3JpZENlbGxLaW5kLkN1c3RvbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0RlbGV0ZSA9IGdldENlbGxSZW5kZXJlcihjZWxsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSB0b0RlbGV0ZT8ucHJvdmlkZUVkaXRvcj8uKGNlbGxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0RlbGV0ZT8ub25EZWxldGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gdG9EZWxldGUub25EZWxldGUoY2VsbFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdEVkaXRvckNhbGxiYWNrUmVzdWx0KGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGVkaXRvcj8uZGVsZXRlZFZhbHVlPy4oY2VsbFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoaXNFZGl0YWJsZUdyaWRDZWxsKGNlbGxWYWx1ZSkgJiYgY2VsbFZhbHVlLmFsbG93T3ZlcmxheSkgfHxcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmtpbmQgPT09IEdyaWRDZWxsS2luZC5Cb29sZWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvRGVsZXRlID0gZ2V0Q2VsbFJlbmRlcmVyKGNlbGxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IHRvRGVsZXRlPy5vbkRlbGV0ZT8uKGNlbGxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWwgIT09IHVuZGVmaW5lZCAmJiAhaXNJbm5lck9ubHlDZWxsKG5ld1ZhbCkgJiYgaXNFZGl0YWJsZUdyaWRDZWxsKG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdExpc3QucHVzaCh7IGxvY2F0aW9uOiBbeCwgeV0sIHZhbHVlOiBuZXdWYWwgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hbmdsZWRPbkNlbGxzRWRpdGVkKGVkaXRMaXN0KTtcbiAgICAgICAgZ3JpZFJlZi5jdXJyZW50Py5kYW1hZ2UoZWRpdExpc3QubWFwKHggPT4gKHsgY2VsbDogeC5sb2NhdGlvbiB9KSkpO1xuICAgIH0sIFtmb2N1cywgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxSZW5kZXJlciwgbWFuZ2xlZE9uQ2VsbHNFZGl0ZWQsIHJvd01hcmtlck9mZnNldF0pO1xuICAgIGNvbnN0IG92ZXJsYXlPcGVuID0gb3ZlcmxheSAhPT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGhhbmRsZUZpeGVkS2V5YmluZGluZ3MgPSBSZWFjdC51c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZXRhaWxzID0ge1xuICAgICAgICAgICAgZGlkTWF0Y2g6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGJvdW5kcyB9ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ29sdW1ucyA9IGdyaWRTZWxlY3Rpb24uY29sdW1ucztcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSb3dzID0gZ3JpZFNlbGVjdGlvbi5yb3dzO1xuICAgICAgICBjb25zdCBrZXlzID0ga2V5YmluZGluZ3M7XG4gICAgICAgIGlmICghb3ZlcmxheU9wZW4gJiYgaXNIb3RrZXkoa2V5cy5jbGVhciwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICBzZXRHcmlkU2VsZWN0aW9uKGVtcHR5R3JpZFNlbGVjdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgb25TZWxlY3Rpb25DbGVhcmVkPy4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3ZlcmxheU9wZW4gJiYgaXNIb3RrZXkoa2V5cy5zZWxlY3RBbGwsIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgc2V0R3JpZFNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgY29sdW1uczogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICAgICAgICAgIHJvd3M6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGw6IGdyaWRTZWxlY3Rpb24uY3VycmVudD8uY2VsbCA/PyBbcm93TWFya2VyT2Zmc2V0LCAwXSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHJvd01hcmtlck9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sdW1uc0luLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcm93cyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VTdGFjazogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0hvdGtleShrZXlzLnNlYXJjaCwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICBzZWFyY2hJbnB1dFJlZj8uY3VycmVudD8uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgc2V0U2hvd1NlYXJjaElubmVyKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuZGVsZXRlLCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrUmVzdWx0ID0gb25EZWxldGU/LihncmlkU2VsZWN0aW9uKSA/PyB0cnVlO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvRGVsZXRlID0gY2FsbGJhY2tSZXN1bHQgPT09IHRydWUgPyBncmlkU2VsZWN0aW9uIDogY2FsbGJhY2tSZXN1bHQ7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9yZGVyOlxuICAgICAgICAgICAgICAgIC8vIDEpIHByaW1hcnkgcmFuZ2VcbiAgICAgICAgICAgICAgICAvLyAyKSBzZWNvbmRhcnkgcmFuZ2VzXG4gICAgICAgICAgICAgICAgLy8gMykgY29sdW1uc1xuICAgICAgICAgICAgICAgIC8vIDQpIHJvd3NcbiAgICAgICAgICAgICAgICBpZiAodG9EZWxldGUuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJhbmdlKHRvRGVsZXRlLmN1cnJlbnQucmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgdG9EZWxldGUuY3VycmVudC5yYW5nZVN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSYW5nZShyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgdG9EZWxldGUucm93cykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVSYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiByb3dNYXJrZXJPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiByLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbHVtbnNJbi5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbCBvZiB0b0RlbGV0ZS5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcm93cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRhaWxzLmRpZE1hdGNoKSB7XG4gICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkU2VsZWN0aW9uLmN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IFtjb2wsIHJvd10gPSBncmlkU2VsZWN0aW9uLmN1cnJlbnQuY2VsbDtcbiAgICAgICAgbGV0IGZyZWVNb3ZlID0gZmFsc2U7XG4gICAgICAgIGxldCBjYW5jZWxPbmx5T25Nb3ZlID0gZmFsc2U7XG4gICAgICAgIGlmIChpc0hvdGtleShrZXlzLnNjcm9sbFRvU2VsZWN0ZWRDZWxsLCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgIHNjcm9sbFRvUmVmLmN1cnJlbnQoY29sIC0gcm93TWFya2VyT2Zmc2V0LCByb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbHVtblNlbGVjdCAhPT0gXCJub25lXCIgJiYgaXNIb3RrZXkoa2V5cy5zZWxlY3RDb2x1bW4sIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ29sdW1ucy5oYXNJbmRleChjb2wpKSB7XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zKHNlbGVjdGVkQ29sdW1ucy5yZW1vdmUoY29sKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5TZWxlY3QgPT09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zKENvbXBhY3RTZWxlY3Rpb24uZnJvbVNpbmdsZVNlbGVjdGlvbihjb2wpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zKHVuZGVmaW5lZCwgY29sLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm93U2VsZWN0ICE9PSBcIm5vbmVcIiAmJiBpc0hvdGtleShrZXlzLnNlbGVjdFJvdywgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRSb3dzLmhhc0luZGV4KHJvdykpIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZFJvd3Moc2VsZWN0ZWRSb3dzLnJlbW92ZShyb3cpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd1NlbGVjdCA9PT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZFJvd3MoQ29tcGFjdFNlbGVjdGlvbi5mcm9tU2luZ2xlU2VsZWN0aW9uKHJvdyksIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZFJvd3ModW5kZWZpbmVkLCByb3csIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3ZlcmxheU9wZW4gJiYgYm91bmRzICE9PSB1bmRlZmluZWQgJiYgaXNIb3RrZXkoa2V5cy5hY3RpdmF0ZUNlbGwsIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgaWYgKHJvdyA9PT0gcm93cyAmJiBzaG93VHJhaWxpbmdCbGFua1Jvdykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VzdG9tVGFyZ2V0Q29sdW1uID0gZ2V0Q3VzdG9tTmV3Um93VGFyZ2V0Q29sdW1uKGNvbCk7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgYXBwZW5kUm93KGN1c3RvbVRhcmdldENvbHVtbiA/PyBjb2wpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25DZWxsQWN0aXZhdGVkPy4oW2NvbCAtIHJvd01hcmtlck9mZnNldCwgcm93XSk7XG4gICAgICAgICAgICAgICAgcmVzZWxlY3QoYm91bmRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChncmlkU2VsZWN0aW9uLmN1cnJlbnQucmFuZ2UuaGVpZ2h0ID4gMSAmJiBpc0hvdGtleShrZXlzLmRvd25GaWxsLCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgIGZpbGxEb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlLndpZHRoID4gMSAmJiBpc0hvdGtleShrZXlzLnJpZ2h0RmlsbCwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICBmaWxsUmlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0hvdGtleShrZXlzLmdvVG9OZXh0UGFnZSwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICByb3cgKz0gTWF0aC5tYXgoMSwgdmlzaWJsZVJlZ2lvblJlZi5jdXJyZW50LmhlaWdodCAtIDQpOyAvLyBwYXJ0aWFsIGNlbGwgYWNjb3VudGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuZ29Ub1ByZXZpb3VzUGFnZSwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICByb3cgLT0gTWF0aC5tYXgoMSwgdmlzaWJsZVJlZ2lvblJlZi5jdXJyZW50LmhlaWdodCAtIDQpOyAvLyBwYXJ0aWFsIGNlbGwgYWNjb3VudGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuZ29Ub0ZpcnN0Q2VsbCwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICBzZXRPdmVybGF5KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByb3cgPSAwO1xuICAgICAgICAgICAgY29sID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0hvdGtleShrZXlzLmdvVG9MYXN0Q2VsbCwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICBzZXRPdmVybGF5KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByb3cgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIGNvbCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuc2VsZWN0VG9GaXJzdENlbGwsIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgc2V0T3ZlcmxheSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgYWRqdXN0U2VsZWN0aW9uKFstMiwgLTJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0hvdGtleShrZXlzLnNlbGVjdFRvTGFzdENlbGwsIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgc2V0T3ZlcmxheSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgYWRqdXN0U2VsZWN0aW9uKFsyLCAyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW92ZXJsYXlPcGVuKSB7XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoa2V5cy5nb0Rvd25DZWxsLCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICByb3cgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuZ29VcENlbGwsIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIHJvdyAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNIb3RrZXkoa2V5cy5nb1JpZ2h0Q2VsbCwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgY29sICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0hvdGtleShrZXlzLmdvTGVmdENlbGwsIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIGNvbCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNIb3RrZXkoa2V5cy5nb0Rvd25DZWxsUmV0YWluU2VsZWN0aW9uLCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICByb3cgKz0gMTtcbiAgICAgICAgICAgICAgICBmcmVlTW92ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0hvdGtleShrZXlzLmdvVXBDZWxsUmV0YWluU2VsZWN0aW9uLCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICByb3cgLT0gMTtcbiAgICAgICAgICAgICAgICBmcmVlTW92ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0hvdGtleShrZXlzLmdvUmlnaHRDZWxsUmV0YWluU2VsZWN0aW9uLCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICBjb2wgKz0gMTtcbiAgICAgICAgICAgICAgICBmcmVlTW92ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0hvdGtleShrZXlzLmdvTGVmdENlbGxSZXRhaW5TZWxlY3Rpb24sIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIGNvbCAtPSAxO1xuICAgICAgICAgICAgICAgIGZyZWVNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuZ29Ub0xhc3RSb3csIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIHJvdyA9IHJvd3MgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNIb3RrZXkoa2V5cy5nb1RvRmlyc3RSb3csIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIHJvdyA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNIb3RrZXkoa2V5cy5nb1RvTGFzdENvbHVtbiwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgY29sID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0hvdGtleShrZXlzLmdvVG9GaXJzdENvbHVtbiwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgY29sID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYW5nZVNlbGVjdCA9PT0gXCJyZWN0XCIgfHwgcmFuZ2VTZWxlY3QgPT09IFwibXVsdGktcmVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSG90a2V5KGtleXMuc2VsZWN0R3Jvd0Rvd24sIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RTZWxlY3Rpb24oWzAsIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNIb3RrZXkoa2V5cy5zZWxlY3RHcm93VXAsIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RTZWxlY3Rpb24oWzAsIC0xXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuc2VsZWN0R3Jvd1JpZ2h0LCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0U2VsZWN0aW9uKFsxLCAwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuc2VsZWN0R3Jvd0xlZnQsIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RTZWxlY3Rpb24oWy0xLCAwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuc2VsZWN0VG9MYXN0Um93LCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0U2VsZWN0aW9uKFswLCAyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSG90a2V5KGtleXMuc2VsZWN0VG9GaXJzdFJvdywgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdFNlbGVjdGlvbihbMCwgLTJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNIb3RrZXkoa2V5cy5zZWxlY3RUb0xhc3RDb2x1bW4sIGV2ZW50LCBkZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RTZWxlY3Rpb24oWzIsIDBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNIb3RrZXkoa2V5cy5zZWxlY3RUb0ZpcnN0Q29sdW1uLCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0U2VsZWN0aW9uKFstMiwgMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbmNlbE9ubHlPbk1vdmUgPSBkZXRhaWxzLmRpZE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzSG90a2V5KGtleXMuY2xvc2VPdmVybGF5LCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICBzZXRPdmVybGF5KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoa2V5cy5hY2NlcHRPdmVybGF5RG93biwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgc2V0T3ZlcmxheSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSG90a2V5KGtleXMuYWNjZXB0T3ZlcmxheVVwLCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICBzZXRPdmVybGF5KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgcm93LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoa2V5cy5hY2NlcHRPdmVybGF5TGVmdCwgZXZlbnQsIGRldGFpbHMpKSB7XG4gICAgICAgICAgICAgICAgc2V0T3ZlcmxheSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGNvbC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSG90a2V5KGtleXMuYWNjZXB0T3ZlcmxheVJpZ2h0LCBldmVudCwgZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgICBzZXRPdmVybGF5KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29sKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gI2VuZHJlZ2lvblxuICAgICAgICBjb25zdCBtb3ZlZCA9IHVwZGF0ZVNlbGVjdGVkQ2VsbChjb2wsIHJvdywgZmFsc2UsIGZyZWVNb3ZlKTtcbiAgICAgICAgY29uc3QgZGlkTWF0Y2ggPSBkZXRhaWxzLmRpZE1hdGNoO1xuICAgICAgICBpZiAoZGlkTWF0Y2ggJiYgKG1vdmVkIHx8ICFjYW5jZWxPbmx5T25Nb3ZlIHx8IHRyYXBGb2N1cykpIHtcbiAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWRNYXRjaDtcbiAgICB9LCBbXG4gICAgICAgIG92ZXJsYXlPcGVuLFxuICAgICAgICBncmlkU2VsZWN0aW9uLFxuICAgICAgICBrZXliaW5kaW5ncyxcbiAgICAgICAgY29sdW1uU2VsZWN0LFxuICAgICAgICByb3dTZWxlY3QsXG4gICAgICAgIHJhbmdlU2VsZWN0LFxuICAgICAgICByb3dNYXJrZXJPZmZzZXQsXG4gICAgICAgIHJvd3MsXG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkQ2VsbCxcbiAgICAgICAgc2V0R3JpZFNlbGVjdGlvbixcbiAgICAgICAgb25TZWxlY3Rpb25DbGVhcmVkLFxuICAgICAgICBjb2x1bW5zSW4ubGVuZ3RoLFxuICAgICAgICBvbkRlbGV0ZSxcbiAgICAgICAgdHJhcEZvY3VzLFxuICAgICAgICBkZWxldGVSYW5nZSxcbiAgICAgICAgc2V0U2VsZWN0ZWRDb2x1bW5zLFxuICAgICAgICBzZXRTZWxlY3RlZFJvd3MsXG4gICAgICAgIHNob3dUcmFpbGluZ0JsYW5rUm93LFxuICAgICAgICBnZXRDdXN0b21OZXdSb3dUYXJnZXRDb2x1bW4sXG4gICAgICAgIGFwcGVuZFJvdyxcbiAgICAgICAgb25DZWxsQWN0aXZhdGVkLFxuICAgICAgICByZXNlbGVjdCxcbiAgICAgICAgZmlsbERvd24sXG4gICAgICAgIGZpbGxSaWdodCxcbiAgICAgICAgYWRqdXN0U2VsZWN0aW9uLFxuICAgIF0pO1xuICAgIGNvbnN0IG9uS2V5RG93biA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvbktleURvd25JbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvbktleURvd25Jbih7XG4gICAgICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5jZWxsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChoYW5kbGVGaXhlZEtleWJpbmRpbmdzKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGdyaWRTZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBbY29sLCByb3ddID0gZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGw7XG4gICAgICAgIGNvbnN0IHZyID0gdmlzaWJsZVJlZ2lvblJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoZWRpdE9uVHlwZSAmJlxuICAgICAgICAgICAgIWV2ZW50Lm1ldGFLZXkgJiZcbiAgICAgICAgICAgICFldmVudC5jdHJsS2V5ICYmXG4gICAgICAgICAgICBncmlkU2VsZWN0aW9uLmN1cnJlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXZlbnQua2V5Lmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgL1sgLX5dL2cudGVzdChldmVudC5rZXkpICYmXG4gICAgICAgICAgICBldmVudC5ib3VuZHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgaXNSZWFkV3JpdGVDZWxsKGdldENlbGxDb250ZW50KFtjb2wgLSByb3dNYXJrZXJPZmZzZXQsIE1hdGgubWF4KDAsIE1hdGgubWluKHJvdywgcm93cyAtIDEpKV0pKSkge1xuICAgICAgICAgICAgaWYgKCghc2hvd1RyYWlsaW5nQmxhbmtSb3cgfHwgcm93ICE9PSByb3dzKSAmJlxuICAgICAgICAgICAgICAgICh2ci55ID4gcm93IHx8IHJvdyA+IHZyLnkgKyB2ci5oZWlnaHQgfHwgdnIueCA+IGNvbCB8fCBjb2wgPiB2ci54ICsgdnIud2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzZWxlY3QoZXZlbnQuYm91bmRzLCB0cnVlLCBldmVudC5rZXkpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBlZGl0T25UeXBlLFxuICAgICAgICBvbktleURvd25JbixcbiAgICAgICAgaGFuZGxlRml4ZWRLZXliaW5kaW5ncyxcbiAgICAgICAgZ3JpZFNlbGVjdGlvbixcbiAgICAgICAgZ2V0Q2VsbENvbnRlbnQsXG4gICAgICAgIHJvd01hcmtlck9mZnNldCxcbiAgICAgICAgcm93cyxcbiAgICAgICAgc2hvd1RyYWlsaW5nQmxhbmtSb3csXG4gICAgICAgIHJlc2VsZWN0LFxuICAgIF0pO1xuICAgIGNvbnN0IG9uQ29udGV4dE1lbnUgPSBSZWFjdC51c2VDYWxsYmFjaygoYXJncywgcHJldmVudERlZmF1bHQpID0+IHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRDb2wgPSBhcmdzLmxvY2F0aW9uWzBdIC0gcm93TWFya2VyT2Zmc2V0O1xuICAgICAgICBpZiAoYXJncy5raW5kID09PSBcImhlYWRlclwiKSB7XG4gICAgICAgICAgICBvbkhlYWRlckNvbnRleHRNZW51Py4oYWRqdXN0ZWRDb2wsIHsgLi4uYXJncywgcHJldmVudERlZmF1bHQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3Mua2luZCA9PT0gZ3JvdXBIZWFkZXJLaW5kKSB7XG4gICAgICAgICAgICBpZiAoYWRqdXN0ZWRDb2wgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Hcm91cEhlYWRlckNvbnRleHRNZW51Py4oYWRqdXN0ZWRDb2wsIHsgLi4uYXJncywgcHJldmVudERlZmF1bHQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3Mua2luZCA9PT0gXCJjZWxsXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjb2wsIHJvd10gPSBhcmdzLmxvY2F0aW9uO1xuICAgICAgICAgICAgb25DZWxsQ29udGV4dE1lbnU/LihbYWRqdXN0ZWRDb2wsIHJvd10sIHtcbiAgICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWdyaWRTZWxlY3Rpb25IYXNJdGVtKGdyaWRTZWxlY3Rpb24sIGFyZ3MubG9jYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlU2VsZWN0ZWRDZWxsKGNvbCwgcm93LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBncmlkU2VsZWN0aW9uLFxuICAgICAgICBvbkNlbGxDb250ZXh0TWVudSxcbiAgICAgICAgb25Hcm91cEhlYWRlckNvbnRleHRNZW51LFxuICAgICAgICBvbkhlYWRlckNvbnRleHRNZW51LFxuICAgICAgICByb3dNYXJrZXJPZmZzZXQsXG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkQ2VsbCxcbiAgICBdKTtcbiAgICBjb25zdCBvblBhc3RlSW50ZXJuYWwgPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAoZSkgPT4ge1xuICAgICAgICBpZiAoIWtleWJpbmRpbmdzLnBhc3RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmdW5jdGlvbiBwYXN0ZVRvQ2VsbChpbm5lciwgdGFyZ2V0LCByYXdWYWx1ZSwgZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZFJhd1ZhbHVlID0gdHlwZW9mIHJhd1ZhbHVlID09PSBcIm9iamVjdFwiID8gcmF3VmFsdWU/LmpvaW4oXCJcXG5cIikgPz8gXCJcIiA6IHJhd1ZhbHVlPy50b1N0cmluZygpID8/IFwiXCI7XG4gICAgICAgICAgICBpZiAoIWlzSW5uZXJPbmx5Q2VsbChpbm5lcikgJiYgaXNSZWFkV3JpdGVDZWxsKGlubmVyKSAmJiBpbm5lci5yZWFkb25seSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZXJjZWQgPSBjb2VyY2VQYXN0ZVZhbHVlPy4oc3RyaW5naWZpZWRSYXdWYWx1ZSwgaW5uZXIpO1xuICAgICAgICAgICAgICAgIGlmIChjb2VyY2VkICE9PSB1bmRlZmluZWQgJiYgaXNFZGl0YWJsZUdyaWRDZWxsKGNvZXJjZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29lcmNlZC5raW5kICE9PSBpbm5lci5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ29lcmNpb24gc2hvdWxkIG5vdCBjaGFuZ2UgY2VsbCBraW5kLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2VyY2VkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByID0gZ2V0Q2VsbFJlbmRlcmVyKGlubmVyKTtcbiAgICAgICAgICAgICAgICBpZiAociA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChyLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGlubmVyLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSByLm9uUGFzdGU/LihzdHJpbmdpZmllZFJhd1ZhbHVlLCBpbm5lci5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmlubmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG5ld1ZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSByLm9uUGFzdGU/LihzdHJpbmdpZmllZFJhd1ZhbHVlLCBpbm5lciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nOiB0eXBlb2YgZm9ybWF0dGVkID09PSBcInN0cmluZ1wiID8gZm9ybWF0dGVkIDogZm9ybWF0dGVkPy5qb2luKFwiXFxuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQobmV3VmFsLmtpbmQgPT09IGlubmVyLmtpbmQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RlZENvbHVtbnMgPSBncmlkU2VsZWN0aW9uLmNvbHVtbnM7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkUm93cyA9IGdyaWRTZWxlY3Rpb24ucm93cztcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHNjcm9sbFJlZi5jdXJyZW50Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQ/LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09PSB0cnVlO1xuICAgICAgICBsZXQgdGFyZ2V0O1xuICAgICAgICBpZiAoZ3JpZFNlbGVjdGlvbi5jdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IFtncmlkU2VsZWN0aW9uLmN1cnJlbnQucmFuZ2UueCwgZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlLnldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkQ29sdW1ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IFtzZWxlY3RlZENvbHVtbnMuZmlyc3QoKSA/PyAwLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZFJvd3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBbcm93TWFya2VyT2Zmc2V0LCBzZWxlY3RlZFJvd3MuZmlyc3QoKSA/PyAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXNlZCAmJiB0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHRleHRQbGFpbiA9IFwidGV4dC9wbGFpblwiO1xuICAgICAgICAgICAgY29uc3QgdGV4dEh0bWwgPSBcInRleHQvaHRtbFwiO1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpcGJvYXJkQ29udGVudCA9IGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjbGlwYm9hcmRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGVzLmluY2x1ZGVzKHRleHRIdG1sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHRtbEJsb2IgPSBhd2FpdCBpdGVtLmdldFR5cGUodGV4dEh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHRtbCA9IGF3YWl0IGh0bWxCbG9iLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVIVE1MKGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkZWNvZGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGVzLmluY2x1ZGVzKHRleHRQbGFpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWF3YWl0LWV4cHJlc3Npb24tbWVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gYXdhaXQgKGF3YWl0IGl0ZW0uZ2V0VHlwZSh0ZXh0UGxhaW4pKS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYXZpZ2F0b3IuY2xpcGJvYXJkLnJlYWRUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC5yZWFkVGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZSAhPT0gdW5kZWZpbmVkICYmIGU/LmNsaXBib2FyZERhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jbGlwYm9hcmREYXRhLnR5cGVzLmluY2x1ZGVzKHRleHRIdG1sKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEodGV4dEh0bWwpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGVjb2RlSFRNTChodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlLmNsaXBib2FyZERhdGEudHlwZXMuaW5jbHVkZXModGV4dFBsYWluKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEodGV4dFBsYWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEkgZGlkbid0IHdhbnQgdG8gcmVhZCB0aGF0IHBhc3RlIHZhbHVlIGFueXdheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3RhcmdldENvbCwgdGFyZ2V0Um93XSA9IHRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRMaXN0ID0gW107XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKG9uUGFzdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsRGF0YSA9IGdldE1hbmdsZWRDZWxsQ29udGVudCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdWYWx1ZSA9IHRleHQgPz8gZGF0YT8ubWFwKHIgPT4gci5tYXAoY2IgPT4gY2IucmF3VmFsdWUpLmpvaW4oXCJcXHRcIikpLmpvaW4oXCJcXHRcIikgPz8gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsID0gcGFzdGVUb0NlbGwoY2VsbERhdGEsIHRhcmdldCwgcmF3VmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdExpc3QucHVzaChuZXdWYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB1bnF1b3RlKHRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25QYXN0ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBvblBhc3RlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUGFzdGU/LihbdGFyZ2V0WzBdIC0gcm93TWFya2VyT2Zmc2V0LCB0YXJnZXRbMV1dLCBkYXRhLm1hcChyID0+IHIubWFwKGNiID0+IGNiLnJhd1ZhbHVlPy50b1N0cmluZygpID8/IFwiXCIpKSkgIT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbcm93LCBkYXRhUm93XSBvZiBkYXRhLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93ICsgdGFyZ2V0Um93ID49IHJvd3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbY29sLCBkYXRhSXRlbV0gb2YgZGF0YVJvdy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gW2NvbCArIHRhcmdldENvbCwgcm93ICsgdGFyZ2V0Um93XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFt3cml0ZUNvbCwgd3JpdGVSb3ddID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod3JpdGVDb2wgPj0gbWFuZ2xlZENvbHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdyaXRlUm93ID49IG1hbmdsZWRSb3dzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbERhdGEgPSBnZXRNYW5nbGVkQ2VsbENvbnRlbnQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsID0gcGFzdGVUb0NlbGwoY2VsbERhdGEsIGluZGV4LCBkYXRhSXRlbS5yYXdWYWx1ZSwgZGF0YUl0ZW0uZm9ybWF0dGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRMaXN0LnB1c2gobmV3VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICAgICB9IHdoaWxlIChmYWxzZSk7XG4gICAgICAgICAgICBtYW5nbGVkT25DZWxsc0VkaXRlZChlZGl0TGlzdCk7XG4gICAgICAgICAgICBncmlkUmVmLmN1cnJlbnQ/LmRhbWFnZShlZGl0TGlzdC5tYXAoYyA9PiAoe1xuICAgICAgICAgICAgICAgIGNlbGw6IGMubG9jYXRpb24sXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBjb2VyY2VQYXN0ZVZhbHVlLFxuICAgICAgICBnZXRDZWxsUmVuZGVyZXIsXG4gICAgICAgIGdldE1hbmdsZWRDZWxsQ29udGVudCxcbiAgICAgICAgZ3JpZFNlbGVjdGlvbixcbiAgICAgICAga2V5YmluZGluZ3MucGFzdGUsXG4gICAgICAgIG1hbmdsZWRDb2xzLmxlbmd0aCxcbiAgICAgICAgbWFuZ2xlZE9uQ2VsbHNFZGl0ZWQsXG4gICAgICAgIG1hbmdsZWRSb3dzLFxuICAgICAgICBvblBhc3RlLFxuICAgICAgICByb3dNYXJrZXJPZmZzZXQsXG4gICAgICAgIHJvd3MsXG4gICAgXSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIG9uUGFzdGVJbnRlcm5hbCwgc2FmZVdpbmRvdywgZmFsc2UsIHRydWUpO1xuICAgIC8vIFdoaWxlIHRoaXMgZnVuY3Rpb24gaXMgYXN5bmMsIHdlIGRlZXBseSBwcmVmZXIgbm90IHRvIGF3YWl0IGlmIHdlIGRvbid0IGhhdmUgdG8uIFRoaXMgd2lsbCBsZWFkIHRvIHVucGFja2luZ1xuICAgIC8vIHByb21pc2VzIGluIHJhdGhlciBhd2t3YXJkIHdheXMgd2hlbiBwb3NzaWJsZSB0byBhdm9pZCBhd2FpdGluZy4gV2UgaGF2ZSB0byB1c2UgZmFsbGJhY2sgY29weSBtZWNoYW5pc21zIHdoZW5cbiAgICAvLyBhbiBhd2FpdCBoYXMgaGFwcGVuZWQuXG4gICAgY29uc3Qgb25Db3B5ID0gUmVhY3QudXNlQ2FsbGJhY2soYXN5bmMgKGUsIGlnbm9yZUZvY3VzKSA9PiB7XG4gICAgICAgIGlmICgha2V5YmluZGluZ3MuY29weSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IGlnbm9yZUZvY3VzID09PSB0cnVlIHx8XG4gICAgICAgICAgICBzY3JvbGxSZWYuY3VycmVudD8uY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT09IHRydWUgfHxcbiAgICAgICAgICAgIGNhbnZhc1JlZi5jdXJyZW50Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSA9PT0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDb2x1bW5zID0gZ3JpZFNlbGVjdGlvbi5jb2x1bW5zO1xuICAgICAgICBjb25zdCBzZWxlY3RlZFJvd3MgPSBncmlkU2VsZWN0aW9uLnJvd3M7XG4gICAgICAgIGNvbnN0IGNvcHlUb0NsaXBib2FyZFdpdGhIZWFkZXJzID0gKGNlbGxzLCBjb2x1bW5JbmRleGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvcHlIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgY29weVRvQ2xpcGJvYXJkKGNlbGxzLCBjb2x1bW5JbmRleGVzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBjb2x1bW5JbmRleGVzLm1hcChpbmRleCA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBHcmlkQ2VsbEtpbmQuVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY29sdW1uc0luW2luZGV4XS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURhdGE6IGNvbHVtbnNJbltpbmRleF0udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93T3ZlcmxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNvcHlUb0NsaXBib2FyZChbaGVhZGVycywgLi4uY2VsbHNdLCBjb2x1bW5JbmRleGVzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZvY3VzZWQgJiYgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGdyaWRTZWxlY3Rpb24uY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRodW5rID0gZ2V0Q2VsbHNGb3JTZWxlY3Rpb24oZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlLCBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5zaWduYWwpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGh1bmsgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGh1bmsgPSBhd2FpdCB0aHVuaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3B5VG9DbGlwYm9hcmRXaXRoSGVhZGVycyh0aHVuaywgcmFuZ2UoZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlLnggLSByb3dNYXJrZXJPZmZzZXQsIGdyaWRTZWxlY3Rpb24uY3VycmVudC5yYW5nZS54ICsgZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlLndpZHRoIC0gcm93TWFya2VyT2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RlZFJvd3MgIT09IHVuZGVmaW5lZCAmJiBzZWxlY3RlZFJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvQ29weSA9IFsuLi5zZWxlY3RlZFJvd3NdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gdG9Db3B5Lm1hcChyb3dJbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRodW5rID0gZ2V0Q2VsbHNGb3JTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcm93TWFya2VyT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcm93SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sdW1uc0luLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgfSwgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuc2lnbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aHVuayA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRodW5rWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHVuaygpLnRoZW4odiA9PiB2WzBdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbHMuc29tZSh4ID0+IHggaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0bGVkID0gYXdhaXQgUHJvbWlzZS5hbGwoY2VsbHMpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5VG9DbGlwYm9hcmRXaXRoSGVhZGVycyhzZXR0bGVkLCByYW5nZShjb2x1bW5zSW4ubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3B5VG9DbGlwYm9hcmRXaXRoSGVhZGVycyhjZWxscywgcmFuZ2UoY29sdW1uc0luLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkQ29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbCBvZiBzZWxlY3RlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRodW5rID0gZ2V0Q2VsbHNGb3JTZWxlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByb3dzLFxuICAgICAgICAgICAgICAgICAgICB9LCBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5zaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRodW5rICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVuayA9IGF3YWl0IHRodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY29scy5wdXNoKGNvbCAtIHJvd01hcmtlck9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5VG9DbGlwYm9hcmRXaXRoSGVhZGVycyhyZXN1bHRzWzBdLCBjb2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiB0aGlzIGlzIGR1bWJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9Db3B5ID0gcmVzdWx0cy5yZWR1Y2UoKHB2LCBjdikgPT4gcHYubWFwKChyb3csIGluZGV4KSA9PiBbLi4ucm93LCAuLi5jdltpbmRleF1dKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlUb0NsaXBib2FyZFdpdGhIZWFkZXJzKHRvQ29weSwgY29scyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2NvbHVtbnNJbiwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24sIGdyaWRTZWxlY3Rpb24sIGtleWJpbmRpbmdzLmNvcHksIHJvd01hcmtlck9mZnNldCwgcm93cywgY29weUhlYWRlcnNdKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKFwiY29weVwiLCBvbkNvcHksIHNhZmVXaW5kb3csIGZhbHNlLCBmYWxzZSk7XG4gICAgY29uc3Qgb25DdXQgPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAoZSkgPT4ge1xuICAgICAgICBpZiAoIWtleWJpbmRpbmdzLmN1dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHNjcm9sbFJlZi5jdXJyZW50Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQ/LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09PSB0cnVlO1xuICAgICAgICBpZiAoIWZvY3VzZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGF3YWl0IG9uQ29weShlKTtcbiAgICAgICAgaWYgKGdyaWRTZWxlY3Rpb24uY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgZWZmZWN0aXZlU2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbDogZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGwsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBncmlkU2VsZWN0aW9uLmN1cnJlbnQucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlU3RhY2s6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcm93czogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbkRlbGV0ZVJlc3VsdCA9IG9uRGVsZXRlPy4oZWZmZWN0aXZlU2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChvbkRlbGV0ZVJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZWZmZWN0aXZlU2VsZWN0aW9uID0gb25EZWxldGVSZXN1bHQgPT09IHRydWUgPyBlZmZlY3RpdmVTZWxlY3Rpb24gOiBvbkRlbGV0ZVJlc3VsdDtcbiAgICAgICAgICAgIGlmIChlZmZlY3RpdmVTZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlbGV0ZVJhbmdlKGVmZmVjdGl2ZVNlbGVjdGlvbi5jdXJyZW50LnJhbmdlKTtcbiAgICAgICAgfVxuICAgIH0sIFtkZWxldGVSYW5nZSwgZ3JpZFNlbGVjdGlvbiwga2V5YmluZGluZ3MuY3V0LCBvbkNvcHksIG9uRGVsZXRlXSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcImN1dFwiLCBvbkN1dCwgc2FmZVdpbmRvdywgZmFsc2UsIGZhbHNlKTtcbiAgICBjb25zdCBvblNlYXJjaFJlc3VsdHNDaGFuZ2VkID0gUmVhY3QudXNlQ2FsbGJhY2soKHJlc3VsdHMsIG5hdkluZGV4KSA9PiB7XG4gICAgICAgIGlmIChvblNlYXJjaFJlc3VsdHNDaGFuZ2VkSW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHJvd01hcmtlck9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLm1hcChpdGVtID0+IFtpdGVtWzBdIC0gcm93TWFya2VyT2Zmc2V0LCBpdGVtWzFdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblNlYXJjaFJlc3VsdHNDaGFuZ2VkSW4ocmVzdWx0cywgbmF2SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCB8fCBuYXZJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IFtjb2wsIHJvd10gPSByZXN1bHRzW25hdkluZGV4XTtcbiAgICAgICAgaWYgKGxhc3RTZW50LmN1cnJlbnQgIT09IHVuZGVmaW5lZCAmJiBsYXN0U2VudC5jdXJyZW50WzBdID09PSBjb2wgJiYgbGFzdFNlbnQuY3VycmVudFsxXSA9PT0gcm93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFNlbnQuY3VycmVudCA9IFtjb2wsIHJvd107XG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkQ2VsbChjb2wsIHJvdywgZmFsc2UsIGZhbHNlKTtcbiAgICB9LCBbb25TZWFyY2hSZXN1bHRzQ2hhbmdlZEluLCByb3dNYXJrZXJPZmZzZXQsIHVwZGF0ZVNlbGVjdGVkQ2VsbF0pO1xuICAgIC8vIHRoaXMgZWZmZWN0cyBwdXJwb3NlIGluIGxpZmUgaXMgdG8gc2Nyb2xsIHRoZSBuZXdseSBzZWxlY3RlZCBjZWxsIGludG8gdmlldyB3aGVuIGFuZCBPTkxZIHdoZW4gdGhhdCBjZWxsXG4gICAgLy8gaXMgZnJvbSBhbiBleHRlcm5hbCBncmlkU2VsZWN0aW9uIGNoYW5nZS4gQWxzbyBub3RlIHdlIHdhbnQgdGhlIHVubWFuZ2xlZCBvdXQgc2VsZWN0aW9uIGJlY2F1c2Ugc2Nyb2xsVG9cbiAgICAvLyBleHBlY3RzIHVubWFuZ2xlZCBpbmRleGVzXG4gICAgY29uc3QgW291dENvbCwgb3V0Um93XSA9IGdyaWRTZWxlY3Rpb25PdXRlcj8uY3VycmVudD8uY2VsbCA/PyBbXTtcbiAgICBjb25zdCBzY3JvbGxUb1JlZiA9IFJlYWN0LnVzZVJlZihzY3JvbGxUbyk7XG4gICAgc2Nyb2xsVG9SZWYuY3VycmVudCA9IHNjcm9sbFRvO1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaGFzSnVzdFNjcm9sbGVkLmN1cnJlbnQgJiZcbiAgICAgICAgICAgIG91dENvbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBvdXRSb3cgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG91dENvbCAhPT0gZXhwZWN0ZWRFeHRlcm5hbEdyaWRTZWxlY3Rpb24uY3VycmVudD8uY3VycmVudD8uY2VsbFswXSB8fFxuICAgICAgICAgICAgICAgIG91dFJvdyAhPT0gZXhwZWN0ZWRFeHRlcm5hbEdyaWRTZWxlY3Rpb24uY3VycmVudD8uY3VycmVudD8uY2VsbFsxXSkpIHtcbiAgICAgICAgICAgIHNjcm9sbFRvUmVmLmN1cnJlbnQob3V0Q29sLCBvdXRSb3cpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0p1c3RTY3JvbGxlZC5jdXJyZW50ID0gZmFsc2U7IC8vb25seSBhbGxvdyBza2lwcGluZyBhIHNpbmdsZSBzY3JvbGxcbiAgICB9LCBbb3V0Q29sLCBvdXRSb3ddKTtcbiAgICBjb25zdCBzZWxlY3Rpb25PdXRPZkJvdW5kcyA9IGdyaWRTZWxlY3Rpb24uY3VycmVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChncmlkU2VsZWN0aW9uLmN1cnJlbnQuY2VsbFswXSA+PSBtYW5nbGVkQ29scy5sZW5ndGggfHwgZ3JpZFNlbGVjdGlvbi5jdXJyZW50LmNlbGxbMV0gPj0gbWFuZ2xlZFJvd3MpO1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3Rpb25PdXRPZkJvdW5kcykge1xuICAgICAgICAgICAgc2V0R3JpZFNlbGVjdGlvbihlbXB0eUdyaWRTZWxlY3Rpb24sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtzZWxlY3Rpb25PdXRPZkJvdW5kcywgc2V0R3JpZFNlbGVjdGlvbl0pO1xuICAgIGNvbnN0IGRpc2FibGVkUm93cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoc2hvd1RyYWlsaW5nQmxhbmtSb3cgPT09IHRydWUgJiYgdHJhaWxpbmdSb3dPcHRpb25zPy50aW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcGFjdFNlbGVjdGlvbi5mcm9tU2luZ2xlU2VsZWN0aW9uKG1hbmdsZWRSb3dzIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKTtcbiAgICB9LCBbbWFuZ2xlZFJvd3MsIHNob3dUcmFpbGluZ0JsYW5rUm93LCB0cmFpbGluZ1Jvd09wdGlvbnM/LnRpbnRdKTtcbiAgICBjb25zdCBtYW5nbGVkVmVydGljYWxCb3JkZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoY29sKSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmVydGljYWxCb3JkZXIgPT09IFwiYm9vbGVhblwiXG4gICAgICAgICAgICA/IHZlcnRpY2FsQm9yZGVyXG4gICAgICAgICAgICA6IHZlcnRpY2FsQm9yZGVyPy4oY29sIC0gcm93TWFya2VyT2Zmc2V0KSA/PyB0cnVlO1xuICAgIH0sIFtyb3dNYXJrZXJPZmZzZXQsIHZlcnRpY2FsQm9yZGVyXSk7XG4gICAgY29uc3QgcmVuYW1lR3JvdXBOb2RlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChyZW5hbWVHcm91cCA9PT0gdW5kZWZpbmVkIHx8IGNhbnZhc1JlZi5jdXJyZW50ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHsgYm91bmRzLCBncm91cCB9ID0gcmVuYW1lR3JvdXA7XG4gICAgICAgIGNvbnN0IGNhbnZhc0JvdW5kcyA9IGNhbnZhc1JlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JvdXBSZW5hbWUsIHsgYm91bmRzOiBib3VuZHMsIGdyb3VwOiBncm91cCwgY2FudmFzQm91bmRzOiBjYW52YXNCb3VuZHMsIG9uQ2xvc2U6ICgpID0+IHNldFJlbmFtZUdyb3VwKHVuZGVmaW5lZCksIG9uRmluaXNoOiBuZXdWYWwgPT4ge1xuICAgICAgICAgICAgICAgIHNldFJlbmFtZUdyb3VwKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgb25Hcm91cEhlYWRlclJlbmFtZWQ/Lihncm91cCwgbmV3VmFsKTtcbiAgICAgICAgICAgIH0gfSkpO1xuICAgIH0sIFtvbkdyb3VwSGVhZGVyUmVuYW1lZCwgcmVuYW1lR3JvdXBdKTtcbiAgICBjb25zdCBtYW5nbGVkRnJlZXplQ29sdW1ucyA9IE1hdGgubWluKG1hbmdsZWRDb2xzLmxlbmd0aCwgZnJlZXplQ29sdW1ucyArIChoYXNSb3dNYXJrZXJzID8gMSA6IDApKTtcbiAgICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4gKHtcbiAgICAgICAgYXBwZW5kUm93OiAoY29sLCBvcGVuT3ZlcmxheSkgPT4gYXBwZW5kUm93KGNvbCArIHJvd01hcmtlck9mZnNldCwgb3Blbk92ZXJsYXkpLFxuICAgICAgICB1cGRhdGVDZWxsczogZGFtYWdlTGlzdCA9PiB7XG4gICAgICAgICAgICBpZiAocm93TWFya2VyT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZGFtYWdlTGlzdCA9IGRhbWFnZUxpc3QubWFwKHggPT4gKHsgY2VsbDogW3guY2VsbFswXSArIHJvd01hcmtlck9mZnNldCwgeC5jZWxsWzFdXSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ3JpZFJlZi5jdXJyZW50Py5kYW1hZ2UoZGFtYWdlTGlzdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEJvdW5kczogKGNvbCwgcm93KSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FudmFzUmVmPy5jdXJyZW50ID09PSBudWxsIHx8IHNjcm9sbFJlZj8uY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sID09PSB1bmRlZmluZWQgJiYgcm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGJvdW5kcyBvZiB0aGUgZW50aXJlIHNjcm9sbCBhcmVhOlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXNSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IHJlY3Qud2lkdGggLyBzY3JvbGxSZWYuY3VycmVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiByZWN0LnggLSBzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxMZWZ0ICogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJlY3QueSAtIHNjcm9sbFJlZi5jdXJyZW50LnNjcm9sbFRvcCAqIHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsUmVmLmN1cnJlbnQuc2Nyb2xsV2lkdGggKiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzY3JvbGxSZWYuY3VycmVudC5zY3JvbGxIZWlnaHQgKiBzY2FsZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyaWRSZWYuY3VycmVudD8uZ2V0Qm91bmRzKChjb2wgPz8gMCkgKyByb3dNYXJrZXJPZmZzZXQsIHJvdyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiAoKSA9PiBncmlkUmVmLmN1cnJlbnQ/LmZvY3VzKCksXG4gICAgICAgIGVtaXQ6IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bih7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiRGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlDb2RlOiA0NixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0V2ZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbGwtcmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsS2V5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcInJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUNvZGU6IDgyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3RXZlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmlsbC1kb3duXCI6XG4gICAgICAgICAgICAgICAgICAgIG9uS2V5RG93bih7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybEtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlDb2RlOiA2OCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0V2ZW50OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvcHlcIjpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgb25Db3B5KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwYXN0ZVwiOlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBvblBhc3RlSW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbFRvLFxuICAgICAgICByZW1lYXN1cmVDb2x1bW5zOiBjb2xzID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29sIG9mIGNvbHMpIHtcbiAgICAgICAgICAgICAgICB2b2lkIG5vcm1hbFNpemVDb2x1bW4oY29sICsgcm93TWFya2VyT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KSwgW2FwcGVuZFJvdywgbm9ybWFsU2l6ZUNvbHVtbiwgb25Db3B5LCBvbktleURvd24sIG9uUGFzdGVJbnRlcm5hbCwgcm93TWFya2VyT2Zmc2V0LCBzY3JvbGxUb10pO1xuICAgIGNvbnN0IFtzZWxDb2wsIHNlbFJvd10gPSBjdXJyZW50Q2VsbCA/PyBbXTtcbiAgICBjb25zdCBvbkNlbGxGb2N1c2VkID0gUmVhY3QudXNlQ2FsbGJhY2soKGNlbGwpID0+IHtcbiAgICAgICAgY29uc3QgW2NvbCwgcm93XSA9IGNlbGw7XG4gICAgICAgIGlmIChyb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uU2VsZWN0ICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkQ29sdW1ucyhDb21wYWN0U2VsZWN0aW9uLmZyb21TaW5nbGVTZWxlY3Rpb24oY29sKSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsQ29sID09PSBjb2wgJiYgc2VsUm93ID09PSByb3cpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldEN1cnJlbnQoe1xuICAgICAgICAgICAgY2VsbCxcbiAgICAgICAgICAgIHJhbmdlOiB7IHg6IGNvbCwgeTogcm93LCB3aWR0aDogMSwgaGVpZ2h0OiAxIH0sXG4gICAgICAgIH0sIHRydWUsIGZhbHNlLCBcImtleWJvYXJkLW5hdlwiKTtcbiAgICAgICAgc2Nyb2xsVG8oY29sLCByb3cpO1xuICAgIH0sIFtjb2x1bW5TZWxlY3QsIGZvY3VzLCBzY3JvbGxUbywgc2VsQ29sLCBzZWxSb3csIHNldEN1cnJlbnQsIHNldFNlbGVjdGVkQ29sdW1uc10pO1xuICAgIGNvbnN0IFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3Qgc2V0SXNGb2N1c2VkRGVib3VuY2VkID0gUmVhY3QudXNlUmVmKGRlYm91bmNlKCh2YWwpID0+IHtcbiAgICAgICAgc2V0SXNGb2N1c2VkKHZhbCk7XG4gICAgfSwgNSkpO1xuICAgIGNvbnN0IG9uQ2FudmFzRm9jdXNlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0SXNGb2N1c2VkRGVib3VuY2VkLmN1cnJlbnQodHJ1ZSk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBtb3VzZSBzdGF0ZSwgZG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHVzZXIgaXMgY2xpY2tlZCB0byBmb2N1cy5cbiAgICAgICAgaWYgKGdyaWRTZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBncmlkU2VsZWN0aW9uLmNvbHVtbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICBncmlkU2VsZWN0aW9uLnJvd3MubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICBtb3VzZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnQoe1xuICAgICAgICAgICAgICAgIGNlbGw6IFtyb3dNYXJrZXJPZmZzZXQsIGNlbGxZT2Zmc2V0XSxcbiAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICB4OiByb3dNYXJrZXJPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNlbGxZT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCB0cnVlLCBmYWxzZSwgXCJrZXlib2FyZC1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICB9LCBbY2VsbFlPZmZzZXQsIGdyaWRTZWxlY3Rpb24sIG1vdXNlU3RhdGUsIHJvd01hcmtlck9mZnNldCwgc2V0Q3VycmVudF0pO1xuICAgIGNvbnN0IG9uRm9jdXNPdXQgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldElzRm9jdXNlZERlYm91bmNlZC5jdXJyZW50KGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgW2lkZWFsV2lkdGgsIGlkZWFsSGVpZ2h0XSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBsZXQgaDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSBleHBlcmltZW50YWw/LnNjcm9sbGJhcldpZHRoT3ZlcnJpZGUgPz8gZ2V0U2Nyb2xsQmFyV2lkdGgoKTtcbiAgICAgICAgY29uc3Qgcm93c0NvdW50V2l0aFRyYWlsaW5nUm93ID0gcm93cyArIChzaG93VHJhaWxpbmdCbGFua1JvdyA/IDEgOiAwKTtcbiAgICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGggPSB0b3RhbEhlYWRlckhlaWdodCArIHJvd3NDb3VudFdpdGhUcmFpbGluZ1JvdyAqIHJvd0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhdmcgPSAwO1xuICAgICAgICAgICAgY29uc3QgdG9BdmVyYWdlID0gTWF0aC5taW4ocm93c0NvdW50V2l0aFRyYWlsaW5nUm93LCAxMCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvQXZlcmFnZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXZnICs9IHJvd0hlaWdodChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF2ZyA9IE1hdGguZmxvb3IoYXZnIC8gdG9BdmVyYWdlKTtcbiAgICAgICAgICAgIGggPSB0b3RhbEhlYWRlckhlaWdodCArIHJvd3NDb3VudFdpdGhUcmFpbGluZ1JvdyAqIGF2ZztcbiAgICAgICAgfVxuICAgICAgICBoICs9IHNjcm9sbGJhcldpZHRoO1xuICAgICAgICBjb25zdCB3ID0gbWFuZ2xlZENvbHMucmVkdWNlKChhY2MsIHgpID0+IHgud2lkdGggKyBhY2MsIDApICsgc2Nyb2xsYmFyV2lkdGg7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2V0IGEgcmVhc29uYWJsZSBjYXAgaGVyZSBhcyBzb21lIGJyb3dzZXJzIHdpbGwganVzdCBpZ25vcmUgaHVnZSB2YWx1ZXNcbiAgICAgICAgLy8gcmF0aGVyIHRoYW4gdHJlYXQgdGhlbSBhcyBodWdlIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIFtgJHtNYXRoLm1pbigxMDAwMDAsIHcpfXB4YCwgYCR7TWF0aC5taW4oMTAwMDAwLCBoKX1weGBdO1xuICAgIH0sIFttYW5nbGVkQ29scywgZXhwZXJpbWVudGFsPy5zY3JvbGxiYXJXaWR0aE92ZXJyaWRlLCByb3dIZWlnaHQsIHJvd3MsIHNob3dUcmFpbGluZ0JsYW5rUm93LCB0b3RhbEhlYWRlckhlaWdodF0pO1xuICAgIGNvbnN0IGNzc1N0eWxlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBtYWtlQ1NTU3R5bGUobWVyZ2VkVGhlbWUpO1xuICAgIH0sIFttZXJnZWRUaGVtZV0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChUaGVtZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG1lcmdlZFRoZW1lIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YUVkaXRvckNvbnRhaW5lciwgeyBzdHlsZTogY3NzU3R5bGUsIGNsYXNzTmFtZTogY2xhc3NOYW1lLCBpbldpZHRoOiB3aWR0aCA/PyBpZGVhbFdpZHRoLCBpbkhlaWdodDogaGVpZ2h0ID8/IGlkZWFsSGVpZ2h0IH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERhdGFHcmlkU2VhcmNoLCB7IGZpbGxIYW5kbGU6IGZpbGxIYW5kbGUsIGRyYXdGb2N1c1Jpbmc6IGRyYXdGb2N1c1JpbmcsIGV4cGVyaW1lbnRhbDogZXhwZXJpbWVudGFsLCBmaXhlZFNoYWRvd1g6IGZpeGVkU2hhZG93WCwgZml4ZWRTaGFkb3dZOiBmaXhlZFNoYWRvd1ksIGdldFJvd1RoZW1lT3ZlcnJpZGU6IGdldFJvd1RoZW1lT3ZlcnJpZGUsIGhlYWRlckljb25zOiBoZWFkZXJJY29ucywgaW1hZ2VXaW5kb3dMb2FkZXI6IGltYWdlV2luZG93TG9hZGVyLCBpbml0aWFsU2l6ZTogaW5pdGlhbFNpemUsIGlzRHJhZ2dhYmxlOiBpc0RyYWdnYWJsZSwgb25EcmFnTGVhdmU6IG9uRHJhZ0xlYXZlLCBvblJvd01vdmVkOiBvblJvd01vdmVkLCBvdmVyc2Nyb2xsWDogb3ZlcnNjcm9sbFgsIG92ZXJzY3JvbGxZOiBvdmVyc2Nyb2xsWSwgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nOiBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmcsIHJpZ2h0RWxlbWVudDogcmlnaHRFbGVtZW50LCByaWdodEVsZW1lbnRQcm9wczogcmlnaHRFbGVtZW50UHJvcHMsIHNtb290aFNjcm9sbFg6IHNtb290aFNjcm9sbFgsIHNtb290aFNjcm9sbFk6IHNtb290aFNjcm9sbFksIGNsYXNzTmFtZTogY2xhc3NOYW1lLCBlbmFibGVHcm91cHM6IGVuYWJsZUdyb3Vwcywgb25DYW52YXNGb2N1c2VkOiBvbkNhbnZhc0ZvY3VzZWQsIG9uQ2FudmFzQmx1cjogb25Gb2N1c091dCwgY2FudmFzUmVmOiBjYW52YXNSZWYsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnUsIHRoZW1lOiBtZXJnZWRUaGVtZSwgY2VsbFhPZmZzZXQ6IGNlbGxYT2Zmc2V0LCBjZWxsWU9mZnNldDogY2VsbFlPZmZzZXQsIGFjY2Vzc2liaWxpdHlIZWlnaHQ6IHZpc2libGVSZWdpb24uaGVpZ2h0LCBvbkRyYWdFbmQ6IG9uRHJhZ0VuZCwgY29sdW1uczogbWFuZ2xlZENvbHMsIG5vbkdyb3dXaWR0aDogbm9uR3Jvd1dpZHRoLCBkcmF3SGVhZGVyOiBkcmF3SGVhZGVyLCBvbkNvbHVtblByb3Bvc2VNb3ZlOiBvbkNvbHVtblByb3Bvc2VNb3ZlLCBkcmF3Q2VsbDogZHJhd0NlbGwsIGRpc2FibGVkUm93czogZGlzYWJsZWRSb3dzLCBmcmVlemVDb2x1bW5zOiBtYW5nbGVkRnJlZXplQ29sdW1ucywgbG9ja0NvbHVtbnM6IHJvd01hcmtlck9mZnNldCwgZmlyc3RDb2xBY2Nlc3NpYmxlOiByb3dNYXJrZXJPZmZzZXQgPT09IDAsIGdldENlbGxDb250ZW50OiBnZXRNYW5nbGVkQ2VsbENvbnRlbnQsIG1pbkNvbHVtbldpZHRoOiBtaW5Db2x1bW5XaWR0aCwgbWF4Q29sdW1uV2lkdGg6IG1heENvbHVtbldpZHRoLCBzZWFyY2hJbnB1dFJlZjogc2VhcmNoSW5wdXRSZWYsIHNob3dTZWFyY2g6IHNob3dTZWFyY2gsIG9uU2VhcmNoQ2xvc2U6IG9uU2VhcmNoQ2xvc2UsIGhpZ2hsaWdodFJlZ2lvbnM6IGhpZ2hsaWdodFJlZ2lvbnMsIGdldENlbGxzRm9yU2VsZWN0aW9uOiBnZXRDZWxsc0ZvclNlbGVjdGlvbiwgZ2V0R3JvdXBEZXRhaWxzOiBtYW5nbGVkR2V0R3JvdXBEZXRhaWxzLCBoZWFkZXJIZWlnaHQ6IGhlYWRlckhlaWdodCwgaXNGb2N1c2VkOiBpc0ZvY3VzZWQsIGdyb3VwSGVhZGVySGVpZ2h0OiBlbmFibGVHcm91cHMgPyBncm91cEhlYWRlckhlaWdodCA6IDAsIGZyZWV6ZVRyYWlsaW5nUm93czogZnJlZXplVHJhaWxpbmdSb3dzICsgKHNob3dUcmFpbGluZ0JsYW5rUm93ICYmIHRyYWlsaW5nUm93T3B0aW9ucz8uc3RpY2t5ID09PSB0cnVlID8gMSA6IDApLCBoYXNBcHBlbmRSb3c6IHNob3dUcmFpbGluZ0JsYW5rUm93LCBvbkNvbHVtblJlc2l6ZTogb25Db2x1bW5SZXNpemUsIG9uQ29sdW1uUmVzaXplRW5kOiBvbkNvbHVtblJlc2l6ZUVuZCwgb25Db2x1bW5SZXNpemVTdGFydDogb25Db2x1bW5SZXNpemVTdGFydCwgb25DZWxsRm9jdXNlZDogb25DZWxsRm9jdXNlZCwgb25Db2x1bW5Nb3ZlZDogb25Db2x1bW5Nb3ZlZEltcGwsIG9uRHJhZ1N0YXJ0OiBvbkRyYWdTdGFydEltcGwsIG9uSGVhZGVyTWVudUNsaWNrOiBvbkhlYWRlck1lbnVDbGlja0lubmVyLCBvbkl0ZW1Ib3ZlcmVkOiBvbkl0ZW1Ib3ZlcmVkSW1wbCwgaXNGaWxsaW5nOiBtb3VzZVN0YXRlPy5maWxsSGFuZGxlID09PSB0cnVlLCBvbk1vdXNlTW92ZTogb25Nb3VzZU1vdmVJbXBsLCBvbktleURvd246IG9uS2V5RG93biwgb25LZXlVcDogb25LZXlVcEluLCBvbk1vdXNlRG93bjogb25Nb3VzZURvd24sIG9uTW91c2VVcDogb25Nb3VzZVVwLCBvbkRyYWdPdmVyQ2VsbDogb25EcmFnT3ZlckNlbGwsIG9uRHJvcDogb25Ecm9wLCBvblNlYXJjaFJlc3VsdHNDaGFuZ2VkOiBvblNlYXJjaFJlc3VsdHNDaGFuZ2VkLCBvblZpc2libGVSZWdpb25DaGFuZ2VkOiBvblZpc2libGVSZWdpb25DaGFuZ2VkSW1wbCwgY2xpZW50U2l6ZTogY2xpZW50U2l6ZSwgcm93SGVpZ2h0OiByb3dIZWlnaHQsIHNlYXJjaFJlc3VsdHM6IHNlYXJjaFJlc3VsdHMsIHNlYXJjaFZhbHVlOiBzZWFyY2hWYWx1ZSwgb25TZWFyY2hWYWx1ZUNoYW5nZTogb25TZWFyY2hWYWx1ZUNoYW5nZSwgcm93czogbWFuZ2xlZFJvd3MsIHNjcm9sbFJlZjogc2Nyb2xsUmVmLCBzZWxlY3Rpb246IGdyaWRTZWxlY3Rpb24sIHRyYW5zbGF0ZVg6IHZpc2libGVSZWdpb24udHgsIHRyYW5zbGF0ZVk6IHZpc2libGVSZWdpb24udHksIHZlcnRpY2FsQm9yZGVyOiBtYW5nbGVkVmVydGljYWxCb3JkZXIsIGdyaWRSZWY6IGdyaWRSZWYsIGdldENlbGxSZW5kZXJlcjogZ2V0Q2VsbFJlbmRlcmVyIH0pLFxuICAgICAgICAgICAgcmVuYW1lR3JvdXBOb2RlLFxuICAgICAgICAgICAgb3ZlcmxheSAhPT0gdW5kZWZpbmVkICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7IGZhbGxiYWNrOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhR3JpZE92ZXJsYXlFZGl0b3IsIHsgLi4ub3ZlcmxheSwgdmFsaWRhdGVDZWxsOiB2YWxpZGF0ZUNlbGwsIGJsb29tOiBlZGl0b3JCbG9vbSwgaWQ6IG92ZXJsYXlJRCwgZ2V0Q2VsbFJlbmRlcmVyOiBnZXRDZWxsUmVuZGVyZXIsIGNsYXNzTmFtZTogZXhwZXJpbWVudGFsPy5pc1N1YkdyaWQgPT09IHRydWUgPyBcImNsaWNrLW91dHNpZGUtaWdub3JlXCIgOiB1bmRlZmluZWQsIHByb3ZpZGVFZGl0b3I6IHByb3ZpZGVFZGl0b3IsIGltYWdlRWRpdG9yT3ZlcnJpZGU6IGltYWdlRWRpdG9yT3ZlcnJpZGUsIG9uRmluaXNoRWRpdGluZzogb25GaW5pc2hFZGl0aW5nLCBtYXJrZG93bkRpdkNyZWF0ZU5vZGU6IG1hcmtkb3duRGl2Q3JlYXRlTm9kZSwgaXNPdXRzaWRlQ2xpY2s6IGlzT3V0c2lkZUNsaWNrIH0pKSkpKSk7XG59O1xuLyoqXG4gKiBUaGUgcHJpbWFyeSBjb21wb25lbnQgb2YgR2xpZGUgRGF0YSBHcmlkLlxuICogQGNhdGVnb3J5IERhdGFFZGl0b3JcbiAqIEBwYXJhbSB7RGF0YUVkaXRvclByb3BzfSBwcm9wc1xuICovXG5leHBvcnQgY29uc3QgRGF0YUVkaXRvciA9IFJlYWN0LmZvcndhcmRSZWYoRGF0YUVkaXRvckltcGwpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS1lZGl0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/data-editor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/group-rename.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/group-rename.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupRename: () => (/* binding */ GroupRename)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n/* harmony import */ var _internal_click_outside_container_click_outside_container_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/click-outside-container/click-outside-container.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/click-outside-container/click-outside-container.js\");\n\n\n\nconst _exp = /*#__PURE__*/() => p => Math.max(16, p.targetHeight - 10);\nconst RenameInput = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_1__.styled)('input')({\n  name: \"RenameInput\",\n  class: \"gdg-r17m35ur\",\n  propsAsIs: false,\n  vars: {\n    \"r17m35ur-0\": [_exp(), \"px\"]\n  }\n});\nconst GroupRename = p => {\n  const {\n    bounds,\n    group,\n    onClose,\n    canvasBounds,\n    onFinish\n  } = p;\n  const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(group);\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_internal_click_outside_container_click_outside_container_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n    style: {\n      position: \"absolute\",\n      left: bounds.x - canvasBounds.left + 1,\n      top: bounds.y - canvasBounds.top,\n      width: bounds.width - 2,\n      height: bounds.height\n    },\n    className: \"gdg-c1tqibwd\",\n    onClickOutside: onClose\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenameInput, {\n    targetHeight: bounds.height,\n    \"data-testid\": \"group-rename-input\",\n    value: value,\n    onBlur: onClose,\n    onFocus: e => e.target.setSelectionRange(0, value.length),\n    onChange: e => setValue(e.target.value),\n    onKeyDown: e => {\n      if (e.key === \"Enter\") {\n        onFinish(value);\n      } else if (e.key === \"Escape\") {\n        onClose();\n      }\n    },\n    autoFocus: true\n  }));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvZ3JvdXAtcmVuYW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEI7QUFDYztBQUMyRDtBQUNuRztBQUNBLGlDQUFpQyxzREFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNEJBQTRCLDJDQUFjO0FBQzFDLFNBQVMsZ0RBQW1CLENBQUMsb0dBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRyxFQUFFLGdEQUFtQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2RhdGEtZWRpdG9yL2dyb3VwLXJlbmFtZS5qcz8yMjYzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuaW1wb3J0IENsaWNrT3V0c2lkZUNvbnRhaW5lciBmcm9tIFwiLi4vaW50ZXJuYWwvY2xpY2stb3V0c2lkZS1jb250YWluZXIvY2xpY2stb3V0c2lkZS1jb250YWluZXIuanNcIjtcbmNvbnN0IF9leHAgPSAvKiNfX1BVUkVfXyovKCkgPT4gcCA9PiBNYXRoLm1heCgxNiwgcC50YXJnZXRIZWlnaHQgLSAxMCk7XG5jb25zdCBSZW5hbWVJbnB1dCA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2lucHV0Jykoe1xuICBuYW1lOiBcIlJlbmFtZUlucHV0XCIsXG4gIGNsYXNzOiBcImdkZy1yMTdtMzV1clwiLFxuICBwcm9wc0FzSXM6IGZhbHNlLFxuICB2YXJzOiB7XG4gICAgXCJyMTdtMzV1ci0wXCI6IFtfZXhwKCksIFwicHhcIl1cbiAgfVxufSk7XG5leHBvcnQgY29uc3QgR3JvdXBSZW5hbWUgPSBwID0+IHtcbiAgY29uc3Qge1xuICAgIGJvdW5kcyxcbiAgICBncm91cCxcbiAgICBvbkNsb3NlLFxuICAgIGNhbnZhc0JvdW5kcyxcbiAgICBvbkZpbmlzaFxuICB9ID0gcDtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShncm91cCk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENsaWNrT3V0c2lkZUNvbnRhaW5lciwge1xuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgbGVmdDogYm91bmRzLnggLSBjYW52YXNCb3VuZHMubGVmdCArIDEsXG4gICAgICB0b3A6IGJvdW5kcy55IC0gY2FudmFzQm91bmRzLnRvcCxcbiAgICAgIHdpZHRoOiBib3VuZHMud2lkdGggLSAyLFxuICAgICAgaGVpZ2h0OiBib3VuZHMuaGVpZ2h0XG4gICAgfSxcbiAgICBjbGFzc05hbWU6IFwiZ2RnLWMxdHFpYndkXCIsXG4gICAgb25DbGlja091dHNpZGU6IG9uQ2xvc2VcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChSZW5hbWVJbnB1dCwge1xuICAgIHRhcmdldEhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICBcImRhdGEtdGVzdGlkXCI6IFwiZ3JvdXAtcmVuYW1lLWlucHV0XCIsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG9uQmx1cjogb25DbG9zZSxcbiAgICBvbkZvY3VzOiBlID0+IGUudGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKDAsIHZhbHVlLmxlbmd0aCksXG4gICAgb25DaGFuZ2U6IGUgPT4gc2V0VmFsdWUoZS50YXJnZXQudmFsdWUpLFxuICAgIG9uS2V5RG93bjogZSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICBvbkZpbmlzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF1dG9Gb2N1czogdHJ1ZVxuICB9KSk7XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/group-rename.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-autoscroll.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-autoscroll.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAutoscroll: () => (/* binding */ useAutoscroll)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst maxPxPerMs = 2;\nconst msToFullSpeed = 1300;\nfunction useAutoscroll(scrollDirection, scrollRef, onScroll) {\n    const speedScalar = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const [xDir, yDir] = scrollDirection ?? [0, 0];\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (xDir === 0 && yDir === 0) {\n            speedScalar.current = 0;\n            return;\n        }\n        let cancelled = false;\n        let lastTime = 0;\n        const scrollFn = (curTime) => {\n            if (cancelled)\n                return;\n            if (lastTime === 0) {\n                lastTime = curTime;\n            }\n            else {\n                const step = curTime - lastTime;\n                speedScalar.current = Math.min(1, speedScalar.current + step / msToFullSpeed);\n                const motion = speedScalar.current ** 1.618 * step * maxPxPerMs;\n                scrollRef.current?.scrollBy(xDir * motion, yDir * motion);\n                lastTime = curTime;\n                onScroll?.();\n            }\n            window.requestAnimationFrame(scrollFn);\n        };\n        window.requestAnimationFrame(scrollFn);\n        return () => {\n            cancelled = true;\n        };\n    }, [scrollRef, xDir, yDir, onScroll]);\n}\n//# sourceMappingURL=use-autoscroll.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvdXNlLWF1dG9zY3JvbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7QUFDMUI7QUFDQTtBQUNPO0FBQ1Asd0JBQXdCLHlDQUFZO0FBQ3BDO0FBQ0EsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9kYXRhLWVkaXRvci91c2UtYXV0b3Njcm9sbC5qcz80Yjk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IG1heFB4UGVyTXMgPSAyO1xuY29uc3QgbXNUb0Z1bGxTcGVlZCA9IDEzMDA7XG5leHBvcnQgZnVuY3Rpb24gdXNlQXV0b3Njcm9sbChzY3JvbGxEaXJlY3Rpb24sIHNjcm9sbFJlZiwgb25TY3JvbGwpIHtcbiAgICBjb25zdCBzcGVlZFNjYWxhciA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBjb25zdCBbeERpciwgeURpcl0gPSBzY3JvbGxEaXJlY3Rpb24gPz8gWzAsIDBdO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh4RGlyID09PSAwICYmIHlEaXIgPT09IDApIHtcbiAgICAgICAgICAgIHNwZWVkU2NhbGFyLmN1cnJlbnQgPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGxhc3RUaW1lID0gMDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRm4gPSAoY3VyVGltZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAobGFzdFRpbWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsYXN0VGltZSA9IGN1clRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gY3VyVGltZSAtIGxhc3RUaW1lO1xuICAgICAgICAgICAgICAgIHNwZWVkU2NhbGFyLmN1cnJlbnQgPSBNYXRoLm1pbigxLCBzcGVlZFNjYWxhci5jdXJyZW50ICsgc3RlcCAvIG1zVG9GdWxsU3BlZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vdGlvbiA9IHNwZWVkU2NhbGFyLmN1cnJlbnQgKiogMS42MTggKiBzdGVwICogbWF4UHhQZXJNcztcbiAgICAgICAgICAgICAgICBzY3JvbGxSZWYuY3VycmVudD8uc2Nyb2xsQnkoeERpciAqIG1vdGlvbiwgeURpciAqIG1vdGlvbik7XG4gICAgICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJUaW1lO1xuICAgICAgICAgICAgICAgIG9uU2Nyb2xsPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2Nyb2xsRm4pO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjcm9sbEZuKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgfSwgW3Njcm9sbFJlZiwgeERpciwgeURpciwgb25TY3JvbGxdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1hdXRvc2Nyb2xsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-autoscroll.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-cells-for-selection.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-cells-for-selection.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useCellsForSelection: () => (/* binding */ useCellsForSelection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n\n\nfunction useCellsForSelection(getCellsForSelectionIn, getCellContent, rowMarkerOffset, abortController, rows) {\n    const getCellsForSelectionDirectWhenValid = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(rect => {\n        if (getCellsForSelectionIn === true) {\n            const result = [];\n            for (let y = rect.y; y < rect.y + rect.height; y++) {\n                const row = [];\n                for (let x = rect.x; x < rect.x + rect.width; x++) {\n                    if (x < 0 || y >= rows) {\n                        row.push({\n                            kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Loading,\n                            allowOverlay: false,\n                        });\n                    }\n                    else {\n                        row.push(getCellContent([x, y]));\n                    }\n                }\n                result.push(row);\n            }\n            return result;\n        }\n        return getCellsForSelectionIn?.(rect, abortController.signal) ?? [];\n    }, [abortController.signal, getCellContent, getCellsForSelectionIn, rows]);\n    const getCellsForSelectionDirect = getCellsForSelectionIn !== undefined ? getCellsForSelectionDirectWhenValid : undefined;\n    const getCellsForSelectionMangled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(rect => {\n        if (getCellsForSelectionDirect === undefined)\n            return [];\n        const newRect = {\n            ...rect,\n            x: rect.x - rowMarkerOffset,\n        };\n        if (newRect.x < 0) {\n            newRect.x = 0;\n            newRect.width--;\n            const r = getCellsForSelectionDirect(newRect, abortController.signal);\n            if (typeof r === \"function\") {\n                return async () => \n                // eslint-disable-next-line unicorn/no-await-expression-member\n                (await r()).map(row => [\n                    { kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Loading, allowOverlay: false },\n                    ...row,\n                ]);\n            }\n            return r.map(row => [{ kind: _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Loading, allowOverlay: false }, ...row]);\n        }\n        return getCellsForSelectionDirect(newRect, abortController.signal);\n    }, [abortController.signal, getCellsForSelectionDirect, rowMarkerOffset]);\n    const getCellsForSelection = getCellsForSelectionIn !== undefined ? getCellsForSelectionMangled : undefined;\n    return [getCellsForSelection, getCellsForSelectionDirect];\n}\n//# sourceMappingURL=use-cells-for-selection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvdXNlLWNlbGxzLWZvci1zZWxlY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStCO0FBQ3lDO0FBQ2pFO0FBQ1AsZ0RBQWdELDhDQUFpQjtBQUNqRTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBLGtDQUFrQyxnRkFBWTtBQUM5QztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3Qyw4Q0FBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNLGdGQUFZLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTSxnRkFBWSwrQkFBK0I7QUFDcEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2RhdGEtZWRpdG9yL3VzZS1jZWxscy1mb3Itc2VsZWN0aW9uLmpzP2Q2MmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBHcmlkQ2VsbEtpbmQgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNlbGxzRm9yU2VsZWN0aW9uKGdldENlbGxzRm9yU2VsZWN0aW9uSW4sIGdldENlbGxDb250ZW50LCByb3dNYXJrZXJPZmZzZXQsIGFib3J0Q29udHJvbGxlciwgcm93cykge1xuICAgIGNvbnN0IGdldENlbGxzRm9yU2VsZWN0aW9uRGlyZWN0V2hlblZhbGlkID0gUmVhY3QudXNlQ2FsbGJhY2socmVjdCA9PiB7XG4gICAgICAgIGlmIChnZXRDZWxsc0ZvclNlbGVjdGlvbkluID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSByZWN0Lnk7IHkgPCByZWN0LnkgKyByZWN0LmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IHJlY3QueDsgeCA8IHJlY3QueCArIHJlY3Qud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8IDAgfHwgeSA+PSByb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogR3JpZENlbGxLaW5kLkxvYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goZ2V0Q2VsbENvbnRlbnQoW3gsIHldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldENlbGxzRm9yU2VsZWN0aW9uSW4/LihyZWN0LCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKSA/PyBbXTtcbiAgICB9LCBbYWJvcnRDb250cm9sbGVyLnNpZ25hbCwgZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxzRm9yU2VsZWN0aW9uSW4sIHJvd3NdKTtcbiAgICBjb25zdCBnZXRDZWxsc0ZvclNlbGVjdGlvbkRpcmVjdCA9IGdldENlbGxzRm9yU2VsZWN0aW9uSW4gIT09IHVuZGVmaW5lZCA/IGdldENlbGxzRm9yU2VsZWN0aW9uRGlyZWN0V2hlblZhbGlkIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGdldENlbGxzRm9yU2VsZWN0aW9uTWFuZ2xlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKHJlY3QgPT4ge1xuICAgICAgICBpZiAoZ2V0Q2VsbHNGb3JTZWxlY3Rpb25EaXJlY3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY29uc3QgbmV3UmVjdCA9IHtcbiAgICAgICAgICAgIC4uLnJlY3QsXG4gICAgICAgICAgICB4OiByZWN0LnggLSByb3dNYXJrZXJPZmZzZXQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChuZXdSZWN0LnggPCAwKSB7XG4gICAgICAgICAgICBuZXdSZWN0LnggPSAwO1xuICAgICAgICAgICAgbmV3UmVjdC53aWR0aC0tO1xuICAgICAgICAgICAgY29uc3QgciA9IGdldENlbGxzRm9yU2VsZWN0aW9uRGlyZWN0KG5ld1JlY3QsIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmMgKCkgPT4gXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tYXdhaXQtZXhwcmVzc2lvbi1tZW1iZXJcbiAgICAgICAgICAgICAgICAoYXdhaXQgcigpKS5tYXAocm93ID0+IFtcbiAgICAgICAgICAgICAgICAgICAgeyBraW5kOiBHcmlkQ2VsbEtpbmQuTG9hZGluZywgYWxsb3dPdmVybGF5OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAuLi5yb3csXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gci5tYXAocm93ID0+IFt7IGtpbmQ6IEdyaWRDZWxsS2luZC5Mb2FkaW5nLCBhbGxvd092ZXJsYXk6IGZhbHNlIH0sIC4uLnJvd10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDZWxsc0ZvclNlbGVjdGlvbkRpcmVjdChuZXdSZWN0LCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICB9LCBbYWJvcnRDb250cm9sbGVyLnNpZ25hbCwgZ2V0Q2VsbHNGb3JTZWxlY3Rpb25EaXJlY3QsIHJvd01hcmtlck9mZnNldF0pO1xuICAgIGNvbnN0IGdldENlbGxzRm9yU2VsZWN0aW9uID0gZ2V0Q2VsbHNGb3JTZWxlY3Rpb25JbiAhPT0gdW5kZWZpbmVkID8gZ2V0Q2VsbHNGb3JTZWxlY3Rpb25NYW5nbGVkIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBbZ2V0Q2VsbHNGb3JTZWxlY3Rpb24sIGdldENlbGxzRm9yU2VsZWN0aW9uRGlyZWN0XTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1jZWxscy1mb3Itc2VsZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-cells-for-selection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-column-sizer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-column-sizer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   measureColumn: () => (/* binding */ measureColumn),\n/* harmony export */   useColumnSizer: () => (/* binding */ useColumnSizer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n\n\nconst defaultSize = 150;\nfunction measureCell(ctx, cell, theme, getCellRenderer) {\n    const r = getCellRenderer(cell);\n    return r?.measure?.(ctx, cell, theme) ?? defaultSize;\n}\nfunction measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, removeOutliers, getCellRenderer) {\n    let max = 0;\n    const sizes = selectedData === undefined\n        ? []\n        : selectedData.map(row => {\n            const r = measureCell(ctx, row[colIndex], theme, getCellRenderer);\n            max = Math.max(max, r);\n            return r;\n        });\n    if (sizes.length > 5 && removeOutliers) {\n        max = 0;\n        // Filter out outliers\n        let sum = 0;\n        for (const size of sizes) {\n            sum += size;\n        }\n        const average = sum / sizes.length;\n        // Set sizes that are considered outliers to zero\n        for (let i = 0; i < sizes.length; i++) {\n            if (sizes[i] >= average * 2) {\n                sizes[i] = 0;\n            }\n            else {\n                max = Math.max(max, sizes[i]);\n            }\n        }\n    }\n    max = Math.max(max, ctx.measureText(c.title).width + 16 + (c.icon === undefined ? 0 : 28));\n    const final = Math.max(Math.ceil(minColumnWidth), Math.min(Math.floor(maxColumnWidth), Math.ceil(max)));\n    return {\n        ...c,\n        width: final,\n    };\n}\n/** @category Hooks */\nfunction useColumnSizer(columns, rows, getCellsForSelection, clientWidth, minColumnWidth, maxColumnWidth, theme, getCellRenderer, abortController) {\n    const rowsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(rows);\n    const getCellsForSelectionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(getCellsForSelection);\n    const themeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(theme);\n    rowsRef.current = rows;\n    getCellsForSelectionRef.current = getCellsForSelection;\n    themeRef.current = theme;\n    const [canvas, ctx] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (typeof window === \"undefined\")\n            return [null, null];\n        const offscreen = document.createElement(\"canvas\");\n        offscreen.style[\"display\"] = \"none\";\n        offscreen.style[\"opacity\"] = \"0\";\n        offscreen.style[\"position\"] = \"fixed\";\n        return [offscreen, offscreen.getContext(\"2d\", { alpha: false })];\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (canvas)\n            document.documentElement.append(canvas);\n        return () => {\n            canvas?.remove();\n        };\n    }, [canvas]);\n    const memoMap = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n    const lastColumns = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const [selectedData, setSelectionData] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        const getCells = getCellsForSelectionRef.current;\n        if (getCells === undefined || columns.every(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.isSizedGridColumn))\n            return;\n        let computeRows = Math.max(1, 10 - Math.floor(columns.length / 10000));\n        let tailRows = 0;\n        if (computeRows < rowsRef.current && computeRows > 1) {\n            computeRows--;\n            tailRows = 1;\n        }\n        const computeArea = {\n            x: 0,\n            y: 0,\n            width: columns.length,\n            height: Math.min(rowsRef.current, computeRows),\n        };\n        const tailComputeArea = {\n            x: 0,\n            y: rowsRef.current - 1,\n            width: columns.length,\n            height: 1,\n        };\n        const fn = async () => {\n            const getResult = getCells(computeArea, abortController.signal);\n            const tailGetResult = tailRows > 0 ? getCells(tailComputeArea, abortController.signal) : undefined;\n            let toSet;\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (typeof getResult === \"object\") {\n                toSet = getResult;\n            }\n            else {\n                toSet = await (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.resolveCellsThunk)(getResult);\n            }\n            if (tailGetResult !== undefined) {\n                // eslint-disable-next-line unicorn/prefer-ternary\n                if (typeof tailGetResult === \"object\") {\n                    toSet = [...toSet, ...tailGetResult];\n                }\n                else {\n                    toSet = [...toSet, ...(await (0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.resolveCellsThunk)(tailGetResult))];\n                }\n            }\n            lastColumns.current = columns;\n            setSelectionData(toSet);\n        };\n        void fn();\n    }, [abortController.signal, columns]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        const getRaw = () => {\n            if (columns.every(_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.isSizedGridColumn)) {\n                return columns;\n            }\n            if (ctx === null) {\n                return columns.map(c => {\n                    if ((0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.isSizedGridColumn)(c))\n                        return c;\n                    return {\n                        ...c,\n                        width: defaultSize,\n                    };\n                });\n            }\n            ctx.font = themeRef.current.baseFontFull;\n            return columns.map((c, colIndex) => {\n                if ((0,_internal_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.isSizedGridColumn)(c))\n                    return c;\n                if (memoMap.current[c.id] !== undefined) {\n                    return {\n                        ...c,\n                        width: memoMap.current[c.id],\n                    };\n                }\n                if (selectedData === undefined || lastColumns.current !== columns || c.id === undefined) {\n                    return {\n                        ...c,\n                        width: defaultSize,\n                    };\n                }\n                const r = measureColumn(ctx, theme, c, colIndex, selectedData, minColumnWidth, maxColumnWidth, true, getCellRenderer);\n                memoMap.current[c.id] = r.width;\n                return r;\n            });\n        };\n        let result = getRaw();\n        let totalWidth = 0;\n        let totalGrow = 0;\n        const distribute = [];\n        for (const [i, c] of result.entries()) {\n            totalWidth += c.width;\n            if (c.grow !== undefined && c.grow > 0) {\n                totalGrow += c.grow;\n                distribute.push(i);\n            }\n        }\n        if (totalWidth < clientWidth && distribute.length > 0) {\n            const writeable = [...result];\n            const extra = clientWidth - totalWidth;\n            let remaining = extra;\n            for (let di = 0; di < distribute.length; di++) {\n                const i = distribute[di];\n                const weighted = (result[i].grow ?? 0) / totalGrow;\n                const toAdd = di === distribute.length - 1 ? remaining : Math.min(remaining, Math.floor(extra * weighted));\n                writeable[i] = {\n                    ...result[i],\n                    growOffset: toAdd,\n                    width: result[i].width + toAdd,\n                };\n                remaining -= toAdd;\n            }\n            result = writeable;\n        }\n        return {\n            sizedColumns: result,\n            nonGrowWidth: totalWidth,\n        };\n    }, [clientWidth, columns, ctx, selectedData, theme, minColumnWidth, maxColumnWidth, getCellRenderer]);\n}\n//# sourceMappingURL=use-column-sizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvdXNlLWNvbHVtbi1zaXplci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStCO0FBQ2tFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQix5Q0FBWTtBQUNoQyxvQ0FBb0MseUNBQVk7QUFDaEQscUJBQXFCLHlDQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsY0FBYztBQUN0RSxLQUFLO0FBQ0wsSUFBSSxrREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IseUNBQVksR0FBRztBQUNuQyx3QkFBd0IseUNBQVk7QUFDcEMsNkNBQTZDLDJDQUFjO0FBQzNELElBQUksa0RBQXFCO0FBQ3pCO0FBQ0Esb0RBQW9ELHFGQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5RkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQseUZBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLDBDQUFhO0FBQ3hCO0FBQ0EsOEJBQThCLHFGQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5RkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUZBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvdXNlLWNvbHVtbi1zaXplci5qcz82YTRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgaXNTaXplZEdyaWRDb2x1bW4sIHJlc29sdmVDZWxsc1RodW5rLCB9IGZyb20gXCIuLi9pbnRlcm5hbC9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5jb25zdCBkZWZhdWx0U2l6ZSA9IDE1MDtcbmZ1bmN0aW9uIG1lYXN1cmVDZWxsKGN0eCwgY2VsbCwgdGhlbWUsIGdldENlbGxSZW5kZXJlcikge1xuICAgIGNvbnN0IHIgPSBnZXRDZWxsUmVuZGVyZXIoY2VsbCk7XG4gICAgcmV0dXJuIHI/Lm1lYXN1cmU/LihjdHgsIGNlbGwsIHRoZW1lKSA/PyBkZWZhdWx0U2l6ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlQ29sdW1uKGN0eCwgdGhlbWUsIGMsIGNvbEluZGV4LCBzZWxlY3RlZERhdGEsIG1pbkNvbHVtbldpZHRoLCBtYXhDb2x1bW5XaWR0aCwgcmVtb3ZlT3V0bGllcnMsIGdldENlbGxSZW5kZXJlcikge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IHNpemVzID0gc2VsZWN0ZWREYXRhID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBbXVxuICAgICAgICA6IHNlbGVjdGVkRGF0YS5tYXAocm93ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtZWFzdXJlQ2VsbChjdHgsIHJvd1tjb2xJbmRleF0sIHRoZW1lLCBnZXRDZWxsUmVuZGVyZXIpO1xuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9KTtcbiAgICBpZiAoc2l6ZXMubGVuZ3RoID4gNSAmJiByZW1vdmVPdXRsaWVycykge1xuICAgICAgICBtYXggPSAwO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IG91dGxpZXJzXG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHNpemUgb2Ygc2l6ZXMpIHtcbiAgICAgICAgICAgIHN1bSArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF2ZXJhZ2UgPSBzdW0gLyBzaXplcy5sZW5ndGg7XG4gICAgICAgIC8vIFNldCBzaXplcyB0aGF0IGFyZSBjb25zaWRlcmVkIG91dGxpZXJzIHRvIHplcm9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNpemVzW2ldID49IGF2ZXJhZ2UgKiAyKSB7XG4gICAgICAgICAgICAgICAgc2l6ZXNbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBzaXplc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF4ID0gTWF0aC5tYXgobWF4LCBjdHgubWVhc3VyZVRleHQoYy50aXRsZSkud2lkdGggKyAxNiArIChjLmljb24gPT09IHVuZGVmaW5lZCA/IDAgOiAyOCkpO1xuICAgIGNvbnN0IGZpbmFsID0gTWF0aC5tYXgoTWF0aC5jZWlsKG1pbkNvbHVtbldpZHRoKSwgTWF0aC5taW4oTWF0aC5mbG9vcihtYXhDb2x1bW5XaWR0aCksIE1hdGguY2VpbChtYXgpKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYyxcbiAgICAgICAgd2lkdGg6IGZpbmFsLFxuICAgIH07XG59XG4vKiogQGNhdGVnb3J5IEhvb2tzICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29sdW1uU2l6ZXIoY29sdW1ucywgcm93cywgZ2V0Q2VsbHNGb3JTZWxlY3Rpb24sIGNsaWVudFdpZHRoLCBtaW5Db2x1bW5XaWR0aCwgbWF4Q29sdW1uV2lkdGgsIHRoZW1lLCBnZXRDZWxsUmVuZGVyZXIsIGFib3J0Q29udHJvbGxlcikge1xuICAgIGNvbnN0IHJvd3NSZWYgPSBSZWFjdC51c2VSZWYocm93cyk7XG4gICAgY29uc3QgZ2V0Q2VsbHNGb3JTZWxlY3Rpb25SZWYgPSBSZWFjdC51c2VSZWYoZ2V0Q2VsbHNGb3JTZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRoZW1lUmVmID0gUmVhY3QudXNlUmVmKHRoZW1lKTtcbiAgICByb3dzUmVmLmN1cnJlbnQgPSByb3dzO1xuICAgIGdldENlbGxzRm9yU2VsZWN0aW9uUmVmLmN1cnJlbnQgPSBnZXRDZWxsc0ZvclNlbGVjdGlvbjtcbiAgICB0aGVtZVJlZi5jdXJyZW50ID0gdGhlbWU7XG4gICAgY29uc3QgW2NhbnZhcywgY3R4XSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIG9mZnNjcmVlbi5zdHlsZVtcImRpc3BsYXlcIl0gPSBcIm5vbmVcIjtcbiAgICAgICAgb2Zmc2NyZWVuLnN0eWxlW1wib3BhY2l0eVwiXSA9IFwiMFwiO1xuICAgICAgICBvZmZzY3JlZW4uc3R5bGVbXCJwb3NpdGlvblwiXSA9IFwiZml4ZWRcIjtcbiAgICAgICAgcmV0dXJuIFtvZmZzY3JlZW4sIG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIiwgeyBhbHBoYTogZmFsc2UgfSldO1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY2FudmFzKVxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZChjYW52YXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2FudmFzPy5yZW1vdmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY2FudmFzXSk7XG4gICAgY29uc3QgbWVtb01hcCA9IFJlYWN0LnVzZVJlZih7fSk7XG4gICAgY29uc3QgbGFzdENvbHVtbnMgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBjb25zdCBbc2VsZWN0ZWREYXRhLCBzZXRTZWxlY3Rpb25EYXRhXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZ2V0Q2VsbHMgPSBnZXRDZWxsc0ZvclNlbGVjdGlvblJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoZ2V0Q2VsbHMgPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5zLmV2ZXJ5KGlzU2l6ZWRHcmlkQ29sdW1uKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvbXB1dGVSb3dzID0gTWF0aC5tYXgoMSwgMTAgLSBNYXRoLmZsb29yKGNvbHVtbnMubGVuZ3RoIC8gMTAwMDApKTtcbiAgICAgICAgbGV0IHRhaWxSb3dzID0gMDtcbiAgICAgICAgaWYgKGNvbXB1dGVSb3dzIDwgcm93c1JlZi5jdXJyZW50ICYmIGNvbXB1dGVSb3dzID4gMSkge1xuICAgICAgICAgICAgY29tcHV0ZVJvd3MtLTtcbiAgICAgICAgICAgIHRhaWxSb3dzID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wdXRlQXJlYSA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbnMubGVuZ3RoLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihyb3dzUmVmLmN1cnJlbnQsIGNvbXB1dGVSb3dzKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGFpbENvbXB1dGVBcmVhID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IHJvd3NSZWYuY3VycmVudCAtIDEsXG4gICAgICAgICAgICB3aWR0aDogY29sdW1ucy5sZW5ndGgsXG4gICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ2V0UmVzdWx0ID0gZ2V0Q2VsbHMoY29tcHV0ZUFyZWEsIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgICAgICAgY29uc3QgdGFpbEdldFJlc3VsdCA9IHRhaWxSb3dzID4gMCA/IGdldENlbGxzKHRhaWxDb21wdXRlQXJlYSwgYWJvcnRDb250cm9sbGVyLnNpZ25hbCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgdG9TZXQ7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItdGVybmFyeVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZXRSZXN1bHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0b1NldCA9IGdldFJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvU2V0ID0gYXdhaXQgcmVzb2x2ZUNlbGxzVGh1bmsoZ2V0UmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWlsR2V0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItdGVybmFyeVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFpbEdldFJlc3VsdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0b1NldCA9IFsuLi50b1NldCwgLi4udGFpbEdldFJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b1NldCA9IFsuLi50b1NldCwgLi4uKGF3YWl0IHJlc29sdmVDZWxsc1RodW5rKHRhaWxHZXRSZXN1bHQpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENvbHVtbnMuY3VycmVudCA9IGNvbHVtbnM7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25EYXRhKHRvU2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdm9pZCBmbigpO1xuICAgIH0sIFthYm9ydENvbnRyb2xsZXIuc2lnbmFsLCBjb2x1bW5zXSk7XG4gICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBnZXRSYXcgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sdW1ucy5ldmVyeShpc1NpemVkR3JpZENvbHVtbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NpemVkR3JpZENvbHVtbihjKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkZWZhdWx0U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5mb250ID0gdGhlbWVSZWYuY3VycmVudC5iYXNlRm9udEZ1bGw7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoKGMsIGNvbEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2l6ZWRHcmlkQ29sdW1uKGMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICBpZiAobWVtb01hcC5jdXJyZW50W2MuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbWVtb01hcC5jdXJyZW50W2MuaWRdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWREYXRhID09PSB1bmRlZmluZWQgfHwgbGFzdENvbHVtbnMuY3VycmVudCAhPT0gY29sdW1ucyB8fCBjLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZGVmYXVsdFNpemUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBtZWFzdXJlQ29sdW1uKGN0eCwgdGhlbWUsIGMsIGNvbEluZGV4LCBzZWxlY3RlZERhdGEsIG1pbkNvbHVtbldpZHRoLCBtYXhDb2x1bW5XaWR0aCwgdHJ1ZSwgZ2V0Q2VsbFJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICBtZW1vTWFwLmN1cnJlbnRbYy5pZF0gPSByLndpZHRoO1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXN1bHQgPSBnZXRSYXcoKTtcbiAgICAgICAgbGV0IHRvdGFsV2lkdGggPSAwO1xuICAgICAgICBsZXQgdG90YWxHcm93ID0gMDtcbiAgICAgICAgY29uc3QgZGlzdHJpYnV0ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCBjXSBvZiByZXN1bHQuZW50cmllcygpKSB7XG4gICAgICAgICAgICB0b3RhbFdpZHRoICs9IGMud2lkdGg7XG4gICAgICAgICAgICBpZiAoYy5ncm93ICE9PSB1bmRlZmluZWQgJiYgYy5ncm93ID4gMCkge1xuICAgICAgICAgICAgICAgIHRvdGFsR3JvdyArPSBjLmdyb3c7XG4gICAgICAgICAgICAgICAgZGlzdHJpYnV0ZS5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b3RhbFdpZHRoIDwgY2xpZW50V2lkdGggJiYgZGlzdHJpYnV0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZWFibGUgPSBbLi4ucmVzdWx0XTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gY2xpZW50V2lkdGggLSB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IGV4dHJhO1xuICAgICAgICAgICAgZm9yIChsZXQgZGkgPSAwOyBkaSA8IGRpc3RyaWJ1dGUubGVuZ3RoOyBkaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGRpc3RyaWJ1dGVbZGldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdlaWdodGVkID0gKHJlc3VsdFtpXS5ncm93ID8/IDApIC8gdG90YWxHcm93O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvQWRkID0gZGkgPT09IGRpc3RyaWJ1dGUubGVuZ3RoIC0gMSA/IHJlbWFpbmluZyA6IE1hdGgubWluKHJlbWFpbmluZywgTWF0aC5mbG9vcihleHRyYSAqIHdlaWdodGVkKSk7XG4gICAgICAgICAgICAgICAgd3JpdGVhYmxlW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHRbaV0sXG4gICAgICAgICAgICAgICAgICAgIGdyb3dPZmZzZXQ6IHRvQWRkLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcmVzdWx0W2ldLndpZHRoICsgdG9BZGQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgLT0gdG9BZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSB3cml0ZWFibGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpemVkQ29sdW1uczogcmVzdWx0LFxuICAgICAgICAgICAgbm9uR3Jvd1dpZHRoOiB0b3RhbFdpZHRoLFxuICAgICAgICB9O1xuICAgIH0sIFtjbGllbnRXaWR0aCwgY29sdW1ucywgY3R4LCBzZWxlY3RlZERhdGEsIHRoZW1lLCBtaW5Db2x1bW5XaWR0aCwgbWF4Q29sdW1uV2lkdGgsIGdldENlbGxSZW5kZXJlcl0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWNvbHVtbi1zaXplci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-column-sizer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-rem-adjuster.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-rem-adjuster.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useRemAdjuster: () => (/* binding */ useRemAdjuster)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _common_styles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/styles.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js\");\n\n\nfunction useRemAdjuster({ rowHeight: rowHeightIn, headerHeight: headerHeightIn, groupHeaderHeight: groupHeaderHeightIn, theme: themeIn, overscrollX: overscrollXIn, overscrollY: overscrollYIn, scaleToRem, remSize, }) {\n    const [rowHeight, headerHeight, groupHeaderHeight, theme, overscrollX, overscrollY] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (!scaleToRem || remSize === 16)\n            return [rowHeightIn, headerHeightIn, groupHeaderHeightIn, themeIn, overscrollXIn, overscrollYIn];\n        const scaler = remSize / 16;\n        const rh = rowHeightIn;\n        const bt = (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_1__.getDataEditorTheme)();\n        return [\n            typeof rh === \"number\" ? rh * scaler : (n) => Math.ceil(rh(n) * scaler),\n            Math.ceil(headerHeightIn * scaler),\n            Math.ceil(groupHeaderHeightIn * scaler),\n            {\n                ...themeIn,\n                headerIconSize: (themeIn?.headerIconSize ?? bt.headerIconSize) * scaler,\n                cellHorizontalPadding: (themeIn?.cellHorizontalPadding ?? bt.cellHorizontalPadding) * scaler,\n                cellVerticalPadding: (themeIn?.cellVerticalPadding ?? bt.cellVerticalPadding) * scaler,\n            },\n            Math.ceil((overscrollXIn ?? 0) * scaler),\n            Math.ceil((overscrollYIn ?? 0) * scaler),\n        ];\n    }, [groupHeaderHeightIn, headerHeightIn, overscrollXIn, overscrollYIn, remSize, rowHeightIn, scaleToRem, themeIn]);\n    return { rowHeight, headerHeight, groupHeaderHeight, theme, overscrollX, overscrollY };\n}\n//# sourceMappingURL=use-rem-adjuster.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vZGF0YS1lZGl0b3IvdXNlLXJlbS1hZGp1c3Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEI7QUFDK0I7QUFDbEQsMEJBQTBCLDRMQUE0TDtBQUM3TiwwRkFBMEYsMENBQWE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUVBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9kYXRhLWVkaXRvci91c2UtcmVtLWFkanVzdGVyLmpzPzU0NjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZ2V0RGF0YUVkaXRvclRoZW1lIH0gZnJvbSBcIi4uL2NvbW1vbi9zdHlsZXMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZW1BZGp1c3Rlcih7IHJvd0hlaWdodDogcm93SGVpZ2h0SW4sIGhlYWRlckhlaWdodDogaGVhZGVySGVpZ2h0SW4sIGdyb3VwSGVhZGVySGVpZ2h0OiBncm91cEhlYWRlckhlaWdodEluLCB0aGVtZTogdGhlbWVJbiwgb3ZlcnNjcm9sbFg6IG92ZXJzY3JvbGxYSW4sIG92ZXJzY3JvbGxZOiBvdmVyc2Nyb2xsWUluLCBzY2FsZVRvUmVtLCByZW1TaXplLCB9KSB7XG4gICAgY29uc3QgW3Jvd0hlaWdodCwgaGVhZGVySGVpZ2h0LCBncm91cEhlYWRlckhlaWdodCwgdGhlbWUsIG92ZXJzY3JvbGxYLCBvdmVyc2Nyb2xsWV0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFzY2FsZVRvUmVtIHx8IHJlbVNpemUgPT09IDE2KVxuICAgICAgICAgICAgcmV0dXJuIFtyb3dIZWlnaHRJbiwgaGVhZGVySGVpZ2h0SW4sIGdyb3VwSGVhZGVySGVpZ2h0SW4sIHRoZW1lSW4sIG92ZXJzY3JvbGxYSW4sIG92ZXJzY3JvbGxZSW5dO1xuICAgICAgICBjb25zdCBzY2FsZXIgPSByZW1TaXplIC8gMTY7XG4gICAgICAgIGNvbnN0IHJoID0gcm93SGVpZ2h0SW47XG4gICAgICAgIGNvbnN0IGJ0ID0gZ2V0RGF0YUVkaXRvclRoZW1lKCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlb2YgcmggPT09IFwibnVtYmVyXCIgPyByaCAqIHNjYWxlciA6IChuKSA9PiBNYXRoLmNlaWwocmgobikgKiBzY2FsZXIpLFxuICAgICAgICAgICAgTWF0aC5jZWlsKGhlYWRlckhlaWdodEluICogc2NhbGVyKSxcbiAgICAgICAgICAgIE1hdGguY2VpbChncm91cEhlYWRlckhlaWdodEluICogc2NhbGVyKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi50aGVtZUluLFxuICAgICAgICAgICAgICAgIGhlYWRlckljb25TaXplOiAodGhlbWVJbj8uaGVhZGVySWNvblNpemUgPz8gYnQuaGVhZGVySWNvblNpemUpICogc2NhbGVyLFxuICAgICAgICAgICAgICAgIGNlbGxIb3Jpem9udGFsUGFkZGluZzogKHRoZW1lSW4/LmNlbGxIb3Jpem9udGFsUGFkZGluZyA/PyBidC5jZWxsSG9yaXpvbnRhbFBhZGRpbmcpICogc2NhbGVyLFxuICAgICAgICAgICAgICAgIGNlbGxWZXJ0aWNhbFBhZGRpbmc6ICh0aGVtZUluPy5jZWxsVmVydGljYWxQYWRkaW5nID8/IGJ0LmNlbGxWZXJ0aWNhbFBhZGRpbmcpICogc2NhbGVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE1hdGguY2VpbCgob3ZlcnNjcm9sbFhJbiA/PyAwKSAqIHNjYWxlciksXG4gICAgICAgICAgICBNYXRoLmNlaWwoKG92ZXJzY3JvbGxZSW4gPz8gMCkgKiBzY2FsZXIpLFxuICAgICAgICBdO1xuICAgIH0sIFtncm91cEhlYWRlckhlaWdodEluLCBoZWFkZXJIZWlnaHRJbiwgb3ZlcnNjcm9sbFhJbiwgb3ZlcnNjcm9sbFlJbiwgcmVtU2l6ZSwgcm93SGVpZ2h0SW4sIHNjYWxlVG9SZW0sIHRoZW1lSW5dKTtcbiAgICByZXR1cm4geyByb3dIZWlnaHQsIGhlYWRlckhlaWdodCwgZ3JvdXBIZWFkZXJIZWlnaHQsIHRoZW1lLCBvdmVyc2Nyb2xsWCwgb3ZlcnNjcm9sbFkgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1yZW0tYWRqdXN0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/data-editor/use-rem-adjuster.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/click-outside-container/click-outside-container.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/click-outside-container/click-outside-container.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ClickOutsideContainer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nclass ClickOutsideContainer extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    wrapperRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    componentDidMount() {\n        document.addEventListener(\"touchend\", this.clickOutside, true);\n        document.addEventListener(\"mousedown\", this.clickOutside, true);\n        document.addEventListener(\"contextmenu\", this.clickOutside, true);\n    }\n    componentWillUnmount() {\n        document.removeEventListener(\"touchend\", this.clickOutside, true);\n        document.removeEventListener(\"mousedown\", this.clickOutside, true);\n        document.removeEventListener(\"contextmenu\", this.clickOutside, true);\n    }\n    clickOutside = (event) => {\n        if (this.props.isOutsideClick && !this.props.isOutsideClick(event)) {\n            return;\n        }\n        if (this.wrapperRef.current !== null && !this.wrapperRef.current.contains(event.target)) {\n            let node = event.target;\n            while (node !== null) {\n                if (node.classList.contains(\"click-outside-ignore\")) {\n                    return;\n                }\n                node = node.parentElement;\n            }\n            this.props.onClickOutside();\n        }\n    };\n    render() {\n        const { onClickOutside, isOutsideClick, ...rest } = this.props;\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ...rest, ref: this.wrapperRef }, this.props.children));\n    }\n}\n//# sourceMappingURL=click-outside-container.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvY2xpY2stb3V0c2lkZS1jb250YWluZXIvY2xpY2stb3V0c2lkZS1jb250YWluZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDaEIsb0NBQW9DLGdEQUFtQjtBQUN0RSxpQkFBaUIsNENBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBMEM7QUFDMUQsZ0JBQWdCLGdEQUFtQixVQUFVLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9jbGljay1vdXRzaWRlLWNvbnRhaW5lci9jbGljay1vdXRzaWRlLWNvbnRhaW5lci5qcz9hNThmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xpY2tPdXRzaWRlQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gICAgd3JhcHBlclJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5jbGlja091dHNpZGUsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuY2xpY2tPdXRzaWRlLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIHRoaXMuY2xpY2tPdXRzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmNsaWNrT3V0c2lkZSwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5jbGlja091dHNpZGUsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgdGhpcy5jbGlja091dHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBjbGlja091dHNpZGUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaXNPdXRzaWRlQ2xpY2sgJiYgIXRoaXMucHJvcHMuaXNPdXRzaWRlQ2xpY2soZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud3JhcHBlclJlZi5jdXJyZW50ICE9PSBudWxsICYmICF0aGlzLndyYXBwZXJSZWYuY3VycmVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY2xpY2stb3V0c2lkZS1pZ25vcmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrT3V0c2lkZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgb25DbGlja091dHNpZGUsIGlzT3V0c2lkZUNsaWNrLCAuLi5yZXN0IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyAuLi5yZXN0LCByZWY6IHRoaXMud3JhcHBlclJlZiB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpY2stb3V0c2lkZS1jb250YWluZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/click-outside-container/click-outside-container.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-editor-container/data-grid-container.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-editor-container/data-grid-container.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataEditorContainer: () => (/* binding */ DataEditorContainer)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\nfunction toCss(x) {\n  if (typeof x === \"string\") return x;\n  return `${x}px`;\n}\nconst _exp = /*#__PURE__*/() => p => p.innerWidth;\nconst _exp2 = /*#__PURE__*/() => p => p.innerHeight;\nconst Wrapper = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_1__.styled)('div')({\n  name: \"Wrapper\",\n  class: \"gdg-wmyidgi\",\n  propsAsIs: false,\n  vars: {\n    \"wmyidgi-0\": [_exp()],\n    \"wmyidgi-1\": [_exp2()]\n  }\n});\nconst DataEditorContainer = p => {\n  const {\n    inWidth,\n    inHeight,\n    children,\n    ...rest\n  } = p;\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Wrapper, {\n    innerHeight: toCss(inHeight),\n    innerWidth: toCss(inWidth),\n    ...rest\n  }, children);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1lZGl0b3ItY29udGFpbmVyL2RhdGEtZ3JpZC1jb250YWluZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdDO0FBQ1Q7QUFDL0I7QUFDQTtBQUNBLFlBQVksRUFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osU0FBUyxnREFBbUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1lZGl0b3ItY29udGFpbmVyL2RhdGEtZ3JpZC1jb250YWluZXIuanM/NTcwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdG9Dc3MoeCkge1xuICBpZiAodHlwZW9mIHggPT09IFwic3RyaW5nXCIpIHJldHVybiB4O1xuICByZXR1cm4gYCR7eH1weGA7XG59XG5jb25zdCBfZXhwID0gLyojX19QVVJFX18qLygpID0+IHAgPT4gcC5pbm5lcldpZHRoO1xuY29uc3QgX2V4cDIgPSAvKiNfX1BVUkVfXyovKCkgPT4gcCA9PiBwLmlubmVySGVpZ2h0O1xuY29uc3QgV3JhcHBlciA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicpKHtcbiAgbmFtZTogXCJXcmFwcGVyXCIsXG4gIGNsYXNzOiBcImdkZy13bXlpZGdpXCIsXG4gIHByb3BzQXNJczogZmFsc2UsXG4gIHZhcnM6IHtcbiAgICBcIndteWlkZ2ktMFwiOiBbX2V4cCgpXSxcbiAgICBcIndteWlkZ2ktMVwiOiBbX2V4cDIoKV1cbiAgfVxufSk7XG5leHBvcnQgY29uc3QgRGF0YUVkaXRvckNvbnRhaW5lciA9IHAgPT4ge1xuICBjb25zdCB7XG4gICAgaW5XaWR0aCxcbiAgICBpbkhlaWdodCxcbiAgICBjaGlsZHJlbixcbiAgICAuLi5yZXN0XG4gIH0gPSBwO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChXcmFwcGVyLCB7XG4gICAgaW5uZXJIZWlnaHQ6IHRvQ3NzKGluSGVpZ2h0KSxcbiAgICBpbm5lcldpZHRoOiB0b0NzcyhpbldpZHRoKSxcbiAgICAuLi5yZXN0XG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-editor-container/data-grid-container.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-dnd/data-grid-dnd.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-dnd/data-grid-dnd.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var lodash_clamp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/clamp.js */ \"(ssr)/./node_modules/lodash/clamp.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _data_grid_data_grid_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data-grid/data-grid.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid.js\");\n/* eslint-disable unicorn/consistent-destructuring */\n\n\n\n// Dear Past Jason,\n// Wtf does this function do? If you remember in the future come back and add a comment\n// -- Future-Past Jason\nfunction offsetColumnSize(column, width, min, max) {\n    return lodash_clamp_js__WEBPACK_IMPORTED_MODULE_0__(Math.round(width - (column.growOffset ?? 0)), Math.ceil(min), Math.floor(max));\n}\nconst DataGridDnd = p => {\n    const [resizeColStartX, setResizeColStartX] = react__WEBPACK_IMPORTED_MODULE_1__.useState();\n    const [resizeCol, setResizeCol] = react__WEBPACK_IMPORTED_MODULE_1__.useState();\n    const [dragCol, setDragCol] = react__WEBPACK_IMPORTED_MODULE_1__.useState();\n    const [dropCol, setDropCol] = react__WEBPACK_IMPORTED_MODULE_1__.useState();\n    const [dragColActive, setDragColActive] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [dragStartX, setDragStartX] = react__WEBPACK_IMPORTED_MODULE_1__.useState();\n    const [dragRow, setDragRow] = react__WEBPACK_IMPORTED_MODULE_1__.useState();\n    const [dropRow, setDropRow] = react__WEBPACK_IMPORTED_MODULE_1__.useState();\n    const [dragRowActive, setDragRowActive] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [dragStartY, setDragStartY] = react__WEBPACK_IMPORTED_MODULE_1__.useState();\n    const { onHeaderMenuClick, getCellContent, onColumnMoved, onColumnResize, onColumnResizeStart, onColumnResizeEnd, gridRef, maxColumnWidth, minColumnWidth, onRowMoved, lockColumns, onColumnProposeMove, onMouseDown, onMouseUp, onItemHovered, onDragStart, canvasRef, } = p;\n    const canResize = (onColumnResize ?? onColumnResizeEnd ?? onColumnResizeStart) !== undefined;\n    const { columns, selection } = p;\n    const selectedColumns = selection.columns;\n    const onItemHoveredImpl = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((args) => {\n        const [col, row] = args.location;\n        if (dragCol !== undefined && dropCol !== col && col >= lockColumns) {\n            setDragColActive(true);\n            setDropCol(col);\n        }\n        else if (dragRow !== undefined && row !== undefined) {\n            setDragRowActive(true);\n            setDropRow(Math.max(0, row));\n            // Don't emit onItemHovered if resizing or reordering a column or row.\n        }\n        else if (resizeCol === undefined && !dragColActive && !dragRowActive) {\n            onItemHovered?.(args);\n        }\n    }, [dragCol, dragRow, dropCol, onItemHovered, lockColumns, resizeCol, dragColActive, dragRowActive]);\n    const canDragCol = onColumnMoved !== undefined;\n    const onMouseDownImpl = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((args) => {\n        if (args.button === 0) {\n            const [col, row] = args.location;\n            if (args.kind === \"out-of-bounds\" && args.isEdge && canResize) {\n                const bounds = gridRef?.current?.getBounds(columns.length - 1, -1);\n                if (bounds !== undefined) {\n                    setResizeColStartX(bounds.x);\n                    setResizeCol(columns.length - 1);\n                }\n            }\n            else if (args.kind === \"header\" && col >= lockColumns) {\n                const canvas = canvasRef?.current;\n                if (args.isEdge && canResize && canvas) {\n                    setResizeColStartX(args.bounds.x);\n                    setResizeCol(col);\n                    const rect = canvas.getBoundingClientRect();\n                    const scale = rect.width / canvas.offsetWidth;\n                    const width = args.bounds.width / scale;\n                    onColumnResizeStart?.(columns[col], width, col, width + (columns[col].growOffset ?? 0));\n                }\n                else if (args.kind === \"header\" && canDragCol) {\n                    setDragStartX(args.bounds.x);\n                    setDragCol(col);\n                }\n            }\n            else if (args.kind === \"cell\" &&\n                lockColumns > 0 &&\n                col === 0 &&\n                row !== undefined &&\n                onRowMoved !== undefined) {\n                setDragStartY(args.bounds.y);\n                setDragRow(row);\n            }\n        }\n        onMouseDown?.(args);\n    }, [onMouseDown, canResize, lockColumns, onRowMoved, gridRef, columns, canDragCol, onColumnResizeStart, canvasRef]);\n    const onHeaderMenuClickMangled = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((col, screenPosition) => {\n        if (dragColActive || dragRowActive)\n            return;\n        onHeaderMenuClick?.(col, screenPosition);\n    }, [dragColActive, dragRowActive, onHeaderMenuClick]);\n    const lastResizeWidthRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(-1);\n    const clearAll = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(() => {\n        lastResizeWidthRef.current = -1;\n        setDragRow(undefined);\n        setDropRow(undefined);\n        setDragStartY(undefined);\n        setDragRowActive(false);\n        setDragCol(undefined);\n        setDropCol(undefined);\n        setDragStartX(undefined);\n        setDragColActive(false);\n        setResizeCol(undefined);\n        setResizeColStartX(undefined);\n    }, []);\n    const onMouseUpImpl = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((args, isOutside) => {\n        if (args.button === 0) {\n            if (resizeCol !== undefined) {\n                // if the column is in selection, the selection may contain extra cols, so lets just re-send the last\n                // resize event to all those columns.\n                if (selectedColumns?.hasIndex(resizeCol) === true) {\n                    for (const c of selectedColumns) {\n                        if (c === resizeCol)\n                            continue;\n                        const col = columns[c];\n                        const newSize = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);\n                        onColumnResize?.(col, newSize, c, newSize + (col.growOffset ?? 0));\n                    }\n                }\n                const ns = offsetColumnSize(columns[resizeCol], lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);\n                onColumnResizeEnd?.(columns[resizeCol], ns, resizeCol, ns + (columns[resizeCol].growOffset ?? 0));\n                if (selectedColumns.hasIndex(resizeCol)) {\n                    for (const c of selectedColumns) {\n                        if (c === resizeCol)\n                            continue;\n                        const col = columns[c];\n                        const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);\n                        onColumnResizeEnd?.(col, s, c, s + (col.growOffset ?? 0));\n                    }\n                }\n            }\n            clearAll();\n            if (dragCol !== undefined && dropCol !== undefined) {\n                onColumnMoved?.(dragCol, dropCol);\n            }\n            if (dragRow !== undefined && dropRow !== undefined) {\n                onRowMoved?.(dragRow, dropRow);\n            }\n        }\n        onMouseUp?.(args, isOutside);\n    }, [\n        onMouseUp,\n        resizeCol,\n        dragCol,\n        dropCol,\n        dragRow,\n        dropRow,\n        selectedColumns,\n        onColumnResizeEnd,\n        columns,\n        minColumnWidth,\n        maxColumnWidth,\n        onColumnResize,\n        onColumnMoved,\n        onRowMoved,\n        clearAll,\n    ]);\n    const dragOffset = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n        if (dragCol === undefined || dropCol === undefined)\n            return undefined;\n        if (dragCol === dropCol)\n            return undefined;\n        if (onColumnProposeMove?.(dragCol, dropCol) === false)\n            return undefined;\n        return {\n            src: dragCol,\n            dest: dropCol,\n        };\n    }, [dragCol, dropCol, onColumnProposeMove]);\n    const onMouseMove = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((event) => {\n        const canvas = canvasRef?.current;\n        if (dragCol !== undefined && dragStartX !== undefined) {\n            const diff = Math.abs(event.clientX - dragStartX);\n            if (diff > 20) {\n                setDragColActive(true);\n            }\n        }\n        else if (dragRow !== undefined && dragStartY !== undefined) {\n            const diff = Math.abs(event.clientY - dragStartY);\n            if (diff > 20) {\n                setDragRowActive(true);\n            }\n        }\n        else if (resizeCol !== undefined && resizeColStartX !== undefined && canvas) {\n            const rect = canvas.getBoundingClientRect();\n            const scale = rect.width / canvas.offsetWidth;\n            const newWidth = (event.clientX - resizeColStartX) / scale;\n            const column = columns[resizeCol];\n            const ns = offsetColumnSize(column, newWidth, minColumnWidth, maxColumnWidth);\n            onColumnResize?.(column, ns, resizeCol, ns + (column.growOffset ?? 0));\n            lastResizeWidthRef.current = newWidth;\n            if (selectedColumns?.first() === resizeCol) {\n                for (const c of selectedColumns) {\n                    if (c === resizeCol)\n                        continue;\n                    const col = columns[c];\n                    const s = offsetColumnSize(col, lastResizeWidthRef.current, minColumnWidth, maxColumnWidth);\n                    onColumnResize?.(col, s, c, s + (col.growOffset ?? 0));\n                }\n            }\n        }\n    }, [\n        dragCol,\n        dragStartX,\n        dragRow,\n        dragStartY,\n        resizeCol,\n        resizeColStartX,\n        columns,\n        minColumnWidth,\n        maxColumnWidth,\n        onColumnResize,\n        selectedColumns,\n        canvasRef,\n    ]);\n    const getMangledCellContent = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((cell, forceStrict) => {\n        if (dragRow === undefined || dropRow === undefined)\n            return getCellContent(cell, forceStrict);\n        // eslint-disable-next-line prefer-const\n        let [col, row] = cell;\n        if (row === dropRow) {\n            row = dragRow;\n        }\n        else {\n            if (row > dropRow)\n                row -= 1;\n            if (row >= dragRow)\n                row += 1;\n        }\n        return getCellContent([col, row], forceStrict);\n    }, [dragRow, dropRow, getCellContent]);\n    const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(args => {\n        onDragStart?.(args);\n        if (!args.defaultPrevented()) {\n            clearAll();\n        }\n    }, [clearAll, onDragStart]);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(_data_grid_data_grid_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], { accessibilityHeight: p.accessibilityHeight, canvasRef: p.canvasRef, cellXOffset: p.cellXOffset, cellYOffset: p.cellYOffset, columns: p.columns, disabledRows: p.disabledRows, drawFocusRing: p.drawFocusRing, drawHeader: p.drawHeader, drawCell: p.drawCell, enableGroups: p.enableGroups, eventTargetRef: p.eventTargetRef, experimental: p.experimental, fillHandle: p.fillHandle, firstColAccessible: p.firstColAccessible, fixedShadowX: p.fixedShadowX, fixedShadowY: p.fixedShadowY, freezeColumns: p.freezeColumns, getCellRenderer: p.getCellRenderer, getGroupDetails: p.getGroupDetails, getRowThemeOverride: p.getRowThemeOverride, groupHeaderHeight: p.groupHeaderHeight, headerHeight: p.headerHeight, headerIcons: p.headerIcons, height: p.height, highlightRegions: p.highlightRegions, imageWindowLoader: p.imageWindowLoader, resizeColumn: resizeCol, isDraggable: p.isDraggable, isFilling: p.isFilling, isFocused: p.isFocused, onCanvasBlur: p.onCanvasBlur, onCanvasFocused: p.onCanvasFocused, onCellFocused: p.onCellFocused, onContextMenu: p.onContextMenu, onDragEnd: p.onDragEnd, onDragLeave: p.onDragLeave, onDragOverCell: p.onDragOverCell, onDrop: p.onDrop, onKeyDown: p.onKeyDown, onKeyUp: p.onKeyUp, onMouseMove: p.onMouseMove, prelightCells: p.prelightCells, rowHeight: p.rowHeight, rows: p.rows, selection: p.selection, smoothScrollX: p.smoothScrollX, smoothScrollY: p.smoothScrollY, theme: p.theme, freezeTrailingRows: p.freezeTrailingRows, hasAppendRow: p.hasAppendRow, translateX: p.translateX, translateY: p.translateY, verticalBorder: p.verticalBorder, width: p.width, getCellContent: getMangledCellContent, isResizing: resizeCol !== undefined, onHeaderMenuClick: onHeaderMenuClickMangled, isDragging: dragColActive, onItemHovered: onItemHoveredImpl, onDragStart: onDragStartImpl, onMouseDown: onMouseDownImpl, allowResize: canResize, onMouseUp: onMouseUpImpl, dragAndDropState: dragOffset, onMouseMoveRaw: onMouseMove, ref: gridRef }));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataGridDnd);\n//# sourceMappingURL=data-grid-dnd.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLWRuZC9kYXRhLWdyaWQtZG5kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNvQztBQUNMO0FBQ3NCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBSztBQUNoQjtBQUNBO0FBQ0Esa0RBQWtELDJDQUFjO0FBQ2hFLHNDQUFzQywyQ0FBYztBQUNwRCxrQ0FBa0MsMkNBQWM7QUFDaEQsa0NBQWtDLDJDQUFjO0FBQ2hELDhDQUE4QywyQ0FBYztBQUM1RCx3Q0FBd0MsMkNBQWM7QUFDdEQsa0NBQWtDLDJDQUFjO0FBQ2hELGtDQUFrQywyQ0FBYztBQUNoRCw4Q0FBOEMsMkNBQWM7QUFDNUQsd0NBQXdDLDJDQUFjO0FBQ3RELFlBQVksa1FBQWtRO0FBQzlRO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQSw4QkFBOEIsOENBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCLDhDQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsOENBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0IseUNBQVk7QUFDM0MscUJBQXFCLDhDQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQiw4Q0FBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCLDhDQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4Q0FBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsOENBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksZ0RBQW1CLENBQUMsK0RBQVEsSUFBSSxrNURBQWs1RDtBQUM5N0Q7QUFDQSxpRUFBZSxXQUFXLEVBQUM7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQtZG5kL2RhdGEtZ3JpZC1kbmQuanM/NWUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSB1bmljb3JuL2NvbnNpc3RlbnQtZGVzdHJ1Y3R1cmluZyAqL1xuaW1wb3J0IGNsYW1wIGZyb20gXCJsb2Rhc2gvY2xhbXAuanNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IERhdGFHcmlkLCB7fSBmcm9tIFwiLi4vZGF0YS1ncmlkL2RhdGEtZ3JpZC5qc1wiO1xuLy8gRGVhciBQYXN0IEphc29uLFxuLy8gV3RmIGRvZXMgdGhpcyBmdW5jdGlvbiBkbz8gSWYgeW91IHJlbWVtYmVyIGluIHRoZSBmdXR1cmUgY29tZSBiYWNrIGFuZCBhZGQgYSBjb21tZW50XG4vLyAtLSBGdXR1cmUtUGFzdCBKYXNvblxuZnVuY3Rpb24gb2Zmc2V0Q29sdW1uU2l6ZShjb2x1bW4sIHdpZHRoLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBjbGFtcChNYXRoLnJvdW5kKHdpZHRoIC0gKGNvbHVtbi5ncm93T2Zmc2V0ID8/IDApKSwgTWF0aC5jZWlsKG1pbiksIE1hdGguZmxvb3IobWF4KSk7XG59XG5jb25zdCBEYXRhR3JpZERuZCA9IHAgPT4ge1xuICAgIGNvbnN0IFtyZXNpemVDb2xTdGFydFgsIHNldFJlc2l6ZUNvbFN0YXJ0WF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFtyZXNpemVDb2wsIHNldFJlc2l6ZUNvbF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFtkcmFnQ29sLCBzZXREcmFnQ29sXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgY29uc3QgW2Ryb3BDb2wsIHNldERyb3BDb2xdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgICBjb25zdCBbZHJhZ0NvbEFjdGl2ZSwgc2V0RHJhZ0NvbEFjdGl2ZV0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2RyYWdTdGFydFgsIHNldERyYWdTdGFydFhdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgICBjb25zdCBbZHJhZ1Jvdywgc2V0RHJhZ1Jvd10gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFtkcm9wUm93LCBzZXREcm9wUm93XSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgY29uc3QgW2RyYWdSb3dBY3RpdmUsIHNldERyYWdSb3dBY3RpdmVdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtkcmFnU3RhcnRZLCBzZXREcmFnU3RhcnRZXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgY29uc3QgeyBvbkhlYWRlck1lbnVDbGljaywgZ2V0Q2VsbENvbnRlbnQsIG9uQ29sdW1uTW92ZWQsIG9uQ29sdW1uUmVzaXplLCBvbkNvbHVtblJlc2l6ZVN0YXJ0LCBvbkNvbHVtblJlc2l6ZUVuZCwgZ3JpZFJlZiwgbWF4Q29sdW1uV2lkdGgsIG1pbkNvbHVtbldpZHRoLCBvblJvd01vdmVkLCBsb2NrQ29sdW1ucywgb25Db2x1bW5Qcm9wb3NlTW92ZSwgb25Nb3VzZURvd24sIG9uTW91c2VVcCwgb25JdGVtSG92ZXJlZCwgb25EcmFnU3RhcnQsIGNhbnZhc1JlZiwgfSA9IHA7XG4gICAgY29uc3QgY2FuUmVzaXplID0gKG9uQ29sdW1uUmVzaXplID8/IG9uQ29sdW1uUmVzaXplRW5kID8/IG9uQ29sdW1uUmVzaXplU3RhcnQpICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgeyBjb2x1bW5zLCBzZWxlY3Rpb24gfSA9IHA7XG4gICAgY29uc3Qgc2VsZWN0ZWRDb2x1bW5zID0gc2VsZWN0aW9uLmNvbHVtbnM7XG4gICAgY29uc3Qgb25JdGVtSG92ZXJlZEltcGwgPSBSZWFjdC51c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICBjb25zdCBbY29sLCByb3ddID0gYXJncy5sb2NhdGlvbjtcbiAgICAgICAgaWYgKGRyYWdDb2wgIT09IHVuZGVmaW5lZCAmJiBkcm9wQ29sICE9PSBjb2wgJiYgY29sID49IGxvY2tDb2x1bW5zKSB7XG4gICAgICAgICAgICBzZXREcmFnQ29sQWN0aXZlKHRydWUpO1xuICAgICAgICAgICAgc2V0RHJvcENvbChjb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRyYWdSb3cgIT09IHVuZGVmaW5lZCAmJiByb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2V0RHJhZ1Jvd0FjdGl2ZSh0cnVlKTtcbiAgICAgICAgICAgIHNldERyb3BSb3coTWF0aC5tYXgoMCwgcm93KSk7XG4gICAgICAgICAgICAvLyBEb24ndCBlbWl0IG9uSXRlbUhvdmVyZWQgaWYgcmVzaXppbmcgb3IgcmVvcmRlcmluZyBhIGNvbHVtbiBvciByb3cuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzaXplQ29sID09PSB1bmRlZmluZWQgJiYgIWRyYWdDb2xBY3RpdmUgJiYgIWRyYWdSb3dBY3RpdmUpIHtcbiAgICAgICAgICAgIG9uSXRlbUhvdmVyZWQ/LihhcmdzKTtcbiAgICAgICAgfVxuICAgIH0sIFtkcmFnQ29sLCBkcmFnUm93LCBkcm9wQ29sLCBvbkl0ZW1Ib3ZlcmVkLCBsb2NrQ29sdW1ucywgcmVzaXplQ29sLCBkcmFnQ29sQWN0aXZlLCBkcmFnUm93QWN0aXZlXSk7XG4gICAgY29uc3QgY2FuRHJhZ0NvbCA9IG9uQ29sdW1uTW92ZWQgIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbk1vdXNlRG93bkltcGwgPSBSZWFjdC51c2VDYWxsYmFjaygoYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IFtjb2wsIHJvd10gPSBhcmdzLmxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKGFyZ3Mua2luZCA9PT0gXCJvdXQtb2YtYm91bmRzXCIgJiYgYXJncy5pc0VkZ2UgJiYgY2FuUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0gZ3JpZFJlZj8uY3VycmVudD8uZ2V0Qm91bmRzKGNvbHVtbnMubGVuZ3RoIC0gMSwgLTEpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZXNpemVDb2xTdGFydFgoYm91bmRzLngpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSZXNpemVDb2woY29sdW1ucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmdzLmtpbmQgPT09IFwiaGVhZGVyXCIgJiYgY29sID49IGxvY2tDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmPy5jdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmlzRWRnZSAmJiBjYW5SZXNpemUgJiYgY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc2l6ZUNvbFN0YXJ0WChhcmdzLmJvdW5kcy54KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVzaXplQ29sKGNvbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gcmVjdC53aWR0aCAvIGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBhcmdzLmJvdW5kcy53aWR0aCAvIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZVN0YXJ0Py4oY29sdW1uc1tjb2xdLCB3aWR0aCwgY29sLCB3aWR0aCArIChjb2x1bW5zW2NvbF0uZ3Jvd09mZnNldCA/PyAwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3Mua2luZCA9PT0gXCJoZWFkZXJcIiAmJiBjYW5EcmFnQ29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERyYWdTdGFydFgoYXJncy5ib3VuZHMueCk7XG4gICAgICAgICAgICAgICAgICAgIHNldERyYWdDb2woY29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmdzLmtpbmQgPT09IFwiY2VsbFwiICYmXG4gICAgICAgICAgICAgICAgbG9ja0NvbHVtbnMgPiAwICYmXG4gICAgICAgICAgICAgICAgY29sID09PSAwICYmXG4gICAgICAgICAgICAgICAgcm93ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvblJvd01vdmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXREcmFnU3RhcnRZKGFyZ3MuYm91bmRzLnkpO1xuICAgICAgICAgICAgICAgIHNldERyYWdSb3cocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbk1vdXNlRG93bj8uKGFyZ3MpO1xuICAgIH0sIFtvbk1vdXNlRG93biwgY2FuUmVzaXplLCBsb2NrQ29sdW1ucywgb25Sb3dNb3ZlZCwgZ3JpZFJlZiwgY29sdW1ucywgY2FuRHJhZ0NvbCwgb25Db2x1bW5SZXNpemVTdGFydCwgY2FudmFzUmVmXSk7XG4gICAgY29uc3Qgb25IZWFkZXJNZW51Q2xpY2tNYW5nbGVkID0gUmVhY3QudXNlQ2FsbGJhY2soKGNvbCwgc2NyZWVuUG9zaXRpb24pID0+IHtcbiAgICAgICAgaWYgKGRyYWdDb2xBY3RpdmUgfHwgZHJhZ1Jvd0FjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb25IZWFkZXJNZW51Q2xpY2s/Lihjb2wsIHNjcmVlblBvc2l0aW9uKTtcbiAgICB9LCBbZHJhZ0NvbEFjdGl2ZSwgZHJhZ1Jvd0FjdGl2ZSwgb25IZWFkZXJNZW51Q2xpY2tdKTtcbiAgICBjb25zdCBsYXN0UmVzaXplV2lkdGhSZWYgPSBSZWFjdC51c2VSZWYoLTEpO1xuICAgIGNvbnN0IGNsZWFyQWxsID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBsYXN0UmVzaXplV2lkdGhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICBzZXREcmFnUm93KHVuZGVmaW5lZCk7XG4gICAgICAgIHNldERyb3BSb3codW5kZWZpbmVkKTtcbiAgICAgICAgc2V0RHJhZ1N0YXJ0WSh1bmRlZmluZWQpO1xuICAgICAgICBzZXREcmFnUm93QWN0aXZlKGZhbHNlKTtcbiAgICAgICAgc2V0RHJhZ0NvbCh1bmRlZmluZWQpO1xuICAgICAgICBzZXREcm9wQ29sKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldERyYWdTdGFydFgodW5kZWZpbmVkKTtcbiAgICAgICAgc2V0RHJhZ0NvbEFjdGl2ZShmYWxzZSk7XG4gICAgICAgIHNldFJlc2l6ZUNvbCh1bmRlZmluZWQpO1xuICAgICAgICBzZXRSZXNpemVDb2xTdGFydFgodW5kZWZpbmVkKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgb25Nb3VzZVVwSW1wbCA9IFJlYWN0LnVzZUNhbGxiYWNrKChhcmdzLCBpc091dHNpZGUpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocmVzaXplQ29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY29sdW1uIGlzIGluIHNlbGVjdGlvbiwgdGhlIHNlbGVjdGlvbiBtYXkgY29udGFpbiBleHRyYSBjb2xzLCBzbyBsZXRzIGp1c3QgcmUtc2VuZCB0aGUgbGFzdFxuICAgICAgICAgICAgICAgIC8vIHJlc2l6ZSBldmVudCB0byBhbGwgdGhvc2UgY29sdW1ucy5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRDb2x1bW5zPy5oYXNJbmRleChyZXNpemVDb2wpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBzZWxlY3RlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSByZXNpemVDb2wpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBjb2x1bW5zW2NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2l6ZSA9IG9mZnNldENvbHVtblNpemUoY29sLCBsYXN0UmVzaXplV2lkdGhSZWYuY3VycmVudCwgbWluQ29sdW1uV2lkdGgsIG1heENvbHVtbldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPy4oY29sLCBuZXdTaXplLCBjLCBuZXdTaXplICsgKGNvbC5ncm93T2Zmc2V0ID8/IDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBucyA9IG9mZnNldENvbHVtblNpemUoY29sdW1uc1tyZXNpemVDb2xdLCBsYXN0UmVzaXplV2lkdGhSZWYuY3VycmVudCwgbWluQ29sdW1uV2lkdGgsIG1heENvbHVtbldpZHRoKTtcbiAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZUVuZD8uKGNvbHVtbnNbcmVzaXplQ29sXSwgbnMsIHJlc2l6ZUNvbCwgbnMgKyAoY29sdW1uc1tyZXNpemVDb2xdLmdyb3dPZmZzZXQgPz8gMCkpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZENvbHVtbnMuaGFzSW5kZXgocmVzaXplQ29sKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc2VsZWN0ZWRDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gcmVzaXplQ29sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gY29sdW1uc1tjXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBvZmZzZXRDb2x1bW5TaXplKGNvbCwgbGFzdFJlc2l6ZVdpZHRoUmVmLmN1cnJlbnQsIG1pbkNvbHVtbldpZHRoLCBtYXhDb2x1bW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbHVtblJlc2l6ZUVuZD8uKGNvbCwgcywgYywgcyArIChjb2wuZ3Jvd09mZnNldCA/PyAwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhckFsbCgpO1xuICAgICAgICAgICAgaWYgKGRyYWdDb2wgIT09IHVuZGVmaW5lZCAmJiBkcm9wQ29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvbkNvbHVtbk1vdmVkPy4oZHJhZ0NvbCwgZHJvcENvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ1JvdyAhPT0gdW5kZWZpbmVkICYmIGRyb3BSb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9uUm93TW92ZWQ/LihkcmFnUm93LCBkcm9wUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbk1vdXNlVXA/LihhcmdzLCBpc091dHNpZGUpO1xuICAgIH0sIFtcbiAgICAgICAgb25Nb3VzZVVwLFxuICAgICAgICByZXNpemVDb2wsXG4gICAgICAgIGRyYWdDb2wsXG4gICAgICAgIGRyb3BDb2wsXG4gICAgICAgIGRyYWdSb3csXG4gICAgICAgIGRyb3BSb3csXG4gICAgICAgIHNlbGVjdGVkQ29sdW1ucyxcbiAgICAgICAgb25Db2x1bW5SZXNpemVFbmQsXG4gICAgICAgIGNvbHVtbnMsXG4gICAgICAgIG1pbkNvbHVtbldpZHRoLFxuICAgICAgICBtYXhDb2x1bW5XaWR0aCxcbiAgICAgICAgb25Db2x1bW5SZXNpemUsXG4gICAgICAgIG9uQ29sdW1uTW92ZWQsXG4gICAgICAgIG9uUm93TW92ZWQsXG4gICAgICAgIGNsZWFyQWxsLFxuICAgIF0pO1xuICAgIGNvbnN0IGRyYWdPZmZzZXQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGRyYWdDb2wgPT09IHVuZGVmaW5lZCB8fCBkcm9wQ29sID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZHJhZ0NvbCA9PT0gZHJvcENvbClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChvbkNvbHVtblByb3Bvc2VNb3ZlPy4oZHJhZ0NvbCwgZHJvcENvbCkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNyYzogZHJhZ0NvbCxcbiAgICAgICAgICAgIGRlc3Q6IGRyb3BDb2wsXG4gICAgICAgIH07XG4gICAgfSwgW2RyYWdDb2wsIGRyb3BDb2wsIG9uQ29sdW1uUHJvcG9zZU1vdmVdKTtcbiAgICBjb25zdCBvbk1vdXNlTW92ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWY/LmN1cnJlbnQ7XG4gICAgICAgIGlmIChkcmFnQ29sICE9PSB1bmRlZmluZWQgJiYgZHJhZ1N0YXJ0WCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMoZXZlbnQuY2xpZW50WCAtIGRyYWdTdGFydFgpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPiAyMCkge1xuICAgICAgICAgICAgICAgIHNldERyYWdDb2xBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHJhZ1JvdyAhPT0gdW5kZWZpbmVkICYmIGRyYWdTdGFydFkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKGV2ZW50LmNsaWVudFkgLSBkcmFnU3RhcnRZKTtcbiAgICAgICAgICAgIGlmIChkaWZmID4gMjApIHtcbiAgICAgICAgICAgICAgICBzZXREcmFnUm93QWN0aXZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc2l6ZUNvbCAhPT0gdW5kZWZpbmVkICYmIHJlc2l6ZUNvbFN0YXJ0WCAhPT0gdW5kZWZpbmVkICYmIGNhbnZhcykge1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gcmVjdC53aWR0aCAvIGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRoID0gKGV2ZW50LmNsaWVudFggLSByZXNpemVDb2xTdGFydFgpIC8gc2NhbGU7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zW3Jlc2l6ZUNvbF07XG4gICAgICAgICAgICBjb25zdCBucyA9IG9mZnNldENvbHVtblNpemUoY29sdW1uLCBuZXdXaWR0aCwgbWluQ29sdW1uV2lkdGgsIG1heENvbHVtbldpZHRoKTtcbiAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPy4oY29sdW1uLCBucywgcmVzaXplQ29sLCBucyArIChjb2x1bW4uZ3Jvd09mZnNldCA/PyAwKSk7XG4gICAgICAgICAgICBsYXN0UmVzaXplV2lkdGhSZWYuY3VycmVudCA9IG5ld1dpZHRoO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ29sdW1ucz8uZmlyc3QoKSA9PT0gcmVzaXplQ29sKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIHNlbGVjdGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gcmVzaXplQ29sKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IGNvbHVtbnNbY107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBvZmZzZXRDb2x1bW5TaXplKGNvbCwgbGFzdFJlc2l6ZVdpZHRoUmVmLmN1cnJlbnQsIG1pbkNvbHVtbldpZHRoLCBtYXhDb2x1bW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29sdW1uUmVzaXplPy4oY29sLCBzLCBjLCBzICsgKGNvbC5ncm93T2Zmc2V0ID8/IDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGRyYWdDb2wsXG4gICAgICAgIGRyYWdTdGFydFgsXG4gICAgICAgIGRyYWdSb3csXG4gICAgICAgIGRyYWdTdGFydFksXG4gICAgICAgIHJlc2l6ZUNvbCxcbiAgICAgICAgcmVzaXplQ29sU3RhcnRYLFxuICAgICAgICBjb2x1bW5zLFxuICAgICAgICBtaW5Db2x1bW5XaWR0aCxcbiAgICAgICAgbWF4Q29sdW1uV2lkdGgsXG4gICAgICAgIG9uQ29sdW1uUmVzaXplLFxuICAgICAgICBzZWxlY3RlZENvbHVtbnMsXG4gICAgICAgIGNhbnZhc1JlZixcbiAgICBdKTtcbiAgICBjb25zdCBnZXRNYW5nbGVkQ2VsbENvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjaygoY2VsbCwgZm9yY2VTdHJpY3QpID0+IHtcbiAgICAgICAgaWYgKGRyYWdSb3cgPT09IHVuZGVmaW5lZCB8fCBkcm9wUm93ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2VsbENvbnRlbnQoY2VsbCwgZm9yY2VTdHJpY3QpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgICAgIGxldCBbY29sLCByb3ddID0gY2VsbDtcbiAgICAgICAgaWYgKHJvdyA9PT0gZHJvcFJvdykge1xuICAgICAgICAgICAgcm93ID0gZHJhZ1JvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyb3cgPiBkcm9wUm93KVxuICAgICAgICAgICAgICAgIHJvdyAtPSAxO1xuICAgICAgICAgICAgaWYgKHJvdyA+PSBkcmFnUm93KVxuICAgICAgICAgICAgICAgIHJvdyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRDZWxsQ29udGVudChbY29sLCByb3ddLCBmb3JjZVN0cmljdCk7XG4gICAgfSwgW2RyYWdSb3csIGRyb3BSb3csIGdldENlbGxDb250ZW50XSk7XG4gICAgY29uc3Qgb25EcmFnU3RhcnRJbXBsID0gUmVhY3QudXNlQ2FsbGJhY2soYXJncyA9PiB7XG4gICAgICAgIG9uRHJhZ1N0YXJ0Py4oYXJncyk7XG4gICAgICAgIGlmICghYXJncy5kZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgIGNsZWFyQWxsKCk7XG4gICAgICAgIH1cbiAgICB9LCBbY2xlYXJBbGwsIG9uRHJhZ1N0YXJ0XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KERhdGFHcmlkLCB7IGFjY2Vzc2liaWxpdHlIZWlnaHQ6IHAuYWNjZXNzaWJpbGl0eUhlaWdodCwgY2FudmFzUmVmOiBwLmNhbnZhc1JlZiwgY2VsbFhPZmZzZXQ6IHAuY2VsbFhPZmZzZXQsIGNlbGxZT2Zmc2V0OiBwLmNlbGxZT2Zmc2V0LCBjb2x1bW5zOiBwLmNvbHVtbnMsIGRpc2FibGVkUm93czogcC5kaXNhYmxlZFJvd3MsIGRyYXdGb2N1c1Jpbmc6IHAuZHJhd0ZvY3VzUmluZywgZHJhd0hlYWRlcjogcC5kcmF3SGVhZGVyLCBkcmF3Q2VsbDogcC5kcmF3Q2VsbCwgZW5hYmxlR3JvdXBzOiBwLmVuYWJsZUdyb3VwcywgZXZlbnRUYXJnZXRSZWY6IHAuZXZlbnRUYXJnZXRSZWYsIGV4cGVyaW1lbnRhbDogcC5leHBlcmltZW50YWwsIGZpbGxIYW5kbGU6IHAuZmlsbEhhbmRsZSwgZmlyc3RDb2xBY2Nlc3NpYmxlOiBwLmZpcnN0Q29sQWNjZXNzaWJsZSwgZml4ZWRTaGFkb3dYOiBwLmZpeGVkU2hhZG93WCwgZml4ZWRTaGFkb3dZOiBwLmZpeGVkU2hhZG93WSwgZnJlZXplQ29sdW1uczogcC5mcmVlemVDb2x1bW5zLCBnZXRDZWxsUmVuZGVyZXI6IHAuZ2V0Q2VsbFJlbmRlcmVyLCBnZXRHcm91cERldGFpbHM6IHAuZ2V0R3JvdXBEZXRhaWxzLCBnZXRSb3dUaGVtZU92ZXJyaWRlOiBwLmdldFJvd1RoZW1lT3ZlcnJpZGUsIGdyb3VwSGVhZGVySGVpZ2h0OiBwLmdyb3VwSGVhZGVySGVpZ2h0LCBoZWFkZXJIZWlnaHQ6IHAuaGVhZGVySGVpZ2h0LCBoZWFkZXJJY29uczogcC5oZWFkZXJJY29ucywgaGVpZ2h0OiBwLmhlaWdodCwgaGlnaGxpZ2h0UmVnaW9uczogcC5oaWdobGlnaHRSZWdpb25zLCBpbWFnZVdpbmRvd0xvYWRlcjogcC5pbWFnZVdpbmRvd0xvYWRlciwgcmVzaXplQ29sdW1uOiByZXNpemVDb2wsIGlzRHJhZ2dhYmxlOiBwLmlzRHJhZ2dhYmxlLCBpc0ZpbGxpbmc6IHAuaXNGaWxsaW5nLCBpc0ZvY3VzZWQ6IHAuaXNGb2N1c2VkLCBvbkNhbnZhc0JsdXI6IHAub25DYW52YXNCbHVyLCBvbkNhbnZhc0ZvY3VzZWQ6IHAub25DYW52YXNGb2N1c2VkLCBvbkNlbGxGb2N1c2VkOiBwLm9uQ2VsbEZvY3VzZWQsIG9uQ29udGV4dE1lbnU6IHAub25Db250ZXh0TWVudSwgb25EcmFnRW5kOiBwLm9uRHJhZ0VuZCwgb25EcmFnTGVhdmU6IHAub25EcmFnTGVhdmUsIG9uRHJhZ092ZXJDZWxsOiBwLm9uRHJhZ092ZXJDZWxsLCBvbkRyb3A6IHAub25Ecm9wLCBvbktleURvd246IHAub25LZXlEb3duLCBvbktleVVwOiBwLm9uS2V5VXAsIG9uTW91c2VNb3ZlOiBwLm9uTW91c2VNb3ZlLCBwcmVsaWdodENlbGxzOiBwLnByZWxpZ2h0Q2VsbHMsIHJvd0hlaWdodDogcC5yb3dIZWlnaHQsIHJvd3M6IHAucm93cywgc2VsZWN0aW9uOiBwLnNlbGVjdGlvbiwgc21vb3RoU2Nyb2xsWDogcC5zbW9vdGhTY3JvbGxYLCBzbW9vdGhTY3JvbGxZOiBwLnNtb290aFNjcm9sbFksIHRoZW1lOiBwLnRoZW1lLCBmcmVlemVUcmFpbGluZ1Jvd3M6IHAuZnJlZXplVHJhaWxpbmdSb3dzLCBoYXNBcHBlbmRSb3c6IHAuaGFzQXBwZW5kUm93LCB0cmFuc2xhdGVYOiBwLnRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVk6IHAudHJhbnNsYXRlWSwgdmVydGljYWxCb3JkZXI6IHAudmVydGljYWxCb3JkZXIsIHdpZHRoOiBwLndpZHRoLCBnZXRDZWxsQ29udGVudDogZ2V0TWFuZ2xlZENlbGxDb250ZW50LCBpc1Jlc2l6aW5nOiByZXNpemVDb2wgIT09IHVuZGVmaW5lZCwgb25IZWFkZXJNZW51Q2xpY2s6IG9uSGVhZGVyTWVudUNsaWNrTWFuZ2xlZCwgaXNEcmFnZ2luZzogZHJhZ0NvbEFjdGl2ZSwgb25JdGVtSG92ZXJlZDogb25JdGVtSG92ZXJlZEltcGwsIG9uRHJhZ1N0YXJ0OiBvbkRyYWdTdGFydEltcGwsIG9uTW91c2VEb3duOiBvbk1vdXNlRG93bkltcGwsIGFsbG93UmVzaXplOiBjYW5SZXNpemUsIG9uTW91c2VVcDogb25Nb3VzZVVwSW1wbCwgZHJhZ0FuZERyb3BTdGF0ZTogZHJhZ09mZnNldCwgb25Nb3VzZU1vdmVSYXc6IG9uTW91c2VNb3ZlLCByZWY6IGdyaWRSZWYgfSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IERhdGFHcmlkRG5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS1ncmlkLWRuZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-dnd/data-grid-dnd.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor-style.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor-style.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataGridOverlayEditorStyle: () => (/* binding */ DataGridOverlayEditorStyle)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\nconst _exp2 = /*#__PURE__*/() => p => p.targetX;\nconst _exp3 = /*#__PURE__*/() => p => p.targetY;\nconst _exp4 = /*#__PURE__*/() => p => p.targetWidth;\nconst _exp5 = /*#__PURE__*/() => p => p.targetHeight;\nconst _exp6 = /*#__PURE__*/() => p => p.targetY + 10;\nconst _exp7 = /*#__PURE__*/() => p => Math.max(0, (p.targetHeight - 28) / 2);\nconst DataGridOverlayEditorStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"DataGridOverlayEditorStyle\",\n  class: \"gdg-d19meir1\",\n  propsAsIs: false,\n  vars: {\n    \"d19meir1-0\": [_exp3(), \"px\"],\n    \"d19meir1-1\": [_exp2(), \"px\"],\n    \"d19meir1-2\": [_exp4(), \"px\"],\n    \"d19meir1-3\": [_exp5(), \"px\"],\n    \"d19meir1-4\": [_exp6(), \"px\"],\n    \"d19meir1-5\": [_exp7(), \"px\"]\n  }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci1zdHlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnREFBZ0Qsc0RBQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yLXN0eWxlLmpzPzZhMWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5jb25zdCBfZXhwMiA9IC8qI19fUFVSRV9fKi8oKSA9PiBwID0+IHAudGFyZ2V0WDtcbmNvbnN0IF9leHAzID0gLyojX19QVVJFX18qLygpID0+IHAgPT4gcC50YXJnZXRZO1xuY29uc3QgX2V4cDQgPSAvKiNfX1BVUkVfXyovKCkgPT4gcCA9PiBwLnRhcmdldFdpZHRoO1xuY29uc3QgX2V4cDUgPSAvKiNfX1BVUkVfXyovKCkgPT4gcCA9PiBwLnRhcmdldEhlaWdodDtcbmNvbnN0IF9leHA2ID0gLyojX19QVVJFX18qLygpID0+IHAgPT4gcC50YXJnZXRZICsgMTA7XG5jb25zdCBfZXhwNyA9IC8qI19fUFVSRV9fKi8oKSA9PiBwID0+IE1hdGgubWF4KDAsIChwLnRhcmdldEhlaWdodCAtIDI4KSAvIDIpO1xuZXhwb3J0IGNvbnN0IERhdGFHcmlkT3ZlcmxheUVkaXRvclN0eWxlID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jykoe1xuICBuYW1lOiBcIkRhdGFHcmlkT3ZlcmxheUVkaXRvclN0eWxlXCIsXG4gIGNsYXNzOiBcImdkZy1kMTltZWlyMVwiLFxuICBwcm9wc0FzSXM6IGZhbHNlLFxuICB2YXJzOiB7XG4gICAgXCJkMTltZWlyMS0wXCI6IFtfZXhwMygpLCBcInB4XCJdLFxuICAgIFwiZDE5bWVpcjEtMVwiOiBbX2V4cDIoKSwgXCJweFwiXSxcbiAgICBcImQxOW1laXIxLTJcIjogW19leHA0KCksIFwicHhcIl0sXG4gICAgXCJkMTltZWlyMS0zXCI6IFtfZXhwNSgpLCBcInB4XCJdLFxuICAgIFwiZDE5bWVpcjEtNFwiOiBbX2V4cDYoKSwgXCJweFwiXSxcbiAgICBcImQxOW1laXIxLTVcIjogW19leHA3KCksIFwicHhcIl1cbiAgfVxufSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor-style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _click_outside_container_click_outside_container_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../click-outside-container/click-outside-container.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/click-outside-container/click-outside-container.js\");\n/* harmony import */ var _common_styles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/styles.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js\");\n/* harmony import */ var _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _data_grid_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./data-grid-overlay-editor-style.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor-style.js\");\n/* harmony import */ var _use_stay_on_screen_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-stay-on-screen.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/use-stay-on-screen.js\");\n\n\n\n\n\n\n\nconst DataGridOverlayEditor = p => {\n    const { target, content, onFinishEditing: onFinishEditingIn, forceEditMode, initialValue, imageEditorOverride, markdownDivCreateNode, highlight, className, theme, id, cell, bloom, validateCell, getCellRenderer, provideEditor, isOutsideClick, } = p;\n    const [tempValue, setTempValueRaw] = react__WEBPACK_IMPORTED_MODULE_0__.useState(forceEditMode ? content : undefined);\n    const lastValueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(tempValue ?? content);\n    lastValueRef.current = tempValue ?? content;\n    const [isValid, setIsValid] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {\n        if (validateCell === undefined)\n            return true;\n        return !((0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isEditableGridCell)(content) && validateCell?.(cell, content, lastValueRef.current) === false);\n    });\n    const onFinishEditing = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newCell, movement) => {\n        onFinishEditingIn(isValid ? newCell : undefined, movement);\n    }, [isValid, onFinishEditingIn]);\n    const setTempValue = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newVal) => {\n        if (validateCell !== undefined && newVal !== undefined && (0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isEditableGridCell)(newVal)) {\n            const validResult = validateCell(cell, newVal, lastValueRef.current);\n            if (validResult === false) {\n                setIsValid(false);\n            }\n            else if (typeof validResult === \"object\") {\n                newVal = validResult;\n                setIsValid(true);\n            }\n            else {\n                setIsValid(true);\n            }\n        }\n        setTempValueRaw(newVal);\n    }, [cell, validateCell]);\n    const finished = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const customMotion = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const onClickOutside = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        onFinishEditing(tempValue, [0, 0]);\n        finished.current = true;\n    }, [tempValue, onFinishEditing]);\n    const onEditorFinished = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newValue, movement) => {\n        onFinishEditing(newValue, movement ?? customMotion.current ?? [0, 0]);\n        finished.current = true;\n    }, [onFinishEditing]);\n    const onKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (event) => {\n        let save = false;\n        if (event.key === \"Escape\") {\n            event.stopPropagation();\n            event.preventDefault();\n            customMotion.current = [0, 0];\n        }\n        else if (event.key === \"Enter\" && !event.shiftKey) {\n            event.stopPropagation();\n            event.preventDefault();\n            customMotion.current = [0, 1];\n            save = true;\n        }\n        else if (event.key === \"Tab\") {\n            event.stopPropagation();\n            event.preventDefault();\n            customMotion.current = [event.shiftKey ? -1 : 1, 0];\n            save = true;\n        }\n        window.setTimeout(() => {\n            if (!finished.current && customMotion.current !== undefined) {\n                onFinishEditing(save ? tempValue : undefined, customMotion.current);\n                finished.current = true;\n            }\n        }, 0);\n    }, [onFinishEditing, tempValue]);\n    const targetValue = tempValue ?? content;\n    const [editorProvider, useLabel] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if ((0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isInnerOnlyCell)(content))\n            return [];\n        const external = provideEditor?.(content);\n        if (external !== undefined)\n            return [external, false];\n        return [getCellRenderer(content)?.provideEditor?.(content), false];\n    }, [content, getCellRenderer, provideEditor]);\n    const { ref, style: stayOnScreenStyle } = (0,_use_stay_on_screen_js__WEBPACK_IMPORTED_MODULE_3__.useStayOnScreen)();\n    let pad = true;\n    let editor;\n    let style = true;\n    let styleOverride;\n    if (editorProvider !== undefined) {\n        pad = editorProvider.disablePadding !== true;\n        style = editorProvider.disableStyling !== true;\n        const isObjectEditor = (0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isObjectEditorCallbackResult)(editorProvider);\n        if (isObjectEditor) {\n            styleOverride = editorProvider.styleOverride;\n        }\n        const CustomEditor = isObjectEditor ? editorProvider.editor : editorProvider;\n        editor = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(CustomEditor, { isHighlighted: highlight, onChange: setTempValue, value: targetValue, initialValue: initialValue, onFinishedEditing: onEditorFinished, validatedSelection: (0,_data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.isEditableGridCell)(targetValue) ? targetValue.selectionRange : undefined, forceEditMode: forceEditMode, target: target, imageEditorOverride: imageEditorOverride, markdownDivCreateNode: markdownDivCreateNode, isValid: isValid, theme: theme }));\n    }\n    styleOverride = { ...styleOverride, ...stayOnScreenStyle };\n    // Consider imperatively creating and adding the element to the dom?\n    const portalElement = document.getElementById(\"portal\");\n    if (portalElement === null) {\n        // eslint-disable-next-line no-console\n        console.error('Cannot open Data Grid overlay editor, because portal not found.  Please add `<div id=\"portal\" />` as the last child of your `<body>`.');\n        return null;\n    }\n    let classWrap = style ? \"gdg-style\" : \"gdg-unstyle\";\n    if (!isValid) {\n        classWrap += \" gdg-invalid\";\n    }\n    if (pad) {\n        classWrap += \" gdg-pad\";\n    }\n    const bloomX = bloom?.[0] ?? 1;\n    const bloomY = bloom?.[1] ?? 1;\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_common_styles_js__WEBPACK_IMPORTED_MODULE_4__.ThemeContext.Provider, { value: theme },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_click_outside_container_click_outside_container_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"], { style: (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_4__.makeCSSStyle)(theme), className: className, onClickOutside: onClickOutside, isOutsideClick: isOutsideClick },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_6__.DataGridOverlayEditorStyle, { ref: ref, id: id, className: classWrap, style: styleOverride, as: useLabel === true ? \"label\" : undefined, targetX: target.x - bloomX, targetY: target.y - bloomY, targetWidth: target.width + bloomX * 2, targetHeight: target.height + bloomY * 2 },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"gdg-clip-region\", onKeyDown: onKeyDown }, editor)))), portalElement);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataGridOverlayEditor);\n//# sourceMappingURL=data-grid-overlay-editor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQjtBQUNVO0FBQ2lEO0FBQ3RCO0FBQ2lEO0FBQ3BDO0FBQ3ZCO0FBQzFEO0FBQ0EsWUFBWSw0T0FBNE87QUFDeFAseUNBQXlDLDJDQUFjO0FBQ3ZELHlCQUF5Qix5Q0FBWTtBQUNyQztBQUNBLGtDQUFrQywyQ0FBYztBQUNoRDtBQUNBO0FBQ0EsaUJBQWlCLGlGQUFrQjtBQUNuQyxLQUFLO0FBQ0wsNEJBQTRCLDhDQUFpQjtBQUM3QztBQUNBLEtBQUs7QUFDTCx5QkFBeUIsOENBQWlCO0FBQzFDLGtFQUFrRSxpRkFBa0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLHlDQUFZO0FBQ2pDLHlCQUF5Qix5Q0FBWTtBQUNyQywyQkFBMkIsOENBQWlCO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCLDhDQUFpQjtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQiw4Q0FBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUMsMENBQWE7QUFDcEQsWUFBWSw4RUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksZ0NBQWdDLEVBQUUsdUVBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkZBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdEQUFtQixpQkFBaUIsMkpBQTJKLGlGQUFrQiw4TkFBOE47QUFDamM7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFZLENBQUMsZ0RBQW1CLENBQUMsMkRBQVksYUFBYSxjQUFjO0FBQ25GLFFBQVEsZ0RBQW1CLENBQUMsMkZBQXFCLElBQUksT0FBTywrREFBWSwrRkFBK0Y7QUFDdkssWUFBWSxnREFBbUIsQ0FBQywwRkFBMEIsSUFBSSxxUEFBcVA7QUFDblQsZ0JBQWdCLGdEQUFtQixVQUFVLG9EQUFvRDtBQUNqRztBQUNBLGlFQUFlLHFCQUFxQixFQUFDO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci5qcz85M2FjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IENsaWNrT3V0c2lkZUNvbnRhaW5lciBmcm9tIFwiLi4vY2xpY2stb3V0c2lkZS1jb250YWluZXIvY2xpY2stb3V0c2lkZS1jb250YWluZXIuanNcIjtcbmltcG9ydCB7IG1ha2VDU1NTdHlsZSwgVGhlbWVDb250ZXh0IH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9zdHlsZXMuanNcIjtcbmltcG9ydCB7IGlzRWRpdGFibGVHcmlkQ2VsbCwgaXNJbm5lck9ubHlDZWxsLCBpc09iamVjdEVkaXRvckNhbGxiYWNrUmVzdWx0LCB9IGZyb20gXCIuLi9kYXRhLWdyaWQvZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5pbXBvcnQgeyBEYXRhR3JpZE92ZXJsYXlFZGl0b3JTdHlsZSB9IGZyb20gXCIuL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci1zdHlsZS5qc1wiO1xuaW1wb3J0IHsgdXNlU3RheU9uU2NyZWVuIH0gZnJvbSBcIi4vdXNlLXN0YXktb24tc2NyZWVuLmpzXCI7XG5jb25zdCBEYXRhR3JpZE92ZXJsYXlFZGl0b3IgPSBwID0+IHtcbiAgICBjb25zdCB7IHRhcmdldCwgY29udGVudCwgb25GaW5pc2hFZGl0aW5nOiBvbkZpbmlzaEVkaXRpbmdJbiwgZm9yY2VFZGl0TW9kZSwgaW5pdGlhbFZhbHVlLCBpbWFnZUVkaXRvck92ZXJyaWRlLCBtYXJrZG93bkRpdkNyZWF0ZU5vZGUsIGhpZ2hsaWdodCwgY2xhc3NOYW1lLCB0aGVtZSwgaWQsIGNlbGwsIGJsb29tLCB2YWxpZGF0ZUNlbGwsIGdldENlbGxSZW5kZXJlciwgcHJvdmlkZUVkaXRvciwgaXNPdXRzaWRlQ2xpY2ssIH0gPSBwO1xuICAgIGNvbnN0IFt0ZW1wVmFsdWUsIHNldFRlbXBWYWx1ZVJhd10gPSBSZWFjdC51c2VTdGF0ZShmb3JjZUVkaXRNb2RlID8gY29udGVudCA6IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgbGFzdFZhbHVlUmVmID0gUmVhY3QudXNlUmVmKHRlbXBWYWx1ZSA/PyBjb250ZW50KTtcbiAgICBsYXN0VmFsdWVSZWYuY3VycmVudCA9IHRlbXBWYWx1ZSA/PyBjb250ZW50O1xuICAgIGNvbnN0IFtpc1ZhbGlkLCBzZXRJc1ZhbGlkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbGlkYXRlQ2VsbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAhKGlzRWRpdGFibGVHcmlkQ2VsbChjb250ZW50KSAmJiB2YWxpZGF0ZUNlbGw/LihjZWxsLCBjb250ZW50LCBsYXN0VmFsdWVSZWYuY3VycmVudCkgPT09IGZhbHNlKTtcbiAgICB9KTtcbiAgICBjb25zdCBvbkZpbmlzaEVkaXRpbmcgPSBSZWFjdC51c2VDYWxsYmFjaygobmV3Q2VsbCwgbW92ZW1lbnQpID0+IHtcbiAgICAgICAgb25GaW5pc2hFZGl0aW5nSW4oaXNWYWxpZCA/IG5ld0NlbGwgOiB1bmRlZmluZWQsIG1vdmVtZW50KTtcbiAgICB9LCBbaXNWYWxpZCwgb25GaW5pc2hFZGl0aW5nSW5dKTtcbiAgICBjb25zdCBzZXRUZW1wVmFsdWUgPSBSZWFjdC51c2VDYWxsYmFjaygobmV3VmFsKSA9PiB7XG4gICAgICAgIGlmICh2YWxpZGF0ZUNlbGwgIT09IHVuZGVmaW5lZCAmJiBuZXdWYWwgIT09IHVuZGVmaW5lZCAmJiBpc0VkaXRhYmxlR3JpZENlbGwobmV3VmFsKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRSZXN1bHQgPSB2YWxpZGF0ZUNlbGwoY2VsbCwgbmV3VmFsLCBsYXN0VmFsdWVSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBpZiAodmFsaWRSZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNWYWxpZChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsaWRSZXN1bHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWwgPSB2YWxpZFJlc3VsdDtcbiAgICAgICAgICAgICAgICBzZXRJc1ZhbGlkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SXNWYWxpZCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRUZW1wVmFsdWVSYXcobmV3VmFsKTtcbiAgICB9LCBbY2VsbCwgdmFsaWRhdGVDZWxsXSk7XG4gICAgY29uc3QgZmluaXNoZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGN1c3RvbU1vdGlvbiA9IFJlYWN0LnVzZVJlZih1bmRlZmluZWQpO1xuICAgIGNvbnN0IG9uQ2xpY2tPdXRzaWRlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBvbkZpbmlzaEVkaXRpbmcodGVtcFZhbHVlLCBbMCwgMF0pO1xuICAgICAgICBmaW5pc2hlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LCBbdGVtcFZhbHVlLCBvbkZpbmlzaEVkaXRpbmddKTtcbiAgICBjb25zdCBvbkVkaXRvckZpbmlzaGVkID0gUmVhY3QudXNlQ2FsbGJhY2soKG5ld1ZhbHVlLCBtb3ZlbWVudCkgPT4ge1xuICAgICAgICBvbkZpbmlzaEVkaXRpbmcobmV3VmFsdWUsIG1vdmVtZW50ID8/IGN1c3RvbU1vdGlvbi5jdXJyZW50ID8/IFswLCAwXSk7XG4gICAgICAgIGZpbmlzaGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sIFtvbkZpbmlzaEVkaXRpbmddKTtcbiAgICBjb25zdCBvbktleURvd24gPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IHNhdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY3VzdG9tTW90aW9uLmN1cnJlbnQgPSBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjdXN0b21Nb3Rpb24uY3VycmVudCA9IFswLCAxXTtcbiAgICAgICAgICAgIHNhdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY3VzdG9tTW90aW9uLmN1cnJlbnQgPSBbZXZlbnQuc2hpZnRLZXkgPyAtMSA6IDEsIDBdO1xuICAgICAgICAgICAgc2F2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaW5pc2hlZC5jdXJyZW50ICYmIGN1c3RvbU1vdGlvbi5jdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvbkZpbmlzaEVkaXRpbmcoc2F2ZSA/IHRlbXBWYWx1ZSA6IHVuZGVmaW5lZCwgY3VzdG9tTW90aW9uLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9LCBbb25GaW5pc2hFZGl0aW5nLCB0ZW1wVmFsdWVdKTtcbiAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRlbXBWYWx1ZSA/PyBjb250ZW50O1xuICAgIGNvbnN0IFtlZGl0b3JQcm92aWRlciwgdXNlTGFiZWxdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChpc0lubmVyT25seUNlbGwoY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGV4dGVybmFsID0gcHJvdmlkZUVkaXRvcj8uKGNvbnRlbnQpO1xuICAgICAgICBpZiAoZXh0ZXJuYWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZXJuYWwsIGZhbHNlXTtcbiAgICAgICAgcmV0dXJuIFtnZXRDZWxsUmVuZGVyZXIoY29udGVudCk/LnByb3ZpZGVFZGl0b3I/Lihjb250ZW50KSwgZmFsc2VdO1xuICAgIH0sIFtjb250ZW50LCBnZXRDZWxsUmVuZGVyZXIsIHByb3ZpZGVFZGl0b3JdKTtcbiAgICBjb25zdCB7IHJlZiwgc3R5bGU6IHN0YXlPblNjcmVlblN0eWxlIH0gPSB1c2VTdGF5T25TY3JlZW4oKTtcbiAgICBsZXQgcGFkID0gdHJ1ZTtcbiAgICBsZXQgZWRpdG9yO1xuICAgIGxldCBzdHlsZSA9IHRydWU7XG4gICAgbGV0IHN0eWxlT3ZlcnJpZGU7XG4gICAgaWYgKGVkaXRvclByb3ZpZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFkID0gZWRpdG9yUHJvdmlkZXIuZGlzYWJsZVBhZGRpbmcgIT09IHRydWU7XG4gICAgICAgIHN0eWxlID0gZWRpdG9yUHJvdmlkZXIuZGlzYWJsZVN0eWxpbmcgIT09IHRydWU7XG4gICAgICAgIGNvbnN0IGlzT2JqZWN0RWRpdG9yID0gaXNPYmplY3RFZGl0b3JDYWxsYmFja1Jlc3VsdChlZGl0b3JQcm92aWRlcik7XG4gICAgICAgIGlmIChpc09iamVjdEVkaXRvcikge1xuICAgICAgICAgICAgc3R5bGVPdmVycmlkZSA9IGVkaXRvclByb3ZpZGVyLnN0eWxlT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgQ3VzdG9tRWRpdG9yID0gaXNPYmplY3RFZGl0b3IgPyBlZGl0b3JQcm92aWRlci5lZGl0b3IgOiBlZGl0b3JQcm92aWRlcjtcbiAgICAgICAgZWRpdG9yID0gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tRWRpdG9yLCB7IGlzSGlnaGxpZ2h0ZWQ6IGhpZ2hsaWdodCwgb25DaGFuZ2U6IHNldFRlbXBWYWx1ZSwgdmFsdWU6IHRhcmdldFZhbHVlLCBpbml0aWFsVmFsdWU6IGluaXRpYWxWYWx1ZSwgb25GaW5pc2hlZEVkaXRpbmc6IG9uRWRpdG9yRmluaXNoZWQsIHZhbGlkYXRlZFNlbGVjdGlvbjogaXNFZGl0YWJsZUdyaWRDZWxsKHRhcmdldFZhbHVlKSA/IHRhcmdldFZhbHVlLnNlbGVjdGlvblJhbmdlIDogdW5kZWZpbmVkLCBmb3JjZUVkaXRNb2RlOiBmb3JjZUVkaXRNb2RlLCB0YXJnZXQ6IHRhcmdldCwgaW1hZ2VFZGl0b3JPdmVycmlkZTogaW1hZ2VFZGl0b3JPdmVycmlkZSwgbWFya2Rvd25EaXZDcmVhdGVOb2RlOiBtYXJrZG93bkRpdkNyZWF0ZU5vZGUsIGlzVmFsaWQ6IGlzVmFsaWQsIHRoZW1lOiB0aGVtZSB9KSk7XG4gICAgfVxuICAgIHN0eWxlT3ZlcnJpZGUgPSB7IC4uLnN0eWxlT3ZlcnJpZGUsIC4uLnN0YXlPblNjcmVlblN0eWxlIH07XG4gICAgLy8gQ29uc2lkZXIgaW1wZXJhdGl2ZWx5IGNyZWF0aW5nIGFuZCBhZGRpbmcgdGhlIGVsZW1lbnQgdG8gdGhlIGRvbT9cbiAgICBjb25zdCBwb3J0YWxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwb3J0YWxcIik7XG4gICAgaWYgKHBvcnRhbEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IG9wZW4gRGF0YSBHcmlkIG92ZXJsYXkgZWRpdG9yLCBiZWNhdXNlIHBvcnRhbCBub3QgZm91bmQuICBQbGVhc2UgYWRkIGA8ZGl2IGlkPVwicG9ydGFsXCIgLz5gIGFzIHRoZSBsYXN0IGNoaWxkIG9mIHlvdXIgYDxib2R5PmAuJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgY2xhc3NXcmFwID0gc3R5bGUgPyBcImdkZy1zdHlsZVwiIDogXCJnZGctdW5zdHlsZVwiO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBjbGFzc1dyYXAgKz0gXCIgZ2RnLWludmFsaWRcIjtcbiAgICB9XG4gICAgaWYgKHBhZCkge1xuICAgICAgICBjbGFzc1dyYXAgKz0gXCIgZ2RnLXBhZFwiO1xuICAgIH1cbiAgICBjb25zdCBibG9vbVggPSBibG9vbT8uWzBdID8/IDE7XG4gICAgY29uc3QgYmxvb21ZID0gYmxvb20/LlsxXSA/PyAxO1xuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoUmVhY3QuY3JlYXRlRWxlbWVudChUaGVtZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoZW1lIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2xpY2tPdXRzaWRlQ29udGFpbmVyLCB7IHN0eWxlOiBtYWtlQ1NTU3R5bGUodGhlbWUpLCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgb25DbGlja091dHNpZGU6IG9uQ2xpY2tPdXRzaWRlLCBpc091dHNpZGVDbGljazogaXNPdXRzaWRlQ2xpY2sgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YUdyaWRPdmVybGF5RWRpdG9yU3R5bGUsIHsgcmVmOiByZWYsIGlkOiBpZCwgY2xhc3NOYW1lOiBjbGFzc1dyYXAsIHN0eWxlOiBzdHlsZU92ZXJyaWRlLCBhczogdXNlTGFiZWwgPT09IHRydWUgPyBcImxhYmVsXCIgOiB1bmRlZmluZWQsIHRhcmdldFg6IHRhcmdldC54IC0gYmxvb21YLCB0YXJnZXRZOiB0YXJnZXQueSAtIGJsb29tWSwgdGFyZ2V0V2lkdGg6IHRhcmdldC53aWR0aCArIGJsb29tWCAqIDIsIHRhcmdldEhlaWdodDogdGFyZ2V0LmhlaWdodCArIGJsb29tWSAqIDIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImdkZy1jbGlwLXJlZ2lvblwiLCBvbktleURvd246IG9uS2V5RG93biB9LCBlZGl0b3IpKSkpLCBwb3J0YWxFbGVtZW50KTtcbn07XG5leHBvcnQgZGVmYXVsdCBEYXRhR3JpZE92ZXJsYXlFZGl0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/data-grid-overlay-editor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/bubbles-overlay-editor-style.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/bubbles-overlay-editor-style.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubblesOverlayEditorStyle: () => (/* binding */ BubblesOverlayEditorStyle)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\nconst BubblesOverlayEditorStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"BubblesOverlayEditorStyle\",\n  class: \"gdg-b1ygi5by\",\n  propsAsIs: false\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvYnViYmxlcy1vdmVybGF5LWVkaXRvci1zdHlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3QztBQUNqQywrQ0FBK0Msc0RBQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2J1YmJsZXMtb3ZlcmxheS1lZGl0b3Itc3R5bGUuanM/Y2EyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmV4cG9ydCBjb25zdCBCdWJibGVzT3ZlcmxheUVkaXRvclN0eWxlID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jykoe1xuICBuYW1lOiBcIkJ1YmJsZXNPdmVybGF5RWRpdG9yU3R5bGVcIixcbiAgY2xhc3M6IFwiZ2RnLWIxeWdpNWJ5XCIsXG4gIHByb3BzQXNJczogZmFsc2Vcbn0pO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/bubbles-overlay-editor-style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/bubbles-overlay-editor.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/bubbles-overlay-editor.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _bubbles_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bubbles-overlay-editor-style.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/bubbles-overlay-editor-style.js\");\n\n\nconst BubblesOverlayEditor = p => {\n    const { bubbles } = p;\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_bubbles_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_1__.BubblesOverlayEditorStyle, null,\n        bubbles.map((b, i) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: i, className: \"boe-bubble\" }, b))),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"textarea\", { className: \"gdg-input\", autoFocus: true })));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BubblesOverlayEditor);\n//# sourceMappingURL=bubbles-overlay-editor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvYnViYmxlcy1vdmVybGF5LWVkaXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0I7QUFDK0M7QUFDOUU7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxnREFBbUIsQ0FBQyx1RkFBeUI7QUFDekQsK0JBQStCLGdEQUFtQixVQUFVLGlDQUFpQztBQUM3RixRQUFRLGdEQUFtQixlQUFlLHlDQUF5QztBQUNuRjtBQUNBLGlFQUFlLG9CQUFvQixFQUFDO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvYnViYmxlcy1vdmVybGF5LWVkaXRvci5qcz85ZTg0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQnViYmxlc092ZXJsYXlFZGl0b3JTdHlsZSB9IGZyb20gXCIuL2J1YmJsZXMtb3ZlcmxheS1lZGl0b3Itc3R5bGUuanNcIjtcbmNvbnN0IEJ1YmJsZXNPdmVybGF5RWRpdG9yID0gcCA9PiB7XG4gICAgY29uc3QgeyBidWJibGVzIH0gPSBwO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChCdWJibGVzT3ZlcmxheUVkaXRvclN0eWxlLCBudWxsLFxuICAgICAgICBidWJibGVzLm1hcCgoYiwgaSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGksIGNsYXNzTmFtZTogXCJib2UtYnViYmxlXCIgfSwgYikpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIsIHsgY2xhc3NOYW1lOiBcImdkZy1pbnB1dFwiLCBhdXRvRm9jdXM6IHRydWUgfSkpKTtcbn07XG5leHBvcnQgZGVmYXVsdCBCdWJibGVzT3ZlcmxheUVkaXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1YmJsZXMtb3ZlcmxheS1lZGl0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/bubbles-overlay-editor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/drilldown-overlay-editor.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/drilldown-overlay-editor.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\n\nconst DrilldownOverlayEditorStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_1__.styled)('div')({\n  name: \"DrilldownOverlayEditorStyle\",\n  class: \"gdg-d4zsq0x\",\n  propsAsIs: false\n});\nconst DrilldownOverlayEditor = p => {\n  const {\n    drilldowns\n  } = p;\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(DrilldownOverlayEditorStyle, null, drilldowns.map((d, i) => react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    key: i,\n    className: \"doe-bubble\"\n  }, d.img !== undefined && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n    src: d.img\n  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, d.text))));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DrilldownOverlayEditor);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvZHJpbGxkb3duLW92ZXJsYXktZWRpdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNTO0FBQ3hDLGlEQUFpRCxzREFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFNBQVMsZ0RBQW1CLDZEQUE2RCxnREFBbUI7QUFDNUc7QUFDQTtBQUNBLEdBQUcseUJBQXlCLGdEQUFtQjtBQUMvQztBQUNBLEdBQUcsR0FBRyxnREFBbUI7QUFDekI7QUFDQSxpRUFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2RyaWxsZG93bi1vdmVybGF5LWVkaXRvci5qcz83YmU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5jb25zdCBEcmlsbGRvd25PdmVybGF5RWRpdG9yU3R5bGUgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnKSh7XG4gIG5hbWU6IFwiRHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlXCIsXG4gIGNsYXNzOiBcImdkZy1kNHpzcTB4XCIsXG4gIHByb3BzQXNJczogZmFsc2Vcbn0pO1xuY29uc3QgRHJpbGxkb3duT3ZlcmxheUVkaXRvciA9IHAgPT4ge1xuICBjb25zdCB7XG4gICAgZHJpbGxkb3duc1xuICB9ID0gcDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRHJpbGxkb3duT3ZlcmxheUVkaXRvclN0eWxlLCBudWxsLCBkcmlsbGRvd25zLm1hcCgoZCwgaSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAga2V5OiBpLFxuICAgIGNsYXNzTmFtZTogXCJkb2UtYnViYmxlXCJcbiAgfSwgZC5pbWcgIT09IHVuZGVmaW5lZCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICBzcmM6IGQuaW1nXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIGQudGV4dCkpKSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgRHJpbGxkb3duT3ZlcmxheUVkaXRvcjtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/drilldown-overlay-editor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/image-overlay-editor-style.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/image-overlay-editor-style.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageOverlayEditorStyle: () => (/* binding */ ImageOverlayEditorStyle)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\nconst ImageOverlayEditorStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"ImageOverlayEditorStyle\",\n  class: \"gdg-i2iowwq\",\n  propsAsIs: false\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvaW1hZ2Utb3ZlcmxheS1lZGl0b3Itc3R5bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7QUFDakMsNkNBQTZDLHNEQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQtb3ZlcmxheS1lZGl0b3IvcHJpdmF0ZS9pbWFnZS1vdmVybGF5LWVkaXRvci1zdHlsZS5qcz85YzU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJAbGluYXJpYS9yZWFjdFwiO1xuZXhwb3J0IGNvbnN0IEltYWdlT3ZlcmxheUVkaXRvclN0eWxlID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jykoe1xuICBuYW1lOiBcIkltYWdlT3ZlcmxheUVkaXRvclN0eWxlXCIsXG4gIGNsYXNzOiBcImdkZy1pMmlvd3dxXCIsXG4gIHByb3BzQXNJczogZmFsc2Vcbn0pO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/image-overlay-editor-style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/image-overlay-editor.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/image-overlay-editor.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageOverlayEditor: () => (/* binding */ ImageOverlayEditor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _image_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./image-overlay-editor-style.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/image-overlay-editor-style.js\");\n/* harmony import */ var react_responsive_carousel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-responsive-carousel */ \"(ssr)/./node_modules/react-responsive-carousel/lib/js/index.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n\n\n\n\n/** @category Renderers */\nconst ImageOverlayEditor = p => {\n    const { urls, canWrite, onEditClick, renderImage } = p;\n    const filtered = urls.filter(u => u !== \"\");\n    if (filtered.length === 0) {\n        return null;\n    }\n    const allowMove = filtered.length > 1;\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_image_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_2__.ImageOverlayEditorStyle, { \"data-testid\": \"GDG-default-image-overlay-editor\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_responsive_carousel__WEBPACK_IMPORTED_MODULE_1__.Carousel, { showArrows: allowMove, showThumbs: false, swipeable: allowMove, emulateTouch: allowMove, infiniteLoop: allowMove }, filtered.map(url => {\n            const innerContent = renderImage?.(url) ?? react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", { draggable: false, src: url });\n            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"gdg-centering-container\", key: url }, innerContent));\n        })),\n        canWrite && onEditClick && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"gdg-edit-icon\", onClick: onEditClick },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_common_utils_js__WEBPACK_IMPORTED_MODULE_3__.EditPencil, null)))));\n};\n//# sourceMappingURL=image-overlay-editor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvaW1hZ2Utb3ZlcmxheS1lZGl0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0I7QUFDMkM7QUFDckI7QUFDQztBQUN0RDtBQUNPO0FBQ1AsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQW1CLENBQUMsbUZBQXVCLElBQUksbURBQW1EO0FBQzlHLFFBQVEsZ0RBQW1CLENBQUMsK0RBQVEsSUFBSSxrSEFBa0g7QUFDMUosdURBQXVELGdEQUFtQixVQUFVLDRCQUE0QjtBQUNoSCxvQkFBb0IsZ0RBQW1CLFVBQVUsZ0RBQWdEO0FBQ2pHLFNBQVM7QUFDVCxvQ0FBb0MsZ0RBQW1CLGFBQWEsa0RBQWtEO0FBQ3RILFlBQVksZ0RBQW1CLENBQUMsd0RBQVU7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL2ltYWdlLW92ZXJsYXktZWRpdG9yLmpzP2YzMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBJbWFnZU92ZXJsYXlFZGl0b3JTdHlsZSB9IGZyb20gXCIuL2ltYWdlLW92ZXJsYXktZWRpdG9yLXN0eWxlLmpzXCI7XG5pbXBvcnQgeyBDYXJvdXNlbCB9IGZyb20gXCJyZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsXCI7XG5pbXBvcnQgeyBFZGl0UGVuY2lsIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi91dGlscy5qc1wiO1xuLyoqIEBjYXRlZ29yeSBSZW5kZXJlcnMgKi9cbmV4cG9ydCBjb25zdCBJbWFnZU92ZXJsYXlFZGl0b3IgPSBwID0+IHtcbiAgICBjb25zdCB7IHVybHMsIGNhbldyaXRlLCBvbkVkaXRDbGljaywgcmVuZGVySW1hZ2UgfSA9IHA7XG4gICAgY29uc3QgZmlsdGVyZWQgPSB1cmxzLmZpbHRlcih1ID0+IHUgIT09IFwiXCIpO1xuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFsbG93TW92ZSA9IGZpbHRlcmVkLmxlbmd0aCA+IDE7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEltYWdlT3ZlcmxheUVkaXRvclN0eWxlLCB7IFwiZGF0YS10ZXN0aWRcIjogXCJHREctZGVmYXVsdC1pbWFnZS1vdmVybGF5LWVkaXRvclwiIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2Fyb3VzZWwsIHsgc2hvd0Fycm93czogYWxsb3dNb3ZlLCBzaG93VGh1bWJzOiBmYWxzZSwgc3dpcGVhYmxlOiBhbGxvd01vdmUsIGVtdWxhdGVUb3VjaDogYWxsb3dNb3ZlLCBpbmZpbml0ZUxvb3A6IGFsbG93TW92ZSB9LCBmaWx0ZXJlZC5tYXAodXJsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyQ29udGVudCA9IHJlbmRlckltYWdlPy4odXJsKSA/PyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHsgZHJhZ2dhYmxlOiBmYWxzZSwgc3JjOiB1cmwgfSk7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZ2RnLWNlbnRlcmluZy1jb250YWluZXJcIiwga2V5OiB1cmwgfSwgaW5uZXJDb250ZW50KSk7XG4gICAgICAgIH0pKSxcbiAgICAgICAgY2FuV3JpdGUgJiYgb25FZGl0Q2xpY2sgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwiZ2RnLWVkaXQtaWNvblwiLCBvbkNsaWNrOiBvbkVkaXRDbGljayB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0UGVuY2lsLCBudWxsKSkpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2Utb3ZlcmxheS1lZGl0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/image-overlay-editor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/markdown-overlay-editor-style.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/markdown-overlay-editor-style.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MarkdownOverlayEditorStyle: () => (/* binding */ MarkdownOverlayEditorStyle)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\nconst _exp = /*#__PURE__*/() => p => p.targetWidth;\nconst MarkdownOverlayEditorStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"MarkdownOverlayEditorStyle\",\n  class: \"gdg-m1pnx84e\",\n  propsAsIs: false,\n  vars: {\n    \"m1pnx84e-0\": [_exp(), \"px\"]\n  }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvbWFya2Rvd24tb3ZlcmxheS1lZGl0b3Itc3R5bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7QUFDeEM7QUFDTyxnREFBZ0Qsc0RBQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL21hcmtkb3duLW92ZXJsYXktZWRpdG9yLXN0eWxlLmpzP2M5YmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5jb25zdCBfZXhwID0gLyojX19QVVJFX18qLygpID0+IHAgPT4gcC50YXJnZXRXaWR0aDtcbmV4cG9ydCBjb25zdCBNYXJrZG93bk92ZXJsYXlFZGl0b3JTdHlsZSA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicpKHtcbiAgbmFtZTogXCJNYXJrZG93bk92ZXJsYXlFZGl0b3JTdHlsZVwiLFxuICBjbGFzczogXCJnZGctbTFwbng4NGVcIixcbiAgcHJvcHNBc0lzOiBmYWxzZSxcbiAgdmFyczoge1xuICAgIFwibTFwbng4NGUtMFwiOiBbX2V4cCgpLCBcInB4XCJdXG4gIH1cbn0pO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/markdown-overlay-editor-style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/markdown-overlay-editor.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/markdown-overlay-editor.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MarkdownOverlayEditor: () => (/* binding */ MarkdownOverlayEditor)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _markdown_div_markdown_div_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../markdown-div/markdown-div.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/markdown-div/markdown-div.js\");\n/* harmony import */ var _growing_entry_growing_entry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../growing-entry/growing-entry.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry.js\");\n/* harmony import */ var _markdown_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./markdown-overlay-editor-style.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/markdown-overlay-editor-style.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n\n\n\n\n\nconst MarkdownOverlayEditor = p => {\n    const { value, onChange, forceEditMode, createNode, targetRect, onFinish, validatedSelection } = p;\n    const markdown = value.data;\n    const readonly = value.readonly === true;\n    const [editMode, setEditMode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(markdown === \"\" || forceEditMode);\n    const onEditClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        setEditMode(e => !e);\n    }, []);\n    const addLeftPad = markdown ? \"gdg-ml-6\" : \"\";\n    if (editMode) {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_markdown_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_1__.MarkdownOverlayEditorStyle, { targetWidth: targetRect.width - 20 },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_growing_entry_growing_entry_js__WEBPACK_IMPORTED_MODULE_2__.GrowingEntry, { autoFocus: true, highlight: false, validatedSelection: validatedSelection, value: markdown, onKeyDown: e => {\n                    if (e.key === \"Enter\")\n                        e.stopPropagation();\n                }, onChange: onChange }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: `gdg-edit-icon gdg-checkmark-hover ${addLeftPad}`, onClick: () => onFinish(value) },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_common_utils_js__WEBPACK_IMPORTED_MODULE_3__.Checkmark, null))));\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_markdown_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_1__.MarkdownOverlayEditorStyle, { targetWidth: targetRect.width },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_markdown_div_markdown_div_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { contents: markdown, createNode: createNode }),\n        !readonly && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"spacer\" }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: `gdg-edit-icon gdg-edit-hover ${addLeftPad}`, onClick: onEditClick },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(_common_utils_js__WEBPACK_IMPORTED_MODULE_3__.EditPencil, null)))),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"textarea\", { className: \"gdg-md-edit-textarea gdg-input\", autoFocus: true })));\n};\n//# sourceMappingURL=markdown-overlay-editor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvbWFya2Rvd24tb3ZlcmxheS1lZGl0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBQzhCO0FBQ087QUFDWTtBQUNmO0FBQzFEO0FBQ1AsWUFBWSx1RkFBdUY7QUFDbkc7QUFDQTtBQUNBLG9DQUFvQywyQ0FBYztBQUNsRCx3QkFBd0IsOENBQWlCO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQW1CLENBQUMseUZBQTBCLElBQUksb0NBQW9DO0FBQ3RHLFlBQVksZ0RBQW1CLENBQUMseUVBQVksSUFBSTtBQUNoRDtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QyxZQUFZLGdEQUFtQixVQUFVLGdEQUFnRCxXQUFXLG1DQUFtQztBQUN2SSxnQkFBZ0IsZ0RBQW1CLENBQUMsdURBQVM7QUFDN0M7QUFDQSxZQUFZLGdEQUFtQixDQUFDLHlGQUEwQixJQUFJLCtCQUErQjtBQUM3RixRQUFRLGdEQUFtQixDQUFDLHFFQUFXLElBQUksNENBQTRDO0FBQ3ZGLHNCQUFzQixnREFBbUIsQ0FBQywyQ0FBYztBQUN4RCxZQUFZLGdEQUFtQixVQUFVLHFCQUFxQjtBQUM5RCxZQUFZLGdEQUFtQixVQUFVLDJDQUEyQyxXQUFXLHlCQUF5QjtBQUN4SCxnQkFBZ0IsZ0RBQW1CLENBQUMsd0RBQVU7QUFDOUMsUUFBUSxnREFBbUIsZUFBZSw4REFBOEQ7QUFDeEc7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL21hcmtkb3duLW92ZXJsYXktZWRpdG9yLmpzPzFiM2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgTWFya2Rvd25EaXYgZnJvbSBcIi4uLy4uL21hcmtkb3duLWRpdi9tYXJrZG93bi1kaXYuanNcIjtcbmltcG9ydCB7IEdyb3dpbmdFbnRyeSB9IGZyb20gXCIuLi8uLi9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnkuanNcIjtcbmltcG9ydCB7IE1hcmtkb3duT3ZlcmxheUVkaXRvclN0eWxlIH0gZnJvbSBcIi4vbWFya2Rvd24tb3ZlcmxheS1lZGl0b3Itc3R5bGUuanNcIjtcbmltcG9ydCB7IEVkaXRQZW5jaWwsIENoZWNrbWFyayB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vdXRpbHMuanNcIjtcbmV4cG9ydCBjb25zdCBNYXJrZG93bk92ZXJsYXlFZGl0b3IgPSBwID0+IHtcbiAgICBjb25zdCB7IHZhbHVlLCBvbkNoYW5nZSwgZm9yY2VFZGl0TW9kZSwgY3JlYXRlTm9kZSwgdGFyZ2V0UmVjdCwgb25GaW5pc2gsIHZhbGlkYXRlZFNlbGVjdGlvbiB9ID0gcDtcbiAgICBjb25zdCBtYXJrZG93biA9IHZhbHVlLmRhdGE7XG4gICAgY29uc3QgcmVhZG9ubHkgPSB2YWx1ZS5yZWFkb25seSA9PT0gdHJ1ZTtcbiAgICBjb25zdCBbZWRpdE1vZGUsIHNldEVkaXRNb2RlXSA9IFJlYWN0LnVzZVN0YXRlKG1hcmtkb3duID09PSBcIlwiIHx8IGZvcmNlRWRpdE1vZGUpO1xuICAgIGNvbnN0IG9uRWRpdENsaWNrID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRFZGl0TW9kZShlID0+ICFlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgYWRkTGVmdFBhZCA9IG1hcmtkb3duID8gXCJnZGctbWwtNlwiIDogXCJcIjtcbiAgICBpZiAoZWRpdE1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duT3ZlcmxheUVkaXRvclN0eWxlLCB7IHRhcmdldFdpZHRoOiB0YXJnZXRSZWN0LndpZHRoIC0gMjAgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3Jvd2luZ0VudHJ5LCB7IGF1dG9Gb2N1czogdHJ1ZSwgaGlnaGxpZ2h0OiBmYWxzZSwgdmFsaWRhdGVkU2VsZWN0aW9uOiB2YWxpZGF0ZWRTZWxlY3Rpb24sIHZhbHVlOiBtYXJrZG93biwgb25LZXlEb3duOiBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0sIG9uQ2hhbmdlOiBvbkNoYW5nZSB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBnZGctZWRpdC1pY29uIGdkZy1jaGVja21hcmstaG92ZXIgJHthZGRMZWZ0UGFkfWAsIG9uQ2xpY2s6ICgpID0+IG9uRmluaXNoKHZhbHVlKSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2ttYXJrLCBudWxsKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duT3ZlcmxheUVkaXRvclN0eWxlLCB7IHRhcmdldFdpZHRoOiB0YXJnZXRSZWN0LndpZHRoIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2Rvd25EaXYsIHsgY29udGVudHM6IG1hcmtkb3duLCBjcmVhdGVOb2RlOiBjcmVhdGVOb2RlIH0pLFxuICAgICAgICAhcmVhZG9ubHkgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInNwYWNlclwiIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYGdkZy1lZGl0LWljb24gZ2RnLWVkaXQtaG92ZXIgJHthZGRMZWZ0UGFkfWAsIG9uQ2xpY2s6IG9uRWRpdENsaWNrIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0UGVuY2lsLCBudWxsKSkpKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIsIHsgY2xhc3NOYW1lOiBcImdkZy1tZC1lZGl0LXRleHRhcmVhIGdkZy1pbnB1dFwiLCBhdXRvRm9jdXM6IHRydWUgfSkpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXJrZG93bi1vdmVybGF5LWVkaXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/markdown-overlay-editor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/number-overlay-editor-style.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/number-overlay-editor-style.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NumberOverlayEditorStyle: () => (/* binding */ NumberOverlayEditorStyle)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\nconst NumberOverlayEditorStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"NumberOverlayEditorStyle\",\n  class: \"gdg-n15fjm3e\",\n  propsAsIs: false\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvbnVtYmVyLW92ZXJsYXktZWRpdG9yLXN0eWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ2pDLDhDQUE4QyxzREFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvbnVtYmVyLW92ZXJsYXktZWRpdG9yLXN0eWxlLmpzPzA2OTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgTnVtYmVyT3ZlcmxheUVkaXRvclN0eWxlID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jykoe1xuICBuYW1lOiBcIk51bWJlck92ZXJsYXlFZGl0b3JTdHlsZVwiLFxuICBjbGFzczogXCJnZGctbjE1ZmptM2VcIixcbiAgcHJvcHNBc0lzOiBmYWxzZVxufSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/number-overlay-editor-style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/number-overlay-editor.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/number-overlay-editor.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _number_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number-overlay-editor-style.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/number-overlay-editor-style.js\");\n/* harmony import */ var react_number_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-number-format */ \"(ssr)/./node_modules/react-number-format/dist/react-number-format.es.js\");\n\n\n\nfunction getDecimalSeparator() {\n    const numberWithDecimalSeparator = 1.1;\n    const result = Intl.NumberFormat()\n        ?.formatToParts(numberWithDecimalSeparator)\n        ?.find(part => part.type === \"decimal\")?.value;\n    return result ?? \".\";\n}\nfunction getThousandSeprator() {\n    return getDecimalSeparator() === \".\" ? \",\" : \".\";\n}\nconst NumberOverlayEditor = p => {\n    const { value, onChange, disabled, highlight, validatedSelection, fixedDecimals, allowNegative, thousandSeparator, decimalSeparator, } = p;\n    const inputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (validatedSelection !== undefined) {\n            const range = typeof validatedSelection === \"number\" ? [validatedSelection, null] : validatedSelection;\n            inputRef.current?.setSelectionRange(range[0], range[1]);\n        }\n    }, [validatedSelection]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_number_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_1__.NumberOverlayEditorStyle, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_number_format__WEBPACK_IMPORTED_MODULE_2__.NumericFormat, { autoFocus: true, getInputRef: inputRef, className: \"gdg-input\", onFocus: (e) => e.target.setSelectionRange(highlight ? 0 : e.target.value.length, e.target.value.length), disabled: disabled === true, decimalScale: fixedDecimals, allowNegative: allowNegative, thousandSeparator: thousandSeparator ?? getThousandSeprator(), decimalSeparator: decimalSeparator ?? getDecimalSeparator(), value: Object.is(value, -0) ? \"-\" : value ?? \"\", \n            // decimalScale={3}\n            // prefix={\"$\"}\n            onValueChange: onChange })));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NumberOverlayEditor);\n//# sourceMappingURL=number-overlay-editor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvbnVtYmVyLW92ZXJsYXktZWRpdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDNkM7QUFDeEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0hBQStIO0FBQzNJLHFCQUFxQix5Q0FBWTtBQUNqQyxJQUFJLGtEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGdEQUFtQixDQUFDLHFGQUF3QjtBQUN4RCxRQUFRLGdEQUFtQixDQUFDLDhEQUFhLElBQUk7QUFDN0MsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2QixxQ0FBcUM7QUFDckM7QUFDQSxpRUFBZSxtQkFBbUIsRUFBQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci9wcml2YXRlL251bWJlci1vdmVybGF5LWVkaXRvci5qcz80YmQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgTnVtYmVyT3ZlcmxheUVkaXRvclN0eWxlIH0gZnJvbSBcIi4vbnVtYmVyLW92ZXJsYXktZWRpdG9yLXN0eWxlLmpzXCI7XG5pbXBvcnQgeyBOdW1lcmljRm9ybWF0IH0gZnJvbSBcInJlYWN0LW51bWJlci1mb3JtYXRcIjtcbmZ1bmN0aW9uIGdldERlY2ltYWxTZXBhcmF0b3IoKSB7XG4gICAgY29uc3QgbnVtYmVyV2l0aERlY2ltYWxTZXBhcmF0b3IgPSAxLjE7XG4gICAgY29uc3QgcmVzdWx0ID0gSW50bC5OdW1iZXJGb3JtYXQoKVxuICAgICAgICA/LmZvcm1hdFRvUGFydHMobnVtYmVyV2l0aERlY2ltYWxTZXBhcmF0b3IpXG4gICAgICAgID8uZmluZChwYXJ0ID0+IHBhcnQudHlwZSA9PT0gXCJkZWNpbWFsXCIpPy52YWx1ZTtcbiAgICByZXR1cm4gcmVzdWx0ID8/IFwiLlwiO1xufVxuZnVuY3Rpb24gZ2V0VGhvdXNhbmRTZXByYXRvcigpIHtcbiAgICByZXR1cm4gZ2V0RGVjaW1hbFNlcGFyYXRvcigpID09PSBcIi5cIiA/IFwiLFwiIDogXCIuXCI7XG59XG5jb25zdCBOdW1iZXJPdmVybGF5RWRpdG9yID0gcCA9PiB7XG4gICAgY29uc3QgeyB2YWx1ZSwgb25DaGFuZ2UsIGRpc2FibGVkLCBoaWdobGlnaHQsIHZhbGlkYXRlZFNlbGVjdGlvbiwgZml4ZWREZWNpbWFscywgYWxsb3dOZWdhdGl2ZSwgdGhvdXNhbmRTZXBhcmF0b3IsIGRlY2ltYWxTZXBhcmF0b3IsIH0gPSBwO1xuICAgIGNvbnN0IGlucHV0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHZhbGlkYXRlZFNlbGVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiB2YWxpZGF0ZWRTZWxlY3Rpb24gPT09IFwibnVtYmVyXCIgPyBbdmFsaWRhdGVkU2VsZWN0aW9uLCBudWxsXSA6IHZhbGlkYXRlZFNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQ/LnNldFNlbGVjdGlvblJhbmdlKHJhbmdlWzBdLCByYW5nZVsxXSk7XG4gICAgICAgIH1cbiAgICB9LCBbdmFsaWRhdGVkU2VsZWN0aW9uXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE51bWJlck92ZXJsYXlFZGl0b3JTdHlsZSwgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChOdW1lcmljRm9ybWF0LCB7IGF1dG9Gb2N1czogdHJ1ZSwgZ2V0SW5wdXRSZWY6IGlucHV0UmVmLCBjbGFzc05hbWU6IFwiZ2RnLWlucHV0XCIsIG9uRm9jdXM6IChlKSA9PiBlLnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZShoaWdobGlnaHQgPyAwIDogZS50YXJnZXQudmFsdWUubGVuZ3RoLCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpLCBkaXNhYmxlZDogZGlzYWJsZWQgPT09IHRydWUsIGRlY2ltYWxTY2FsZTogZml4ZWREZWNpbWFscywgYWxsb3dOZWdhdGl2ZTogYWxsb3dOZWdhdGl2ZSwgdGhvdXNhbmRTZXBhcmF0b3I6IHRob3VzYW5kU2VwYXJhdG9yID8/IGdldFRob3VzYW5kU2VwcmF0b3IoKSwgZGVjaW1hbFNlcGFyYXRvcjogZGVjaW1hbFNlcGFyYXRvciA/PyBnZXREZWNpbWFsU2VwYXJhdG9yKCksIHZhbHVlOiBPYmplY3QuaXModmFsdWUsIC0wKSA/IFwiLVwiIDogdmFsdWUgPz8gXCJcIiwgXG4gICAgICAgICAgICAvLyBkZWNpbWFsU2NhbGU9ezN9XG4gICAgICAgICAgICAvLyBwcmVmaXg9e1wiJFwifVxuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZTogb25DaGFuZ2UgfSkpKTtcbn07XG5leHBvcnQgZGVmYXVsdCBOdW1iZXJPdmVybGF5RWRpdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVtYmVyLW92ZXJsYXktZWRpdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/number-overlay-editor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/uri-overlay-editor-style.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/uri-overlay-editor-style.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UriOverlayEditorStyle: () => (/* binding */ UriOverlayEditorStyle)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\nconst UriOverlayEditorStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"UriOverlayEditorStyle\",\n  class: \"gdg-u1rrojo\",\n  propsAsIs: false\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvdXJpLW92ZXJsYXktZWRpdG9yLXN0eWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ2pDLDJDQUEyQyxzREFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvdXJpLW92ZXJsYXktZWRpdG9yLXN0eWxlLmpzP2ZlZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgVXJpT3ZlcmxheUVkaXRvclN0eWxlID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jykoe1xuICBuYW1lOiBcIlVyaU92ZXJsYXlFZGl0b3JTdHlsZVwiLFxuICBjbGFzczogXCJnZGctdTFycm9qb1wiLFxuICBwcm9wc0FzSXM6IGZhbHNlXG59KTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/uri-overlay-editor-style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/uri-overlay-editor.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/uri-overlay-editor.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _growing_entry_growing_entry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../growing-entry/growing-entry.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry.js\");\n/* harmony import */ var _uri_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./uri-overlay-editor-style.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/uri-overlay-editor-style.js\");\n\n\n\n\nconst UriOverlayEditor = p => {\n    const { uri, onChange, forceEditMode, readonly, validatedSelection, preview } = p;\n    const [editMode, setEditMode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(!readonly && (uri === \"\" || forceEditMode));\n    const onEditClick = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        setEditMode(true);\n    }, []);\n    if (editMode) {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_growing_entry_growing_entry_js__WEBPACK_IMPORTED_MODULE_1__.GrowingEntry, { validatedSelection: validatedSelection, highlight: true, autoFocus: true, value: uri, onChange: onChange }));\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_uri_overlay_editor_style_js__WEBPACK_IMPORTED_MODULE_2__.UriOverlayEditorStyle, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", { className: \"gdg-link-area\", href: uri, target: \"_blank\", rel: \"noopener noreferrer\" }, preview),\n        !readonly && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"gdg-edit-icon\", onClick: onEditClick },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_common_utils_js__WEBPACK_IMPORTED_MODULE_3__.EditPencil, null))),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"textarea\", { className: \"gdg-input\", autoFocus: true })));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UriOverlayEditor);\n//# sourceMappingURL=uri-overlay-editor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvdXJpLW92ZXJsYXktZWRpdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQ3ZCO0FBQ3FDO0FBQ0U7QUFDdEU7QUFDQSxZQUFZLHNFQUFzRTtBQUNsRixvQ0FBb0MsMkNBQWM7QUFDbEQsd0JBQXdCLDhDQUFpQjtBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixnREFBbUIsQ0FBQyx5RUFBWSxJQUFJLDBHQUEwRztBQUM5SjtBQUNBLFlBQVksZ0RBQW1CLENBQUMsK0VBQXFCO0FBQ3JELFFBQVEsZ0RBQW1CLFFBQVEscUZBQXFGO0FBQ3hILHNCQUFzQixnREFBbUIsVUFBVSxrREFBa0Q7QUFDckcsWUFBWSxnREFBbUIsQ0FBQyx3REFBVTtBQUMxQyxRQUFRLGdEQUFtQixlQUFlLHlDQUF5QztBQUNuRjtBQUNBLGlFQUFlLGdCQUFnQixFQUFDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3ByaXZhdGUvdXJpLW92ZXJsYXktZWRpdG9yLmpzP2I4ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdFBlbmNpbCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgR3Jvd2luZ0VudHJ5IH0gZnJvbSBcIi4uLy4uL2dyb3dpbmctZW50cnkvZ3Jvd2luZy1lbnRyeS5qc1wiO1xuaW1wb3J0IHsgVXJpT3ZlcmxheUVkaXRvclN0eWxlIH0gZnJvbSBcIi4vdXJpLW92ZXJsYXktZWRpdG9yLXN0eWxlLmpzXCI7XG5jb25zdCBVcmlPdmVybGF5RWRpdG9yID0gcCA9PiB7XG4gICAgY29uc3QgeyB1cmksIG9uQ2hhbmdlLCBmb3JjZUVkaXRNb2RlLCByZWFkb25seSwgdmFsaWRhdGVkU2VsZWN0aW9uLCBwcmV2aWV3IH0gPSBwO1xuICAgIGNvbnN0IFtlZGl0TW9kZSwgc2V0RWRpdE1vZGVdID0gUmVhY3QudXNlU3RhdGUoIXJlYWRvbmx5ICYmICh1cmkgPT09IFwiXCIgfHwgZm9yY2VFZGl0TW9kZSkpO1xuICAgIGNvbnN0IG9uRWRpdENsaWNrID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRFZGl0TW9kZSh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKGVkaXRNb2RlKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChHcm93aW5nRW50cnksIHsgdmFsaWRhdGVkU2VsZWN0aW9uOiB2YWxpZGF0ZWRTZWxlY3Rpb24sIGhpZ2hsaWdodDogdHJ1ZSwgYXV0b0ZvY3VzOiB0cnVlLCB2YWx1ZTogdXJpLCBvbkNoYW5nZTogb25DaGFuZ2UgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoVXJpT3ZlcmxheUVkaXRvclN0eWxlLCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IGNsYXNzTmFtZTogXCJnZGctbGluay1hcmVhXCIsIGhyZWY6IHVyaSwgdGFyZ2V0OiBcIl9ibGFua1wiLCByZWw6IFwibm9vcGVuZXIgbm9yZWZlcnJlclwiIH0sIHByZXZpZXcpLFxuICAgICAgICAhcmVhZG9ubHkgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZ2RnLWVkaXQtaWNvblwiLCBvbkNsaWNrOiBvbkVkaXRDbGljayB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0UGVuY2lsLCBudWxsKSkpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIiwgeyBjbGFzc05hbWU6IFwiZ2RnLWlucHV0XCIsIGF1dG9Gb2N1czogdHJ1ZSB9KSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IFVyaU92ZXJsYXlFZGl0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmktb3ZlcmxheS1lZGl0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/private/uri-overlay-editor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/use-stay-on-screen.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/use-stay-on-screen.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStayOnScreen: () => (/* binding */ useStayOnScreen)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction useRefState() {\n    const [refState, setRefState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    return [refState ?? undefined, setRefState];\n}\nfunction useStayOnScreen() {\n    const [ref, setRef] = useRefState();\n    const [xOffset, setXOffset] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    const [isIntersecting, setIsIntersecting] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (ref === undefined)\n            return;\n        if (!(\"IntersectionObserver\" in window))\n            return;\n        const observer = new IntersectionObserver(ents => {\n            if (ents.length === 0)\n                return;\n            setIsIntersecting(ents[0].isIntersecting);\n        }, { threshold: 1 });\n        observer.observe(ref);\n        return () => observer.disconnect();\n    }, [ref]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (isIntersecting || ref === undefined)\n            return;\n        let rafHandle;\n        const fn = () => {\n            const { right: refRight } = ref.getBoundingClientRect();\n            setXOffset(cv => Math.min(cv + window.innerWidth - refRight - 10, 0));\n            rafHandle = requestAnimationFrame(fn);\n        };\n        rafHandle = requestAnimationFrame(fn);\n        return () => {\n            if (rafHandle !== undefined) {\n                cancelAnimationFrame(rafHandle);\n            }\n        };\n    }, [ref, isIntersecting]);\n    const style = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return { transform: `translateX(${xOffset}px)` };\n    }, [xOffset]);\n    return {\n        ref: setRef,\n        style,\n    };\n}\n//# sourceMappingURL=use-stay-on-screen.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLW92ZXJsYXktZWRpdG9yL3VzZS1zdGF5LW9uLXNjcmVlbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQUMvQjtBQUNBLG9DQUFvQywyQ0FBYztBQUNsRDtBQUNBO0FBQ087QUFDUDtBQUNBLGtDQUFrQywyQ0FBYztBQUNoRCxnREFBZ0QsMkNBQWM7QUFDOUQsSUFBSSxrREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQiwwQ0FBYTtBQUMvQixpQkFBaUIseUJBQXlCLFFBQVE7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC1vdmVybGF5LWVkaXRvci91c2Utc3RheS1vbi1zY3JlZW4uanM/ZTkzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVJlZlN0YXRlKCkge1xuICAgIGNvbnN0IFtyZWZTdGF0ZSwgc2V0UmVmU3RhdGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgICByZXR1cm4gW3JlZlN0YXRlID8/IHVuZGVmaW5lZCwgc2V0UmVmU3RhdGVdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXlPblNjcmVlbigpIHtcbiAgICBjb25zdCBbcmVmLCBzZXRSZWZdID0gdXNlUmVmU3RhdGUoKTtcbiAgICBjb25zdCBbeE9mZnNldCwgc2V0WE9mZnNldF0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBbaXNJbnRlcnNlY3RpbmcsIHNldElzSW50ZXJzZWN0aW5nXSA9IFJlYWN0LnVzZVN0YXRlKHRydWUpO1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChyZWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEoXCJJbnRlcnNlY3Rpb25PYnNlcnZlclwiIGluIHdpbmRvdykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHMgPT4ge1xuICAgICAgICAgICAgaWYgKGVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNldElzSW50ZXJzZWN0aW5nKGVudHNbMF0uaXNJbnRlcnNlY3RpbmcpO1xuICAgICAgICB9LCB7IHRocmVzaG9sZDogMSB9KTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyZWYpO1xuICAgICAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH0sIFtyZWZdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaXNJbnRlcnNlY3RpbmcgfHwgcmVmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCByYWZIYW5kbGU7XG4gICAgICAgIGNvbnN0IGZuID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyByaWdodDogcmVmUmlnaHQgfSA9IHJlZi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHNldFhPZmZzZXQoY3YgPT4gTWF0aC5taW4oY3YgKyB3aW5kb3cuaW5uZXJXaWR0aCAtIHJlZlJpZ2h0IC0gMTAsIDApKTtcbiAgICAgICAgICAgIHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICAgIH07XG4gICAgICAgIHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmFmSGFuZGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtyZWYsIGlzSW50ZXJzZWN0aW5nXSk7XG4gICAgY29uc3Qgc3R5bGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWCgke3hPZmZzZXR9cHgpYCB9O1xuICAgIH0sIFt4T2Zmc2V0XSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmOiBzZXRSZWYsXG4gICAgICAgIHN0eWxlLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2Utc3RheS1vbi1zY3JlZW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-overlay-editor/use-stay-on-screen.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-search/data-grid-search-style.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-search/data-grid-search-style.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SearchWrapper: () => (/* binding */ SearchWrapper)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\nconst SearchWrapper = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"SearchWrapper\",\n  class: \"gdg-seveqep\",\n  propsAsIs: false\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLXNlYXJjaC9kYXRhLWdyaWQtc2VhcmNoLXN0eWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ2pDLG1DQUFtQyxzREFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLXNlYXJjaC9kYXRhLWdyaWQtc2VhcmNoLXN0eWxlLmpzP2FkNjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgU2VhcmNoV3JhcHBlciA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicpKHtcbiAgbmFtZTogXCJTZWFyY2hXcmFwcGVyXCIsXG4gIGNsYXNzOiBcImdkZy1zZXZlcWVwXCIsXG4gIHByb3BzQXNJczogZmFsc2Vcbn0pO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-search/data-grid-search-style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-search/data-grid-search.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-search/data-grid-search.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data-grid/data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _scrolling_data_grid_scrolling_data_grid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../scrolling-data-grid/scrolling-data-grid.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/scrolling-data-grid.js\");\n/* harmony import */ var _data_grid_search_style_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data-grid-search-style.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-search/data-grid-search-style.js\");\n/* harmony import */ var _common_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n/* eslint-disable unicorn/consistent-destructuring */\n\n\n\n\n\n// icons\nconst upArrow = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { className: \"button-icon\", viewBox: \"0 0 512 512\" },\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { fill: \"none\", stroke: \"currentColor\", strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: \"48\", d: \"M112 244l144-144 144 144M256 120v292\" })));\nconst downArrow = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { className: \"button-icon\", viewBox: \"0 0 512 512\" },\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { fill: \"none\", stroke: \"currentColor\", strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: \"48\", d: \"M112 268l144 144 144-144M256 392V100\" })));\nconst closeX = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { className: \"button-icon\", viewBox: \"0 0 512 512\" },\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { fill: \"none\", stroke: \"currentColor\", strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: \"32\", d: \"M368 368L144 144M368 144L144 368\" })));\nconst targetSearchTimeMS = 10;\nconst DataGridSearch = p => {\n    const { canvasRef, cellYOffset, rows, columns, searchInputRef, searchValue, searchResults: searchResultsIn, onSearchValueChange, getCellsForSelection, onSearchResultsChanged, showSearch = false, onSearchClose, } = p;\n    const [searchID] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => \"search-box-\" + Math.round(Math.random() * 1000));\n    const [searchStringInner, setSearchStringInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"\");\n    const searchString = searchValue ?? searchStringInner;\n    // always emit both, this allows the user to spy on the search value without controlling it.\n    const setSearchString = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newVal) => {\n        setSearchStringInner(newVal);\n        onSearchValueChange?.(newVal);\n    }, [onSearchValueChange]);\n    const [searchStatus, setSearchStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const searchStatusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(searchStatus);\n    searchStatusRef.current = searchStatus;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (searchResultsIn === undefined)\n            return;\n        if (searchResultsIn.length > 0) {\n            setSearchStatus(cv => ({\n                rowsSearched: rows,\n                results: searchResultsIn.length,\n                selectedIndex: cv?.selectedIndex ?? -1,\n            }));\n        }\n        else {\n            setSearchStatus(undefined);\n        }\n    }, [rows, searchResultsIn]);\n    const abortControllerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (abortControllerRef.current === undefined)\n        abortControllerRef.current = new AbortController();\n    const searchHandle = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const [searchResultsInner, setSearchResultsInner] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n    const searchResults = searchResultsIn ?? searchResultsInner;\n    const cancelSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        if (searchHandle.current !== undefined) {\n            window.cancelAnimationFrame(searchHandle.current);\n            searchHandle.current = undefined;\n            abortControllerRef.current.abort();\n        }\n    }, []);\n    const cellYOffsetRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cellYOffset);\n    cellYOffsetRef.current = cellYOffset;\n    const beginSearch = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((str) => {\n        const regex = new RegExp(str.replace(/([$()*+.?[\\\\\\]^{|}-])/g, \"\\\\$1\"), \"i\");\n        let startY = cellYOffsetRef.current;\n        // Lets assume we can do 10 rows at a time\n        // This is usually very safe and limits the damage for bad\n        // performing sheets.\n        let searchStride = Math.min(10, rows);\n        let rowsSearched = 0;\n        setSearchStatus(undefined);\n        setSearchResultsInner([]);\n        const runningResult = [];\n        const tick = async () => {\n            if (getCellsForSelection === undefined)\n                return;\n            const tStart = performance.now();\n            const rowsLeft = rows - rowsSearched;\n            let data = getCellsForSelection({\n                x: 0,\n                y: startY,\n                width: columns.length,\n                height: Math.min(searchStride, rowsLeft, rows - startY),\n            }, abortControllerRef.current.signal);\n            if (typeof data === \"function\") {\n                data = await data();\n            }\n            let added = false;\n            for (const [row, d] of data.entries()) {\n                for (const [col, cell] of d.entries()) {\n                    let testString;\n                    switch (cell.kind) {\n                        case _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Text:\n                        case _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Number:\n                            testString = cell.displayData;\n                            break;\n                        case _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Uri:\n                        case _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Markdown:\n                            testString = cell.data;\n                            break;\n                        case _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Boolean:\n                            testString = typeof cell.data === \"boolean\" ? cell.data.toString() : undefined;\n                            break;\n                        case _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Image:\n                        case _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Bubble:\n                            // I know its lazy, but unless someone is actually\n                            // searching for the whale emoji, this is pretty side effect\n                            // free. And ya know... it's nice and easy to do...\n                            testString = cell.data.join(\"\");\n                            break;\n                        case _data_grid_data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.GridCellKind.Custom:\n                            testString = cell.copyData;\n                            break;\n                    }\n                    if (testString !== undefined && regex.test(testString)) {\n                        runningResult.push([col, row + startY]);\n                        added = true;\n                    }\n                }\n            }\n            const tEnd = performance.now();\n            if (added) {\n                setSearchResultsInner([...runningResult]);\n            }\n            rowsSearched += data.length;\n            (0,_common_support_js__WEBPACK_IMPORTED_MODULE_2__.assert)(rowsSearched <= rows);\n            const selectedIndex = searchStatusRef.current?.selectedIndex ?? -1;\n            setSearchStatus({\n                results: runningResult.length,\n                rowsSearched,\n                selectedIndex,\n            });\n            onSearchResultsChanged?.(runningResult, selectedIndex);\n            if (startY + searchStride >= rows) {\n                startY = 0;\n            }\n            else {\n                startY += searchStride;\n            }\n            const tElapsed = tEnd - tStart;\n            const rounded = Math.max(tElapsed, 1);\n            const scalar = targetSearchTimeMS / rounded;\n            searchStride = Math.ceil(searchStride * scalar);\n            if (rowsSearched < rows && runningResult.length < 1000) {\n                searchHandle.current = window.requestAnimationFrame(tick);\n            }\n        };\n        cancelSearch();\n        searchHandle.current = window.requestAnimationFrame(tick);\n    }, [cancelSearch, columns.length, getCellsForSelection, onSearchResultsChanged, rows]);\n    const onClose = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        onSearchClose?.();\n        setSearchStatus(undefined);\n        setSearchResultsInner([]);\n        onSearchResultsChanged?.([], -1);\n        cancelSearch();\n        canvasRef?.current?.focus();\n    }, [cancelSearch, canvasRef, onSearchClose, onSearchResultsChanged]);\n    const onSearchChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {\n        setSearchString(event.target.value);\n        if (searchResultsIn !== undefined)\n            return;\n        if (event.target.value === \"\") {\n            setSearchStatus(undefined);\n            setSearchResultsInner([]);\n            cancelSearch();\n        }\n        else {\n            beginSearch(event.target.value);\n        }\n    }, [beginSearch, cancelSearch, setSearchString, searchResultsIn]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (showSearch && searchInputRef.current !== null) {\n            setSearchString(\"\");\n            searchInputRef.current.focus({ preventScroll: true });\n        }\n    }, [showSearch, searchInputRef, setSearchString]);\n    const onNext = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((ev) => {\n        ev?.stopPropagation?.();\n        if (searchStatus === undefined)\n            return;\n        const newIndex = (searchStatus.selectedIndex + 1) % searchStatus.results;\n        setSearchStatus({\n            ...searchStatus,\n            selectedIndex: newIndex,\n        });\n        onSearchResultsChanged?.(searchResults, newIndex);\n    }, [searchStatus, onSearchResultsChanged, searchResults]);\n    const onPrev = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((ev) => {\n        ev?.stopPropagation?.();\n        if (searchStatus === undefined)\n            return;\n        let newIndex = (searchStatus.selectedIndex - 1) % searchStatus.results;\n        if (newIndex < 0)\n            newIndex += searchStatus.results;\n        setSearchStatus({\n            ...searchStatus,\n            selectedIndex: newIndex,\n        });\n        onSearchResultsChanged?.(searchResults, newIndex);\n    }, [onSearchResultsChanged, searchResults, searchStatus]);\n    const onSearchKeyDown = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {\n        if (((event.ctrlKey || event.metaKey) && event.nativeEvent.code === \"KeyF\") || event.key === \"Escape\") {\n            onClose();\n            event.stopPropagation();\n            event.preventDefault();\n        }\n        else if (event.key === \"Enter\") {\n            if (event.shiftKey) {\n                onPrev();\n            }\n            else {\n                onNext();\n            }\n        }\n    }, [onClose, onNext, onPrev]);\n    // cancel search if the component is unmounted\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        return () => {\n            cancelSearch();\n        };\n    }, [cancelSearch]);\n    const [isAnimatingOut, setIsAnimatingOut] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (showSearch) {\n            setIsAnimatingOut(true);\n        }\n        else {\n            const timeoutId = setTimeout(() => setIsAnimatingOut(false), 150);\n            return () => clearTimeout(timeoutId);\n        }\n    }, [showSearch]);\n    const searchbox = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (!showSearch && !isAnimatingOut) {\n            return null;\n        }\n        let resultString;\n        if (searchStatus !== undefined) {\n            resultString =\n                searchStatus.results >= 1000\n                    ? `over 1000`\n                    : `${searchStatus.results} result${searchStatus.results !== 1 ? \"s\" : \"\"}`;\n            if (searchStatus.selectedIndex >= 0) {\n                resultString = `${searchStatus.selectedIndex + 1} of ${resultString}`;\n            }\n        }\n        const cancelEvent = (ev) => {\n            ev.stopPropagation();\n        };\n        const rowsSearchedProgress = Math.floor(((searchStatus?.rowsSearched ?? 0) / rows) * 100);\n        const progressStyle = {\n            width: `${rowsSearchedProgress}%`,\n        };\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid_search_style_js__WEBPACK_IMPORTED_MODULE_3__.SearchWrapper, { className: showSearch ? \"\" : \"out\", onMouseDown: cancelEvent, onMouseMove: cancelEvent, onMouseUp: cancelEvent, onClick: cancelEvent },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"gdg-search-bar-inner\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"input\", { id: searchID, \"aria-hidden\": !showSearch, \"data-testid\": \"search-input\", ref: searchInputRef, onChange: onSearchChange, value: searchString, tabIndex: showSearch ? undefined : -1, onKeyDownCapture: onSearchKeyDown }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { \"aria-label\": \"Previous Result\", \"aria-hidden\": !showSearch, tabIndex: showSearch ? undefined : -1, onClick: onPrev, disabled: (searchStatus?.results ?? 0) === 0 }, upArrow),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { \"aria-label\": \"Next Result\", \"aria-hidden\": !showSearch, tabIndex: showSearch ? undefined : -1, onClick: onNext, disabled: (searchStatus?.results ?? 0) === 0 }, downArrow),\n                onSearchClose !== undefined && (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { \"aria-label\": \"Close Search\", \"aria-hidden\": !showSearch, \"data-testid\": \"search-close-button\", tabIndex: showSearch ? undefined : -1, onClick: onClose }, closeX))),\n            searchStatus !== undefined ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"gdg-search-status\" },\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { \"data-testid\": \"search-result-area\" }, resultString)),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"gdg-search-progress\", style: progressStyle }))) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"gdg-search-status\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"label\", { htmlFor: searchID }, \"Type to search\")))));\n    }, [\n        showSearch,\n        isAnimatingOut,\n        searchStatus,\n        rows,\n        searchID,\n        searchInputRef,\n        onSearchChange,\n        searchString,\n        onSearchKeyDown,\n        onPrev,\n        onNext,\n        onSearchClose,\n        onClose,\n    ]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_scrolling_data_grid_scrolling_data_grid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { prelightCells: searchResults, accessibilityHeight: p.accessibilityHeight, canvasRef: p.canvasRef, cellXOffset: p.cellXOffset, cellYOffset: p.cellYOffset, className: p.className, clientSize: p.clientSize, columns: p.columns, disabledRows: p.disabledRows, enableGroups: p.enableGroups, fillHandle: p.fillHandle, firstColAccessible: p.firstColAccessible, nonGrowWidth: p.nonGrowWidth, fixedShadowX: p.fixedShadowX, fixedShadowY: p.fixedShadowY, freezeColumns: p.freezeColumns, getCellContent: p.getCellContent, getCellRenderer: p.getCellRenderer, getGroupDetails: p.getGroupDetails, getRowThemeOverride: p.getRowThemeOverride, groupHeaderHeight: p.groupHeaderHeight, headerHeight: p.headerHeight, highlightRegions: p.highlightRegions, imageWindowLoader: p.imageWindowLoader, initialSize: p.initialSize, isFilling: p.isFilling, isFocused: p.isFocused, lockColumns: p.lockColumns, maxColumnWidth: p.maxColumnWidth, minColumnWidth: p.minColumnWidth, onHeaderMenuClick: p.onHeaderMenuClick, onMouseMove: p.onMouseMove, onVisibleRegionChanged: p.onVisibleRegionChanged, overscrollX: p.overscrollX, overscrollY: p.overscrollY, preventDiagonalScrolling: p.preventDiagonalScrolling, rightElement: p.rightElement, rightElementProps: p.rightElementProps, rowHeight: p.rowHeight, rows: p.rows, scrollRef: p.scrollRef, selection: p.selection, theme: p.theme, freezeTrailingRows: p.freezeTrailingRows, hasAppendRow: p.hasAppendRow, translateX: p.translateX, translateY: p.translateY, verticalBorder: p.verticalBorder, onColumnProposeMove: p.onColumnProposeMove, drawFocusRing: p.drawFocusRing, drawCell: p.drawCell, drawHeader: p.drawHeader, experimental: p.experimental, gridRef: p.gridRef, headerIcons: p.headerIcons, isDraggable: p.isDraggable, onCanvasBlur: p.onCanvasBlur, onCanvasFocused: p.onCanvasFocused, onCellFocused: p.onCellFocused, onColumnMoved: p.onColumnMoved, onColumnResize: p.onColumnResize, onColumnResizeEnd: p.onColumnResizeEnd, onColumnResizeStart: p.onColumnResizeStart, onContextMenu: p.onContextMenu, onDragEnd: p.onDragEnd, onDragLeave: p.onDragLeave, onDragOverCell: p.onDragOverCell, onDragStart: p.onDragStart, onDrop: p.onDrop, onItemHovered: p.onItemHovered, onKeyDown: p.onKeyDown, onKeyUp: p.onKeyUp, onMouseDown: p.onMouseDown, onMouseUp: p.onMouseUp, onRowMoved: p.onRowMoved, smoothScrollX: p.smoothScrollX, smoothScrollY: p.smoothScrollY }),\n        searchbox));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataGridSearch);\n//# sourceMappingURL=data-grid-search.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkLXNlYXJjaC9kYXRhLWdyaWQtc2VhcmNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQytCO0FBQ2lDO0FBQ2tCO0FBQ3RCO0FBQ1g7QUFDakQ7QUFDQSxpQkFBaUIsZ0RBQW1CLFVBQVUsa0RBQWtEO0FBQ2hHLElBQUksZ0RBQW1CLFdBQVcscUpBQXFKO0FBQ3ZMLG1CQUFtQixnREFBbUIsVUFBVSxrREFBa0Q7QUFDbEcsSUFBSSxnREFBbUIsV0FBVyxxSkFBcUo7QUFDdkwsZ0JBQWdCLGdEQUFtQixVQUFVLGtEQUFrRDtBQUMvRixJQUFJLGdEQUFtQixXQUFXLGlKQUFpSjtBQUNuTDtBQUNBO0FBQ0EsWUFBWSw0TUFBNE07QUFDeE4sdUJBQXVCLDJDQUFjO0FBQ3JDLHNEQUFzRCwyQ0FBYztBQUNwRTtBQUNBO0FBQ0EsNEJBQTRCLDhDQUFpQjtBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMLDRDQUE0QywyQ0FBYztBQUMxRCw0QkFBNEIseUNBQVk7QUFDeEM7QUFDQSxJQUFJLDRDQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQix5Q0FBWTtBQUMzQztBQUNBO0FBQ0EseUJBQXlCLHlDQUFZO0FBQ3JDLHdEQUF3RCwyQ0FBYztBQUN0RTtBQUNBLHlCQUF5Qiw4Q0FBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIseUNBQVk7QUFDdkM7QUFDQSx3QkFBd0IsOENBQWlCO0FBQ3pDLDhEQUE4RCxFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUVBQVk7QUFDekMsNkJBQTZCLHVFQUFZO0FBQ3pDO0FBQ0E7QUFDQSw2QkFBNkIsdUVBQVk7QUFDekMsNkJBQTZCLHVFQUFZO0FBQ3pDO0FBQ0E7QUFDQSw2QkFBNkIsdUVBQVk7QUFDekM7QUFDQTtBQUNBLDZCQUE2Qix1RUFBWTtBQUN6Qyw2QkFBNkIsdUVBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1RUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLDhDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLDhDQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLDhDQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsOENBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsOENBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0RBQWdELDJDQUFjO0FBQzlELElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLDBDQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCLFFBQVEsc0NBQXNDO0FBQzdGO0FBQ0Esa0NBQWtDLGdDQUFnQyxLQUFLLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0EsZ0JBQWdCLGdEQUFtQixDQUFDLHFFQUFhLElBQUksc0lBQXNJO0FBQzNMLFlBQVksZ0RBQW1CLFVBQVUsbUNBQW1DO0FBQzVFLGdCQUFnQixnREFBbUIsWUFBWSx1TkFBdU47QUFDdFEsZ0JBQWdCLGdEQUFtQixhQUFhLG1LQUFtSztBQUNuTixnQkFBZ0IsZ0RBQW1CLGFBQWEsK0pBQStKO0FBQy9NLGdEQUFnRCxnREFBbUIsYUFBYSx5SkFBeUo7QUFDek8sMENBQTBDLGdEQUFtQixDQUFDLDJDQUFjO0FBQzVFLGdCQUFnQixnREFBbUIsVUFBVSxnQ0FBZ0M7QUFDN0Usb0JBQW9CLGdEQUFtQixVQUFVLHFDQUFxQztBQUN0RixnQkFBZ0IsZ0RBQW1CLFVBQVUsd0RBQXdELE9BQU8sZ0RBQW1CLFVBQVUsZ0NBQWdDO0FBQ3pLLGdCQUFnQixnREFBbUIsWUFBWSxtQkFBbUI7QUFDbEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFtQixDQUFDLDJDQUFjO0FBQzlDLFFBQVEsZ0RBQW1CLENBQUMsbUZBQWlCLElBQUksMHpFQUEwekU7QUFDMzJFO0FBQ0E7QUFDQSxpRUFBZSxjQUFjLEVBQUM7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQtc2VhcmNoL2RhdGEtZ3JpZC1zZWFyY2guanM/ZTI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSB1bmljb3JuL2NvbnNpc3RlbnQtZGVzdHJ1Y3R1cmluZyAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBHcmlkQ2VsbEtpbmQsIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmltcG9ydCBTY3JvbGxpbmdEYXRhR3JpZCwge30gZnJvbSBcIi4uL3Njcm9sbGluZy1kYXRhLWdyaWQvc2Nyb2xsaW5nLWRhdGEtZ3JpZC5qc1wiO1xuaW1wb3J0IHsgU2VhcmNoV3JhcHBlciB9IGZyb20gXCIuL2RhdGEtZ3JpZC1zZWFyY2gtc3R5bGUuanNcIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuLi8uLi9jb21tb24vc3VwcG9ydC5qc1wiO1xuLy8gaWNvbnNcbmNvbnN0IHVwQXJyb3cgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IGNsYXNzTmFtZTogXCJidXR0b24taWNvblwiLCB2aWV3Qm94OiBcIjAgMCA1MTIgNTEyXCIgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgc3Ryb2tlV2lkdGg6IFwiNDhcIiwgZDogXCJNMTEyIDI0NGwxNDQtMTQ0IDE0NCAxNDRNMjU2IDEyMHYyOTJcIiB9KSkpO1xuY29uc3QgZG93bkFycm93ID0gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyBjbGFzc05hbWU6IFwiYnV0dG9uLWljb25cIiwgdmlld0JveDogXCIwIDAgNTEyIDUxMlwiIH0sXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHN0cm9rZVdpZHRoOiBcIjQ4XCIsIGQ6IFwiTTExMiAyNjhsMTQ0IDE0NCAxNDQtMTQ0TTI1NiAzOTJWMTAwXCIgfSkpKTtcbmNvbnN0IGNsb3NlWCA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgY2xhc3NOYW1lOiBcImJ1dHRvbi1pY29uXCIsIHZpZXdCb3g6IFwiMCAwIDUxMiA1MTJcIiB9LFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLCBzdHJva2VXaWR0aDogXCIzMlwiLCBkOiBcIk0zNjggMzY4TDE0NCAxNDRNMzY4IDE0NEwxNDQgMzY4XCIgfSkpKTtcbmNvbnN0IHRhcmdldFNlYXJjaFRpbWVNUyA9IDEwO1xuY29uc3QgRGF0YUdyaWRTZWFyY2ggPSBwID0+IHtcbiAgICBjb25zdCB7IGNhbnZhc1JlZiwgY2VsbFlPZmZzZXQsIHJvd3MsIGNvbHVtbnMsIHNlYXJjaElucHV0UmVmLCBzZWFyY2hWYWx1ZSwgc2VhcmNoUmVzdWx0czogc2VhcmNoUmVzdWx0c0luLCBvblNlYXJjaFZhbHVlQ2hhbmdlLCBnZXRDZWxsc0ZvclNlbGVjdGlvbiwgb25TZWFyY2hSZXN1bHRzQ2hhbmdlZCwgc2hvd1NlYXJjaCA9IGZhbHNlLCBvblNlYXJjaENsb3NlLCB9ID0gcDtcbiAgICBjb25zdCBbc2VhcmNoSURdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gXCJzZWFyY2gtYm94LVwiICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMCkpO1xuICAgIGNvbnN0IFtzZWFyY2hTdHJpbmdJbm5lciwgc2V0U2VhcmNoU3RyaW5nSW5uZXJdID0gUmVhY3QudXNlU3RhdGUoXCJcIik7XG4gICAgY29uc3Qgc2VhcmNoU3RyaW5nID0gc2VhcmNoVmFsdWUgPz8gc2VhcmNoU3RyaW5nSW5uZXI7XG4gICAgLy8gYWx3YXlzIGVtaXQgYm90aCwgdGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gc3B5IG9uIHRoZSBzZWFyY2ggdmFsdWUgd2l0aG91dCBjb250cm9sbGluZyBpdC5cbiAgICBjb25zdCBzZXRTZWFyY2hTdHJpbmcgPSBSZWFjdC51c2VDYWxsYmFjaygobmV3VmFsKSA9PiB7XG4gICAgICAgIHNldFNlYXJjaFN0cmluZ0lubmVyKG5ld1ZhbCk7XG4gICAgICAgIG9uU2VhcmNoVmFsdWVDaGFuZ2U/LihuZXdWYWwpO1xuICAgIH0sIFtvblNlYXJjaFZhbHVlQ2hhbmdlXSk7XG4gICAgY29uc3QgW3NlYXJjaFN0YXR1cywgc2V0U2VhcmNoU3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgY29uc3Qgc2VhcmNoU3RhdHVzUmVmID0gUmVhY3QudXNlUmVmKHNlYXJjaFN0YXR1cyk7XG4gICAgc2VhcmNoU3RhdHVzUmVmLmN1cnJlbnQgPSBzZWFyY2hTdGF0dXM7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNlYXJjaFJlc3VsdHNJbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoc2VhcmNoUmVzdWx0c0luLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNldFNlYXJjaFN0YXR1cyhjdiA9PiAoe1xuICAgICAgICAgICAgICAgIHJvd3NTZWFyY2hlZDogcm93cyxcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBzZWFyY2hSZXN1bHRzSW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXg6IGN2Py5zZWxlY3RlZEluZGV4ID8/IC0xLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VhcmNoU3RhdHVzKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9LCBbcm93cywgc2VhcmNoUmVzdWx0c0luXSk7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNlYXJjaEhhbmRsZSA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGNvbnN0IFtzZWFyY2hSZXN1bHRzSW5uZXIsIHNldFNlYXJjaFJlc3VsdHNJbm5lcl0gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gICAgY29uc3Qgc2VhcmNoUmVzdWx0cyA9IHNlYXJjaFJlc3VsdHNJbiA/PyBzZWFyY2hSZXN1bHRzSW5uZXI7XG4gICAgY29uc3QgY2FuY2VsU2VhcmNoID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAoc2VhcmNoSGFuZGxlLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHNlYXJjaEhhbmRsZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHNlYXJjaEhhbmRsZS5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBjZWxsWU9mZnNldFJlZiA9IFJlYWN0LnVzZVJlZihjZWxsWU9mZnNldCk7XG4gICAgY2VsbFlPZmZzZXRSZWYuY3VycmVudCA9IGNlbGxZT2Zmc2V0O1xuICAgIGNvbnN0IGJlZ2luU2VhcmNoID0gUmVhY3QudXNlQ2FsbGJhY2soKHN0cikgPT4ge1xuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoc3RyLnJlcGxhY2UoLyhbJCgpKisuP1tcXFxcXFxdXnt8fS1dKS9nLCBcIlxcXFwkMVwiKSwgXCJpXCIpO1xuICAgICAgICBsZXQgc3RhcnRZID0gY2VsbFlPZmZzZXRSZWYuY3VycmVudDtcbiAgICAgICAgLy8gTGV0cyBhc3N1bWUgd2UgY2FuIGRvIDEwIHJvd3MgYXQgYSB0aW1lXG4gICAgICAgIC8vIFRoaXMgaXMgdXN1YWxseSB2ZXJ5IHNhZmUgYW5kIGxpbWl0cyB0aGUgZGFtYWdlIGZvciBiYWRcbiAgICAgICAgLy8gcGVyZm9ybWluZyBzaGVldHMuXG4gICAgICAgIGxldCBzZWFyY2hTdHJpZGUgPSBNYXRoLm1pbigxMCwgcm93cyk7XG4gICAgICAgIGxldCByb3dzU2VhcmNoZWQgPSAwO1xuICAgICAgICBzZXRTZWFyY2hTdGF0dXModW5kZWZpbmVkKTtcbiAgICAgICAgc2V0U2VhcmNoUmVzdWx0c0lubmVyKFtdKTtcbiAgICAgICAgY29uc3QgcnVubmluZ1Jlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCB0aWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGdldENlbGxzRm9yU2VsZWN0aW9uID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdFN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBjb25zdCByb3dzTGVmdCA9IHJvd3MgLSByb3dzU2VhcmNoZWQ7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGdldENlbGxzRm9yU2VsZWN0aW9uKHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IHN0YXJ0WSxcbiAgICAgICAgICAgICAgICB3aWR0aDogY29sdW1ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihzZWFyY2hTdHJpZGUsIHJvd3NMZWZ0LCByb3dzIC0gc3RhcnRZKSxcbiAgICAgICAgICAgIH0sIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LnNpZ25hbCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCBkYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3JvdywgZF0gb2YgZGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjb2wsIGNlbGxdIG9mIGQuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXN0U3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNlbGwua2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuVGV4dDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk51bWJlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0U3RyaW5nID0gY2VsbC5kaXNwbGF5RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLlVyaTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgR3JpZENlbGxLaW5kLk1hcmtkb3duOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RTdHJpbmcgPSBjZWxsLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5Cb29sZWFuOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RTdHJpbmcgPSB0eXBlb2YgY2VsbC5kYXRhID09PSBcImJvb2xlYW5cIiA/IGNlbGwuZGF0YS50b1N0cmluZygpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuSW1hZ2U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEdyaWRDZWxsS2luZC5CdWJibGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSSBrbm93IGl0cyBsYXp5LCBidXQgdW5sZXNzIHNvbWVvbmUgaXMgYWN0dWFsbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWFyY2hpbmcgZm9yIHRoZSB3aGFsZSBlbW9qaSwgdGhpcyBpcyBwcmV0dHkgc2lkZSBlZmZlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmVlLiBBbmQgeWEga25vdy4uLiBpdCdzIG5pY2UgYW5kIGVhc3kgdG8gZG8uLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0U3RyaW5nID0gY2VsbC5kYXRhLmpvaW4oXCLwn5CzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBHcmlkQ2VsbEtpbmQuQ3VzdG9tOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RTdHJpbmcgPSBjZWxsLmNvcHlEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0U3RyaW5nICE9PSB1bmRlZmluZWQgJiYgcmVnZXgudGVzdCh0ZXN0U3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1Jlc3VsdC5wdXNoKFtjb2wsIHJvdyArIHN0YXJ0WV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdEVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgaWYgKGFkZGVkKSB7XG4gICAgICAgICAgICAgICAgc2V0U2VhcmNoUmVzdWx0c0lubmVyKFsuLi5ydW5uaW5nUmVzdWx0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzU2VhcmNoZWQgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBhc3NlcnQocm93c1NlYXJjaGVkIDw9IHJvd3MpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IHNlYXJjaFN0YXR1c1JlZi5jdXJyZW50Py5zZWxlY3RlZEluZGV4ID8/IC0xO1xuICAgICAgICAgICAgc2V0U2VhcmNoU3RhdHVzKHtcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBydW5uaW5nUmVzdWx0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICByb3dzU2VhcmNoZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb25TZWFyY2hSZXN1bHRzQ2hhbmdlZD8uKHJ1bm5pbmdSZXN1bHQsIHNlbGVjdGVkSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0WSArIHNlYXJjaFN0cmlkZSA+PSByb3dzKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0WSArPSBzZWFyY2hTdHJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0RWxhcHNlZCA9IHRFbmQgLSB0U3RhcnQ7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkID0gTWF0aC5tYXgodEVsYXBzZWQsIDEpO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gdGFyZ2V0U2VhcmNoVGltZU1TIC8gcm91bmRlZDtcbiAgICAgICAgICAgIHNlYXJjaFN0cmlkZSA9IE1hdGguY2VpbChzZWFyY2hTdHJpZGUgKiBzY2FsYXIpO1xuICAgICAgICAgICAgaWYgKHJvd3NTZWFyY2hlZCA8IHJvd3MgJiYgcnVubmluZ1Jlc3VsdC5sZW5ndGggPCAxMDAwKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoSGFuZGxlLmN1cnJlbnQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYW5jZWxTZWFyY2goKTtcbiAgICAgICAgc2VhcmNoSGFuZGxlLmN1cnJlbnQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgIH0sIFtjYW5jZWxTZWFyY2gsIGNvbHVtbnMubGVuZ3RoLCBnZXRDZWxsc0ZvclNlbGVjdGlvbiwgb25TZWFyY2hSZXN1bHRzQ2hhbmdlZCwgcm93c10pO1xuICAgIGNvbnN0IG9uQ2xvc2UgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIG9uU2VhcmNoQ2xvc2U/LigpO1xuICAgICAgICBzZXRTZWFyY2hTdGF0dXModW5kZWZpbmVkKTtcbiAgICAgICAgc2V0U2VhcmNoUmVzdWx0c0lubmVyKFtdKTtcbiAgICAgICAgb25TZWFyY2hSZXN1bHRzQ2hhbmdlZD8uKFtdLCAtMSk7XG4gICAgICAgIGNhbmNlbFNlYXJjaCgpO1xuICAgICAgICBjYW52YXNSZWY/LmN1cnJlbnQ/LmZvY3VzKCk7XG4gICAgfSwgW2NhbmNlbFNlYXJjaCwgY2FudmFzUmVmLCBvblNlYXJjaENsb3NlLCBvblNlYXJjaFJlc3VsdHNDaGFuZ2VkXSk7XG4gICAgY29uc3Qgb25TZWFyY2hDaGFuZ2UgPSBSZWFjdC51c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgc2V0U2VhcmNoU3RyaW5nKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgIGlmIChzZWFyY2hSZXN1bHRzSW4gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgc2V0U2VhcmNoU3RhdHVzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBzZXRTZWFyY2hSZXN1bHRzSW5uZXIoW10pO1xuICAgICAgICAgICAgY2FuY2VsU2VhcmNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZWdpblNlYXJjaChldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW2JlZ2luU2VhcmNoLCBjYW5jZWxTZWFyY2gsIHNldFNlYXJjaFN0cmluZywgc2VhcmNoUmVzdWx0c0luXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNob3dTZWFyY2ggJiYgc2VhcmNoSW5wdXRSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U2VhcmNoU3RyaW5nKFwiXCIpO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXRSZWYuY3VycmVudC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbc2hvd1NlYXJjaCwgc2VhcmNoSW5wdXRSZWYsIHNldFNlYXJjaFN0cmluZ10pO1xuICAgIGNvbnN0IG9uTmV4dCA9IFJlYWN0LnVzZUNhbGxiYWNrKChldikgPT4ge1xuICAgICAgICBldj8uc3RvcFByb3BhZ2F0aW9uPy4oKTtcbiAgICAgICAgaWYgKHNlYXJjaFN0YXR1cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IChzZWFyY2hTdGF0dXMuc2VsZWN0ZWRJbmRleCArIDEpICUgc2VhcmNoU3RhdHVzLnJlc3VsdHM7XG4gICAgICAgIHNldFNlYXJjaFN0YXR1cyh7XG4gICAgICAgICAgICAuLi5zZWFyY2hTdGF0dXMsXG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4OiBuZXdJbmRleCxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VhcmNoUmVzdWx0c0NoYW5nZWQ/LihzZWFyY2hSZXN1bHRzLCBuZXdJbmRleCk7XG4gICAgfSwgW3NlYXJjaFN0YXR1cywgb25TZWFyY2hSZXN1bHRzQ2hhbmdlZCwgc2VhcmNoUmVzdWx0c10pO1xuICAgIGNvbnN0IG9uUHJldiA9IFJlYWN0LnVzZUNhbGxiYWNrKChldikgPT4ge1xuICAgICAgICBldj8uc3RvcFByb3BhZ2F0aW9uPy4oKTtcbiAgICAgICAgaWYgKHNlYXJjaFN0YXR1cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbmV3SW5kZXggPSAoc2VhcmNoU3RhdHVzLnNlbGVjdGVkSW5kZXggLSAxKSAlIHNlYXJjaFN0YXR1cy5yZXN1bHRzO1xuICAgICAgICBpZiAobmV3SW5kZXggPCAwKVxuICAgICAgICAgICAgbmV3SW5kZXggKz0gc2VhcmNoU3RhdHVzLnJlc3VsdHM7XG4gICAgICAgIHNldFNlYXJjaFN0YXR1cyh7XG4gICAgICAgICAgICAuLi5zZWFyY2hTdGF0dXMsXG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4OiBuZXdJbmRleCxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VhcmNoUmVzdWx0c0NoYW5nZWQ/LihzZWFyY2hSZXN1bHRzLCBuZXdJbmRleCk7XG4gICAgfSwgW29uU2VhcmNoUmVzdWx0c0NoYW5nZWQsIHNlYXJjaFJlc3VsdHMsIHNlYXJjaFN0YXR1c10pO1xuICAgIGNvbnN0IG9uU2VhcmNoS2V5RG93biA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBpZiAoKChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICYmIGV2ZW50Lm5hdGl2ZUV2ZW50LmNvZGUgPT09IFwiS2V5RlwiKSB8fCBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgb25QcmV2KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbk5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtvbkNsb3NlLCBvbk5leHQsIG9uUHJldl0pO1xuICAgIC8vIGNhbmNlbCBzZWFyY2ggaWYgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWRcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2FuY2VsU2VhcmNoKCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NhbmNlbFNlYXJjaF0pO1xuICAgIGNvbnN0IFtpc0FuaW1hdGluZ091dCwgc2V0SXNBbmltYXRpbmdPdXRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaG93U2VhcmNoKSB7XG4gICAgICAgICAgICBzZXRJc0FuaW1hdGluZ091dCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0SXNBbmltYXRpbmdPdXQoZmFsc2UpLCAxNTApO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgfSwgW3Nob3dTZWFyY2hdKTtcbiAgICBjb25zdCBzZWFyY2hib3ggPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFzaG93U2VhcmNoICYmICFpc0FuaW1hdGluZ091dCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdFN0cmluZztcbiAgICAgICAgaWYgKHNlYXJjaFN0YXR1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRTdHJpbmcgPVxuICAgICAgICAgICAgICAgIHNlYXJjaFN0YXR1cy5yZXN1bHRzID49IDEwMDBcbiAgICAgICAgICAgICAgICAgICAgPyBgb3ZlciAxMDAwYFxuICAgICAgICAgICAgICAgICAgICA6IGAke3NlYXJjaFN0YXR1cy5yZXN1bHRzfSByZXN1bHQke3NlYXJjaFN0YXR1cy5yZXN1bHRzICE9PSAxID8gXCJzXCIgOiBcIlwifWA7XG4gICAgICAgICAgICBpZiAoc2VhcmNoU3RhdHVzLnNlbGVjdGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFN0cmluZyA9IGAke3NlYXJjaFN0YXR1cy5zZWxlY3RlZEluZGV4ICsgMX0gb2YgJHtyZXN1bHRTdHJpbmd9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5jZWxFdmVudCA9IChldikgPT4ge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvd3NTZWFyY2hlZFByb2dyZXNzID0gTWF0aC5mbG9vcigoKHNlYXJjaFN0YXR1cz8ucm93c1NlYXJjaGVkID8/IDApIC8gcm93cykgKiAxMDApO1xuICAgICAgICBjb25zdCBwcm9ncmVzc1N0eWxlID0ge1xuICAgICAgICAgICAgd2lkdGg6IGAke3Jvd3NTZWFyY2hlZFByb2dyZXNzfSVgLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2VhcmNoV3JhcHBlciwgeyBjbGFzc05hbWU6IHNob3dTZWFyY2ggPyBcIlwiIDogXCJvdXRcIiwgb25Nb3VzZURvd246IGNhbmNlbEV2ZW50LCBvbk1vdXNlTW92ZTogY2FuY2VsRXZlbnQsIG9uTW91c2VVcDogY2FuY2VsRXZlbnQsIG9uQ2xpY2s6IGNhbmNlbEV2ZW50IH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImdkZy1zZWFyY2gtYmFyLWlubmVyXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgeyBpZDogc2VhcmNoSUQsIFwiYXJpYS1oaWRkZW5cIjogIXNob3dTZWFyY2gsIFwiZGF0YS10ZXN0aWRcIjogXCJzZWFyY2gtaW5wdXRcIiwgcmVmOiBzZWFyY2hJbnB1dFJlZiwgb25DaGFuZ2U6IG9uU2VhcmNoQ2hhbmdlLCB2YWx1ZTogc2VhcmNoU3RyaW5nLCB0YWJJbmRleDogc2hvd1NlYXJjaCA/IHVuZGVmaW5lZCA6IC0xLCBvbktleURvd25DYXB0dXJlOiBvblNlYXJjaEtleURvd24gfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IFwiYXJpYS1sYWJlbFwiOiBcIlByZXZpb3VzIFJlc3VsdFwiLCBcImFyaWEtaGlkZGVuXCI6ICFzaG93U2VhcmNoLCB0YWJJbmRleDogc2hvd1NlYXJjaCA/IHVuZGVmaW5lZCA6IC0xLCBvbkNsaWNrOiBvblByZXYsIGRpc2FibGVkOiAoc2VhcmNoU3RhdHVzPy5yZXN1bHRzID8/IDApID09PSAwIH0sIHVwQXJyb3cpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBcImFyaWEtbGFiZWxcIjogXCJOZXh0IFJlc3VsdFwiLCBcImFyaWEtaGlkZGVuXCI6ICFzaG93U2VhcmNoLCB0YWJJbmRleDogc2hvd1NlYXJjaCA/IHVuZGVmaW5lZCA6IC0xLCBvbkNsaWNrOiBvbk5leHQsIGRpc2FibGVkOiAoc2VhcmNoU3RhdHVzPy5yZXN1bHRzID8/IDApID09PSAwIH0sIGRvd25BcnJvdyksXG4gICAgICAgICAgICAgICAgb25TZWFyY2hDbG9zZSAhPT0gdW5kZWZpbmVkICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgXCJhcmlhLWxhYmVsXCI6IFwiQ2xvc2UgU2VhcmNoXCIsIFwiYXJpYS1oaWRkZW5cIjogIXNob3dTZWFyY2gsIFwiZGF0YS10ZXN0aWRcIjogXCJzZWFyY2gtY2xvc2UtYnV0dG9uXCIsIHRhYkluZGV4OiBzaG93U2VhcmNoID8gdW5kZWZpbmVkIDogLTEsIG9uQ2xpY2s6IG9uQ2xvc2UgfSwgY2xvc2VYKSkpLFxuICAgICAgICAgICAgc2VhcmNoU3RhdHVzICE9PSB1bmRlZmluZWQgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImdkZy1zZWFyY2gtc3RhdHVzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS10ZXN0aWRcIjogXCJzZWFyY2gtcmVzdWx0LWFyZWFcIiB9LCByZXN1bHRTdHJpbmcpKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImdkZy1zZWFyY2gtcHJvZ3Jlc3NcIiwgc3R5bGU6IHByb2dyZXNzU3R5bGUgfSkpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImdkZy1zZWFyY2gtc3RhdHVzXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIiwgeyBodG1sRm9yOiBzZWFyY2hJRCB9LCBcIlR5cGUgdG8gc2VhcmNoXCIpKSkpKTtcbiAgICB9LCBbXG4gICAgICAgIHNob3dTZWFyY2gsXG4gICAgICAgIGlzQW5pbWF0aW5nT3V0LFxuICAgICAgICBzZWFyY2hTdGF0dXMsXG4gICAgICAgIHJvd3MsXG4gICAgICAgIHNlYXJjaElELFxuICAgICAgICBzZWFyY2hJbnB1dFJlZixcbiAgICAgICAgb25TZWFyY2hDaGFuZ2UsXG4gICAgICAgIHNlYXJjaFN0cmluZyxcbiAgICAgICAgb25TZWFyY2hLZXlEb3duLFxuICAgICAgICBvblByZXYsXG4gICAgICAgIG9uTmV4dCxcbiAgICAgICAgb25TZWFyY2hDbG9zZSxcbiAgICAgICAgb25DbG9zZSxcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2Nyb2xsaW5nRGF0YUdyaWQsIHsgcHJlbGlnaHRDZWxsczogc2VhcmNoUmVzdWx0cywgYWNjZXNzaWJpbGl0eUhlaWdodDogcC5hY2Nlc3NpYmlsaXR5SGVpZ2h0LCBjYW52YXNSZWY6IHAuY2FudmFzUmVmLCBjZWxsWE9mZnNldDogcC5jZWxsWE9mZnNldCwgY2VsbFlPZmZzZXQ6IHAuY2VsbFlPZmZzZXQsIGNsYXNzTmFtZTogcC5jbGFzc05hbWUsIGNsaWVudFNpemU6IHAuY2xpZW50U2l6ZSwgY29sdW1uczogcC5jb2x1bW5zLCBkaXNhYmxlZFJvd3M6IHAuZGlzYWJsZWRSb3dzLCBlbmFibGVHcm91cHM6IHAuZW5hYmxlR3JvdXBzLCBmaWxsSGFuZGxlOiBwLmZpbGxIYW5kbGUsIGZpcnN0Q29sQWNjZXNzaWJsZTogcC5maXJzdENvbEFjY2Vzc2libGUsIG5vbkdyb3dXaWR0aDogcC5ub25Hcm93V2lkdGgsIGZpeGVkU2hhZG93WDogcC5maXhlZFNoYWRvd1gsIGZpeGVkU2hhZG93WTogcC5maXhlZFNoYWRvd1ksIGZyZWV6ZUNvbHVtbnM6IHAuZnJlZXplQ29sdW1ucywgZ2V0Q2VsbENvbnRlbnQ6IHAuZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxSZW5kZXJlcjogcC5nZXRDZWxsUmVuZGVyZXIsIGdldEdyb3VwRGV0YWlsczogcC5nZXRHcm91cERldGFpbHMsIGdldFJvd1RoZW1lT3ZlcnJpZGU6IHAuZ2V0Um93VGhlbWVPdmVycmlkZSwgZ3JvdXBIZWFkZXJIZWlnaHQ6IHAuZ3JvdXBIZWFkZXJIZWlnaHQsIGhlYWRlckhlaWdodDogcC5oZWFkZXJIZWlnaHQsIGhpZ2hsaWdodFJlZ2lvbnM6IHAuaGlnaGxpZ2h0UmVnaW9ucywgaW1hZ2VXaW5kb3dMb2FkZXI6IHAuaW1hZ2VXaW5kb3dMb2FkZXIsIGluaXRpYWxTaXplOiBwLmluaXRpYWxTaXplLCBpc0ZpbGxpbmc6IHAuaXNGaWxsaW5nLCBpc0ZvY3VzZWQ6IHAuaXNGb2N1c2VkLCBsb2NrQ29sdW1uczogcC5sb2NrQ29sdW1ucywgbWF4Q29sdW1uV2lkdGg6IHAubWF4Q29sdW1uV2lkdGgsIG1pbkNvbHVtbldpZHRoOiBwLm1pbkNvbHVtbldpZHRoLCBvbkhlYWRlck1lbnVDbGljazogcC5vbkhlYWRlck1lbnVDbGljaywgb25Nb3VzZU1vdmU6IHAub25Nb3VzZU1vdmUsIG9uVmlzaWJsZVJlZ2lvbkNoYW5nZWQ6IHAub25WaXNpYmxlUmVnaW9uQ2hhbmdlZCwgb3ZlcnNjcm9sbFg6IHAub3ZlcnNjcm9sbFgsIG92ZXJzY3JvbGxZOiBwLm92ZXJzY3JvbGxZLCBwcmV2ZW50RGlhZ29uYWxTY3JvbGxpbmc6IHAucHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCByaWdodEVsZW1lbnQ6IHAucmlnaHRFbGVtZW50LCByaWdodEVsZW1lbnRQcm9wczogcC5yaWdodEVsZW1lbnRQcm9wcywgcm93SGVpZ2h0OiBwLnJvd0hlaWdodCwgcm93czogcC5yb3dzLCBzY3JvbGxSZWY6IHAuc2Nyb2xsUmVmLCBzZWxlY3Rpb246IHAuc2VsZWN0aW9uLCB0aGVtZTogcC50aGVtZSwgZnJlZXplVHJhaWxpbmdSb3dzOiBwLmZyZWV6ZVRyYWlsaW5nUm93cywgaGFzQXBwZW5kUm93OiBwLmhhc0FwcGVuZFJvdywgdHJhbnNsYXRlWDogcC50cmFuc2xhdGVYLCB0cmFuc2xhdGVZOiBwLnRyYW5zbGF0ZVksIHZlcnRpY2FsQm9yZGVyOiBwLnZlcnRpY2FsQm9yZGVyLCBvbkNvbHVtblByb3Bvc2VNb3ZlOiBwLm9uQ29sdW1uUHJvcG9zZU1vdmUsIGRyYXdGb2N1c1Jpbmc6IHAuZHJhd0ZvY3VzUmluZywgZHJhd0NlbGw6IHAuZHJhd0NlbGwsIGRyYXdIZWFkZXI6IHAuZHJhd0hlYWRlciwgZXhwZXJpbWVudGFsOiBwLmV4cGVyaW1lbnRhbCwgZ3JpZFJlZjogcC5ncmlkUmVmLCBoZWFkZXJJY29uczogcC5oZWFkZXJJY29ucywgaXNEcmFnZ2FibGU6IHAuaXNEcmFnZ2FibGUsIG9uQ2FudmFzQmx1cjogcC5vbkNhbnZhc0JsdXIsIG9uQ2FudmFzRm9jdXNlZDogcC5vbkNhbnZhc0ZvY3VzZWQsIG9uQ2VsbEZvY3VzZWQ6IHAub25DZWxsRm9jdXNlZCwgb25Db2x1bW5Nb3ZlZDogcC5vbkNvbHVtbk1vdmVkLCBvbkNvbHVtblJlc2l6ZTogcC5vbkNvbHVtblJlc2l6ZSwgb25Db2x1bW5SZXNpemVFbmQ6IHAub25Db2x1bW5SZXNpemVFbmQsIG9uQ29sdW1uUmVzaXplU3RhcnQ6IHAub25Db2x1bW5SZXNpemVTdGFydCwgb25Db250ZXh0TWVudTogcC5vbkNvbnRleHRNZW51LCBvbkRyYWdFbmQ6IHAub25EcmFnRW5kLCBvbkRyYWdMZWF2ZTogcC5vbkRyYWdMZWF2ZSwgb25EcmFnT3ZlckNlbGw6IHAub25EcmFnT3ZlckNlbGwsIG9uRHJhZ1N0YXJ0OiBwLm9uRHJhZ1N0YXJ0LCBvbkRyb3A6IHAub25Ecm9wLCBvbkl0ZW1Ib3ZlcmVkOiBwLm9uSXRlbUhvdmVyZWQsIG9uS2V5RG93bjogcC5vbktleURvd24sIG9uS2V5VXA6IHAub25LZXlVcCwgb25Nb3VzZURvd246IHAub25Nb3VzZURvd24sIG9uTW91c2VVcDogcC5vbk1vdXNlVXAsIG9uUm93TW92ZWQ6IHAub25Sb3dNb3ZlZCwgc21vb3RoU2Nyb2xsWDogcC5zbW9vdGhTY3JvbGxYLCBzbW9vdGhTY3JvbGxZOiBwLnNtb290aFNjcm9sbFkgfSksXG4gICAgICAgIHNlYXJjaGJveCkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IERhdGFHcmlkU2VhcmNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS1ncmlkLXNlYXJjaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-search/data-grid-search.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/animation-manager.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/animation-manager.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnimationManager: () => (/* binding */ AnimationManager)\n/* harmony export */ });\n/* harmony import */ var lodash_clamp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/clamp.js */ \"(ssr)/./node_modules/lodash/clamp.js\");\n/* harmony import */ var _render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n\n\nconst hoverTime = 80;\nfunction easeOutCubic(x) {\n    const x1 = x - 1;\n    return x1 * x1 * x1 + 1;\n}\nclass AnimationManager {\n    callback;\n    constructor(callback) {\n        this.callback = callback;\n    }\n    currentHoveredItem = undefined;\n    leavingItems = [];\n    lastAnimationTime;\n    addToLeavingItems = (item) => {\n        const isAlreadyLeaving = this.leavingItems.some(i => (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.itemsAreEqual)(i.item, item.item));\n        if (isAlreadyLeaving) {\n            return;\n        }\n        this.leavingItems.push(item);\n    };\n    /**\n     * @returns the hover amount of the item, if it was leaving (0 if not).\n     */\n    removeFromLeavingItems = (item) => {\n        const leavingItem = this.leavingItems.find(e => (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.itemsAreEqual)(e.item, item));\n        this.leavingItems = this.leavingItems.filter(i => i !== leavingItem);\n        return leavingItem?.hoverAmount ?? 0;\n    };\n    cleanUpLeavingElements = () => {\n        this.leavingItems = this.leavingItems.filter(i => i.hoverAmount > 0);\n    };\n    shouldStep = () => {\n        const hasLeavingItems = this.leavingItems.length > 0;\n        const currentHoveredIsAnimating = this.currentHoveredItem !== undefined && this.currentHoveredItem.hoverAmount < 1;\n        return hasLeavingItems || currentHoveredIsAnimating;\n    };\n    getAnimatingItems = () => {\n        // this is horrible. We shoudl be mutating the array in place. The reason we don't right now is because the\n        // hoveramount is used as both the tweened value and the raw value. We should separate these two things.\n        // Then we can stop doing the allocation insanity dance.\n        if (this.currentHoveredItem !== undefined) {\n            return [...this.leavingItems, this.currentHoveredItem];\n        }\n        return this.leavingItems.map(x => ({ ...x, hoverAmount: easeOutCubic(x.hoverAmount) }));\n    };\n    step = (timestamp) => {\n        if (this.lastAnimationTime === undefined) {\n            this.lastAnimationTime = timestamp;\n        }\n        else {\n            const step = timestamp - this.lastAnimationTime;\n            const delta = step / hoverTime;\n            for (const item of this.leavingItems) {\n                item.hoverAmount = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_0__(item.hoverAmount - delta, 0, 1);\n            }\n            if (this.currentHoveredItem !== undefined) {\n                this.currentHoveredItem.hoverAmount = lodash_clamp_js__WEBPACK_IMPORTED_MODULE_0__(this.currentHoveredItem.hoverAmount + delta, 0, 1);\n            }\n            const animating = this.getAnimatingItems();\n            this.callback(animating);\n            this.cleanUpLeavingElements();\n        }\n        if (this.shouldStep()) {\n            this.lastAnimationTime = timestamp;\n            window.requestAnimationFrame(this.step);\n        }\n        else {\n            this.lastAnimationTime = undefined;\n        }\n    };\n    setHovered = (item) => {\n        if ((0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.itemsAreEqual)(this.currentHoveredItem?.item, item)) {\n            return;\n        }\n        if (this.currentHoveredItem !== undefined) {\n            this.addToLeavingItems(this.currentHoveredItem);\n        }\n        if (item !== undefined) {\n            const hoverAmount = this.removeFromLeavingItems(item);\n            this.currentHoveredItem = {\n                item,\n                hoverAmount,\n            };\n        }\n        else {\n            this.currentHoveredItem = undefined;\n        }\n        if (this.lastAnimationTime === undefined) {\n            window.requestAnimationFrame(this.step);\n        }\n    };\n}\n//# sourceMappingURL=animation-manager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2FuaW1hdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUNzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHVFQUFhO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1RUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0RBQWdEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0Q0FBSztBQUN4QztBQUNBO0FBQ0Esc0RBQXNELDRDQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVFQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC9hbmltYXRpb24tbWFuYWdlci5qcz9mZjljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjbGFtcCBmcm9tIFwibG9kYXNoL2NsYW1wLmpzXCI7XG5pbXBvcnQgeyBpdGVtc0FyZUVxdWFsIH0gZnJvbSBcIi4vcmVuZGVyL2RhdGEtZ3JpZC1saWIuanNcIjtcbmNvbnN0IGhvdmVyVGltZSA9IDgwO1xuZnVuY3Rpb24gZWFzZU91dEN1YmljKHgpIHtcbiAgICBjb25zdCB4MSA9IHggLSAxO1xuICAgIHJldHVybiB4MSAqIHgxICogeDEgKyAxO1xufVxuZXhwb3J0IGNsYXNzIEFuaW1hdGlvbk1hbmFnZXIge1xuICAgIGNhbGxiYWNrO1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgY3VycmVudEhvdmVyZWRJdGVtID0gdW5kZWZpbmVkO1xuICAgIGxlYXZpbmdJdGVtcyA9IFtdO1xuICAgIGxhc3RBbmltYXRpb25UaW1lO1xuICAgIGFkZFRvTGVhdmluZ0l0ZW1zID0gKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaXNBbHJlYWR5TGVhdmluZyA9IHRoaXMubGVhdmluZ0l0ZW1zLnNvbWUoaSA9PiBpdGVtc0FyZUVxdWFsKGkuaXRlbSwgaXRlbS5pdGVtKSk7XG4gICAgICAgIGlmIChpc0FscmVhZHlMZWF2aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWF2aW5nSXRlbXMucHVzaChpdGVtKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRoZSBob3ZlciBhbW91bnQgb2YgdGhlIGl0ZW0sIGlmIGl0IHdhcyBsZWF2aW5nICgwIGlmIG5vdCkuXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUxlYXZpbmdJdGVtcyA9IChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGxlYXZpbmdJdGVtID0gdGhpcy5sZWF2aW5nSXRlbXMuZmluZChlID0+IGl0ZW1zQXJlRXF1YWwoZS5pdGVtLCBpdGVtKSk7XG4gICAgICAgIHRoaXMubGVhdmluZ0l0ZW1zID0gdGhpcy5sZWF2aW5nSXRlbXMuZmlsdGVyKGkgPT4gaSAhPT0gbGVhdmluZ0l0ZW0pO1xuICAgICAgICByZXR1cm4gbGVhdmluZ0l0ZW0/LmhvdmVyQW1vdW50ID8/IDA7XG4gICAgfTtcbiAgICBjbGVhblVwTGVhdmluZ0VsZW1lbnRzID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxlYXZpbmdJdGVtcyA9IHRoaXMubGVhdmluZ0l0ZW1zLmZpbHRlcihpID0+IGkuaG92ZXJBbW91bnQgPiAwKTtcbiAgICB9O1xuICAgIHNob3VsZFN0ZXAgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc0xlYXZpbmdJdGVtcyA9IHRoaXMubGVhdmluZ0l0ZW1zLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIb3ZlcmVkSXNBbmltYXRpbmcgPSB0aGlzLmN1cnJlbnRIb3ZlcmVkSXRlbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY3VycmVudEhvdmVyZWRJdGVtLmhvdmVyQW1vdW50IDwgMTtcbiAgICAgICAgcmV0dXJuIGhhc0xlYXZpbmdJdGVtcyB8fCBjdXJyZW50SG92ZXJlZElzQW5pbWF0aW5nO1xuICAgIH07XG4gICAgZ2V0QW5pbWF0aW5nSXRlbXMgPSAoKSA9PiB7XG4gICAgICAgIC8vIHRoaXMgaXMgaG9ycmlibGUuIFdlIHNob3VkbCBiZSBtdXRhdGluZyB0aGUgYXJyYXkgaW4gcGxhY2UuIFRoZSByZWFzb24gd2UgZG9uJ3QgcmlnaHQgbm93IGlzIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGhvdmVyYW1vdW50IGlzIHVzZWQgYXMgYm90aCB0aGUgdHdlZW5lZCB2YWx1ZSBhbmQgdGhlIHJhdyB2YWx1ZS4gV2Ugc2hvdWxkIHNlcGFyYXRlIHRoZXNlIHR3byB0aGluZ3MuXG4gICAgICAgIC8vIFRoZW4gd2UgY2FuIHN0b3AgZG9pbmcgdGhlIGFsbG9jYXRpb24gaW5zYW5pdHkgZGFuY2UuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRIb3ZlcmVkSXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMubGVhdmluZ0l0ZW1zLCB0aGlzLmN1cnJlbnRIb3ZlcmVkSXRlbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGVhdmluZ0l0ZW1zLm1hcCh4ID0+ICh7IC4uLngsIGhvdmVyQW1vdW50OiBlYXNlT3V0Q3ViaWMoeC5ob3ZlckFtb3VudCkgfSkpO1xuICAgIH07XG4gICAgc3RlcCA9ICh0aW1lc3RhbXApID0+IHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEFuaW1hdGlvblRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0QW5pbWF0aW9uVGltZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSB0aW1lc3RhbXAgLSB0aGlzLmxhc3RBbmltYXRpb25UaW1lO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBzdGVwIC8gaG92ZXJUaW1lO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMubGVhdmluZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5ob3ZlckFtb3VudCA9IGNsYW1wKGl0ZW0uaG92ZXJBbW91bnQgLSBkZWx0YSwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SG92ZXJlZEl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEhvdmVyZWRJdGVtLmhvdmVyQW1vdW50ID0gY2xhbXAodGhpcy5jdXJyZW50SG92ZXJlZEl0ZW0uaG92ZXJBbW91bnQgKyBkZWx0YSwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbmltYXRpbmcgPSB0aGlzLmdldEFuaW1hdGluZ0l0ZW1zKCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGFuaW1hdGluZyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFuVXBMZWF2aW5nRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG91bGRTdGVwKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEFuaW1hdGlvblRpbWUgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RBbmltYXRpb25UaW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZXRIb3ZlcmVkID0gKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGl0ZW1zQXJlRXF1YWwodGhpcy5jdXJyZW50SG92ZXJlZEl0ZW0/Lml0ZW0sIGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEhvdmVyZWRJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVG9MZWF2aW5nSXRlbXModGhpcy5jdXJyZW50SG92ZXJlZEl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyQW1vdW50ID0gdGhpcy5yZW1vdmVGcm9tTGVhdmluZ0l0ZW1zKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SG92ZXJlZEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBob3ZlckFtb3VudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRIb3ZlcmVkSXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0QW5pbWF0aW9uVGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RlcCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5pbWF0aW9uLW1hbmFnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/animation-manager.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/cell-set.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/cell-set.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellSet: () => (/* binding */ CellSet)\n/* harmony export */ });\n/* harmony import */ var _common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/render-state-provider.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/render-state-provider.js\");\n\nclass CellSet {\n    cells;\n    constructor(items = []) {\n        this.cells = new Set(items.map(x => (0,_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_0__.packColRowToNumber)(x[0], x[1])));\n    }\n    add(cell) {\n        this.cells.add((0,_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_0__.packColRowToNumber)(cell[0], cell[1]));\n    }\n    has(cell) {\n        if (cell === undefined)\n            return false;\n        return this.cells.has((0,_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_0__.packColRowToNumber)(cell[0], cell[1]));\n    }\n    remove(cell) {\n        this.cells.delete((0,_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_0__.packColRowToNumber)(cell[0], cell[1]));\n    }\n    clear() {\n        this.cells.clear();\n    }\n    get size() {\n        return this.cells.size;\n    }\n    hasHeader() {\n        for (const cellNumber of this.cells) {\n            const row = (0,_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_0__.unpackRow)(cellNumber);\n            if (row < 0)\n                return true;\n        }\n        return false;\n    }\n    hasItemInRectangle(rect) {\n        for (let row = rect.y; row < rect.y + rect.height; row++) {\n            for (let col = rect.x; col < rect.x + rect.width; col++) {\n                if (this.cells.has((0,_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_0__.packColRowToNumber)(col, row))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    hasItemInRegion(rect) {\n        for (const r of rect) {\n            if (this.hasItemInRectangle(r)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    *values() {\n        for (const cellNumber of this.cells) {\n            yield (0,_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_0__.unpackNumberToColRow)(cellNumber);\n        }\n    }\n}\n//# sourceMappingURL=cell-set.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2NlbGwtc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRHO0FBQ3JHO0FBQ1A7QUFDQTtBQUNBLDRDQUE0QyxvRkFBa0I7QUFDOUQ7QUFDQTtBQUNBLHVCQUF1QixvRkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0ZBQWtCO0FBQ2hEO0FBQ0E7QUFDQSwwQkFBMEIsb0ZBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNELG1DQUFtQywyQkFBMkI7QUFDOUQsbUNBQW1DLG9GQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzRkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQvY2VsbC1zZXQuanM/YTk1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYWNrQ29sUm93VG9OdW1iZXIsIHVucGFja051bWJlclRvQ29sUm93LCB1bnBhY2tSb3cgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3JlbmRlci1zdGF0ZS1wcm92aWRlci5qc1wiO1xuZXhwb3J0IGNsYXNzIENlbGxTZXQge1xuICAgIGNlbGxzO1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zID0gW10pIHtcbiAgICAgICAgdGhpcy5jZWxscyA9IG5ldyBTZXQoaXRlbXMubWFwKHggPT4gcGFja0NvbFJvd1RvTnVtYmVyKHhbMF0sIHhbMV0pKSk7XG4gICAgfVxuICAgIGFkZChjZWxsKSB7XG4gICAgICAgIHRoaXMuY2VsbHMuYWRkKHBhY2tDb2xSb3dUb051bWJlcihjZWxsWzBdLCBjZWxsWzFdKSk7XG4gICAgfVxuICAgIGhhcyhjZWxsKSB7XG4gICAgICAgIGlmIChjZWxsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxzLmhhcyhwYWNrQ29sUm93VG9OdW1iZXIoY2VsbFswXSwgY2VsbFsxXSkpO1xuICAgIH1cbiAgICByZW1vdmUoY2VsbCkge1xuICAgICAgICB0aGlzLmNlbGxzLmRlbGV0ZShwYWNrQ29sUm93VG9OdW1iZXIoY2VsbFswXSwgY2VsbFsxXSkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5jZWxscy5jbGVhcigpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbHMuc2l6ZTtcbiAgICB9XG4gICAgaGFzSGVhZGVyKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNlbGxOdW1iZXIgb2YgdGhpcy5jZWxscykge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gdW5wYWNrUm93KGNlbGxOdW1iZXIpO1xuICAgICAgICAgICAgaWYgKHJvdyA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNJdGVtSW5SZWN0YW5nbGUocmVjdCkge1xuICAgICAgICBmb3IgKGxldCByb3cgPSByZWN0Lnk7IHJvdyA8IHJlY3QueSArIHJlY3QuaGVpZ2h0OyByb3crKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gcmVjdC54OyBjb2wgPCByZWN0LnggKyByZWN0LndpZHRoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNlbGxzLmhhcyhwYWNrQ29sUm93VG9OdW1iZXIoY29sLCByb3cpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNJdGVtSW5SZWdpb24ocmVjdCkge1xuICAgICAgICBmb3IgKGNvbnN0IHIgb2YgcmVjdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzSXRlbUluUmVjdGFuZ2xlKHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAqdmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNlbGxOdW1iZXIgb2YgdGhpcy5jZWxscykge1xuICAgICAgICAgICAgeWllbGQgdW5wYWNrTnVtYmVyVG9Db2xSb3coY2VsbE51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZWxsLXNldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/cell-set.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blend: () => (/* binding */ blend),\n/* harmony export */   blendCache: () => (/* binding */ blendCache),\n/* harmony export */   getLuminance: () => (/* binding */ getLuminance),\n/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),\n/* harmony export */   parseToRgba: () => (/* binding */ parseToRgba),\n/* harmony export */   withAlpha: () => (/* binding */ withAlpha)\n/* harmony export */ });\n// Shamelessly stolen from https://github.com/ricokahler/color2k\n// We don't need all the color functions but we deeply appreciate their work.\nconst cache = {};\nlet div = null;\nfunction createDiv() {\n    const d = document.createElement(\"div\");\n    d.style.opacity = \"0\";\n    d.style.pointerEvents = \"none\";\n    d.style.position = \"fixed\";\n    // div must be mounted for `getComputedStyle` to work\n    document.body.append(d);\n    return d;\n}\n/** @category Drawing */\nfunction parseToRgba(color) {\n    // normalize the color\n    const normalizedColor = color.toLowerCase().trim();\n    if (cache[normalizedColor] !== undefined)\n        return cache[normalizedColor];\n    div = div || createDiv();\n    div.style.color = \"#000\";\n    div.style.color = normalizedColor;\n    const control = getComputedStyle(div).color;\n    div.style.color = \"#fff\";\n    div.style.color = normalizedColor;\n    const computedColor = getComputedStyle(div).color;\n    if (computedColor !== control)\n        return [0, 0, 0, 1];\n    let result = computedColor\n        // eslint-disable-next-line unicorn/better-regex\n        .replace(/[^\\d.,]/g, \"\")\n        .split(\",\")\n        .map(Number.parseFloat);\n    if (result.length < 4) {\n        result.push(1);\n    }\n    result = result.map(x => {\n        const isNaN = Number.isNaN(x);\n        if ( true && isNaN) {\n            // eslint-disable-next-line no-console\n            console.warn(\"Could not parse color\", color);\n        }\n        return isNaN ? 0 : x;\n    });\n    cache[normalizedColor] = result;\n    return result;\n}\n/** @category Drawing */\nfunction withAlpha(color, alpha) {\n    const [r, g, b] = parseToRgba(color);\n    return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n}\nconst blendResultCache = new Map();\nfunction blendCache(color, background) {\n    const cacheKey = `${color}-${background}`;\n    const maybe = blendResultCache.get(cacheKey);\n    if (maybe !== undefined)\n        return maybe;\n    const result = blend(color, background);\n    blendResultCache.set(cacheKey, result);\n    return result;\n}\n/** @category Drawing */\nfunction blend(color, background) {\n    if (background === undefined)\n        return color;\n    const [r, g, b, a] = parseToRgba(color);\n    if (a === 1)\n        return color;\n    const [br, bg, bb, ba] = parseToRgba(background);\n    const ao = a + ba * (1 - a);\n    // (xaA + xaB(1aA))/aR\n    const ro = (a * r + ba * br * (1 - a)) / ao;\n    const go = (a * g + ba * bg * (1 - a)) / ao;\n    const bo = (a * b + ba * bb * (1 - a)) / ao;\n    return `rgba(${ro}, ${go}, ${bo}, ${ao})`;\n}\n/** @category Drawing */\nfunction interpolateColors(leftColor, rightColor, val) {\n    // toot toot im a GPU\n    if (val <= 0)\n        return leftColor;\n    if (val >= 1)\n        return rightColor;\n    // Parse to rgba returns straight alpha colors, for interpolation we want pre-multiplied alpha\n    // FIXME: This can be faster if instead of makign an array we just use variables. No memory allocation.\n    const left = [...parseToRgba(leftColor)];\n    left[0] = left[0] * left[3];\n    left[1] = left[1] * left[3];\n    left[2] = left[2] * left[3];\n    const right = [...parseToRgba(rightColor)];\n    right[0] = right[0] * right[3];\n    right[1] = right[1] * right[3];\n    right[2] = right[2] * right[3];\n    const hScaler = val;\n    const nScaler = 1 - val;\n    const a = left[3] * nScaler + right[3] * hScaler;\n    // now we need to divide the alpha back out to get linear alpha back for the final result\n    const r = Math.floor((left[0] * nScaler + right[0] * hScaler) / a);\n    const g = Math.floor((left[1] * nScaler + right[1] * hScaler) / a);\n    const b = Math.floor((left[2] * nScaler + right[2] * hScaler) / a);\n    return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n/**\n * Returns a number (float) representing the luminance of a color.\n *\n * @category Drawing\n */\nfunction getLuminance(color) {\n    if (color === \"transparent\")\n        return 0;\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    function f(x) {\n        const channel = x / 255;\n        return channel <= 0.04045 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);\n    }\n    const [r, g, b] = parseToRgba(color);\n    return 0.2126 * f(r) + 0.7152 * f(g) + 0.0722 * f(b);\n}\n//# sourceMappingURL=color-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2NvbG9yLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxtQkFBbUIsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksTUFBTTtBQUMzQztBQUNBO0FBQ087QUFDUCx3QkFBd0IsTUFBTSxHQUFHLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHO0FBQzNDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2NvbG9yLXBhcnNlci5qcz8zM2U1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNoYW1lbGVzc2x5IHN0b2xlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9yaWNva2FobGVyL2NvbG9yMmtcbi8vIFdlIGRvbid0IG5lZWQgYWxsIHRoZSBjb2xvciBmdW5jdGlvbnMgYnV0IHdlIGRlZXBseSBhcHByZWNpYXRlIHRoZWlyIHdvcmsuXG5jb25zdCBjYWNoZSA9IHt9O1xubGV0IGRpdiA9IG51bGw7XG5mdW5jdGlvbiBjcmVhdGVEaXYoKSB7XG4gICAgY29uc3QgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZC5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgZC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgZC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAvLyBkaXYgbXVzdCBiZSBtb3VudGVkIGZvciBgZ2V0Q29tcHV0ZWRTdHlsZWAgdG8gd29ya1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGQpO1xuICAgIHJldHVybiBkO1xufVxuLyoqIEBjYXRlZ29yeSBEcmF3aW5nICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUb1JnYmEoY29sb3IpIHtcbiAgICAvLyBub3JtYWxpemUgdGhlIGNvbG9yXG4gICAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gY29sb3IudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgaWYgKGNhY2hlW25vcm1hbGl6ZWRDb2xvcl0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNhY2hlW25vcm1hbGl6ZWRDb2xvcl07XG4gICAgZGl2ID0gZGl2IHx8IGNyZWF0ZURpdigpO1xuICAgIGRpdi5zdHlsZS5jb2xvciA9IFwiIzAwMFwiO1xuICAgIGRpdi5zdHlsZS5jb2xvciA9IG5vcm1hbGl6ZWRDb2xvcjtcbiAgICBjb25zdCBjb250cm9sID0gZ2V0Q29tcHV0ZWRTdHlsZShkaXYpLmNvbG9yO1xuICAgIGRpdi5zdHlsZS5jb2xvciA9IFwiI2ZmZlwiO1xuICAgIGRpdi5zdHlsZS5jb2xvciA9IG5vcm1hbGl6ZWRDb2xvcjtcbiAgICBjb25zdCBjb21wdXRlZENvbG9yID0gZ2V0Q29tcHV0ZWRTdHlsZShkaXYpLmNvbG9yO1xuICAgIGlmIChjb21wdXRlZENvbG9yICE9PSBjb250cm9sKVxuICAgICAgICByZXR1cm4gWzAsIDAsIDAsIDFdO1xuICAgIGxldCByZXN1bHQgPSBjb21wdXRlZENvbG9yXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuICAgICAgICAucmVwbGFjZSgvW15cXGQuLF0vZywgXCJcIilcbiAgICAgICAgLnNwbGl0KFwiLFwiKVxuICAgICAgICAubWFwKE51bWJlci5wYXJzZUZsb2F0KTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goMSk7XG4gICAgfVxuICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoeCA9PiB7XG4gICAgICAgIGNvbnN0IGlzTmFOID0gTnVtYmVyLmlzTmFOKHgpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzTmFOKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IHBhcnNlIGNvbG9yXCIsIGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOYU4gPyAwIDogeDtcbiAgICB9KTtcbiAgICBjYWNoZVtub3JtYWxpemVkQ29sb3JdID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGNhdGVnb3J5IERyYXdpbmcgKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQWxwaGEoY29sb3IsIGFscGhhKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gcGFyc2VUb1JnYmEoY29sb3IpO1xuICAgIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke2FscGhhfSlgO1xufVxuY29uc3QgYmxlbmRSZXN1bHRDYWNoZSA9IG5ldyBNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBibGVuZENhY2hlKGNvbG9yLCBiYWNrZ3JvdW5kKSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgJHtjb2xvcn0tJHtiYWNrZ3JvdW5kfWA7XG4gICAgY29uc3QgbWF5YmUgPSBibGVuZFJlc3VsdENhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKG1heWJlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBtYXliZTtcbiAgICBjb25zdCByZXN1bHQgPSBibGVuZChjb2xvciwgYmFja2dyb3VuZCk7XG4gICAgYmxlbmRSZXN1bHRDYWNoZS5zZXQoY2FjaGVLZXksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAY2F0ZWdvcnkgRHJhd2luZyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsZW5kKGNvbG9yLCBiYWNrZ3JvdW5kKSB7XG4gICAgaWYgKGJhY2tncm91bmQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IHBhcnNlVG9SZ2JhKGNvbG9yKTtcbiAgICBpZiAoYSA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIGNvbnN0IFticiwgYmcsIGJiLCBiYV0gPSBwYXJzZVRvUmdiYShiYWNrZ3JvdW5kKTtcbiAgICBjb25zdCBhbyA9IGEgKyBiYSAqICgxIC0gYSk7XG4gICAgLy8gKHhhQSArIHhhQsK3KDHiiJJhQSkpL2FSXG4gICAgY29uc3Qgcm8gPSAoYSAqIHIgKyBiYSAqIGJyICogKDEgLSBhKSkgLyBhbztcbiAgICBjb25zdCBnbyA9IChhICogZyArIGJhICogYmcgKiAoMSAtIGEpKSAvIGFvO1xuICAgIGNvbnN0IGJvID0gKGEgKiBiICsgYmEgKiBiYiAqICgxIC0gYSkpIC8gYW87XG4gICAgcmV0dXJuIGByZ2JhKCR7cm99LCAke2dvfSwgJHtib30sICR7YW99KWA7XG59XG4vKiogQGNhdGVnb3J5IERyYXdpbmcgKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUNvbG9ycyhsZWZ0Q29sb3IsIHJpZ2h0Q29sb3IsIHZhbCkge1xuICAgIC8vIHRvb3QgdG9vdCBpbSBhIEdQVVxuICAgIGlmICh2YWwgPD0gMClcbiAgICAgICAgcmV0dXJuIGxlZnRDb2xvcjtcbiAgICBpZiAodmFsID49IDEpXG4gICAgICAgIHJldHVybiByaWdodENvbG9yO1xuICAgIC8vIFBhcnNlIHRvIHJnYmEgcmV0dXJucyBzdHJhaWdodCBhbHBoYSBjb2xvcnMsIGZvciBpbnRlcnBvbGF0aW9uIHdlIHdhbnQgcHJlLW11bHRpcGxpZWQgYWxwaGFcbiAgICAvLyBGSVhNRTogVGhpcyBjYW4gYmUgZmFzdGVyIGlmIGluc3RlYWQgb2YgbWFraWduIGFuIGFycmF5IHdlIGp1c3QgdXNlIHZhcmlhYmxlcy4gTm8gbWVtb3J5IGFsbG9jYXRpb24uXG4gICAgY29uc3QgbGVmdCA9IFsuLi5wYXJzZVRvUmdiYShsZWZ0Q29sb3IpXTtcbiAgICBsZWZ0WzBdID0gbGVmdFswXSAqIGxlZnRbM107XG4gICAgbGVmdFsxXSA9IGxlZnRbMV0gKiBsZWZ0WzNdO1xuICAgIGxlZnRbMl0gPSBsZWZ0WzJdICogbGVmdFszXTtcbiAgICBjb25zdCByaWdodCA9IFsuLi5wYXJzZVRvUmdiYShyaWdodENvbG9yKV07XG4gICAgcmlnaHRbMF0gPSByaWdodFswXSAqIHJpZ2h0WzNdO1xuICAgIHJpZ2h0WzFdID0gcmlnaHRbMV0gKiByaWdodFszXTtcbiAgICByaWdodFsyXSA9IHJpZ2h0WzJdICogcmlnaHRbM107XG4gICAgY29uc3QgaFNjYWxlciA9IHZhbDtcbiAgICBjb25zdCBuU2NhbGVyID0gMSAtIHZhbDtcbiAgICBjb25zdCBhID0gbGVmdFszXSAqIG5TY2FsZXIgKyByaWdodFszXSAqIGhTY2FsZXI7XG4gICAgLy8gbm93IHdlIG5lZWQgdG8gZGl2aWRlIHRoZSBhbHBoYSBiYWNrIG91dCB0byBnZXQgbGluZWFyIGFscGhhIGJhY2sgZm9yIHRoZSBmaW5hbCByZXN1bHRcbiAgICBjb25zdCByID0gTWF0aC5mbG9vcigobGVmdFswXSAqIG5TY2FsZXIgKyByaWdodFswXSAqIGhTY2FsZXIpIC8gYSk7XG4gICAgY29uc3QgZyA9IE1hdGguZmxvb3IoKGxlZnRbMV0gKiBuU2NhbGVyICsgcmlnaHRbMV0gKiBoU2NhbGVyKSAvIGEpO1xuICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKChsZWZ0WzJdICogblNjYWxlciArIHJpZ2h0WzJdICogaFNjYWxlcikgLyBhKTtcbiAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbnVtYmVyIChmbG9hdCkgcmVwcmVzZW50aW5nIHRoZSBsdW1pbmFuY2Ugb2YgYSBjb2xvci5cbiAqXG4gKiBAY2F0ZWdvcnkgRHJhd2luZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0THVtaW5hbmNlKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yID09PSBcInRyYW5zcGFyZW50XCIpXG4gICAgICAgIHJldHVybiAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2NvbnNpc3RlbnQtZnVuY3Rpb24tc2NvcGluZ1xuICAgIGZ1bmN0aW9uIGYoeCkge1xuICAgICAgICBjb25zdCBjaGFubmVsID0geCAvIDI1NTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwgPD0gMC4wNDA0NSA/IGNoYW5uZWwgLyAxMi45MiA6IE1hdGgucG93KChjaGFubmVsICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gICAgfVxuICAgIGNvbnN0IFtyLCBnLCBiXSA9IHBhcnNlVG9SZ2JhKGNvbG9yKTtcbiAgICByZXR1cm4gMC4yMTI2ICogZihyKSArIDAuNzE1MiAqIGYoZykgKyAwLjA3MjIgKiBmKGIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3ItcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-sprites.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-sprites.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpriteManager: () => (/* binding */ SpriteManager)\n/* harmony export */ });\n\nfunction getColors(variant, theme) {\n    if (variant === \"normal\") {\n        return [theme.bgIconHeader, theme.fgIconHeader];\n    }\n    else if (variant === \"selected\") {\n        return [\"white\", theme.accentColor];\n    }\n    else {\n        return [theme.accentColor, theme.bgHeader];\n    }\n}\n/** @category Columns */\nclass SpriteManager {\n    onSettled;\n    spriteMap = new Map();\n    headerIcons;\n    inFlight = 0;\n    constructor(headerIcons, onSettled) {\n        this.onSettled = onSettled;\n        this.headerIcons = headerIcons ?? {};\n    }\n    drawSprite(sprite, variant, ctx, x, y, size, theme, alpha = 1) {\n        const [bgColor, fgColor] = getColors(variant, theme);\n        const rSize = size * Math.ceil(window.devicePixelRatio);\n        const key = `${bgColor}_${fgColor}_${rSize}_${sprite}`;\n        let spriteCanvas = this.spriteMap.get(key);\n        if (spriteCanvas === undefined) {\n            const spriteCb = this.headerIcons[sprite];\n            if (spriteCb === undefined)\n                return;\n            spriteCanvas = document.createElement(\"canvas\");\n            const spriteCtx = spriteCanvas.getContext(\"2d\");\n            if (spriteCtx === null)\n                return;\n            const imgSource = new Image();\n            imgSource.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(spriteCb({ fgColor, bgColor }))}`;\n            this.spriteMap.set(key, spriteCanvas);\n            const promise = imgSource.decode();\n            if (promise === undefined)\n                return;\n            this.inFlight++;\n            promise\n                .then(() => {\n                spriteCtx.drawImage(imgSource, 0, 0, rSize, rSize);\n            })\n                .finally(() => {\n                this.inFlight--;\n                if (this.inFlight === 0) {\n                    this.onSettled();\n                }\n            });\n        }\n        else {\n            if (alpha < 1) {\n                ctx.globalAlpha = alpha;\n            }\n            ctx.drawImage(spriteCanvas, 0, 0, rSize, rSize, x, y, size, size);\n            if (alpha < 1) {\n                ctx.globalAlpha = 1;\n            }\n        }\n    }\n}\n//# sourceMappingURL=data-grid-sprites.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2RhdGEtZ3JpZC1zcHJpdGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsR0FBRyxRQUFRLEdBQUcsTUFBTSxHQUFHLE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCLDhCQUE4QixrQkFBa0IsR0FBRztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQvZGF0YS1ncmlkLXNwcml0ZXMuanM/YWUyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge30gZnJvbSBcIi4vc3ByaXRlcy5qc1wiO1xuZnVuY3Rpb24gZ2V0Q29sb3JzKHZhcmlhbnQsIHRoZW1lKSB7XG4gICAgaWYgKHZhcmlhbnQgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgcmV0dXJuIFt0aGVtZS5iZ0ljb25IZWFkZXIsIHRoZW1lLmZnSWNvbkhlYWRlcl07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhcmlhbnQgPT09IFwic2VsZWN0ZWRcIikge1xuICAgICAgICByZXR1cm4gW1wid2hpdGVcIiwgdGhlbWUuYWNjZW50Q29sb3JdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt0aGVtZS5hY2NlbnRDb2xvciwgdGhlbWUuYmdIZWFkZXJdO1xuICAgIH1cbn1cbi8qKiBAY2F0ZWdvcnkgQ29sdW1ucyAqL1xuZXhwb3J0IGNsYXNzIFNwcml0ZU1hbmFnZXIge1xuICAgIG9uU2V0dGxlZDtcbiAgICBzcHJpdGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgaGVhZGVySWNvbnM7XG4gICAgaW5GbGlnaHQgPSAwO1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlckljb25zLCBvblNldHRsZWQpIHtcbiAgICAgICAgdGhpcy5vblNldHRsZWQgPSBvblNldHRsZWQ7XG4gICAgICAgIHRoaXMuaGVhZGVySWNvbnMgPSBoZWFkZXJJY29ucyA/PyB7fTtcbiAgICB9XG4gICAgZHJhd1Nwcml0ZShzcHJpdGUsIHZhcmlhbnQsIGN0eCwgeCwgeSwgc2l6ZSwgdGhlbWUsIGFscGhhID0gMSkge1xuICAgICAgICBjb25zdCBbYmdDb2xvciwgZmdDb2xvcl0gPSBnZXRDb2xvcnModmFyaWFudCwgdGhlbWUpO1xuICAgICAgICBjb25zdCByU2l6ZSA9IHNpemUgKiBNYXRoLmNlaWwod2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtiZ0NvbG9yfV8ke2ZnQ29sb3J9XyR7clNpemV9XyR7c3ByaXRlfWA7XG4gICAgICAgIGxldCBzcHJpdGVDYW52YXMgPSB0aGlzLnNwcml0ZU1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHNwcml0ZUNhbnZhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzcHJpdGVDYiA9IHRoaXMuaGVhZGVySWNvbnNbc3ByaXRlXTtcbiAgICAgICAgICAgIGlmIChzcHJpdGVDYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNwcml0ZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICBjb25zdCBzcHJpdGVDdHggPSBzcHJpdGVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgaWYgKHNwcml0ZUN0eCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBpbWdTb3VyY2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltZ1NvdXJjZS5zcmMgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJHtlbmNvZGVVUklDb21wb25lbnQoc3ByaXRlQ2IoeyBmZ0NvbG9yLCBiZ0NvbG9yIH0pKX1gO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVNYXAuc2V0KGtleSwgc3ByaXRlQ2FudmFzKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBpbWdTb3VyY2UuZGVjb2RlKCk7XG4gICAgICAgICAgICBpZiAocHJvbWlzZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaW5GbGlnaHQrKztcbiAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3ByaXRlQ3R4LmRyYXdJbWFnZShpbWdTb3VyY2UsIDAsIDAsIHJTaXplLCByU2l6ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluRmxpZ2h0LS07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5GbGlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNldHRsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbHBoYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2Uoc3ByaXRlQ2FudmFzLCAwLCAwLCByU2l6ZSwgclNpemUsIHgsIHksIHNpemUsIHNpemUpO1xuICAgICAgICAgICAgaWYgKGFscGhhIDwgMSkge1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLWdyaWQtc3ByaXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-sprites.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanEmpty: () => (/* binding */ BooleanEmpty),\n/* harmony export */   BooleanIndeterminate: () => (/* binding */ BooleanIndeterminate),\n/* harmony export */   CompactSelection: () => (/* binding */ CompactSelection),\n/* harmony export */   GridCellKind: () => (/* binding */ GridCellKind),\n/* harmony export */   GridColumnIcon: () => (/* binding */ GridColumnIcon),\n/* harmony export */   GridColumnMenuIcon: () => (/* binding */ GridColumnMenuIcon),\n/* harmony export */   InnerGridCellKind: () => (/* binding */ InnerGridCellKind),\n/* harmony export */   booleanCellIsEditable: () => (/* binding */ booleanCellIsEditable),\n/* harmony export */   isEditableGridCell: () => (/* binding */ isEditableGridCell),\n/* harmony export */   isInnerOnlyCell: () => (/* binding */ isInnerOnlyCell),\n/* harmony export */   isObjectEditorCallbackResult: () => (/* binding */ isObjectEditorCallbackResult),\n/* harmony export */   isReadWriteCell: () => (/* binding */ isReadWriteCell),\n/* harmony export */   isRectangleEqual: () => (/* binding */ isRectangleEqual),\n/* harmony export */   isSizedGridColumn: () => (/* binding */ isSizedGridColumn),\n/* harmony export */   isTextEditableGridCell: () => (/* binding */ isTextEditableGridCell),\n/* harmony export */   resolveCellsThunk: () => (/* binding */ resolveCellsThunk)\n/* harmony export */ });\n/* harmony import */ var _common_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n/* harmony import */ var lodash_has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/has.js */ \"(ssr)/./node_modules/lodash/has.js\");\n\n\n/** @category Types */\nconst BooleanEmpty = null;\n/** @category Types */\nconst BooleanIndeterminate = undefined;\n/** @category Cells */\nvar GridCellKind;\n(function (GridCellKind) {\n    GridCellKind[\"Uri\"] = \"uri\";\n    GridCellKind[\"Text\"] = \"text\";\n    GridCellKind[\"Image\"] = \"image\";\n    GridCellKind[\"RowID\"] = \"row-id\";\n    GridCellKind[\"Number\"] = \"number\";\n    GridCellKind[\"Bubble\"] = \"bubble\";\n    GridCellKind[\"Boolean\"] = \"boolean\";\n    GridCellKind[\"Loading\"] = \"loading\";\n    GridCellKind[\"Markdown\"] = \"markdown\";\n    GridCellKind[\"Drilldown\"] = \"drilldown\";\n    GridCellKind[\"Protected\"] = \"protected\";\n    GridCellKind[\"Custom\"] = \"custom\";\n})(GridCellKind || (GridCellKind = {}));\n/** @category Columns */\nvar GridColumnIcon;\n(function (GridColumnIcon) {\n    GridColumnIcon[\"HeaderRowID\"] = \"headerRowID\";\n    GridColumnIcon[\"HeaderCode\"] = \"headerCode\";\n    GridColumnIcon[\"HeaderNumber\"] = \"headerNumber\";\n    GridColumnIcon[\"HeaderString\"] = \"headerString\";\n    GridColumnIcon[\"HeaderBoolean\"] = \"headerBoolean\";\n    GridColumnIcon[\"HeaderAudioUri\"] = \"headerAudioUri\";\n    GridColumnIcon[\"HeaderVideoUri\"] = \"headerVideoUri\";\n    GridColumnIcon[\"HeaderEmoji\"] = \"headerEmoji\";\n    GridColumnIcon[\"HeaderImage\"] = \"headerImage\";\n    GridColumnIcon[\"HeaderUri\"] = \"headerUri\";\n    GridColumnIcon[\"HeaderPhone\"] = \"headerPhone\";\n    GridColumnIcon[\"HeaderMarkdown\"] = \"headerMarkdown\";\n    GridColumnIcon[\"HeaderDate\"] = \"headerDate\";\n    GridColumnIcon[\"HeaderTime\"] = \"headerTime\";\n    GridColumnIcon[\"HeaderEmail\"] = \"headerEmail\";\n    GridColumnIcon[\"HeaderReference\"] = \"headerReference\";\n    GridColumnIcon[\"HeaderIfThenElse\"] = \"headerIfThenElse\";\n    GridColumnIcon[\"HeaderSingleValue\"] = \"headerSingleValue\";\n    GridColumnIcon[\"HeaderLookup\"] = \"headerLookup\";\n    GridColumnIcon[\"HeaderTextTemplate\"] = \"headerTextTemplate\";\n    GridColumnIcon[\"HeaderMath\"] = \"headerMath\";\n    GridColumnIcon[\"HeaderRollup\"] = \"headerRollup\";\n    GridColumnIcon[\"HeaderJoinStrings\"] = \"headerJoinStrings\";\n    GridColumnIcon[\"HeaderSplitString\"] = \"headerSplitString\";\n    GridColumnIcon[\"HeaderGeoDistance\"] = \"headerGeoDistance\";\n    GridColumnIcon[\"HeaderArray\"] = \"headerArray\";\n    GridColumnIcon[\"RowOwnerOverlay\"] = \"rowOwnerOverlay\";\n    GridColumnIcon[\"ProtectedColumnOverlay\"] = \"protectedColumnOverlay\";\n})(GridColumnIcon || (GridColumnIcon = {}));\n/** @category Columns */\nvar GridColumnMenuIcon;\n(function (GridColumnMenuIcon) {\n    GridColumnMenuIcon[\"Triangle\"] = \"triangle\";\n    GridColumnMenuIcon[\"Dots\"] = \"dots\";\n})(GridColumnMenuIcon || (GridColumnMenuIcon = {}));\n/** @category Columns */\nfunction isSizedGridColumn(c) {\n    return \"width\" in c && typeof c.width === \"number\";\n}\n/** @category Types */\nasync function resolveCellsThunk(thunk) {\n    if (typeof thunk === \"object\")\n        return thunk;\n    return await thunk();\n}\n// All EditableGridCells are inherently ValidatedGridCells, and this is more specific and thus more useful.\n/** @category Cells */\nfunction isEditableGridCell(cell) {\n    if (cell.kind === GridCellKind.Loading ||\n        cell.kind === GridCellKind.Bubble ||\n        cell.kind === GridCellKind.RowID ||\n        cell.kind === GridCellKind.Protected ||\n        cell.kind === GridCellKind.Drilldown) {\n        return false;\n    }\n    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_1__.proveType)(cell);\n    return true;\n}\n/** @category Cells */\nfunction isTextEditableGridCell(cell) {\n    if (cell.kind === GridCellKind.Loading ||\n        cell.kind === GridCellKind.Bubble ||\n        cell.kind === GridCellKind.RowID ||\n        cell.kind === GridCellKind.Protected ||\n        cell.kind === GridCellKind.Drilldown ||\n        cell.kind === GridCellKind.Boolean ||\n        cell.kind === GridCellKind.Image ||\n        cell.kind === GridCellKind.Custom) {\n        return false;\n    }\n    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_1__.proveType)(cell);\n    return true;\n}\n/** @category Cells */\nfunction isInnerOnlyCell(cell) {\n    return cell.kind === InnerGridCellKind.Marker || cell.kind === InnerGridCellKind.NewRow;\n}\n/** @category Cells */\nfunction isReadWriteCell(cell) {\n    if (!isEditableGridCell(cell) || cell.kind === GridCellKind.Image)\n        return false;\n    if (cell.kind === GridCellKind.Text ||\n        cell.kind === GridCellKind.Number ||\n        cell.kind === GridCellKind.Markdown ||\n        cell.kind === GridCellKind.Uri ||\n        cell.kind === GridCellKind.Custom ||\n        cell.kind === GridCellKind.Boolean) {\n        return cell.readonly !== true;\n    }\n    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_1__.assertNever)(cell, \"A cell was passed with an invalid kind\");\n}\nfunction isRectangleEqual(a, b) {\n    if (a === b)\n        return true;\n    if (a === undefined || b === undefined)\n        return false;\n    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n/** @category Renderers */\nfunction isObjectEditorCallbackResult(obj) {\n    return lodash_has_js__WEBPACK_IMPORTED_MODULE_0__(obj, \"editor\");\n}\n// Can be written more concisely, not easier to read if more concise.\n/** @category Cells */\nfunction booleanCellIsEditable(cell) {\n    return !(cell.readonly ?? false);\n}\n/** @category Cells */\nvar InnerGridCellKind;\n(function (InnerGridCellKind) {\n    InnerGridCellKind[\"NewRow\"] = \"new-row\";\n    InnerGridCellKind[\"Marker\"] = \"marker\";\n})(InnerGridCellKind || (InnerGridCellKind = {}));\nfunction mergeRanges(input) {\n    if (input.length === 0) {\n        return [];\n    }\n    const ranges = [...input];\n    const stack = [];\n    ranges.sort(function (a, b) {\n        return a[0] - b[0];\n    });\n    stack.push([...ranges[0]]);\n    for (const range of ranges.slice(1)) {\n        const top = stack[stack.length - 1];\n        if (top[1] < range[0]) {\n            stack.push([...range]);\n        }\n        else if (top[1] < range[1]) {\n            top[1] = range[1];\n        }\n    }\n    return stack;\n}\nlet emptyCompactSelection;\n/** @category Selection */\nclass CompactSelection {\n    items;\n    constructor(items) {\n        this.items = items;\n    }\n    static empty = () => {\n        return emptyCompactSelection ?? (emptyCompactSelection = new CompactSelection([]));\n    };\n    static fromSingleSelection = (selection) => {\n        return CompactSelection.empty().add(selection);\n    };\n    offset(amount) {\n        if (amount === 0)\n            return this;\n        const newItems = this.items.map(x => [x[0] + amount, x[1] + amount]);\n        return new CompactSelection(newItems);\n    }\n    add(selection) {\n        const slice = typeof selection === \"number\" ? [selection, selection + 1] : selection;\n        const newItems = mergeRanges([...this.items, slice]);\n        return new CompactSelection(newItems);\n    }\n    remove(selection) {\n        const items = [...this.items];\n        const selMin = typeof selection === \"number\" ? selection : selection[0];\n        const selMax = typeof selection === \"number\" ? selection + 1 : selection[1];\n        for (const [i, slice] of items.entries()) {\n            const [start, end] = slice;\n            // Remove part of slice that intersects removed selection.\n            if (start <= selMax && selMin <= end) {\n                const toAdd = [];\n                if (start < selMin) {\n                    toAdd.push([start, selMin]);\n                }\n                if (selMax < end) {\n                    toAdd.push([selMax, end]);\n                }\n                items.splice(i, 1, ...toAdd);\n            }\n        }\n        return new CompactSelection(items);\n    }\n    first() {\n        if (this.items.length === 0)\n            return undefined;\n        return this.items[0][0];\n    }\n    last() {\n        if (this.items.length === 0)\n            return undefined;\n        return this.items.slice(-1)[0][1] - 1;\n    }\n    hasIndex(index) {\n        for (let i = 0; i < this.items.length; i++) {\n            const [start, end] = this.items[i];\n            if (index >= start && index < end)\n                return true;\n        }\n        return false;\n    }\n    hasAll(index) {\n        for (let x = index[0]; x < index[1]; x++) {\n            if (!this.hasIndex(x))\n                return false;\n        }\n        return true;\n    }\n    some(predicate) {\n        for (const i of this) {\n            if (predicate(i))\n                return true;\n        }\n        return false;\n    }\n    equals(other) {\n        if (other === this)\n            return true;\n        if (other.items.length !== this.items.length)\n            return false;\n        for (let i = 0; i < this.items.length; i++) {\n            const left = other.items[i];\n            const right = this.items[i];\n            if (left[0] !== right[0] || left[1] !== right[1])\n                return false;\n        }\n        return true;\n    }\n    // Really old JS wont have access to the iterator and babel will stop people using it\n    // when trying to support browsers so old we don't support them anyway. What goes on\n    // between an engineer and their bundler in the privacy of their CI server is none of\n    // my business anyway.\n    toArray() {\n        const result = [];\n        for (const [start, end] of this.items) {\n            for (let x = start; x < end; x++) {\n                result.push(x);\n            }\n        }\n        return result;\n    }\n    get length() {\n        let len = 0;\n        for (const [start, end] of this.items) {\n            len += end - start;\n        }\n        return len;\n    }\n    *[Symbol.iterator]() {\n        for (const [start, end] of this.items) {\n            for (let x = start; x < end; x++) {\n                yield x;\n            }\n        }\n    }\n}\n//# sourceMappingURL=data-grid-types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDakM7QUFDaEM7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2REFBUztBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrREFBVztBQUNmO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVywwQ0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2RhdGEtZ3JpZC10eXBlcy5qcz8zNzc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydE5ldmVyLCBwcm92ZVR5cGUgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3N1cHBvcnQuanNcIjtcbmltcG9ydCBoYXMgZnJvbSBcImxvZGFzaC9oYXMuanNcIjtcbi8qKiBAY2F0ZWdvcnkgVHlwZXMgKi9cbmV4cG9ydCBjb25zdCBCb29sZWFuRW1wdHkgPSBudWxsO1xuLyoqIEBjYXRlZ29yeSBUeXBlcyAqL1xuZXhwb3J0IGNvbnN0IEJvb2xlYW5JbmRldGVybWluYXRlID0gdW5kZWZpbmVkO1xuLyoqIEBjYXRlZ29yeSBDZWxscyAqL1xuZXhwb3J0IHZhciBHcmlkQ2VsbEtpbmQ7XG4oZnVuY3Rpb24gKEdyaWRDZWxsS2luZCkge1xuICAgIEdyaWRDZWxsS2luZFtcIlVyaVwiXSA9IFwidXJpXCI7XG4gICAgR3JpZENlbGxLaW5kW1wiVGV4dFwiXSA9IFwidGV4dFwiO1xuICAgIEdyaWRDZWxsS2luZFtcIkltYWdlXCJdID0gXCJpbWFnZVwiO1xuICAgIEdyaWRDZWxsS2luZFtcIlJvd0lEXCJdID0gXCJyb3ctaWRcIjtcbiAgICBHcmlkQ2VsbEtpbmRbXCJOdW1iZXJcIl0gPSBcIm51bWJlclwiO1xuICAgIEdyaWRDZWxsS2luZFtcIkJ1YmJsZVwiXSA9IFwiYnViYmxlXCI7XG4gICAgR3JpZENlbGxLaW5kW1wiQm9vbGVhblwiXSA9IFwiYm9vbGVhblwiO1xuICAgIEdyaWRDZWxsS2luZFtcIkxvYWRpbmdcIl0gPSBcImxvYWRpbmdcIjtcbiAgICBHcmlkQ2VsbEtpbmRbXCJNYXJrZG93blwiXSA9IFwibWFya2Rvd25cIjtcbiAgICBHcmlkQ2VsbEtpbmRbXCJEcmlsbGRvd25cIl0gPSBcImRyaWxsZG93blwiO1xuICAgIEdyaWRDZWxsS2luZFtcIlByb3RlY3RlZFwiXSA9IFwicHJvdGVjdGVkXCI7XG4gICAgR3JpZENlbGxLaW5kW1wiQ3VzdG9tXCJdID0gXCJjdXN0b21cIjtcbn0pKEdyaWRDZWxsS2luZCB8fCAoR3JpZENlbGxLaW5kID0ge30pKTtcbi8qKiBAY2F0ZWdvcnkgQ29sdW1ucyAqL1xuZXhwb3J0IHZhciBHcmlkQ29sdW1uSWNvbjtcbihmdW5jdGlvbiAoR3JpZENvbHVtbkljb24pIHtcbiAgICBHcmlkQ29sdW1uSWNvbltcIkhlYWRlclJvd0lEXCJdID0gXCJoZWFkZXJSb3dJRFwiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVyQ29kZVwiXSA9IFwiaGVhZGVyQ29kZVwiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVyTnVtYmVyXCJdID0gXCJoZWFkZXJOdW1iZXJcIjtcbiAgICBHcmlkQ29sdW1uSWNvbltcIkhlYWRlclN0cmluZ1wiXSA9IFwiaGVhZGVyU3RyaW5nXCI7XG4gICAgR3JpZENvbHVtbkljb25bXCJIZWFkZXJCb29sZWFuXCJdID0gXCJoZWFkZXJCb29sZWFuXCI7XG4gICAgR3JpZENvbHVtbkljb25bXCJIZWFkZXJBdWRpb1VyaVwiXSA9IFwiaGVhZGVyQXVkaW9VcmlcIjtcbiAgICBHcmlkQ29sdW1uSWNvbltcIkhlYWRlclZpZGVvVXJpXCJdID0gXCJoZWFkZXJWaWRlb1VyaVwiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVyRW1vamlcIl0gPSBcImhlYWRlckVtb2ppXCI7XG4gICAgR3JpZENvbHVtbkljb25bXCJIZWFkZXJJbWFnZVwiXSA9IFwiaGVhZGVySW1hZ2VcIjtcbiAgICBHcmlkQ29sdW1uSWNvbltcIkhlYWRlclVyaVwiXSA9IFwiaGVhZGVyVXJpXCI7XG4gICAgR3JpZENvbHVtbkljb25bXCJIZWFkZXJQaG9uZVwiXSA9IFwiaGVhZGVyUGhvbmVcIjtcbiAgICBHcmlkQ29sdW1uSWNvbltcIkhlYWRlck1hcmtkb3duXCJdID0gXCJoZWFkZXJNYXJrZG93blwiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVyRGF0ZVwiXSA9IFwiaGVhZGVyRGF0ZVwiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVyVGltZVwiXSA9IFwiaGVhZGVyVGltZVwiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVyRW1haWxcIl0gPSBcImhlYWRlckVtYWlsXCI7XG4gICAgR3JpZENvbHVtbkljb25bXCJIZWFkZXJSZWZlcmVuY2VcIl0gPSBcImhlYWRlclJlZmVyZW5jZVwiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVySWZUaGVuRWxzZVwiXSA9IFwiaGVhZGVySWZUaGVuRWxzZVwiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVyU2luZ2xlVmFsdWVcIl0gPSBcImhlYWRlclNpbmdsZVZhbHVlXCI7XG4gICAgR3JpZENvbHVtbkljb25bXCJIZWFkZXJMb29rdXBcIl0gPSBcImhlYWRlckxvb2t1cFwiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVyVGV4dFRlbXBsYXRlXCJdID0gXCJoZWFkZXJUZXh0VGVtcGxhdGVcIjtcbiAgICBHcmlkQ29sdW1uSWNvbltcIkhlYWRlck1hdGhcIl0gPSBcImhlYWRlck1hdGhcIjtcbiAgICBHcmlkQ29sdW1uSWNvbltcIkhlYWRlclJvbGx1cFwiXSA9IFwiaGVhZGVyUm9sbHVwXCI7XG4gICAgR3JpZENvbHVtbkljb25bXCJIZWFkZXJKb2luU3RyaW5nc1wiXSA9IFwiaGVhZGVySm9pblN0cmluZ3NcIjtcbiAgICBHcmlkQ29sdW1uSWNvbltcIkhlYWRlclNwbGl0U3RyaW5nXCJdID0gXCJoZWFkZXJTcGxpdFN0cmluZ1wiO1xuICAgIEdyaWRDb2x1bW5JY29uW1wiSGVhZGVyR2VvRGlzdGFuY2VcIl0gPSBcImhlYWRlckdlb0Rpc3RhbmNlXCI7XG4gICAgR3JpZENvbHVtbkljb25bXCJIZWFkZXJBcnJheVwiXSA9IFwiaGVhZGVyQXJyYXlcIjtcbiAgICBHcmlkQ29sdW1uSWNvbltcIlJvd093bmVyT3ZlcmxheVwiXSA9IFwicm93T3duZXJPdmVybGF5XCI7XG4gICAgR3JpZENvbHVtbkljb25bXCJQcm90ZWN0ZWRDb2x1bW5PdmVybGF5XCJdID0gXCJwcm90ZWN0ZWRDb2x1bW5PdmVybGF5XCI7XG59KShHcmlkQ29sdW1uSWNvbiB8fCAoR3JpZENvbHVtbkljb24gPSB7fSkpO1xuLyoqIEBjYXRlZ29yeSBDb2x1bW5zICovXG5leHBvcnQgdmFyIEdyaWRDb2x1bW5NZW51SWNvbjtcbihmdW5jdGlvbiAoR3JpZENvbHVtbk1lbnVJY29uKSB7XG4gICAgR3JpZENvbHVtbk1lbnVJY29uW1wiVHJpYW5nbGVcIl0gPSBcInRyaWFuZ2xlXCI7XG4gICAgR3JpZENvbHVtbk1lbnVJY29uW1wiRG90c1wiXSA9IFwiZG90c1wiO1xufSkoR3JpZENvbHVtbk1lbnVJY29uIHx8IChHcmlkQ29sdW1uTWVudUljb24gPSB7fSkpO1xuLyoqIEBjYXRlZ29yeSBDb2x1bW5zICovXG5leHBvcnQgZnVuY3Rpb24gaXNTaXplZEdyaWRDb2x1bW4oYykge1xuICAgIHJldHVybiBcIndpZHRoXCIgaW4gYyAmJiB0eXBlb2YgYy53aWR0aCA9PT0gXCJudW1iZXJcIjtcbn1cbi8qKiBAY2F0ZWdvcnkgVHlwZXMgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlQ2VsbHNUaHVuayh0aHVuaykge1xuICAgIGlmICh0eXBlb2YgdGh1bmsgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiB0aHVuaztcbiAgICByZXR1cm4gYXdhaXQgdGh1bmsoKTtcbn1cbi8vIEFsbCBFZGl0YWJsZUdyaWRDZWxscyBhcmUgaW5oZXJlbnRseSBWYWxpZGF0ZWRHcmlkQ2VsbHMsIGFuZCB0aGlzIGlzIG1vcmUgc3BlY2lmaWMgYW5kIHRodXMgbW9yZSB1c2VmdWwuXG4vKiogQGNhdGVnb3J5IENlbGxzICovXG5leHBvcnQgZnVuY3Rpb24gaXNFZGl0YWJsZUdyaWRDZWxsKGNlbGwpIHtcbiAgICBpZiAoY2VsbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuTG9hZGluZyB8fFxuICAgICAgICBjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5CdWJibGUgfHxcbiAgICAgICAgY2VsbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuUm93SUQgfHxcbiAgICAgICAgY2VsbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuUHJvdGVjdGVkIHx8XG4gICAgICAgIGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkRyaWxsZG93bikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHByb3ZlVHlwZShjZWxsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBAY2F0ZWdvcnkgQ2VsbHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RleHRFZGl0YWJsZUdyaWRDZWxsKGNlbGwpIHtcbiAgICBpZiAoY2VsbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuTG9hZGluZyB8fFxuICAgICAgICBjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5CdWJibGUgfHxcbiAgICAgICAgY2VsbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuUm93SUQgfHxcbiAgICAgICAgY2VsbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuUHJvdGVjdGVkIHx8XG4gICAgICAgIGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkRyaWxsZG93biB8fFxuICAgICAgICBjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5Cb29sZWFuIHx8XG4gICAgICAgIGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkltYWdlIHx8XG4gICAgICAgIGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkN1c3RvbSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHByb3ZlVHlwZShjZWxsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBAY2F0ZWdvcnkgQ2VsbHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lubmVyT25seUNlbGwoY2VsbCkge1xuICAgIHJldHVybiBjZWxsLmtpbmQgPT09IElubmVyR3JpZENlbGxLaW5kLk1hcmtlciB8fCBjZWxsLmtpbmQgPT09IElubmVyR3JpZENlbGxLaW5kLk5ld1Jvdztcbn1cbi8qKiBAY2F0ZWdvcnkgQ2VsbHMgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JlYWRXcml0ZUNlbGwoY2VsbCkge1xuICAgIGlmICghaXNFZGl0YWJsZUdyaWRDZWxsKGNlbGwpIHx8IGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkltYWdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLlRleHQgfHxcbiAgICAgICAgY2VsbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuTnVtYmVyIHx8XG4gICAgICAgIGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLk1hcmtkb3duIHx8XG4gICAgICAgIGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLlVyaSB8fFxuICAgICAgICBjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20gfHxcbiAgICAgICAgY2VsbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gY2VsbC5yZWFkb25seSAhPT0gdHJ1ZTtcbiAgICB9XG4gICAgYXNzZXJ0TmV2ZXIoY2VsbCwgXCJBIGNlbGwgd2FzIHBhc3NlZCB3aXRoIGFuIGludmFsaWQga2luZFwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1JlY3RhbmdsZUVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnkgJiYgYS53aWR0aCA9PT0gYi53aWR0aCAmJiBhLmhlaWdodCA9PT0gYi5oZWlnaHQ7XG59XG4vKiogQGNhdGVnb3J5IFJlbmRlcmVycyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0RWRpdG9yQ2FsbGJhY2tSZXN1bHQob2JqKSB7XG4gICAgcmV0dXJuIGhhcyhvYmosIFwiZWRpdG9yXCIpO1xufVxuLy8gQ2FuIGJlIHdyaXR0ZW4gbW9yZSBjb25jaXNlbHksIG5vdCBlYXNpZXIgdG8gcmVhZCBpZiBtb3JlIGNvbmNpc2UuXG4vKiogQGNhdGVnb3J5IENlbGxzICovXG5leHBvcnQgZnVuY3Rpb24gYm9vbGVhbkNlbGxJc0VkaXRhYmxlKGNlbGwpIHtcbiAgICByZXR1cm4gIShjZWxsLnJlYWRvbmx5ID8/IGZhbHNlKTtcbn1cbi8qKiBAY2F0ZWdvcnkgQ2VsbHMgKi9cbmV4cG9ydCB2YXIgSW5uZXJHcmlkQ2VsbEtpbmQ7XG4oZnVuY3Rpb24gKElubmVyR3JpZENlbGxLaW5kKSB7XG4gICAgSW5uZXJHcmlkQ2VsbEtpbmRbXCJOZXdSb3dcIl0gPSBcIm5ldy1yb3dcIjtcbiAgICBJbm5lckdyaWRDZWxsS2luZFtcIk1hcmtlclwiXSA9IFwibWFya2VyXCI7XG59KShJbm5lckdyaWRDZWxsS2luZCB8fCAoSW5uZXJHcmlkQ2VsbEtpbmQgPSB7fSkpO1xuZnVuY3Rpb24gbWVyZ2VSYW5nZXMoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VzID0gWy4uLmlucHV0XTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIHJhbmdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICB9KTtcbiAgICBzdGFjay5wdXNoKFsuLi5yYW5nZXNbMF1dKTtcbiAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIHJhbmdlcy5zbGljZSgxKSkge1xuICAgICAgICBjb25zdCB0b3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRvcFsxXSA8IHJhbmdlWzBdKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFsuLi5yYW5nZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvcFsxXSA8IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICB0b3BbMV0gPSByYW5nZVsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG5sZXQgZW1wdHlDb21wYWN0U2VsZWN0aW9uO1xuLyoqIEBjYXRlZ29yeSBTZWxlY3Rpb24gKi9cbmV4cG9ydCBjbGFzcyBDb21wYWN0U2VsZWN0aW9uIHtcbiAgICBpdGVtcztcbiAgICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGVtcHR5Q29tcGFjdFNlbGVjdGlvbiA/PyAoZW1wdHlDb21wYWN0U2VsZWN0aW9uID0gbmV3IENvbXBhY3RTZWxlY3Rpb24oW10pKTtcbiAgICB9O1xuICAgIHN0YXRpYyBmcm9tU2luZ2xlU2VsZWN0aW9uID0gKHNlbGVjdGlvbikgPT4ge1xuICAgICAgICByZXR1cm4gQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLmFkZChzZWxlY3Rpb24pO1xuICAgIH07XG4gICAgb2Zmc2V0KGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IG5ld0l0ZW1zID0gdGhpcy5pdGVtcy5tYXAoeCA9PiBbeFswXSArIGFtb3VudCwgeFsxXSArIGFtb3VudF0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBhY3RTZWxlY3Rpb24obmV3SXRlbXMpO1xuICAgIH1cbiAgICBhZGQoc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNsaWNlID0gdHlwZW9mIHNlbGVjdGlvbiA9PT0gXCJudW1iZXJcIiA/IFtzZWxlY3Rpb24sIHNlbGVjdGlvbiArIDFdIDogc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBuZXdJdGVtcyA9IG1lcmdlUmFuZ2VzKFsuLi50aGlzLml0ZW1zLCBzbGljZV0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBhY3RTZWxlY3Rpb24obmV3SXRlbXMpO1xuICAgIH1cbiAgICByZW1vdmUoc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLnRoaXMuaXRlbXNdO1xuICAgICAgICBjb25zdCBzZWxNaW4gPSB0eXBlb2Ygc2VsZWN0aW9uID09PSBcIm51bWJlclwiID8gc2VsZWN0aW9uIDogc2VsZWN0aW9uWzBdO1xuICAgICAgICBjb25zdCBzZWxNYXggPSB0eXBlb2Ygc2VsZWN0aW9uID09PSBcIm51bWJlclwiID8gc2VsZWN0aW9uICsgMSA6IHNlbGVjdGlvblsxXTtcbiAgICAgICAgZm9yIChjb25zdCBbaSwgc2xpY2VdIG9mIGl0ZW1zLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gc2xpY2U7XG4gICAgICAgICAgICAvLyBSZW1vdmUgcGFydCBvZiBzbGljZSB0aGF0IGludGVyc2VjdHMgcmVtb3ZlZCBzZWxlY3Rpb24uXG4gICAgICAgICAgICBpZiAoc3RhcnQgPD0gc2VsTWF4ICYmIHNlbE1pbiA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0FkZCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHNlbE1pbikge1xuICAgICAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKFtzdGFydCwgc2VsTWluXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxNYXggPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9BZGQucHVzaChbc2VsTWF4LCBlbmRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbXMuc3BsaWNlKGksIDEsIC4uLnRvQWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBhY3RTZWxlY3Rpb24oaXRlbXMpO1xuICAgIH1cbiAgICBmaXJzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbMF1bMF07XG4gICAgfVxuICAgIGxhc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnNsaWNlKC0xKVswXVsxXSAtIDE7XG4gICAgfVxuICAgIGhhc0luZGV4KGluZGV4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBzdGFydCAmJiBpbmRleCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0FsbChpbmRleCkge1xuICAgICAgICBmb3IgKGxldCB4ID0gaW5kZXhbMF07IHggPCBpbmRleFsxXTsgeCsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzSW5kZXgoeCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzb21lKHByZWRpY2F0ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcykge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG90aGVyLml0ZW1zLmxlbmd0aCAhPT0gdGhpcy5pdGVtcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IG90aGVyLml0ZW1zW2ldO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLml0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGxlZnRbMF0gIT09IHJpZ2h0WzBdIHx8IGxlZnRbMV0gIT09IHJpZ2h0WzFdKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUmVhbGx5IG9sZCBKUyB3b250IGhhdmUgYWNjZXNzIHRvIHRoZSBpdGVyYXRvciBhbmQgYmFiZWwgd2lsbCBzdG9wIHBlb3BsZSB1c2luZyBpdFxuICAgIC8vIHdoZW4gdHJ5aW5nIHRvIHN1cHBvcnQgYnJvd3NlcnMgc28gb2xkIHdlIGRvbid0IHN1cHBvcnQgdGhlbSBhbnl3YXkuIFdoYXQgZ29lcyBvblxuICAgIC8vIGJldHdlZW4gYW4gZW5naW5lZXIgYW5kIHRoZWlyIGJ1bmRsZXIgaW4gdGhlIHByaXZhY3kgb2YgdGhlaXIgQ0kgc2VydmVyIGlzIG5vbmUgb2ZcbiAgICAvLyBteSBidXNpbmVzcyBhbnl3YXkuXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBzdGFydDsgeCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGxlbiArPSBlbmQgLSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3N0YXJ0LCBlbmRdIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBzdGFydDsgeCA8IGVuZDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtZ3JpZC10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./render/data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _cell_set_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cell-set.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/cell-set.js\");\n/* harmony import */ var _data_grid_sprites_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data-grid-sprites.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-sprites.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* harmony import */ var lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/clamp.js */ \"(ssr)/./node_modules/lodash/clamp.js\");\n/* harmony import */ var lodash_range_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/range.js */ \"(ssr)/./node_modules/lodash/range.js\");\n/* harmony import */ var _render_data_grid_render_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./render/data-grid-render.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.js\");\n/* harmony import */ var _animation_manager_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./animation-manager.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/animation-manager.js\");\n/* harmony import */ var _common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../common/render-state-provider.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/render-state-provider.js\");\n/* harmony import */ var _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/browser-detect.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/browser-detect.js\");\n/* harmony import */ var _use_animation_queue_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./use-animation-queue.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/use-animation-queue.js\");\n/* harmony import */ var _common_support_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n/* harmony import */ var _event_args_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./event-args.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/event-args.js\");\n/* harmony import */ var _common_math_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../common/math.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js\");\n/* harmony import */ var _render_data_grid_render_cells_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./render/data-grid-render.cells.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.cells.js\");\n/* harmony import */ var _render_data_grid_render_header_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./render/data-grid-render.header.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.header.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst fillHandleClickSize = 6;\nconst getRowData = (cell, getCellRenderer) => {\n    if (cell.kind === _data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.GridCellKind.Custom)\n        return cell.copyData;\n    const r = getCellRenderer?.(cell);\n    return r?.getAccessibilityString(cell) ?? \"\";\n};\nconst DataGrid = (p, forwardedRef) => {\n    const { width, height, accessibilityHeight, columns, cellXOffset: cellXOffsetReal, cellYOffset, headerHeight, fillHandle = false, groupHeaderHeight, rowHeight, rows, getCellContent, getRowThemeOverride, onHeaderMenuClick, enableGroups, isFilling, onCanvasFocused, onCanvasBlur, isFocused, selection, freezeColumns, onContextMenu, freezeTrailingRows, fixedShadowX = true, fixedShadowY = true, drawFocusRing, onMouseDown, onMouseUp, onMouseMoveRaw, onMouseMove, onItemHovered, dragAndDropState, firstColAccessible, onKeyDown, onKeyUp, highlightRegions, canvasRef, onDragStart, onDragEnd, eventTargetRef, isResizing, resizeColumn: resizeCol, isDragging, isDraggable = false, allowResize, disabledRows, hasAppendRow, getGroupDetails, theme, prelightCells, headerIcons, verticalBorder, drawCell: drawCellCallback, drawHeader: drawHeaderCallback, onCellFocused, onDragOverCell, onDrop, onDragLeave, imageWindowLoader, smoothScrollX = false, smoothScrollY = false, experimental, getCellRenderer, } = p;\n    const translateX = p.translateX ?? 0;\n    const translateY = p.translateY ?? 0;\n    const cellXOffset = Math.max(freezeColumns, Math.min(columns.length - 1, cellXOffsetReal));\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const imageLoader = imageWindowLoader;\n    const damageRegion = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const [scrolling, setScrolling] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const hoverValues = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const lastBlitData = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const [hoveredItemInfo, setHoveredItemInfo] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [hoveredOnEdge, setHoveredOnEdge] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const overlayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [drawCursorOverride, setDrawCursorOverride] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [lastWasTouch, setLastWasTouch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const lastWasTouchRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(lastWasTouch);\n    lastWasTouchRef.current = lastWasTouch;\n    const spriteManager = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new _data_grid_sprites_js__WEBPACK_IMPORTED_MODULE_4__.SpriteManager(headerIcons, () => {\n        lastArgsRef.current = undefined;\n        lastDrawRef.current();\n    }), [headerIcons]);\n    const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;\n    const scrollingStopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n    const enableFirefoxRescaling = (experimental?.enableFirefoxRescaling ?? false) && _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_5__.browserIsFirefox.value;\n    const enableSafariRescaling = (experimental?.enableSafariRescaling ?? false) && _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_5__.browserIsSafari.value;\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (window.devicePixelRatio === 1 || (!enableFirefoxRescaling && !enableSafariRescaling))\n            return;\n        // We don't want to go into scroll mode for a single repaint\n        if (scrollingStopRef.current !== -1) {\n            setScrolling(true);\n        }\n        window.clearTimeout(scrollingStopRef.current);\n        scrollingStopRef.current = window.setTimeout(() => {\n            setScrolling(false);\n            scrollingStopRef.current = -1;\n        }, 200);\n    }, [cellYOffset, cellXOffset, translateX, translateY, enableFirefoxRescaling, enableSafariRescaling]);\n    const mappedColumns = (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_6__.useMappedColumns)(columns, freezeColumns);\n    const stickyX = fixedShadowX ? (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_6__.getStickyWidth)(mappedColumns, dragAndDropState) : 0;\n    // row: -1 === columnHeader, -2 === groupHeader\n    const getBoundsForItem = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, col, row) => {\n        const rect = canvas.getBoundingClientRect();\n        if (col >= mappedColumns.length || row >= rows) {\n            return undefined;\n        }\n        const scale = rect.width / width;\n        const result = (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_6__.computeBounds)(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, freezeTrailingRows, mappedColumns, rowHeight);\n        if (scale !== 1) {\n            result.x *= scale;\n            result.y *= scale;\n            result.width *= scale;\n            result.height *= scale;\n        }\n        result.x += rect.x;\n        result.y += rect.y;\n        return result;\n    }, [\n        width,\n        height,\n        groupHeaderHeight,\n        totalHeaderHeight,\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        rows,\n        freezeColumns,\n        freezeTrailingRows,\n        mappedColumns,\n        rowHeight,\n    ]);\n    const getMouseArgsForPosition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, posX, posY, ev) => {\n        const rect = canvas.getBoundingClientRect();\n        const scale = rect.width / width;\n        const x = (posX - rect.left) / scale;\n        const y = (posY - rect.top) / scale;\n        const edgeDetectionBuffer = 5;\n        const effectiveCols = (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_6__.getEffectiveColumns)(mappedColumns, cellXOffset, width, undefined, translateX);\n        let button = 0;\n        let buttons = 0;\n        if (ev instanceof MouseEvent) {\n            button = ev.button;\n            buttons = ev.buttons;\n        }\n        // -1 === off right edge\n        const col = (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_6__.getColumnIndexForX)(x, effectiveCols, translateX);\n        // -1: header or above\n        // undefined: offbottom\n        const row = (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_6__.getRowIndexForY)(y, height, enableGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, freezeTrailingRows);\n        const shiftKey = ev?.shiftKey === true;\n        const ctrlKey = ev?.ctrlKey === true;\n        const metaKey = ev?.metaKey === true;\n        const isTouch = (ev !== undefined && !(ev instanceof MouseEvent)) || ev?.pointerType === \"touch\";\n        const scrollEdge = [\n            x < 0 ? -1 : width < x ? 1 : 0,\n            y < totalHeaderHeight ? -1 : height < y ? 1 : 0,\n        ];\n        let result;\n        if (col === -1 || y < 0 || x < 0 || row === undefined || x > width || y > height) {\n            const horizontal = x > width ? 1 : x < 0 ? -1 : 0;\n            const vertical = y > height ? 1 : y < 0 ? -1 : 0;\n            let innerHorizontal = horizontal * 2;\n            let innerVertical = vertical * 2;\n            if (horizontal === 0)\n                innerHorizontal = col === -1 ? _event_args_js__WEBPACK_IMPORTED_MODULE_7__.OutOfBoundsRegionAxis.EndPadding : _event_args_js__WEBPACK_IMPORTED_MODULE_7__.OutOfBoundsRegionAxis.Center;\n            if (vertical === 0)\n                innerVertical = row === undefined ? _event_args_js__WEBPACK_IMPORTED_MODULE_7__.OutOfBoundsRegionAxis.EndPadding : _event_args_js__WEBPACK_IMPORTED_MODULE_7__.OutOfBoundsRegionAxis.Center;\n            let isEdge = false;\n            if (col === -1 && row === -1) {\n                const b = getBoundsForItem(canvas, mappedColumns.length - 1, -1);\n                (0,_common_support_js__WEBPACK_IMPORTED_MODULE_8__.assert)(b !== undefined);\n                isEdge = posX < b.x + b.width + edgeDetectionBuffer;\n            }\n            // This is used to ensure that clicking on the scrollbar doesn't unset the selection.\n            // Unfortunately this doesn't work for overlay scrollbars because they are just a broken interaction\n            // by design.\n            const isMaybeScrollbar = (x > width && x < width + (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.getScrollBarWidth)()) || (y > height && y < height + (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.getScrollBarWidth)());\n            result = {\n                kind: _event_args_js__WEBPACK_IMPORTED_MODULE_7__.outOfBoundsKind,\n                location: [col !== -1 ? col : x < 0 ? 0 : mappedColumns.length - 1, row ?? rows - 1],\n                region: [innerHorizontal, innerVertical],\n                shiftKey,\n                ctrlKey,\n                metaKey,\n                isEdge,\n                isTouch,\n                button,\n                buttons,\n                scrollEdge,\n                isMaybeScrollbar,\n            };\n        }\n        else if (row <= -1) {\n            let bounds = getBoundsForItem(canvas, col, row);\n            (0,_common_support_js__WEBPACK_IMPORTED_MODULE_8__.assert)(bounds !== undefined);\n            let isEdge = bounds !== undefined && bounds.x + bounds.width - posX <= edgeDetectionBuffer;\n            const previousCol = col - 1;\n            if (posX - bounds.x <= edgeDetectionBuffer && previousCol >= 0) {\n                isEdge = true;\n                bounds = getBoundsForItem(canvas, previousCol, row);\n                (0,_common_support_js__WEBPACK_IMPORTED_MODULE_8__.assert)(bounds !== undefined);\n                result = {\n                    kind: enableGroups && row === -2 ? _event_args_js__WEBPACK_IMPORTED_MODULE_7__.groupHeaderKind : _event_args_js__WEBPACK_IMPORTED_MODULE_7__.headerKind,\n                    location: [previousCol, row],\n                    bounds: bounds,\n                    group: mappedColumns[previousCol].group ?? \"\",\n                    isEdge,\n                    shiftKey,\n                    ctrlKey,\n                    metaKey,\n                    isTouch,\n                    localEventX: posX - bounds.x,\n                    localEventY: posY - bounds.y,\n                    button,\n                    buttons,\n                    scrollEdge,\n                };\n            }\n            else {\n                result = {\n                    kind: enableGroups && row === -2 ? _event_args_js__WEBPACK_IMPORTED_MODULE_7__.groupHeaderKind : _event_args_js__WEBPACK_IMPORTED_MODULE_7__.headerKind,\n                    group: mappedColumns[col].group ?? \"\",\n                    location: [col, row],\n                    bounds: bounds,\n                    isEdge,\n                    shiftKey,\n                    ctrlKey,\n                    metaKey,\n                    isTouch,\n                    localEventX: posX - bounds.x,\n                    localEventY: posY - bounds.y,\n                    button,\n                    buttons,\n                    scrollEdge,\n                };\n            }\n        }\n        else {\n            const bounds = getBoundsForItem(canvas, col, row);\n            (0,_common_support_js__WEBPACK_IMPORTED_MODULE_8__.assert)(bounds !== undefined);\n            const isEdge = bounds !== undefined && bounds.x + bounds.width - posX < edgeDetectionBuffer;\n            let isFillHandle = false;\n            if (fillHandle && selection.current !== undefined) {\n                const fillHandleLocation = (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_6__.rectBottomRight)(selection.current.range);\n                const fillHandleCellBounds = getBoundsForItem(canvas, fillHandleLocation[0], fillHandleLocation[1]);\n                if (fillHandleCellBounds !== undefined) {\n                    const handleLogicalCenterX = fillHandleCellBounds.x + fillHandleCellBounds.width - 2;\n                    const handleLogicalCenterY = fillHandleCellBounds.y + fillHandleCellBounds.height - 2;\n                    //check if posX and posY are within fillHandleClickSize from handleLogicalCenter\n                    isFillHandle =\n                        Math.abs(handleLogicalCenterX - posX) < fillHandleClickSize &&\n                            Math.abs(handleLogicalCenterY - posY) < fillHandleClickSize;\n                }\n            }\n            result = {\n                kind: \"cell\",\n                location: [col, row],\n                bounds: bounds,\n                isEdge,\n                shiftKey,\n                ctrlKey,\n                isFillHandle,\n                metaKey,\n                isTouch,\n                localEventX: posX - bounds.x,\n                localEventY: posY - bounds.y,\n                button,\n                buttons,\n                scrollEdge,\n            };\n        }\n        return result;\n    }, [\n        width,\n        mappedColumns,\n        cellXOffset,\n        translateX,\n        height,\n        enableGroups,\n        headerHeight,\n        groupHeaderHeight,\n        rows,\n        rowHeight,\n        cellYOffset,\n        translateY,\n        freezeTrailingRows,\n        getBoundsForItem,\n        fillHandle,\n        selection,\n        totalHeaderHeight,\n    ]);\n    const [hoveredItem] = hoveredItemInfo ?? [];\n    const enqueueRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {\n        // do nothing\n    });\n    const hoverInfoRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(hoveredItemInfo);\n    hoverInfoRef.current = hoveredItemInfo;\n    const [bufferACtx, bufferBCtx] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        const a = document.createElement(\"canvas\");\n        const b = document.createElement(\"canvas\");\n        a.style[\"display\"] = \"none\";\n        a.style[\"opacity\"] = \"0\";\n        a.style[\"position\"] = \"fixed\";\n        b.style[\"display\"] = \"none\";\n        b.style[\"opacity\"] = \"0\";\n        b.style[\"position\"] = \"fixed\";\n        return [a.getContext(\"2d\", { alpha: false }), b.getContext(\"2d\", { alpha: false })];\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (bufferACtx === null || bufferBCtx === null)\n            return;\n        document.documentElement.append(bufferACtx.canvas);\n        document.documentElement.append(bufferBCtx.canvas);\n        return () => {\n            bufferACtx.canvas.remove();\n            bufferBCtx.canvas.remove();\n        };\n    }, [bufferACtx, bufferBCtx]);\n    const renderStateProvider = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new _common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_10__.RenderStateProvider(), []);\n    const maxDPR = enableFirefoxRescaling && scrolling ? 1 : enableSafariRescaling && scrolling ? 2 : 5;\n    const minimumCellWidth = experimental?.disableMinimumCellWidth === true ? 1 : 10;\n    const lastArgsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const canvasCtx = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const overlayCtx = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const draw = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        const canvas = ref.current;\n        const overlay = overlayRef.current;\n        if (canvas === null || overlay === null)\n            return;\n        if (canvasCtx.current === null) {\n            canvasCtx.current = canvas.getContext(\"2d\", { alpha: false });\n            canvas.width = 0;\n            canvas.height = 0;\n        }\n        if (overlayCtx.current === null) {\n            overlayCtx.current = overlay.getContext(\"2d\", { alpha: false });\n            overlay.width = 0;\n            overlay.height = 0;\n        }\n        if (canvasCtx.current === null || overlayCtx.current === null || bufferACtx === null || bufferBCtx === null) {\n            return;\n        }\n        let didOverride = false;\n        const overrideCursor = (cursor) => {\n            didOverride = true;\n            setDrawCursorOverride(cursor);\n        };\n        const last = lastArgsRef.current;\n        const current = {\n            headerCanvasCtx: overlayCtx.current,\n            canvasCtx: canvasCtx.current,\n            bufferACtx,\n            bufferBCtx,\n            width,\n            height,\n            cellXOffset,\n            cellYOffset,\n            translateX: Math.round(translateX),\n            translateY: Math.round(translateY),\n            mappedColumns,\n            enableGroups,\n            freezeColumns,\n            dragAndDropState,\n            theme,\n            headerHeight,\n            groupHeaderHeight,\n            disabledRows: disabledRows ?? _data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.CompactSelection.empty(),\n            rowHeight,\n            verticalBorder,\n            isResizing,\n            resizeCol,\n            isFocused,\n            selection,\n            fillHandle,\n            drawCellCallback,\n            hasAppendRow,\n            overrideCursor,\n            maxScaleFactor: maxDPR,\n            freezeTrailingRows,\n            rows,\n            drawFocus: drawFocusRing,\n            getCellContent,\n            getGroupDetails: getGroupDetails ?? (name => ({ name })),\n            getRowThemeOverride,\n            drawHeaderCallback,\n            prelightCells,\n            highlightRegions,\n            imageLoader,\n            lastBlitData,\n            damage: damageRegion.current,\n            hoverValues: hoverValues.current,\n            hoverInfo: hoverInfoRef.current,\n            spriteManager,\n            scrolling,\n            hyperWrapping: experimental?.hyperWrapping ?? false,\n            touchMode: lastWasTouch,\n            enqueue: enqueueRef.current,\n            renderStateProvider,\n            renderStrategy: experimental?.renderStrategy ?? (_common_browser_detect_js__WEBPACK_IMPORTED_MODULE_5__.browserIsSafari.value ? \"double-buffer\" : \"single-buffer\"),\n            getCellRenderer,\n            minimumCellWidth,\n        };\n        // This confusing bit of code due to some poor design. Long story short, the damage property is only used\n        // with what is effectively the \"last args\" for the last normal draw anyway. We don't want the drawing code\n        // to look at this and go \"shit dawg, nothing changed\" so we force it to draw frash, but the damage restricts\n        // the draw anyway.\n        //\n        // Dear future Jason, I'm sorry. It was expedient, it worked, and had almost zero perf overhead. THe universe\n        // basically made me do it. What choice did I have?\n        if (current.damage === undefined) {\n            lastArgsRef.current = current;\n            (0,_render_data_grid_render_js__WEBPACK_IMPORTED_MODULE_11__.drawGrid)(current, last);\n        }\n        else {\n            (0,_render_data_grid_render_js__WEBPACK_IMPORTED_MODULE_11__.drawGrid)(current, undefined);\n        }\n        // don't reset on damage events\n        if (!didOverride && (current.damage === undefined || current.damage.has(hoverInfoRef?.current?.[0]))) {\n            setDrawCursorOverride(undefined);\n        }\n    }, [\n        bufferACtx,\n        bufferBCtx,\n        width,\n        height,\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mappedColumns,\n        enableGroups,\n        freezeColumns,\n        dragAndDropState,\n        theme,\n        headerHeight,\n        groupHeaderHeight,\n        disabledRows,\n        rowHeight,\n        verticalBorder,\n        isResizing,\n        hasAppendRow,\n        resizeCol,\n        isFocused,\n        selection,\n        fillHandle,\n        freezeTrailingRows,\n        rows,\n        drawFocusRing,\n        maxDPR,\n        getCellContent,\n        getGroupDetails,\n        getRowThemeOverride,\n        drawCellCallback,\n        drawHeaderCallback,\n        prelightCells,\n        highlightRegions,\n        imageLoader,\n        spriteManager,\n        scrolling,\n        experimental?.hyperWrapping,\n        experimental?.renderStrategy,\n        lastWasTouch,\n        renderStateProvider,\n        getCellRenderer,\n        minimumCellWidth,\n    ]);\n    const lastDrawRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(draw);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        draw();\n        lastDrawRef.current = draw;\n    }, [draw]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        const fn = async () => {\n            if (document?.fonts?.ready === undefined)\n                return;\n            await document.fonts.ready;\n            lastArgsRef.current = undefined;\n            lastDrawRef.current();\n        };\n        void fn();\n    }, []);\n    const damageInternal = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((locations) => {\n        damageRegion.current = locations;\n        lastDrawRef.current();\n        damageRegion.current = undefined;\n    }, []);\n    const enqueue = (0,_use_animation_queue_js__WEBPACK_IMPORTED_MODULE_12__.useAnimationQueue)(damageInternal);\n    enqueueRef.current = enqueue;\n    const damage = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cells) => {\n        damageInternal(new _cell_set_js__WEBPACK_IMPORTED_MODULE_13__.CellSet(cells.map(x => x.cell)));\n    }, [damageInternal]);\n    imageLoader.setCallback(damageInternal);\n    const [overFill, setOverFill] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [hCol, hRow] = hoveredItem ?? [];\n    const headerHovered = hCol !== undefined && hRow === -1;\n    const groupHeaderHovered = hCol !== undefined && hRow === -2;\n    let clickableInnerCellHovered = false;\n    let editableBoolHovered = false;\n    let cursorOverride = drawCursorOverride;\n    if (cursorOverride === undefined && hCol !== undefined && hRow !== undefined && hRow > -1 && hRow < rows) {\n        const cell = getCellContent([hCol, hRow], true);\n        clickableInnerCellHovered =\n            cell.kind === _data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.InnerGridCellKind.NewRow ||\n                (cell.kind === _data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.InnerGridCellKind.Marker && cell.markerKind !== \"number\");\n        editableBoolHovered = cell.kind === _data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.GridCellKind.Boolean && (0,_data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.booleanCellIsEditable)(cell);\n        cursorOverride = cell.cursor;\n    }\n    const canDrag = hoveredOnEdge ?? false;\n    const cursor = isDragging\n        ? \"grabbing\"\n        : canDrag || isResizing\n            ? \"col-resize\"\n            : overFill || isFilling\n                ? \"crosshair\"\n                : cursorOverride !== undefined\n                    ? cursorOverride\n                    : headerHovered || clickableInnerCellHovered || editableBoolHovered || groupHeaderHovered\n                        ? \"pointer\"\n                        : \"default\";\n    const style = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n        // width,\n        // height,\n        contain: \"strict\",\n        display: \"block\",\n        cursor,\n    }), [cursor]);\n    const lastSetCursor = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"default\");\n    const target = eventTargetRef?.current;\n    if (target !== null && target !== undefined && lastSetCursor.current !== style.cursor) {\n        // because we have an event target we need to set its cursor instead.\n        target.style.cursor = lastSetCursor.current = style.cursor;\n    }\n    const groupHeaderActionForEvent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((group, bounds, localEventX, localEventY) => {\n        if (getGroupDetails === undefined)\n            return undefined;\n        const groupDesc = getGroupDetails(group);\n        if (groupDesc.actions !== undefined) {\n            const boxes = (0,_render_data_grid_render_header_js__WEBPACK_IMPORTED_MODULE_14__.getActionBoundsForGroup)(bounds, groupDesc.actions);\n            for (const [i, box] of boxes.entries()) {\n                if ((0,_common_math_js__WEBPACK_IMPORTED_MODULE_15__.pointInRect)(box, localEventX + bounds.x, localEventY + box.y)) {\n                    return groupDesc.actions[i];\n                }\n            }\n        }\n        return undefined;\n    }, [getGroupDetails]);\n    const isOverHeaderMenu = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((canvas, col, clientX, clientY) => {\n        const header = columns[col];\n        if (!isDragging && !isResizing && header.hasMenu === true && !(hoveredOnEdge ?? false)) {\n            const headerBounds = getBoundsForItem(canvas, col, -1);\n            (0,_common_support_js__WEBPACK_IMPORTED_MODULE_8__.assert)(headerBounds !== undefined);\n            const menuBounds = (0,_render_data_grid_render_header_js__WEBPACK_IMPORTED_MODULE_14__.getHeaderMenuBounds)(headerBounds.x, headerBounds.y, headerBounds.width, headerBounds.height, (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.direction)(header.title) === \"rtl\");\n            if (clientX > menuBounds.x &&\n                clientX < menuBounds.x + menuBounds.width &&\n                clientY > menuBounds.y &&\n                clientY < menuBounds.y + menuBounds.height) {\n                return headerBounds;\n            }\n        }\n        return undefined;\n    }, [columns, getBoundsForItem, hoveredOnEdge, isDragging, isResizing]);\n    const downTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const downPosition = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const mouseDown = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const onMouseDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((ev) => {\n        const canvas = ref.current;\n        const eventTarget = eventTargetRef?.current;\n        if (canvas === null || (ev.target !== canvas && ev.target !== eventTarget))\n            return;\n        mouseDown.current = true;\n        let clientX;\n        let clientY;\n        if (ev instanceof MouseEvent) {\n            clientX = ev.clientX;\n            clientY = ev.clientY;\n        }\n        else {\n            clientX = ev.touches[0].clientX;\n            clientY = ev.touches[0].clientY;\n        }\n        if (ev.target === eventTarget && eventTarget !== null) {\n            const bounds = eventTarget.getBoundingClientRect();\n            if (clientX > bounds.right || clientY > bounds.bottom)\n                return;\n        }\n        const args = getMouseArgsForPosition(canvas, clientX, clientY, ev);\n        downPosition.current = args.location;\n        if (args.isTouch) {\n            downTime.current = Date.now();\n        }\n        if (lastWasTouchRef.current !== args.isTouch) {\n            setLastWasTouch(args.isTouch);\n        }\n        if (args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.headerKind &&\n            isOverHeaderMenu(canvas, args.location[0], clientX, clientY) !== undefined) {\n            return;\n        }\n        else if (args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.groupHeaderKind) {\n            const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);\n            if (action !== undefined) {\n                return;\n            }\n        }\n        onMouseDown?.(args);\n        if (!args.isTouch &&\n            isDraggable !== true &&\n            isDraggable !== args.kind &&\n            args.button < 3 &&\n            args.button !== 1) {\n            // preventing default in touch events stops scroll\n            ev.preventDefault();\n        }\n    }, [eventTargetRef, isDraggable, getMouseArgsForPosition, groupHeaderActionForEvent, isOverHeaderMenu, onMouseDown]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"touchstart\", onMouseDownImpl, window, false);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"mousedown\", onMouseDownImpl, window, false);\n    const lastUpTime = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const onMouseUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((ev) => {\n        const lastUpTimeValue = lastUpTime.current;\n        lastUpTime.current = Date.now();\n        const canvas = ref.current;\n        mouseDown.current = false;\n        if (onMouseUp === undefined || canvas === null)\n            return;\n        const eventTarget = eventTargetRef?.current;\n        const isOutside = ev.target !== canvas && ev.target !== eventTarget;\n        let clientX;\n        let clientY;\n        let canCancel = true;\n        if (ev instanceof MouseEvent) {\n            clientX = ev.clientX;\n            clientY = ev.clientY;\n            canCancel = ev.button < 3;\n            if (ev.pointerType === \"touch\") {\n                return;\n            }\n        }\n        else {\n            clientX = ev.changedTouches[0].clientX;\n            clientY = ev.changedTouches[0].clientY;\n        }\n        let args = getMouseArgsForPosition(canvas, clientX, clientY, ev);\n        if (args.isTouch && downTime.current !== 0 && Date.now() - downTime.current > 500) {\n            args = {\n                ...args,\n                isLongTouch: true,\n            };\n        }\n        if (lastUpTimeValue !== 0 && Date.now() - lastUpTimeValue < (args.isTouch ? 1000 : 500)) {\n            args = {\n                ...args,\n                isDoubleClick: true,\n            };\n        }\n        if (lastWasTouchRef.current !== args.isTouch) {\n            setLastWasTouch(args.isTouch);\n        }\n        if (!isOutside && ev.cancelable && canCancel) {\n            ev.preventDefault();\n        }\n        const [col] = args.location;\n        const headerBounds = isOverHeaderMenu(canvas, col, clientX, clientY);\n        if (args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.headerKind && headerBounds !== undefined) {\n            if (args.button !== 0 || downPosition.current?.[0] !== col || downPosition.current?.[1] !== -1) {\n                // force outside so that click will not process\n                onMouseUp(args, true);\n            }\n            return;\n        }\n        else if (args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.groupHeaderKind) {\n            const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);\n            if (action !== undefined) {\n                if (args.button === 0) {\n                    action.onClick(args);\n                }\n                return;\n            }\n        }\n        onMouseUp(args, isOutside);\n    }, [onMouseUp, eventTargetRef, getMouseArgsForPosition, isOverHeaderMenu, groupHeaderActionForEvent]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"mouseup\", onMouseUpImpl, window, false);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"touchend\", onMouseUpImpl, window, false);\n    const onClickImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((ev) => {\n        const canvas = ref.current;\n        if (canvas === null)\n            return;\n        const eventTarget = eventTargetRef?.current;\n        const isOutside = ev.target !== canvas && ev.target !== eventTarget;\n        let clientX;\n        let clientY;\n        let canCancel = true;\n        if (ev instanceof MouseEvent) {\n            clientX = ev.clientX;\n            clientY = ev.clientY;\n            canCancel = ev.button < 3;\n        }\n        else {\n            clientX = ev.changedTouches[0].clientX;\n            clientY = ev.changedTouches[0].clientY;\n        }\n        const args = getMouseArgsForPosition(canvas, clientX, clientY, ev);\n        if (lastWasTouchRef.current !== args.isTouch) {\n            setLastWasTouch(args.isTouch);\n        }\n        if (!isOutside && ev.cancelable && canCancel) {\n            ev.preventDefault();\n        }\n        const [col] = args.location;\n        const headerBounds = isOverHeaderMenu(canvas, col, clientX, clientY);\n        if (args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.headerKind && headerBounds !== undefined) {\n            if (args.button === 0 && downPosition.current?.[0] === col && downPosition.current?.[1] === -1) {\n                onHeaderMenuClick?.(col, headerBounds);\n            }\n        }\n        else if (args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.groupHeaderKind) {\n            const action = groupHeaderActionForEvent(args.group, args.bounds, args.localEventX, args.localEventY);\n            if (action !== undefined && args.button === 0) {\n                action.onClick(args);\n            }\n        }\n    }, [eventTargetRef, getMouseArgsForPosition, isOverHeaderMenu, onHeaderMenuClick, groupHeaderActionForEvent]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"click\", onClickImpl, window, false);\n    const onContextMenuImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((ev) => {\n        const canvas = ref.current;\n        const eventTarget = eventTargetRef?.current;\n        if (canvas === null || (ev.target !== canvas && ev.target !== eventTarget) || onContextMenu === undefined)\n            return;\n        const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);\n        onContextMenu(args, () => {\n            if (ev.cancelable)\n                ev.preventDefault();\n        });\n    }, [eventTargetRef, getMouseArgsForPosition, onContextMenu]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"contextmenu\", onContextMenuImpl, eventTargetRef?.current ?? null, false);\n    const onAnimationFrame = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(values => {\n        damageRegion.current = new _cell_set_js__WEBPACK_IMPORTED_MODULE_13__.CellSet(values.map(x => x.item));\n        hoverValues.current = values;\n        lastDrawRef.current();\n        damageRegion.current = undefined;\n    }, []);\n    const animManagerValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => new _animation_manager_js__WEBPACK_IMPORTED_MODULE_16__.AnimationManager(onAnimationFrame), [onAnimationFrame]);\n    const animationManager = react__WEBPACK_IMPORTED_MODULE_0__.useRef(animManagerValue);\n    animationManager.current = animManagerValue;\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        const am = animationManager.current;\n        if (hoveredItem === undefined || hoveredItem[1] < 0) {\n            am.setHovered(hoveredItem);\n            return;\n        }\n        const cell = getCellContent(hoveredItem, true);\n        const r = getCellRenderer(cell);\n        const cellNeedsHover = (r === undefined && cell.kind === _data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.GridCellKind.Custom) ||\n            (r?.needsHover !== undefined && (typeof r.needsHover === \"boolean\" ? r.needsHover : r.needsHover(cell)));\n        am.setHovered(cellNeedsHover ? hoveredItem : undefined);\n    }, [getCellContent, getCellRenderer, hoveredItem]);\n    const hoveredRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const onMouseMoveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((ev) => {\n        const canvas = ref.current;\n        if (canvas === null)\n            return;\n        const eventTarget = eventTargetRef?.current;\n        const isIndirect = ev.target !== canvas && ev.target !== eventTarget;\n        const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);\n        if (args.kind !== \"out-of-bounds\" && isIndirect && !mouseDown.current && !args.isTouch) {\n            // we are obscured by something else, so we want to not register events if we are not doing anything\n            // important already\n            return;\n        }\n        // the point here is not to trigger re-renders every time the mouse moves over a cell\n        // that doesn't care about the mouse positon.\n        const maybeSetHoveredInfo = (newVal, needPosition) => {\n            setHoveredItemInfo(cv => {\n                if (cv === newVal)\n                    return cv;\n                if (cv?.[0][0] === newVal?.[0][0] &&\n                    cv?.[0][1] === newVal?.[0][1] &&\n                    ((cv?.[1][0] === newVal?.[1][0] && cv?.[1][1] === newVal?.[1][1]) || !needPosition)) {\n                    return cv;\n                }\n                return newVal;\n            });\n        };\n        if (!(0,_event_args_js__WEBPACK_IMPORTED_MODULE_7__.mouseEventArgsAreEqual)(args, hoveredRef.current)) {\n            setDrawCursorOverride(undefined);\n            onItemHovered?.(args);\n            maybeSetHoveredInfo(args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.outOfBoundsKind ? undefined : [args.location, [args.localEventX, args.localEventY]], true);\n            hoveredRef.current = args;\n        }\n        else if (args.kind === \"cell\" || args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.headerKind || args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.groupHeaderKind) {\n            let needsDamageCell = false;\n            let needsHoverPosition = true;\n            if (args.kind === \"cell\") {\n                const toCheck = getCellContent(args.location);\n                const rendererNeeds = getCellRenderer(toCheck)?.needsHoverPosition;\n                // custom cells we will assume need the position if they don't explicitly say they don't, everything\n                // else we will assume doesn't need it.\n                needsHoverPosition = rendererNeeds ?? toCheck.kind === _data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.GridCellKind.Custom;\n                needsDamageCell = needsHoverPosition;\n            }\n            else if (args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.groupHeaderKind) {\n                needsDamageCell = true;\n            }\n            const newInfo = [args.location, [args.localEventX, args.localEventY]];\n            maybeSetHoveredInfo(newInfo, needsHoverPosition);\n            hoverInfoRef.current = newInfo;\n            if (needsDamageCell) {\n                damageInternal(new _cell_set_js__WEBPACK_IMPORTED_MODULE_13__.CellSet([args.location]));\n            }\n        }\n        const notRowMarkerCol = args.location[0] >= (firstColAccessible ? 0 : 1);\n        setHoveredOnEdge(args.kind === _event_args_js__WEBPACK_IMPORTED_MODULE_7__.headerKind && args.isEdge && notRowMarkerCol && allowResize === true);\n        setOverFill(args.kind === \"cell\" && args.isFillHandle);\n        onMouseMoveRaw?.(ev);\n        onMouseMove(args);\n    }, [\n        eventTargetRef,\n        getMouseArgsForPosition,\n        firstColAccessible,\n        allowResize,\n        onMouseMoveRaw,\n        onMouseMove,\n        onItemHovered,\n        getCellContent,\n        getCellRenderer,\n        damageInternal,\n    ]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"mousemove\", onMouseMoveImpl, window, true);\n    const onKeyDownImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {\n        const canvas = ref.current;\n        if (canvas === null)\n            return;\n        let bounds;\n        let location = undefined;\n        if (selection.current !== undefined) {\n            bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);\n            location = selection.current.cell;\n        }\n        onKeyDown?.({\n            bounds,\n            stopPropagation: () => event.stopPropagation(),\n            preventDefault: () => event.preventDefault(),\n            cancel: () => undefined,\n            ctrlKey: event.ctrlKey,\n            metaKey: event.metaKey,\n            shiftKey: event.shiftKey,\n            altKey: event.altKey,\n            key: event.key,\n            keyCode: event.keyCode,\n            rawEvent: event,\n            location,\n        });\n    }, [onKeyDown, selection, getBoundsForItem]);\n    const onKeyUpImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {\n        const canvas = ref.current;\n        if (canvas === null)\n            return;\n        let bounds;\n        let location = undefined;\n        if (selection.current !== undefined) {\n            bounds = getBoundsForItem(canvas, selection.current.cell[0], selection.current.cell[1]);\n            location = selection.current.cell;\n        }\n        onKeyUp?.({\n            bounds,\n            stopPropagation: () => event.stopPropagation(),\n            preventDefault: () => event.preventDefault(),\n            cancel: () => undefined,\n            ctrlKey: event.ctrlKey,\n            metaKey: event.metaKey,\n            shiftKey: event.shiftKey,\n            altKey: event.altKey,\n            key: event.key,\n            keyCode: event.keyCode,\n            rawEvent: event,\n            location,\n        });\n    }, [onKeyUp, selection, getBoundsForItem]);\n    const refImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((instance) => {\n        ref.current = instance;\n        if (canvasRef !== undefined) {\n            canvasRef.current = instance;\n        }\n    }, [canvasRef]);\n    const onDragStartImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {\n        const canvas = ref.current;\n        if (canvas === null || isDraggable === false || isResizing) {\n            event.preventDefault();\n            return;\n        }\n        let dragMime;\n        let dragData;\n        const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);\n        if (isDraggable !== true && args.kind !== isDraggable) {\n            event.preventDefault();\n            return;\n        }\n        const setData = (mime, payload) => {\n            dragMime = mime;\n            dragData = payload;\n        };\n        let dragImage;\n        let dragImageX;\n        let dragImageY;\n        const setDragImage = (image, x, y) => {\n            dragImage = image;\n            dragImageX = x;\n            dragImageY = y;\n        };\n        let prevented = false;\n        onDragStart?.({\n            ...args,\n            setData,\n            setDragImage,\n            preventDefault: () => (prevented = true),\n            defaultPrevented: () => prevented,\n        });\n        if (!prevented && dragMime !== undefined && dragData !== undefined && event.dataTransfer !== null) {\n            event.dataTransfer.setData(dragMime, dragData);\n            event.dataTransfer.effectAllowed = \"copyLink\";\n            if (dragImage !== undefined && dragImageX !== undefined && dragImageY !== undefined) {\n                event.dataTransfer.setDragImage(dragImage, dragImageX, dragImageY);\n            }\n            else {\n                const [col, row] = args.location;\n                if (row !== undefined) {\n                    const offscreen = document.createElement(\"canvas\");\n                    const boundsForDragTarget = getBoundsForItem(canvas, col, row);\n                    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_8__.assert)(boundsForDragTarget !== undefined);\n                    const dpr = Math.ceil(window.devicePixelRatio ?? 1);\n                    offscreen.width = boundsForDragTarget.width * dpr;\n                    offscreen.height = boundsForDragTarget.height * dpr;\n                    const ctx = offscreen.getContext(\"2d\");\n                    if (ctx !== null) {\n                        ctx.scale(dpr, dpr);\n                        ctx.textBaseline = \"middle\";\n                        if (row === -1) {\n                            ctx.font = theme.headerFontFull;\n                            ctx.fillStyle = theme.bgHeader;\n                            ctx.fillRect(0, 0, offscreen.width, offscreen.height);\n                            (0,_render_data_grid_render_header_js__WEBPACK_IMPORTED_MODULE_14__.drawHeader)(ctx, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, mappedColumns[col], false, theme, false, false, 0, spriteManager, drawHeaderCallback, false);\n                        }\n                        else {\n                            ctx.font = theme.baseFontFull;\n                            ctx.fillStyle = theme.bgCell;\n                            ctx.fillRect(0, 0, offscreen.width, offscreen.height);\n                            (0,_render_data_grid_render_cells_js__WEBPACK_IMPORTED_MODULE_17__.drawCell)(ctx, getCellContent([col, row]), 0, row, false, false, 0, 0, boundsForDragTarget.width, boundsForDragTarget.height, false, theme, theme.bgCell, imageLoader, spriteManager, 1, undefined, false, 0, undefined, undefined, undefined, renderStateProvider, getCellRenderer, () => undefined);\n                        }\n                    }\n                    offscreen.style.left = \"-100%\";\n                    offscreen.style.position = \"absolute\";\n                    offscreen.style.width = `${boundsForDragTarget.width}px`;\n                    offscreen.style.height = `${boundsForDragTarget.height}px`;\n                    document.body.append(offscreen);\n                    event.dataTransfer.setDragImage(offscreen, boundsForDragTarget.width / 2, boundsForDragTarget.height / 2);\n                    window.setTimeout(() => {\n                        offscreen.remove();\n                    }, 0);\n                }\n            }\n        }\n        else {\n            event.preventDefault();\n        }\n    }, [\n        isDraggable,\n        isResizing,\n        getMouseArgsForPosition,\n        onDragStart,\n        getBoundsForItem,\n        theme,\n        mappedColumns,\n        spriteManager,\n        drawHeaderCallback,\n        getCellContent,\n        imageLoader,\n        renderStateProvider,\n        getCellRenderer,\n    ]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"dragstart\", onDragStartImpl, eventTargetRef?.current ?? null, false, false);\n    const activeDropTarget = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const onDragOverImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {\n        const canvas = ref.current;\n        if (onDrop !== undefined) {\n            // Need to preventDefault to allow drop\n            event.preventDefault();\n        }\n        if (canvas === null || onDragOverCell === undefined) {\n            return;\n        }\n        const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);\n        const [rawCol, row] = args.location;\n        const col = rawCol - (firstColAccessible ? 0 : 1);\n        const [activeCol, activeRow] = activeDropTarget.current ?? [];\n        if (activeCol !== col || activeRow !== row) {\n            activeDropTarget.current = [col, row];\n            onDragOverCell([col, row], event.dataTransfer);\n        }\n    }, [firstColAccessible, getMouseArgsForPosition, onDragOverCell, onDrop]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"dragover\", onDragOverImpl, eventTargetRef?.current ?? null, false, false);\n    const onDragEndImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        activeDropTarget.current = undefined;\n        onDragEnd?.();\n    }, [onDragEnd]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"dragend\", onDragEndImpl, eventTargetRef?.current ?? null, false, false);\n    const onDropImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event) => {\n        const canvas = ref.current;\n        if (canvas === null || onDrop === undefined) {\n            return;\n        }\n        // Default can mess up sometimes.\n        event.preventDefault();\n        const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);\n        const [rawCol, row] = args.location;\n        const col = rawCol - (firstColAccessible ? 0 : 1);\n        onDrop([col, row], event.dataTransfer);\n    }, [firstColAccessible, getMouseArgsForPosition, onDrop]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"drop\", onDropImpl, eventTargetRef?.current ?? null, false, false);\n    const onDragLeaveImpl = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        onDragLeave?.();\n    }, [onDragLeave]);\n    (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useEventListener)(\"dragleave\", onDragLeaveImpl, eventTargetRef?.current ?? null, false, false);\n    const selectionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selection);\n    selectionRef.current = selection;\n    const focusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const focusElement = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((el) => {\n        // We don't want to steal the focus if we don't currently own the focus.\n        if (ref.current === null || !ref.current.contains(document.activeElement))\n            return;\n        if (el === null && selectionRef.current.current !== undefined) {\n            canvasRef?.current?.focus({\n                preventScroll: true,\n            });\n        }\n        else if (el !== null) {\n            el.focus({\n                preventScroll: true,\n            });\n        }\n        focusRef.current = el;\n    }, [canvasRef]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(forwardedRef, () => ({\n        focus: () => {\n            const el = focusRef.current;\n            // The element in the ref may have been removed however our callback method ref\n            // won't see the removal so bad things happen. Checking to see if the element is\n            // no longer attached is enough to resolve the problem. In the future this\n            // should be replaced with something much more robust.\n            if (el === null || !document.contains(el)) {\n                canvasRef?.current?.focus({\n                    preventScroll: true,\n                });\n            }\n            else {\n                el.focus({\n                    preventScroll: true,\n                });\n            }\n        },\n        getBounds: (col, row) => {\n            if (canvasRef === undefined || canvasRef.current === null) {\n                return undefined;\n            }\n            return getBoundsForItem(canvasRef.current, col ?? 0, row ?? -1);\n        },\n        damage,\n    }), [canvasRef, damage, getBoundsForItem]);\n    const lastFocusedSubdomNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const accessibilityTree = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_9__.useDebouncedMemo)(() => {\n        if (width < 50 || experimental?.disableAccessibilityTree === true)\n            return null;\n        let effectiveCols = (0,_render_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_6__.getEffectiveColumns)(mappedColumns, cellXOffset, width, dragAndDropState, translateX);\n        const colOffset = firstColAccessible ? 0 : -1;\n        if (!firstColAccessible && effectiveCols[0]?.sourceIndex === 0) {\n            effectiveCols = effectiveCols.slice(1);\n        }\n        const [fCol, fRow] = selection.current?.cell ?? [];\n        const range = selection.current?.range;\n        const visibleCols = effectiveCols.map(c => c.sourceIndex);\n        const visibleRows = lodash_range_js__WEBPACK_IMPORTED_MODULE_2__(cellYOffset, Math.min(rows, cellYOffset + accessibilityHeight));\n        // Maintain focus within grid if we own it but focused cell is outside visible viewport\n        // and not rendered.\n        if (fCol !== undefined &&\n            fRow !== undefined &&\n            !(visibleCols.includes(fCol) && visibleRows.includes(fRow))) {\n            focusElement(null);\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"table\", { key: \"access-tree\", role: \"grid\", \"aria-rowcount\": rows + 1, \"aria-multiselectable\": \"true\", \"aria-colcount\": mappedColumns.length + colOffset },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"thead\", { role: \"rowgroup\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"tr\", { role: \"row\", \"aria-rowindex\": 1 }, effectiveCols.map(c => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"th\", { role: \"columnheader\", \"aria-selected\": selection.columns.hasIndex(c.sourceIndex), \"aria-colindex\": c.sourceIndex + 1 + colOffset, tabIndex: -1, onFocus: e => {\n                        if (e.target === focusRef.current)\n                            return;\n                        return onCellFocused?.([c.sourceIndex, -1]);\n                    }, key: c.sourceIndex }, c.title))))),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"tbody\", { role: \"rowgroup\" }, visibleRows.map(row => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"tr\", { role: \"row\", \"aria-selected\": selection.rows.hasIndex(row), key: row, \"aria-rowindex\": row + 2 }, effectiveCols.map(c => {\n                const col = c.sourceIndex;\n                const key = (0,_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_10__.packColRowToNumber)(col, row);\n                const focused = fCol === col && fRow === row;\n                const selected = range !== undefined &&\n                    col >= range.x &&\n                    col < range.x + range.width &&\n                    row >= range.y &&\n                    row < range.y + range.height;\n                const id = `glide-cell-${col}-${row}`;\n                const location = [col, row];\n                const cellContent = getCellContent(location, true);\n                return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"td\", { key: key, role: \"gridcell\", \"aria-colindex\": col + 1 + colOffset, \"aria-selected\": selected, \"aria-readonly\": (0,_data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.isInnerOnlyCell)(cellContent) || !(0,_data_grid_types_js__WEBPACK_IMPORTED_MODULE_3__.isReadWriteCell)(cellContent), id: id, \"data-testid\": id, onClick: () => {\n                        const canvas = canvasRef?.current;\n                        if (canvas === null || canvas === undefined)\n                            return;\n                        return onKeyDown?.({\n                            bounds: getBoundsForItem(canvas, col, row),\n                            cancel: () => undefined,\n                            preventDefault: () => undefined,\n                            stopPropagation: () => undefined,\n                            ctrlKey: false,\n                            key: \"Enter\",\n                            keyCode: 13,\n                            metaKey: false,\n                            shiftKey: false,\n                            altKey: false,\n                            rawEvent: undefined,\n                            location,\n                        });\n                    }, onFocusCapture: e => {\n                        if (e.target === focusRef.current ||\n                            (lastFocusedSubdomNode.current?.[0] === col &&\n                                lastFocusedSubdomNode.current?.[1] === row))\n                            return;\n                        lastFocusedSubdomNode.current = location;\n                        return onCellFocused?.(location);\n                    }, ref: focused ? focusElement : undefined, tabIndex: -1 }, getRowData(cellContent, getCellRenderer)));\n            })))))));\n    }, [\n        width,\n        mappedColumns,\n        cellXOffset,\n        dragAndDropState,\n        translateX,\n        rows,\n        cellYOffset,\n        accessibilityHeight,\n        selection,\n        focusElement,\n        getCellContent,\n        canvasRef,\n        onKeyDown,\n        getBoundsForItem,\n        onCellFocused,\n    ], 200);\n    const opacityX = freezeColumns === 0 || !fixedShadowX ? 0 : cellXOffset > freezeColumns ? 1 : lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(-translateX / 100, 0, 1);\n    const absoluteOffsetY = -cellYOffset * 32 + translateY;\n    const opacityY = !fixedShadowY ? 0 : lodash_clamp_js__WEBPACK_IMPORTED_MODULE_1__(-absoluteOffsetY / 100, 0, 1);\n    const stickyShadow = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (!opacityX && !opacityY) {\n            return null;\n        }\n        const styleX = {\n            position: \"absolute\",\n            top: 0,\n            left: stickyX,\n            width: width - stickyX,\n            height: height,\n            opacity: opacityX,\n            pointerEvents: \"none\",\n            transition: !smoothScrollX ? \"opacity 0.2s\" : undefined,\n            boxShadow: \"inset 13px 0 10px -13px rgba(0, 0, 0, 0.2)\",\n        };\n        const styleY = {\n            position: \"absolute\",\n            top: totalHeaderHeight,\n            left: 0,\n            width: width,\n            height: height,\n            opacity: opacityY,\n            pointerEvents: \"none\",\n            transition: !smoothScrollY ? \"opacity 0.2s\" : undefined,\n            boxShadow: \"inset 0 13px 10px -13px rgba(0, 0, 0, 0.2)\",\n        };\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            opacityX > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { id: \"shadow-x\", style: styleX }),\n            opacityY > 0 && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { id: \"shadow-y\", style: styleY })));\n    }, [opacityX, opacityY, stickyX, width, smoothScrollX, totalHeaderHeight, height, smoothScrollY]);\n    const overlayStyle = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n    }), []);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"canvas\", { \"data-testid\": \"data-grid-canvas\", tabIndex: 0, onKeyDown: onKeyDownImpl, onKeyUp: onKeyUpImpl, onFocus: onCanvasFocused, onBlur: onCanvasBlur, ref: refImpl, style: style }, accessibilityTree),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"canvas\", { ref: overlayRef, style: overlayStyle }),\n        stickyShadow));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (react__WEBPACK_IMPORTED_MODULE_0__.memo(react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(DataGrid)));\n//# sourceMappingURL=data-grid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2RhdGEtZ3JpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ3lJO0FBQ3JCO0FBQzNHO0FBQ2U7QUFDa0Q7QUFDckU7QUFDSTtBQUNnQjtBQUNMO0FBQ087QUFDc0M7QUFDYjtBQUN0QjtBQUNaO0FBQzhFO0FBQzVFO0FBQ1k7QUFDZ0Q7QUFDL0c7QUFDQTtBQUNBLHNCQUFzQiw2REFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1OUJBQXU5QjtBQUNuK0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUFZO0FBQzVCO0FBQ0EseUJBQXlCLHlDQUFZO0FBQ3JDLHNDQUFzQywyQ0FBYztBQUNwRCx3QkFBd0IseUNBQVk7QUFDcEMseUJBQXlCLHlDQUFZO0FBQ3JDLGtEQUFrRCwyQ0FBYztBQUNoRSw4Q0FBOEMsMkNBQWM7QUFDNUQsdUJBQXVCLHlDQUFZO0FBQ25DLHdEQUF3RCwyQ0FBYztBQUN0RSw0Q0FBNEMsMkNBQWM7QUFDMUQsNEJBQTRCLHlDQUFZO0FBQ3hDO0FBQ0EsMEJBQTBCLDBDQUFhLFdBQVcsZ0VBQWE7QUFDL0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2Qix5Q0FBWTtBQUN6QyxzRkFBc0YsdUVBQWdCO0FBQ3RHLG9GQUFvRixzRUFBZTtBQUNuRyxJQUFJLGtEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsMEJBQTBCLDBFQUFnQjtBQUMxQyxtQ0FBbUMsd0VBQWM7QUFDakQ7QUFDQSw2QkFBNkIsOENBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUVBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOENBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkVBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRFQUFrQjtBQUN0QztBQUNBO0FBQ0Esb0JBQW9CLHlFQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpRUFBcUIsY0FBYyxpRUFBcUI7QUFDdkc7QUFDQSxvREFBb0QsaUVBQXFCLGNBQWMsaUVBQXFCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELG1FQUFpQixtQ0FBbUMsbUVBQWlCO0FBQ3BJO0FBQ0Esc0JBQXNCLDJEQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBTTtBQUN0QjtBQUNBLHVEQUF1RCwyREFBZSxHQUFHLHNEQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkRBQWUsR0FBRyxzREFBVTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5RUFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5Q0FBWTtBQUNuQztBQUNBLEtBQUs7QUFDTCx5QkFBeUIseUNBQVk7QUFDckM7QUFDQSxxQ0FBcUMsMENBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjLHdCQUF3QixjQUFjO0FBQ3pGLEtBQUs7QUFDTCxJQUFJLGtEQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQywwQ0FBYSxXQUFXLGtGQUFtQjtBQUMzRTtBQUNBO0FBQ0Esd0JBQXdCLHlDQUFZO0FBQ3BDLHNCQUFzQix5Q0FBWTtBQUNsQyx1QkFBdUIseUNBQVk7QUFDbkMsaUJBQWlCLDhDQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaUVBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxzRUFBZTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNFQUFRO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLHNFQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlDQUFZO0FBQ3BDLElBQUksa0RBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxrREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsOENBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkVBQWlCO0FBQ3JDO0FBQ0EsbUJBQW1CLDhDQUFpQjtBQUNwQywyQkFBMkIsa0RBQU87QUFDbEMsS0FBSztBQUNMO0FBQ0Esb0NBQW9DLDJDQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrRUFBaUI7QUFDM0MsK0JBQStCLGtFQUFpQjtBQUNoRCw0Q0FBNEMsNkRBQVksWUFBWSwwRUFBcUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQ0FBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBCQUEwQix5Q0FBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0RkFBdUI7QUFDakQ7QUFDQSxvQkFBb0IsNkRBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsOENBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQU07QUFDbEIsK0JBQStCLHdGQUFtQiwwRUFBMEUsMkRBQVM7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIseUNBQVk7QUFDakMseUJBQXlCLHlDQUFZO0FBQ3JDLHNCQUFzQix5Q0FBWTtBQUNsQyw0QkFBNEIsOENBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyREFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksa0VBQWdCO0FBQ3BCLElBQUksa0VBQWdCO0FBQ3BCLHVCQUF1Qix5Q0FBWTtBQUNuQywwQkFBMEIsOENBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJEQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGtFQUFnQjtBQUNwQixJQUFJLGtFQUFnQjtBQUNwQix3QkFBd0IsOENBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkRBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGtFQUFnQjtBQUNwQiw4QkFBOEIsOENBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLElBQUksa0VBQWdCO0FBQ3BCLDZCQUE2Qiw4Q0FBaUI7QUFDOUMsbUNBQW1DLGtEQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsMENBQWEsV0FBVyxvRUFBZ0I7QUFDckUsNkJBQTZCLHlDQUFZO0FBQ3pDO0FBQ0EsSUFBSSxrREFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNkRBQVk7QUFDN0U7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIseUNBQVk7QUFDbkMsNEJBQTRCLDhDQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYSxzRUFBc0I7QUFDbkM7QUFDQTtBQUNBLDhDQUE4QywyREFBZTtBQUM3RDtBQUNBO0FBQ0EsdURBQXVELHNEQUFVLGtCQUFrQiwyREFBZTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSw2REFBWTtBQUNuRjtBQUNBO0FBQ0EsbUNBQW1DLDJEQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrREFBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0RBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtFQUFnQjtBQUNwQiwwQkFBMEIsOENBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCx3QkFBd0IsOENBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxvQkFBb0IsOENBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRCQUE0Qiw4Q0FBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtFQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEVBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMEJBQTBCO0FBQ3pFLGdEQUFnRCwyQkFBMkI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtFQUFnQjtBQUNwQiw2QkFBNkIseUNBQVk7QUFDekMsMkJBQTJCLDhDQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGtFQUFnQjtBQUNwQiwwQkFBMEIsOENBQWlCO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxrRUFBZ0I7QUFDcEIsdUJBQXVCLDhDQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGtFQUFnQjtBQUNwQiw0QkFBNEIsOENBQWlCO0FBQzdDO0FBQ0EsS0FBSztBQUNMLElBQUksa0VBQWdCO0FBQ3BCLHlCQUF5Qix5Q0FBWTtBQUNyQztBQUNBLHFCQUFxQix5Q0FBWTtBQUNqQyx5QkFBeUIsOENBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksc0RBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLGtDQUFrQyx5Q0FBWTtBQUM5Qyw4QkFBOEIsa0VBQWdCO0FBQzlDO0FBQ0E7QUFDQSw0QkFBNEIsNkVBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRDQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFtQixZQUFZLGdKQUFnSjtBQUMvTCxZQUFZLGdEQUFtQixZQUFZLGtCQUFrQjtBQUM3RCxnQkFBZ0IsZ0RBQW1CLFNBQVMsaUNBQWlDLDBCQUEwQixnREFBbUIsU0FBUztBQUNuSTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLFlBQVksZ0RBQW1CLFlBQVksa0JBQWtCLDBCQUEwQixnREFBbUIsU0FBUyxnR0FBZ0c7QUFDbk47QUFDQSw0QkFBNEIscUZBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJLEdBQUcsSUFBSTtBQUNwRDtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFtQixTQUFTLDhHQUE4RyxvRUFBZSxrQkFBa0Isb0VBQWU7QUFDbE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5REFBeUQ7QUFDOUUsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyw0Q0FBSztBQUN2RztBQUNBLHlDQUF5Qyw0Q0FBSztBQUM5Qyx5QkFBeUIsMENBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQW1CLENBQUMsMkNBQWM7QUFDbEQsNEJBQTRCLGdEQUFtQixVQUFVLCtCQUErQjtBQUN4Riw0QkFBNEIsZ0RBQW1CLFVBQVUsK0JBQStCO0FBQ3hGLEtBQUs7QUFDTCx5QkFBeUIsMENBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksZ0RBQW1CLENBQUMsMkNBQWM7QUFDOUMsUUFBUSxnREFBbUIsYUFBYSw0S0FBNEs7QUFDcE4sUUFBUSxnREFBbUIsYUFBYSxzQ0FBc0M7QUFDOUU7QUFDQTtBQUNBLGlFQUFlLHVDQUFVLENBQUMsNkNBQWdCLFdBQVcsRUFBQztBQUN0RCIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC9kYXRhLWdyaWQuanM/NjlhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNvbXB1dGVCb3VuZHMsIGdldENvbHVtbkluZGV4Rm9yWCwgZ2V0RWZmZWN0aXZlQ29sdW1ucywgZ2V0Um93SW5kZXhGb3JZLCBnZXRTdGlja3lXaWR0aCwgcmVjdEJvdHRvbVJpZ2h0LCB1c2VNYXBwZWRDb2x1bW5zLCB9IGZyb20gXCIuL3JlbmRlci9kYXRhLWdyaWQtbGliLmpzXCI7XG5pbXBvcnQgeyBHcmlkQ2VsbEtpbmQsIElubmVyR3JpZENlbGxLaW5kLCBDb21wYWN0U2VsZWN0aW9uLCBpc1JlYWRXcml0ZUNlbGwsIGlzSW5uZXJPbmx5Q2VsbCwgYm9vbGVhbkNlbGxJc0VkaXRhYmxlLCB9IGZyb20gXCIuL2RhdGEtZ3JpZC10eXBlcy5qc1wiO1xuaW1wb3J0IHsgQ2VsbFNldCB9IGZyb20gXCIuL2NlbGwtc2V0LmpzXCI7XG5pbXBvcnQgeyBTcHJpdGVNYW5hZ2VyIH0gZnJvbSBcIi4vZGF0YS1ncmlkLXNwcml0ZXMuanNcIjtcbmltcG9ydCB7IGRpcmVjdGlvbiwgZ2V0U2Nyb2xsQmFyV2lkdGgsIHVzZURlYm91bmNlZE1lbW8sIHVzZUV2ZW50TGlzdGVuZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3V0aWxzLmpzXCI7XG5pbXBvcnQgY2xhbXAgZnJvbSBcImxvZGFzaC9jbGFtcC5qc1wiO1xuaW1wb3J0IG1ha2VSYW5nZSBmcm9tIFwibG9kYXNoL3JhbmdlLmpzXCI7XG5pbXBvcnQgeyBkcmF3R3JpZCB9IGZyb20gXCIuL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmpzXCI7XG5pbXBvcnQge30gZnJvbSBcIi4vcmVuZGVyL2RhdGEtZ3JpZC1yZW5kZXIuYmxpdC5qc1wiO1xuaW1wb3J0IHsgQW5pbWF0aW9uTWFuYWdlciB9IGZyb20gXCIuL2FuaW1hdGlvbi1tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBSZW5kZXJTdGF0ZVByb3ZpZGVyLCBwYWNrQ29sUm93VG9OdW1iZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3JlbmRlci1zdGF0ZS1wcm92aWRlci5qc1wiO1xuaW1wb3J0IHsgYnJvd3NlcklzRmlyZWZveCwgYnJvd3NlcklzU2FmYXJpIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9icm93c2VyLWRldGVjdC5qc1wiO1xuaW1wb3J0IHsgdXNlQW5pbWF0aW9uUXVldWUgfSBmcm9tIFwiLi91c2UtYW5pbWF0aW9uLXF1ZXVlLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3N1cHBvcnQuanNcIjtcbmltcG9ydCB7IE91dE9mQm91bmRzUmVnaW9uQXhpcywgb3V0T2ZCb3VuZHNLaW5kLCBncm91cEhlYWRlcktpbmQsIGhlYWRlcktpbmQsIG1vdXNlRXZlbnRBcmdzQXJlRXF1YWwsIH0gZnJvbSBcIi4vZXZlbnQtYXJncy5qc1wiO1xuaW1wb3J0IHsgcG9pbnRJblJlY3QgfSBmcm9tIFwiLi4vLi4vY29tbW9uL21hdGguanNcIjtcbmltcG9ydCB7IGRyYXdDZWxsLCB9IGZyb20gXCIuL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmNlbGxzLmpzXCI7XG5pbXBvcnQgeyBnZXRBY3Rpb25Cb3VuZHNGb3JHcm91cCwgZ2V0SGVhZGVyTWVudUJvdW5kcywgZHJhd0hlYWRlciB9IGZyb20gXCIuL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmhlYWRlci5qc1wiO1xuY29uc3QgZmlsbEhhbmRsZUNsaWNrU2l6ZSA9IDY7XG5jb25zdCBnZXRSb3dEYXRhID0gKGNlbGwsIGdldENlbGxSZW5kZXJlcikgPT4ge1xuICAgIGlmIChjZWxsLmtpbmQgPT09IEdyaWRDZWxsS2luZC5DdXN0b20pXG4gICAgICAgIHJldHVybiBjZWxsLmNvcHlEYXRhO1xuICAgIGNvbnN0IHIgPSBnZXRDZWxsUmVuZGVyZXI/LihjZWxsKTtcbiAgICByZXR1cm4gcj8uZ2V0QWNjZXNzaWJpbGl0eVN0cmluZyhjZWxsKSA/PyBcIlwiO1xufTtcbmNvbnN0IERhdGFHcmlkID0gKHAsIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgYWNjZXNzaWJpbGl0eUhlaWdodCwgY29sdW1ucywgY2VsbFhPZmZzZXQ6IGNlbGxYT2Zmc2V0UmVhbCwgY2VsbFlPZmZzZXQsIGhlYWRlckhlaWdodCwgZmlsbEhhbmRsZSA9IGZhbHNlLCBncm91cEhlYWRlckhlaWdodCwgcm93SGVpZ2h0LCByb3dzLCBnZXRDZWxsQ29udGVudCwgZ2V0Um93VGhlbWVPdmVycmlkZSwgb25IZWFkZXJNZW51Q2xpY2ssIGVuYWJsZUdyb3VwcywgaXNGaWxsaW5nLCBvbkNhbnZhc0ZvY3VzZWQsIG9uQ2FudmFzQmx1ciwgaXNGb2N1c2VkLCBzZWxlY3Rpb24sIGZyZWV6ZUNvbHVtbnMsIG9uQ29udGV4dE1lbnUsIGZyZWV6ZVRyYWlsaW5nUm93cywgZml4ZWRTaGFkb3dYID0gdHJ1ZSwgZml4ZWRTaGFkb3dZID0gdHJ1ZSwgZHJhd0ZvY3VzUmluZywgb25Nb3VzZURvd24sIG9uTW91c2VVcCwgb25Nb3VzZU1vdmVSYXcsIG9uTW91c2VNb3ZlLCBvbkl0ZW1Ib3ZlcmVkLCBkcmFnQW5kRHJvcFN0YXRlLCBmaXJzdENvbEFjY2Vzc2libGUsIG9uS2V5RG93biwgb25LZXlVcCwgaGlnaGxpZ2h0UmVnaW9ucywgY2FudmFzUmVmLCBvbkRyYWdTdGFydCwgb25EcmFnRW5kLCBldmVudFRhcmdldFJlZiwgaXNSZXNpemluZywgcmVzaXplQ29sdW1uOiByZXNpemVDb2wsIGlzRHJhZ2dpbmcsIGlzRHJhZ2dhYmxlID0gZmFsc2UsIGFsbG93UmVzaXplLCBkaXNhYmxlZFJvd3MsIGhhc0FwcGVuZFJvdywgZ2V0R3JvdXBEZXRhaWxzLCB0aGVtZSwgcHJlbGlnaHRDZWxscywgaGVhZGVySWNvbnMsIHZlcnRpY2FsQm9yZGVyLCBkcmF3Q2VsbDogZHJhd0NlbGxDYWxsYmFjaywgZHJhd0hlYWRlcjogZHJhd0hlYWRlckNhbGxiYWNrLCBvbkNlbGxGb2N1c2VkLCBvbkRyYWdPdmVyQ2VsbCwgb25Ecm9wLCBvbkRyYWdMZWF2ZSwgaW1hZ2VXaW5kb3dMb2FkZXIsIHNtb290aFNjcm9sbFggPSBmYWxzZSwgc21vb3RoU2Nyb2xsWSA9IGZhbHNlLCBleHBlcmltZW50YWwsIGdldENlbGxSZW5kZXJlciwgfSA9IHA7XG4gICAgY29uc3QgdHJhbnNsYXRlWCA9IHAudHJhbnNsYXRlWCA/PyAwO1xuICAgIGNvbnN0IHRyYW5zbGF0ZVkgPSBwLnRyYW5zbGF0ZVkgPz8gMDtcbiAgICBjb25zdCBjZWxsWE9mZnNldCA9IE1hdGgubWF4KGZyZWV6ZUNvbHVtbnMsIE1hdGgubWluKGNvbHVtbnMubGVuZ3RoIC0gMSwgY2VsbFhPZmZzZXRSZWFsKSk7XG4gICAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGltYWdlTG9hZGVyID0gaW1hZ2VXaW5kb3dMb2FkZXI7XG4gICAgY29uc3QgZGFtYWdlUmVnaW9uID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgW3Njcm9sbGluZywgc2V0U2Nyb2xsaW5nXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBob3ZlclZhbHVlcyA9IFJlYWN0LnVzZVJlZihbXSk7XG4gICAgY29uc3QgbGFzdEJsaXREYXRhID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgW2hvdmVyZWRJdGVtSW5mbywgc2V0SG92ZXJlZEl0ZW1JbmZvXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gICAgY29uc3QgW2hvdmVyZWRPbkVkZ2UsIHNldEhvdmVyZWRPbkVkZ2VdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgICBjb25zdCBvdmVybGF5UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IFtkcmF3Q3Vyc29yT3ZlcnJpZGUsIHNldERyYXdDdXJzb3JPdmVycmlkZV0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICAgIGNvbnN0IFtsYXN0V2FzVG91Y2gsIHNldExhc3RXYXNUb3VjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgbGFzdFdhc1RvdWNoUmVmID0gUmVhY3QudXNlUmVmKGxhc3RXYXNUb3VjaCk7XG4gICAgbGFzdFdhc1RvdWNoUmVmLmN1cnJlbnQgPSBsYXN0V2FzVG91Y2g7XG4gICAgY29uc3Qgc3ByaXRlTWFuYWdlciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gbmV3IFNwcml0ZU1hbmFnZXIoaGVhZGVySWNvbnMsICgpID0+IHtcbiAgICAgICAgbGFzdEFyZ3NSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdERyYXdSZWYuY3VycmVudCgpO1xuICAgIH0pLCBbaGVhZGVySWNvbnNdKTtcbiAgICBjb25zdCB0b3RhbEhlYWRlckhlaWdodCA9IGVuYWJsZUdyb3VwcyA/IGdyb3VwSGVhZGVySGVpZ2h0ICsgaGVhZGVySGVpZ2h0IDogaGVhZGVySGVpZ2h0O1xuICAgIGNvbnN0IHNjcm9sbGluZ1N0b3BSZWYgPSBSZWFjdC51c2VSZWYoLTEpO1xuICAgIGNvbnN0IGVuYWJsZUZpcmVmb3hSZXNjYWxpbmcgPSAoZXhwZXJpbWVudGFsPy5lbmFibGVGaXJlZm94UmVzY2FsaW5nID8/IGZhbHNlKSAmJiBicm93c2VySXNGaXJlZm94LnZhbHVlO1xuICAgIGNvbnN0IGVuYWJsZVNhZmFyaVJlc2NhbGluZyA9IChleHBlcmltZW50YWw/LmVuYWJsZVNhZmFyaVJlc2NhbGluZyA/PyBmYWxzZSkgJiYgYnJvd3NlcklzU2FmYXJpLnZhbHVlO1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA9PT0gMSB8fCAoIWVuYWJsZUZpcmVmb3hSZXNjYWxpbmcgJiYgIWVuYWJsZVNhZmFyaVJlc2NhbGluZykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gZ28gaW50byBzY3JvbGwgbW9kZSBmb3IgYSBzaW5nbGUgcmVwYWludFxuICAgICAgICBpZiAoc2Nyb2xsaW5nU3RvcFJlZi5jdXJyZW50ICE9PSAtMSkge1xuICAgICAgICAgICAgc2V0U2Nyb2xsaW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2Nyb2xsaW5nU3RvcFJlZi5jdXJyZW50KTtcbiAgICAgICAgc2Nyb2xsaW5nU3RvcFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2V0U2Nyb2xsaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNjcm9sbGluZ1N0b3BSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICB9LCAyMDApO1xuICAgIH0sIFtjZWxsWU9mZnNldCwgY2VsbFhPZmZzZXQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIGVuYWJsZUZpcmVmb3hSZXNjYWxpbmcsIGVuYWJsZVNhZmFyaVJlc2NhbGluZ10pO1xuICAgIGNvbnN0IG1hcHBlZENvbHVtbnMgPSB1c2VNYXBwZWRDb2x1bW5zKGNvbHVtbnMsIGZyZWV6ZUNvbHVtbnMpO1xuICAgIGNvbnN0IHN0aWNreVggPSBmaXhlZFNoYWRvd1ggPyBnZXRTdGlja3lXaWR0aChtYXBwZWRDb2x1bW5zLCBkcmFnQW5kRHJvcFN0YXRlKSA6IDA7XG4gICAgLy8gcm93OiAtMSA9PT0gY29sdW1uSGVhZGVyLCAtMiA9PT0gZ3JvdXBIZWFkZXJcbiAgICBjb25zdCBnZXRCb3VuZHNGb3JJdGVtID0gUmVhY3QudXNlQ2FsbGJhY2soKGNhbnZhcywgY29sLCByb3cpID0+IHtcbiAgICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGNvbCA+PSBtYXBwZWRDb2x1bW5zLmxlbmd0aCB8fCByb3cgPj0gcm93cykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2FsZSA9IHJlY3Qud2lkdGggLyB3aWR0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcHV0ZUJvdW5kcyhjb2wsIHJvdywgd2lkdGgsIGhlaWdodCwgZ3JvdXBIZWFkZXJIZWlnaHQsIHRvdGFsSGVhZGVySGVpZ2h0LCBjZWxsWE9mZnNldCwgY2VsbFlPZmZzZXQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHJvd3MsIGZyZWV6ZUNvbHVtbnMsIGZyZWV6ZVRyYWlsaW5nUm93cywgbWFwcGVkQ29sdW1ucywgcm93SGVpZ2h0KTtcbiAgICAgICAgaWYgKHNjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQueCAqPSBzY2FsZTtcbiAgICAgICAgICAgIHJlc3VsdC55ICo9IHNjYWxlO1xuICAgICAgICAgICAgcmVzdWx0LndpZHRoICo9IHNjYWxlO1xuICAgICAgICAgICAgcmVzdWx0LmhlaWdodCAqPSBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQueCArPSByZWN0Lng7XG4gICAgICAgIHJlc3VsdC55ICs9IHJlY3QueTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGdyb3VwSGVhZGVySGVpZ2h0LFxuICAgICAgICB0b3RhbEhlYWRlckhlaWdodCxcbiAgICAgICAgY2VsbFhPZmZzZXQsXG4gICAgICAgIGNlbGxZT2Zmc2V0LFxuICAgICAgICB0cmFuc2xhdGVYLFxuICAgICAgICB0cmFuc2xhdGVZLFxuICAgICAgICByb3dzLFxuICAgICAgICBmcmVlemVDb2x1bW5zLFxuICAgICAgICBmcmVlemVUcmFpbGluZ1Jvd3MsXG4gICAgICAgIG1hcHBlZENvbHVtbnMsXG4gICAgICAgIHJvd0hlaWdodCxcbiAgICBdKTtcbiAgICBjb25zdCBnZXRNb3VzZUFyZ3NGb3JQb3NpdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKChjYW52YXMsIHBvc1gsIHBvc1ksIGV2KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gcmVjdC53aWR0aCAvIHdpZHRoO1xuICAgICAgICBjb25zdCB4ID0gKHBvc1ggLSByZWN0LmxlZnQpIC8gc2NhbGU7XG4gICAgICAgIGNvbnN0IHkgPSAocG9zWSAtIHJlY3QudG9wKSAvIHNjYWxlO1xuICAgICAgICBjb25zdCBlZGdlRGV0ZWN0aW9uQnVmZmVyID0gNTtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlQ29scyA9IGdldEVmZmVjdGl2ZUNvbHVtbnMobWFwcGVkQ29sdW1ucywgY2VsbFhPZmZzZXQsIHdpZHRoLCB1bmRlZmluZWQsIHRyYW5zbGF0ZVgpO1xuICAgICAgICBsZXQgYnV0dG9uID0gMDtcbiAgICAgICAgbGV0IGJ1dHRvbnMgPSAwO1xuICAgICAgICBpZiAoZXYgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICBidXR0b24gPSBldi5idXR0b247XG4gICAgICAgICAgICBidXR0b25zID0gZXYuYnV0dG9ucztcbiAgICAgICAgfVxuICAgICAgICAvLyAtMSA9PT0gb2ZmIHJpZ2h0IGVkZ2VcbiAgICAgICAgY29uc3QgY29sID0gZ2V0Q29sdW1uSW5kZXhGb3JYKHgsIGVmZmVjdGl2ZUNvbHMsIHRyYW5zbGF0ZVgpO1xuICAgICAgICAvLyAtMTogaGVhZGVyIG9yIGFib3ZlXG4gICAgICAgIC8vIHVuZGVmaW5lZDogb2ZmYm90dG9tXG4gICAgICAgIGNvbnN0IHJvdyA9IGdldFJvd0luZGV4Rm9yWSh5LCBoZWlnaHQsIGVuYWJsZUdyb3VwcywgaGVhZGVySGVpZ2h0LCBncm91cEhlYWRlckhlaWdodCwgcm93cywgcm93SGVpZ2h0LCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWSwgZnJlZXplVHJhaWxpbmdSb3dzKTtcbiAgICAgICAgY29uc3Qgc2hpZnRLZXkgPSBldj8uc2hpZnRLZXkgPT09IHRydWU7XG4gICAgICAgIGNvbnN0IGN0cmxLZXkgPSBldj8uY3RybEtleSA9PT0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbWV0YUtleSA9IGV2Py5tZXRhS2V5ID09PSB0cnVlO1xuICAgICAgICBjb25zdCBpc1RvdWNoID0gKGV2ICE9PSB1bmRlZmluZWQgJiYgIShldiBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpKSB8fCBldj8ucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIjtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRWRnZSA9IFtcbiAgICAgICAgICAgIHggPCAwID8gLTEgOiB3aWR0aCA8IHggPyAxIDogMCxcbiAgICAgICAgICAgIHkgPCB0b3RhbEhlYWRlckhlaWdodCA/IC0xIDogaGVpZ2h0IDwgeSA/IDEgOiAwLFxuICAgICAgICBdO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoY29sID09PSAtMSB8fCB5IDwgMCB8fCB4IDwgMCB8fCByb3cgPT09IHVuZGVmaW5lZCB8fCB4ID4gd2lkdGggfHwgeSA+IGhlaWdodCkge1xuICAgICAgICAgICAgY29uc3QgaG9yaXpvbnRhbCA9IHggPiB3aWR0aCA/IDEgOiB4IDwgMCA/IC0xIDogMDtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsID0geSA+IGhlaWdodCA/IDEgOiB5IDwgMCA/IC0xIDogMDtcbiAgICAgICAgICAgIGxldCBpbm5lckhvcml6b250YWwgPSBob3Jpem9udGFsICogMjtcbiAgICAgICAgICAgIGxldCBpbm5lclZlcnRpY2FsID0gdmVydGljYWwgKiAyO1xuICAgICAgICAgICAgaWYgKGhvcml6b250YWwgPT09IDApXG4gICAgICAgICAgICAgICAgaW5uZXJIb3Jpem9udGFsID0gY29sID09PSAtMSA/IE91dE9mQm91bmRzUmVnaW9uQXhpcy5FbmRQYWRkaW5nIDogT3V0T2ZCb3VuZHNSZWdpb25BeGlzLkNlbnRlcjtcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbCA9PT0gMClcbiAgICAgICAgICAgICAgICBpbm5lclZlcnRpY2FsID0gcm93ID09PSB1bmRlZmluZWQgPyBPdXRPZkJvdW5kc1JlZ2lvbkF4aXMuRW5kUGFkZGluZyA6IE91dE9mQm91bmRzUmVnaW9uQXhpcy5DZW50ZXI7XG4gICAgICAgICAgICBsZXQgaXNFZGdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY29sID09PSAtMSAmJiByb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IGdldEJvdW5kc0Zvckl0ZW0oY2FudmFzLCBtYXBwZWRDb2x1bW5zLmxlbmd0aCAtIDEsIC0xKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoYiAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBpc0VkZ2UgPSBwb3NYIDwgYi54ICsgYi53aWR0aCArIGVkZ2VEZXRlY3Rpb25CdWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgY2xpY2tpbmcgb24gdGhlIHNjcm9sbGJhciBkb2Vzbid0IHVuc2V0IHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoaXMgZG9lc24ndCB3b3JrIGZvciBvdmVybGF5IHNjcm9sbGJhcnMgYmVjYXVzZSB0aGV5IGFyZSBqdXN0IGEgYnJva2VuIGludGVyYWN0aW9uXG4gICAgICAgICAgICAvLyBieSBkZXNpZ24uXG4gICAgICAgICAgICBjb25zdCBpc01heWJlU2Nyb2xsYmFyID0gKHggPiB3aWR0aCAmJiB4IDwgd2lkdGggKyBnZXRTY3JvbGxCYXJXaWR0aCgpKSB8fCAoeSA+IGhlaWdodCAmJiB5IDwgaGVpZ2h0ICsgZ2V0U2Nyb2xsQmFyV2lkdGgoKSk7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAga2luZDogb3V0T2ZCb3VuZHNLaW5kLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBbY29sICE9PSAtMSA/IGNvbCA6IHggPCAwID8gMCA6IG1hcHBlZENvbHVtbnMubGVuZ3RoIC0gMSwgcm93ID8/IHJvd3MgLSAxXSxcbiAgICAgICAgICAgICAgICByZWdpb246IFtpbm5lckhvcml6b250YWwsIGlubmVyVmVydGljYWxdLFxuICAgICAgICAgICAgICAgIHNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgIGN0cmxLZXksXG4gICAgICAgICAgICAgICAgbWV0YUtleSxcbiAgICAgICAgICAgICAgICBpc0VkZ2UsXG4gICAgICAgICAgICAgICAgaXNUb3VjaCxcbiAgICAgICAgICAgICAgICBidXR0b24sXG4gICAgICAgICAgICAgICAgYnV0dG9ucyxcbiAgICAgICAgICAgICAgICBzY3JvbGxFZGdlLFxuICAgICAgICAgICAgICAgIGlzTWF5YmVTY3JvbGxiYXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvdyA8PSAtMSkge1xuICAgICAgICAgICAgbGV0IGJvdW5kcyA9IGdldEJvdW5kc0Zvckl0ZW0oY2FudmFzLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICBhc3NlcnQoYm91bmRzICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgbGV0IGlzRWRnZSA9IGJvdW5kcyAhPT0gdW5kZWZpbmVkICYmIGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC0gcG9zWCA8PSBlZGdlRGV0ZWN0aW9uQnVmZmVyO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDb2wgPSBjb2wgLSAxO1xuICAgICAgICAgICAgaWYgKHBvc1ggLSBib3VuZHMueCA8PSBlZGdlRGV0ZWN0aW9uQnVmZmVyICYmIHByZXZpb3VzQ29sID49IDApIHtcbiAgICAgICAgICAgICAgICBpc0VkZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJvdW5kcyA9IGdldEJvdW5kc0Zvckl0ZW0oY2FudmFzLCBwcmV2aW91c0NvbCwgcm93KTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoYm91bmRzICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogZW5hYmxlR3JvdXBzICYmIHJvdyA9PT0gLTIgPyBncm91cEhlYWRlcktpbmQgOiBoZWFkZXJLaW5kLFxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogW3ByZXZpb3VzQ29sLCByb3ddLFxuICAgICAgICAgICAgICAgICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IG1hcHBlZENvbHVtbnNbcHJldmlvdXNDb2xdLmdyb3VwID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGlzRWRnZSxcbiAgICAgICAgICAgICAgICAgICAgc2hpZnRLZXksXG4gICAgICAgICAgICAgICAgICAgIGN0cmxLZXksXG4gICAgICAgICAgICAgICAgICAgIG1ldGFLZXksXG4gICAgICAgICAgICAgICAgICAgIGlzVG91Y2gsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRXZlbnRYOiBwb3NYIC0gYm91bmRzLngsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsRXZlbnRZOiBwb3NZIC0gYm91bmRzLnksXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbixcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRWRnZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBlbmFibGVHcm91cHMgJiYgcm93ID09PSAtMiA/IGdyb3VwSGVhZGVyS2luZCA6IGhlYWRlcktpbmQsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiBtYXBwZWRDb2x1bW5zW2NvbF0uZ3JvdXAgPz8gXCJcIixcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IFtjb2wsIHJvd10sXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kczogYm91bmRzLFxuICAgICAgICAgICAgICAgICAgICBpc0VkZ2UsXG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICBjdHJsS2V5LFxuICAgICAgICAgICAgICAgICAgICBtZXRhS2V5LFxuICAgICAgICAgICAgICAgICAgICBpc1RvdWNoLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbEV2ZW50WDogcG9zWCAtIGJvdW5kcy54LFxuICAgICAgICAgICAgICAgICAgICBsb2NhbEV2ZW50WTogcG9zWSAtIGJvdW5kcy55LFxuICAgICAgICAgICAgICAgICAgICBidXR0b24sXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbEVkZ2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kc0Zvckl0ZW0oY2FudmFzLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICBhc3NlcnQoYm91bmRzICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgaXNFZGdlID0gYm91bmRzICE9PSB1bmRlZmluZWQgJiYgYm91bmRzLnggKyBib3VuZHMud2lkdGggLSBwb3NYIDwgZWRnZURldGVjdGlvbkJ1ZmZlcjtcbiAgICAgICAgICAgIGxldCBpc0ZpbGxIYW5kbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChmaWxsSGFuZGxlICYmIHNlbGVjdGlvbi5jdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsSGFuZGxlTG9jYXRpb24gPSByZWN0Qm90dG9tUmlnaHQoc2VsZWN0aW9uLmN1cnJlbnQucmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxIYW5kbGVDZWxsQm91bmRzID0gZ2V0Qm91bmRzRm9ySXRlbShjYW52YXMsIGZpbGxIYW5kbGVMb2NhdGlvblswXSwgZmlsbEhhbmRsZUxvY2F0aW9uWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsbEhhbmRsZUNlbGxCb3VuZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVMb2dpY2FsQ2VudGVyWCA9IGZpbGxIYW5kbGVDZWxsQm91bmRzLnggKyBmaWxsSGFuZGxlQ2VsbEJvdW5kcy53aWR0aCAtIDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUxvZ2ljYWxDZW50ZXJZID0gZmlsbEhhbmRsZUNlbGxCb3VuZHMueSArIGZpbGxIYW5kbGVDZWxsQm91bmRzLmhlaWdodCAtIDI7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgcG9zWCBhbmQgcG9zWSBhcmUgd2l0aGluIGZpbGxIYW5kbGVDbGlja1NpemUgZnJvbSBoYW5kbGVMb2dpY2FsQ2VudGVyXG4gICAgICAgICAgICAgICAgICAgIGlzRmlsbEhhbmRsZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhoYW5kbGVMb2dpY2FsQ2VudGVyWCAtIHBvc1gpIDwgZmlsbEhhbmRsZUNsaWNrU2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGhhbmRsZUxvZ2ljYWxDZW50ZXJZIC0gcG9zWSkgPCBmaWxsSGFuZGxlQ2xpY2tTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImNlbGxcIixcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogW2NvbCwgcm93XSxcbiAgICAgICAgICAgICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgICAgICAgICAgICBpc0VkZ2UsXG4gICAgICAgICAgICAgICAgc2hpZnRLZXksXG4gICAgICAgICAgICAgICAgY3RybEtleSxcbiAgICAgICAgICAgICAgICBpc0ZpbGxIYW5kbGUsXG4gICAgICAgICAgICAgICAgbWV0YUtleSxcbiAgICAgICAgICAgICAgICBpc1RvdWNoLFxuICAgICAgICAgICAgICAgIGxvY2FsRXZlbnRYOiBwb3NYIC0gYm91bmRzLngsXG4gICAgICAgICAgICAgICAgbG9jYWxFdmVudFk6IHBvc1kgLSBib3VuZHMueSxcbiAgICAgICAgICAgICAgICBidXR0b24sXG4gICAgICAgICAgICAgICAgYnV0dG9ucyxcbiAgICAgICAgICAgICAgICBzY3JvbGxFZGdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIG1hcHBlZENvbHVtbnMsXG4gICAgICAgIGNlbGxYT2Zmc2V0LFxuICAgICAgICB0cmFuc2xhdGVYLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGVuYWJsZUdyb3VwcyxcbiAgICAgICAgaGVhZGVySGVpZ2h0LFxuICAgICAgICBncm91cEhlYWRlckhlaWdodCxcbiAgICAgICAgcm93cyxcbiAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICBjZWxsWU9mZnNldCxcbiAgICAgICAgdHJhbnNsYXRlWSxcbiAgICAgICAgZnJlZXplVHJhaWxpbmdSb3dzLFxuICAgICAgICBnZXRCb3VuZHNGb3JJdGVtLFxuICAgICAgICBmaWxsSGFuZGxlLFxuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIHRvdGFsSGVhZGVySGVpZ2h0LFxuICAgIF0pO1xuICAgIGNvbnN0IFtob3ZlcmVkSXRlbV0gPSBob3ZlcmVkSXRlbUluZm8gPz8gW107XG4gICAgY29uc3QgZW5xdWV1ZVJlZiA9IFJlYWN0LnVzZVJlZigoKSA9PiB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9KTtcbiAgICBjb25zdCBob3ZlckluZm9SZWYgPSBSZWFjdC51c2VSZWYoaG92ZXJlZEl0ZW1JbmZvKTtcbiAgICBob3ZlckluZm9SZWYuY3VycmVudCA9IGhvdmVyZWRJdGVtSW5mbztcbiAgICBjb25zdCBbYnVmZmVyQUN0eCwgYnVmZmVyQkN0eF0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIGNvbnN0IGIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICBhLnN0eWxlW1wiZGlzcGxheVwiXSA9IFwibm9uZVwiO1xuICAgICAgICBhLnN0eWxlW1wib3BhY2l0eVwiXSA9IFwiMFwiO1xuICAgICAgICBhLnN0eWxlW1wicG9zaXRpb25cIl0gPSBcImZpeGVkXCI7XG4gICAgICAgIGIuc3R5bGVbXCJkaXNwbGF5XCJdID0gXCJub25lXCI7XG4gICAgICAgIGIuc3R5bGVbXCJvcGFjaXR5XCJdID0gXCIwXCI7XG4gICAgICAgIGIuc3R5bGVbXCJwb3NpdGlvblwiXSA9IFwiZml4ZWRcIjtcbiAgICAgICAgcmV0dXJuIFthLmdldENvbnRleHQoXCIyZFwiLCB7IGFscGhhOiBmYWxzZSB9KSwgYi5nZXRDb250ZXh0KFwiMmRcIiwgeyBhbHBoYTogZmFsc2UgfSldO1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoYnVmZmVyQUN0eCA9PT0gbnVsbCB8fCBidWZmZXJCQ3R4ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kKGJ1ZmZlckFDdHguY2FudmFzKTtcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZChidWZmZXJCQ3R4LmNhbnZhcyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBidWZmZXJBQ3R4LmNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIGJ1ZmZlckJDdHguY2FudmFzLnJlbW92ZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtidWZmZXJBQ3R4LCBidWZmZXJCQ3R4XSk7XG4gICAgY29uc3QgcmVuZGVyU3RhdGVQcm92aWRlciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gbmV3IFJlbmRlclN0YXRlUHJvdmlkZXIoKSwgW10pO1xuICAgIGNvbnN0IG1heERQUiA9IGVuYWJsZUZpcmVmb3hSZXNjYWxpbmcgJiYgc2Nyb2xsaW5nID8gMSA6IGVuYWJsZVNhZmFyaVJlc2NhbGluZyAmJiBzY3JvbGxpbmcgPyAyIDogNTtcbiAgICBjb25zdCBtaW5pbXVtQ2VsbFdpZHRoID0gZXhwZXJpbWVudGFsPy5kaXNhYmxlTWluaW11bUNlbGxXaWR0aCA9PT0gdHJ1ZSA/IDEgOiAxMDtcbiAgICBjb25zdCBsYXN0QXJnc1JlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGNvbnN0IGNhbnZhc0N0eCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCBvdmVybGF5Q3R4ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGRyYXcgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBvdmVybGF5ID0gb3ZlcmxheVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY2FudmFzID09PSBudWxsIHx8IG92ZXJsYXkgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjYW52YXNDdHguY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY2FudmFzQ3R4LmN1cnJlbnQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHsgYWxwaGE6IGZhbHNlIH0pO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gMDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVybGF5Q3R4LmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG92ZXJsYXlDdHguY3VycmVudCA9IG92ZXJsYXkuZ2V0Q29udGV4dChcIjJkXCIsIHsgYWxwaGE6IGZhbHNlIH0pO1xuICAgICAgICAgICAgb3ZlcmxheS53aWR0aCA9IDA7XG4gICAgICAgICAgICBvdmVybGF5LmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbnZhc0N0eC5jdXJyZW50ID09PSBudWxsIHx8IG92ZXJsYXlDdHguY3VycmVudCA9PT0gbnVsbCB8fCBidWZmZXJBQ3R4ID09PSBudWxsIHx8IGJ1ZmZlckJDdHggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlkT3ZlcnJpZGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGVDdXJzb3IgPSAoY3Vyc29yKSA9PiB7XG4gICAgICAgICAgICBkaWRPdmVycmlkZSA9IHRydWU7XG4gICAgICAgICAgICBzZXREcmF3Q3Vyc29yT3ZlcnJpZGUoY3Vyc29yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGFzdCA9IGxhc3RBcmdzUmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICBoZWFkZXJDYW52YXNDdHg6IG92ZXJsYXlDdHguY3VycmVudCxcbiAgICAgICAgICAgIGNhbnZhc0N0eDogY2FudmFzQ3R4LmN1cnJlbnQsXG4gICAgICAgICAgICBidWZmZXJBQ3R4LFxuICAgICAgICAgICAgYnVmZmVyQkN0eCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgY2VsbFhPZmZzZXQsXG4gICAgICAgICAgICBjZWxsWU9mZnNldCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IE1hdGgucm91bmQodHJhbnNsYXRlWCksXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiBNYXRoLnJvdW5kKHRyYW5zbGF0ZVkpLFxuICAgICAgICAgICAgbWFwcGVkQ29sdW1ucyxcbiAgICAgICAgICAgIGVuYWJsZUdyb3VwcyxcbiAgICAgICAgICAgIGZyZWV6ZUNvbHVtbnMsXG4gICAgICAgICAgICBkcmFnQW5kRHJvcFN0YXRlLFxuICAgICAgICAgICAgdGhlbWUsXG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQsXG4gICAgICAgICAgICBncm91cEhlYWRlckhlaWdodCxcbiAgICAgICAgICAgIGRpc2FibGVkUm93czogZGlzYWJsZWRSb3dzID8/IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICAgICAgICAgIHJvd0hlaWdodCxcbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyLFxuICAgICAgICAgICAgaXNSZXNpemluZyxcbiAgICAgICAgICAgIHJlc2l6ZUNvbCxcbiAgICAgICAgICAgIGlzRm9jdXNlZCxcbiAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgIGZpbGxIYW5kbGUsXG4gICAgICAgICAgICBkcmF3Q2VsbENhbGxiYWNrLFxuICAgICAgICAgICAgaGFzQXBwZW5kUm93LFxuICAgICAgICAgICAgb3ZlcnJpZGVDdXJzb3IsXG4gICAgICAgICAgICBtYXhTY2FsZUZhY3RvcjogbWF4RFBSLFxuICAgICAgICAgICAgZnJlZXplVHJhaWxpbmdSb3dzLFxuICAgICAgICAgICAgcm93cyxcbiAgICAgICAgICAgIGRyYXdGb2N1czogZHJhd0ZvY3VzUmluZyxcbiAgICAgICAgICAgIGdldENlbGxDb250ZW50LFxuICAgICAgICAgICAgZ2V0R3JvdXBEZXRhaWxzOiBnZXRHcm91cERldGFpbHMgPz8gKG5hbWUgPT4gKHsgbmFtZSB9KSksXG4gICAgICAgICAgICBnZXRSb3dUaGVtZU92ZXJyaWRlLFxuICAgICAgICAgICAgZHJhd0hlYWRlckNhbGxiYWNrLFxuICAgICAgICAgICAgcHJlbGlnaHRDZWxscyxcbiAgICAgICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMsXG4gICAgICAgICAgICBpbWFnZUxvYWRlcixcbiAgICAgICAgICAgIGxhc3RCbGl0RGF0YSxcbiAgICAgICAgICAgIGRhbWFnZTogZGFtYWdlUmVnaW9uLmN1cnJlbnQsXG4gICAgICAgICAgICBob3ZlclZhbHVlczogaG92ZXJWYWx1ZXMuY3VycmVudCxcbiAgICAgICAgICAgIGhvdmVySW5mbzogaG92ZXJJbmZvUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBzcHJpdGVNYW5hZ2VyLFxuICAgICAgICAgICAgc2Nyb2xsaW5nLFxuICAgICAgICAgICAgaHlwZXJXcmFwcGluZzogZXhwZXJpbWVudGFsPy5oeXBlcldyYXBwaW5nID8/IGZhbHNlLFxuICAgICAgICAgICAgdG91Y2hNb2RlOiBsYXN0V2FzVG91Y2gsXG4gICAgICAgICAgICBlbnF1ZXVlOiBlbnF1ZXVlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICByZW5kZXJTdGF0ZVByb3ZpZGVyLFxuICAgICAgICAgICAgcmVuZGVyU3RyYXRlZ3k6IGV4cGVyaW1lbnRhbD8ucmVuZGVyU3RyYXRlZ3kgPz8gKGJyb3dzZXJJc1NhZmFyaS52YWx1ZSA/IFwiZG91YmxlLWJ1ZmZlclwiIDogXCJzaW5nbGUtYnVmZmVyXCIpLFxuICAgICAgICAgICAgZ2V0Q2VsbFJlbmRlcmVyLFxuICAgICAgICAgICAgbWluaW11bUNlbGxXaWR0aCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBjb25mdXNpbmcgYml0IG9mIGNvZGUgZHVlIHRvIHNvbWUgcG9vciBkZXNpZ24uIExvbmcgc3Rvcnkgc2hvcnQsIHRoZSBkYW1hZ2UgcHJvcGVydHkgaXMgb25seSB1c2VkXG4gICAgICAgIC8vIHdpdGggd2hhdCBpcyBlZmZlY3RpdmVseSB0aGUgXCJsYXN0IGFyZ3NcIiBmb3IgdGhlIGxhc3Qgbm9ybWFsIGRyYXcgYW55d2F5LiBXZSBkb24ndCB3YW50IHRoZSBkcmF3aW5nIGNvZGVcbiAgICAgICAgLy8gdG8gbG9vayBhdCB0aGlzIGFuZCBnbyBcInNoaXQgZGF3Zywgbm90aGluZyBjaGFuZ2VkXCIgc28gd2UgZm9yY2UgaXQgdG8gZHJhdyBmcmFzaCwgYnV0IHRoZSBkYW1hZ2UgcmVzdHJpY3RzXG4gICAgICAgIC8vIHRoZSBkcmF3IGFueXdheS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVhciBmdXR1cmUgSmFzb24sIEknbSBzb3JyeS4gSXQgd2FzIGV4cGVkaWVudCwgaXQgd29ya2VkLCBhbmQgaGFkIGFsbW9zdCB6ZXJvIHBlcmYgb3ZlcmhlYWQuIFRIZSB1bml2ZXJzZVxuICAgICAgICAvLyBiYXNpY2FsbHkgbWFkZSBtZSBkbyBpdC4gV2hhdCBjaG9pY2UgZGlkIEkgaGF2ZT9cbiAgICAgICAgaWYgKGN1cnJlbnQuZGFtYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxhc3RBcmdzUmVmLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgICAgZHJhd0dyaWQoY3VycmVudCwgbGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkcmF3R3JpZChjdXJyZW50LCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IHJlc2V0IG9uIGRhbWFnZSBldmVudHNcbiAgICAgICAgaWYgKCFkaWRPdmVycmlkZSAmJiAoY3VycmVudC5kYW1hZ2UgPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50LmRhbWFnZS5oYXMoaG92ZXJJbmZvUmVmPy5jdXJyZW50Py5bMF0pKSkge1xuICAgICAgICAgICAgc2V0RHJhd0N1cnNvck92ZXJyaWRlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGJ1ZmZlckFDdHgsXG4gICAgICAgIGJ1ZmZlckJDdHgsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNlbGxYT2Zmc2V0LFxuICAgICAgICBjZWxsWU9mZnNldCxcbiAgICAgICAgdHJhbnNsYXRlWCxcbiAgICAgICAgdHJhbnNsYXRlWSxcbiAgICAgICAgbWFwcGVkQ29sdW1ucyxcbiAgICAgICAgZW5hYmxlR3JvdXBzLFxuICAgICAgICBmcmVlemVDb2x1bW5zLFxuICAgICAgICBkcmFnQW5kRHJvcFN0YXRlLFxuICAgICAgICB0aGVtZSxcbiAgICAgICAgaGVhZGVySGVpZ2h0LFxuICAgICAgICBncm91cEhlYWRlckhlaWdodCxcbiAgICAgICAgZGlzYWJsZWRSb3dzLFxuICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgIHZlcnRpY2FsQm9yZGVyLFxuICAgICAgICBpc1Jlc2l6aW5nLFxuICAgICAgICBoYXNBcHBlbmRSb3csXG4gICAgICAgIHJlc2l6ZUNvbCxcbiAgICAgICAgaXNGb2N1c2VkLFxuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGZpbGxIYW5kbGUsXG4gICAgICAgIGZyZWV6ZVRyYWlsaW5nUm93cyxcbiAgICAgICAgcm93cyxcbiAgICAgICAgZHJhd0ZvY3VzUmluZyxcbiAgICAgICAgbWF4RFBSLFxuICAgICAgICBnZXRDZWxsQ29udGVudCxcbiAgICAgICAgZ2V0R3JvdXBEZXRhaWxzLFxuICAgICAgICBnZXRSb3dUaGVtZU92ZXJyaWRlLFxuICAgICAgICBkcmF3Q2VsbENhbGxiYWNrLFxuICAgICAgICBkcmF3SGVhZGVyQ2FsbGJhY2ssXG4gICAgICAgIHByZWxpZ2h0Q2VsbHMsXG4gICAgICAgIGhpZ2hsaWdodFJlZ2lvbnMsXG4gICAgICAgIGltYWdlTG9hZGVyLFxuICAgICAgICBzcHJpdGVNYW5hZ2VyLFxuICAgICAgICBzY3JvbGxpbmcsXG4gICAgICAgIGV4cGVyaW1lbnRhbD8uaHlwZXJXcmFwcGluZyxcbiAgICAgICAgZXhwZXJpbWVudGFsPy5yZW5kZXJTdHJhdGVneSxcbiAgICAgICAgbGFzdFdhc1RvdWNoLFxuICAgICAgICByZW5kZXJTdGF0ZVByb3ZpZGVyLFxuICAgICAgICBnZXRDZWxsUmVuZGVyZXIsXG4gICAgICAgIG1pbmltdW1DZWxsV2lkdGgsXG4gICAgXSk7XG4gICAgY29uc3QgbGFzdERyYXdSZWYgPSBSZWFjdC51c2VSZWYoZHJhdyk7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgZHJhdygpO1xuICAgICAgICBsYXN0RHJhd1JlZi5jdXJyZW50ID0gZHJhdztcbiAgICB9LCBbZHJhd10pO1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50Py5mb250cz8ucmVhZHkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhd2FpdCBkb2N1bWVudC5mb250cy5yZWFkeTtcbiAgICAgICAgICAgIGxhc3RBcmdzUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsYXN0RHJhd1JlZi5jdXJyZW50KCk7XG4gICAgICAgIH07XG4gICAgICAgIHZvaWQgZm4oKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgZGFtYWdlSW50ZXJuYWwgPSBSZWFjdC51c2VDYWxsYmFjaygobG9jYXRpb25zKSA9PiB7XG4gICAgICAgIGRhbWFnZVJlZ2lvbi5jdXJyZW50ID0gbG9jYXRpb25zO1xuICAgICAgICBsYXN0RHJhd1JlZi5jdXJyZW50KCk7XG4gICAgICAgIGRhbWFnZVJlZ2lvbi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBlbnF1ZXVlID0gdXNlQW5pbWF0aW9uUXVldWUoZGFtYWdlSW50ZXJuYWwpO1xuICAgIGVucXVldWVSZWYuY3VycmVudCA9IGVucXVldWU7XG4gICAgY29uc3QgZGFtYWdlID0gUmVhY3QudXNlQ2FsbGJhY2soKGNlbGxzKSA9PiB7XG4gICAgICAgIGRhbWFnZUludGVybmFsKG5ldyBDZWxsU2V0KGNlbGxzLm1hcCh4ID0+IHguY2VsbCkpKTtcbiAgICB9LCBbZGFtYWdlSW50ZXJuYWxdKTtcbiAgICBpbWFnZUxvYWRlci5zZXRDYWxsYmFjayhkYW1hZ2VJbnRlcm5hbCk7XG4gICAgY29uc3QgW292ZXJGaWxsLCBzZXRPdmVyRmlsbF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2hDb2wsIGhSb3ddID0gaG92ZXJlZEl0ZW0gPz8gW107XG4gICAgY29uc3QgaGVhZGVySG92ZXJlZCA9IGhDb2wgIT09IHVuZGVmaW5lZCAmJiBoUm93ID09PSAtMTtcbiAgICBjb25zdCBncm91cEhlYWRlckhvdmVyZWQgPSBoQ29sICE9PSB1bmRlZmluZWQgJiYgaFJvdyA9PT0gLTI7XG4gICAgbGV0IGNsaWNrYWJsZUlubmVyQ2VsbEhvdmVyZWQgPSBmYWxzZTtcbiAgICBsZXQgZWRpdGFibGVCb29sSG92ZXJlZCA9IGZhbHNlO1xuICAgIGxldCBjdXJzb3JPdmVycmlkZSA9IGRyYXdDdXJzb3JPdmVycmlkZTtcbiAgICBpZiAoY3Vyc29yT3ZlcnJpZGUgPT09IHVuZGVmaW5lZCAmJiBoQ29sICE9PSB1bmRlZmluZWQgJiYgaFJvdyAhPT0gdW5kZWZpbmVkICYmIGhSb3cgPiAtMSAmJiBoUm93IDwgcm93cykge1xuICAgICAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoW2hDb2wsIGhSb3ddLCB0cnVlKTtcbiAgICAgICAgY2xpY2thYmxlSW5uZXJDZWxsSG92ZXJlZCA9XG4gICAgICAgICAgICBjZWxsLmtpbmQgPT09IElubmVyR3JpZENlbGxLaW5kLk5ld1JvdyB8fFxuICAgICAgICAgICAgICAgIChjZWxsLmtpbmQgPT09IElubmVyR3JpZENlbGxLaW5kLk1hcmtlciAmJiBjZWxsLm1hcmtlcktpbmQgIT09IFwibnVtYmVyXCIpO1xuICAgICAgICBlZGl0YWJsZUJvb2xIb3ZlcmVkID0gY2VsbC5raW5kID09PSBHcmlkQ2VsbEtpbmQuQm9vbGVhbiAmJiBib29sZWFuQ2VsbElzRWRpdGFibGUoY2VsbCk7XG4gICAgICAgIGN1cnNvck92ZXJyaWRlID0gY2VsbC5jdXJzb3I7XG4gICAgfVxuICAgIGNvbnN0IGNhbkRyYWcgPSBob3ZlcmVkT25FZGdlID8/IGZhbHNlO1xuICAgIGNvbnN0IGN1cnNvciA9IGlzRHJhZ2dpbmdcbiAgICAgICAgPyBcImdyYWJiaW5nXCJcbiAgICAgICAgOiBjYW5EcmFnIHx8IGlzUmVzaXppbmdcbiAgICAgICAgICAgID8gXCJjb2wtcmVzaXplXCJcbiAgICAgICAgICAgIDogb3ZlckZpbGwgfHwgaXNGaWxsaW5nXG4gICAgICAgICAgICAgICAgPyBcImNyb3NzaGFpclwiXG4gICAgICAgICAgICAgICAgOiBjdXJzb3JPdmVycmlkZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gY3Vyc29yT3ZlcnJpZGVcbiAgICAgICAgICAgICAgICAgICAgOiBoZWFkZXJIb3ZlcmVkIHx8IGNsaWNrYWJsZUlubmVyQ2VsbEhvdmVyZWQgfHwgZWRpdGFibGVCb29sSG92ZXJlZCB8fCBncm91cEhlYWRlckhvdmVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJwb2ludGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJkZWZhdWx0XCI7XG4gICAgY29uc3Qgc3R5bGUgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIC8vIHdpZHRoLFxuICAgICAgICAvLyBoZWlnaHQsXG4gICAgICAgIGNvbnRhaW46IFwic3RyaWN0XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgY3Vyc29yLFxuICAgIH0pLCBbY3Vyc29yXSk7XG4gICAgY29uc3QgbGFzdFNldEN1cnNvciA9IFJlYWN0LnVzZVJlZihcImRlZmF1bHRcIik7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnRUYXJnZXRSZWY/LmN1cnJlbnQ7XG4gICAgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiBsYXN0U2V0Q3Vyc29yLmN1cnJlbnQgIT09IHN0eWxlLmN1cnNvcikge1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGhhdmUgYW4gZXZlbnQgdGFyZ2V0IHdlIG5lZWQgdG8gc2V0IGl0cyBjdXJzb3IgaW5zdGVhZC5cbiAgICAgICAgdGFyZ2V0LnN0eWxlLmN1cnNvciA9IGxhc3RTZXRDdXJzb3IuY3VycmVudCA9IHN0eWxlLmN1cnNvcjtcbiAgICB9XG4gICAgY29uc3QgZ3JvdXBIZWFkZXJBY3Rpb25Gb3JFdmVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKChncm91cCwgYm91bmRzLCBsb2NhbEV2ZW50WCwgbG9jYWxFdmVudFkpID0+IHtcbiAgICAgICAgaWYgKGdldEdyb3VwRGV0YWlscyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZ3JvdXBEZXNjID0gZ2V0R3JvdXBEZXRhaWxzKGdyb3VwKTtcbiAgICAgICAgaWYgKGdyb3VwRGVzYy5hY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveGVzID0gZ2V0QWN0aW9uQm91bmRzRm9yR3JvdXAoYm91bmRzLCBncm91cERlc2MuYWN0aW9ucyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpLCBib3hdIG9mIGJveGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwb2ludEluUmVjdChib3gsIGxvY2FsRXZlbnRYICsgYm91bmRzLngsIGxvY2FsRXZlbnRZICsgYm94LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBncm91cERlc2MuYWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LCBbZ2V0R3JvdXBEZXRhaWxzXSk7XG4gICAgY29uc3QgaXNPdmVySGVhZGVyTWVudSA9IFJlYWN0LnVzZUNhbGxiYWNrKChjYW52YXMsIGNvbCwgY2xpZW50WCwgY2xpZW50WSkgPT4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBjb2x1bW5zW2NvbF07XG4gICAgICAgIGlmICghaXNEcmFnZ2luZyAmJiAhaXNSZXNpemluZyAmJiBoZWFkZXIuaGFzTWVudSA9PT0gdHJ1ZSAmJiAhKGhvdmVyZWRPbkVkZ2UgPz8gZmFsc2UpKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJCb3VuZHMgPSBnZXRCb3VuZHNGb3JJdGVtKGNhbnZhcywgY29sLCAtMSk7XG4gICAgICAgICAgICBhc3NlcnQoaGVhZGVyQm91bmRzICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgbWVudUJvdW5kcyA9IGdldEhlYWRlck1lbnVCb3VuZHMoaGVhZGVyQm91bmRzLngsIGhlYWRlckJvdW5kcy55LCBoZWFkZXJCb3VuZHMud2lkdGgsIGhlYWRlckJvdW5kcy5oZWlnaHQsIGRpcmVjdGlvbihoZWFkZXIudGl0bGUpID09PSBcInJ0bFwiKTtcbiAgICAgICAgICAgIGlmIChjbGllbnRYID4gbWVudUJvdW5kcy54ICYmXG4gICAgICAgICAgICAgICAgY2xpZW50WCA8IG1lbnVCb3VuZHMueCArIG1lbnVCb3VuZHMud2lkdGggJiZcbiAgICAgICAgICAgICAgICBjbGllbnRZID4gbWVudUJvdW5kcy55ICYmXG4gICAgICAgICAgICAgICAgY2xpZW50WSA8IG1lbnVCb3VuZHMueSArIG1lbnVCb3VuZHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlckJvdW5kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sIFtjb2x1bW5zLCBnZXRCb3VuZHNGb3JJdGVtLCBob3ZlcmVkT25FZGdlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nXSk7XG4gICAgY29uc3QgZG93blRpbWUgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgZG93blBvc2l0aW9uID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgbW91c2VEb3duID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBvbk1vdXNlRG93bkltcGwgPSBSZWFjdC51c2VDYWxsYmFjaygoZXYpID0+IHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gZXZlbnRUYXJnZXRSZWY/LmN1cnJlbnQ7XG4gICAgICAgIGlmIChjYW52YXMgPT09IG51bGwgfHwgKGV2LnRhcmdldCAhPT0gY2FudmFzICYmIGV2LnRhcmdldCAhPT0gZXZlbnRUYXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtb3VzZURvd24uY3VycmVudCA9IHRydWU7XG4gICAgICAgIGxldCBjbGllbnRYO1xuICAgICAgICBsZXQgY2xpZW50WTtcbiAgICAgICAgaWYgKGV2IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgICAgICAgY2xpZW50WCA9IGV2LmNsaWVudFg7XG4gICAgICAgICAgICBjbGllbnRZID0gZXYuY2xpZW50WTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudFggPSBldi50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgICBjbGllbnRZID0gZXYudG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldi50YXJnZXQgPT09IGV2ZW50VGFyZ2V0ICYmIGV2ZW50VGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBldmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGlmIChjbGllbnRYID4gYm91bmRzLnJpZ2h0IHx8IGNsaWVudFkgPiBib3VuZHMuYm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gZ2V0TW91c2VBcmdzRm9yUG9zaXRpb24oY2FudmFzLCBjbGllbnRYLCBjbGllbnRZLCBldik7XG4gICAgICAgIGRvd25Qb3NpdGlvbi5jdXJyZW50ID0gYXJncy5sb2NhdGlvbjtcbiAgICAgICAgaWYgKGFyZ3MuaXNUb3VjaCkge1xuICAgICAgICAgICAgZG93blRpbWUuY3VycmVudCA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RXYXNUb3VjaFJlZi5jdXJyZW50ICE9PSBhcmdzLmlzVG91Y2gpIHtcbiAgICAgICAgICAgIHNldExhc3RXYXNUb3VjaChhcmdzLmlzVG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmtpbmQgPT09IGhlYWRlcktpbmQgJiZcbiAgICAgICAgICAgIGlzT3ZlckhlYWRlck1lbnUoY2FudmFzLCBhcmdzLmxvY2F0aW9uWzBdLCBjbGllbnRYLCBjbGllbnRZKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJncy5raW5kID09PSBncm91cEhlYWRlcktpbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGdyb3VwSGVhZGVyQWN0aW9uRm9yRXZlbnQoYXJncy5ncm91cCwgYXJncy5ib3VuZHMsIGFyZ3MubG9jYWxFdmVudFgsIGFyZ3MubG9jYWxFdmVudFkpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uTW91c2VEb3duPy4oYXJncyk7XG4gICAgICAgIGlmICghYXJncy5pc1RvdWNoICYmXG4gICAgICAgICAgICBpc0RyYWdnYWJsZSAhPT0gdHJ1ZSAmJlxuICAgICAgICAgICAgaXNEcmFnZ2FibGUgIT09IGFyZ3Mua2luZCAmJlxuICAgICAgICAgICAgYXJncy5idXR0b24gPCAzICYmXG4gICAgICAgICAgICBhcmdzLmJ1dHRvbiAhPT0gMSkge1xuICAgICAgICAgICAgLy8gcHJldmVudGluZyBkZWZhdWx0IGluIHRvdWNoIGV2ZW50cyBzdG9wcyBzY3JvbGxcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LCBbZXZlbnRUYXJnZXRSZWYsIGlzRHJhZ2dhYmxlLCBnZXRNb3VzZUFyZ3NGb3JQb3NpdGlvbiwgZ3JvdXBIZWFkZXJBY3Rpb25Gb3JFdmVudCwgaXNPdmVySGVhZGVyTWVudSwgb25Nb3VzZURvd25dKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBvbk1vdXNlRG93bkltcGwsIHdpbmRvdywgZmFsc2UpO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd25JbXBsLCB3aW5kb3csIGZhbHNlKTtcbiAgICBjb25zdCBsYXN0VXBUaW1lID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IG9uTW91c2VVcEltcGwgPSBSZWFjdC51c2VDYWxsYmFjaygoZXYpID0+IHtcbiAgICAgICAgY29uc3QgbGFzdFVwVGltZVZhbHVlID0gbGFzdFVwVGltZS5jdXJyZW50O1xuICAgICAgICBsYXN0VXBUaW1lLmN1cnJlbnQgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBjYW52YXMgPSByZWYuY3VycmVudDtcbiAgICAgICAgbW91c2VEb3duLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9uTW91c2VVcCA9PT0gdW5kZWZpbmVkIHx8IGNhbnZhcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldFJlZj8uY3VycmVudDtcbiAgICAgICAgY29uc3QgaXNPdXRzaWRlID0gZXYudGFyZ2V0ICE9PSBjYW52YXMgJiYgZXYudGFyZ2V0ICE9PSBldmVudFRhcmdldDtcbiAgICAgICAgbGV0IGNsaWVudFg7XG4gICAgICAgIGxldCBjbGllbnRZO1xuICAgICAgICBsZXQgY2FuQ2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgaWYgKGV2IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgICAgICAgY2xpZW50WCA9IGV2LmNsaWVudFg7XG4gICAgICAgICAgICBjbGllbnRZID0gZXYuY2xpZW50WTtcbiAgICAgICAgICAgIGNhbkNhbmNlbCA9IGV2LmJ1dHRvbiA8IDM7XG4gICAgICAgICAgICBpZiAoZXYucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudFggPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgY2xpZW50WSA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3MgPSBnZXRNb3VzZUFyZ3NGb3JQb3NpdGlvbihjYW52YXMsIGNsaWVudFgsIGNsaWVudFksIGV2KTtcbiAgICAgICAgaWYgKGFyZ3MuaXNUb3VjaCAmJiBkb3duVGltZS5jdXJyZW50ICE9PSAwICYmIERhdGUubm93KCkgLSBkb3duVGltZS5jdXJyZW50ID4gNTAwKSB7XG4gICAgICAgICAgICBhcmdzID0ge1xuICAgICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAgICAgaXNMb25nVG91Y2g6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0VXBUaW1lVmFsdWUgIT09IDAgJiYgRGF0ZS5ub3coKSAtIGxhc3RVcFRpbWVWYWx1ZSA8IChhcmdzLmlzVG91Y2ggPyAxMDAwIDogNTAwKSkge1xuICAgICAgICAgICAgYXJncyA9IHtcbiAgICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgICAgIGlzRG91YmxlQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0V2FzVG91Y2hSZWYuY3VycmVudCAhPT0gYXJncy5pc1RvdWNoKSB7XG4gICAgICAgICAgICBzZXRMYXN0V2FzVG91Y2goYXJncy5pc1RvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT3V0c2lkZSAmJiBldi5jYW5jZWxhYmxlICYmIGNhbkNhbmNlbCkge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbY29sXSA9IGFyZ3MubG9jYXRpb247XG4gICAgICAgIGNvbnN0IGhlYWRlckJvdW5kcyA9IGlzT3ZlckhlYWRlck1lbnUoY2FudmFzLCBjb2wsIGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICBpZiAoYXJncy5raW5kID09PSBoZWFkZXJLaW5kICYmIGhlYWRlckJvdW5kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5idXR0b24gIT09IDAgfHwgZG93blBvc2l0aW9uLmN1cnJlbnQ/LlswXSAhPT0gY29sIHx8IGRvd25Qb3NpdGlvbi5jdXJyZW50Py5bMV0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yY2Ugb3V0c2lkZSBzbyB0aGF0IGNsaWNrIHdpbGwgbm90IHByb2Nlc3NcbiAgICAgICAgICAgICAgICBvbk1vdXNlVXAoYXJncywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJncy5raW5kID09PSBncm91cEhlYWRlcktpbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGdyb3VwSGVhZGVyQWN0aW9uRm9yRXZlbnQoYXJncy5ncm91cCwgYXJncy5ib3VuZHMsIGFyZ3MubG9jYWxFdmVudFgsIGFyZ3MubG9jYWxFdmVudFkpO1xuICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5vbkNsaWNrKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25Nb3VzZVVwKGFyZ3MsIGlzT3V0c2lkZSk7XG4gICAgfSwgW29uTW91c2VVcCwgZXZlbnRUYXJnZXRSZWYsIGdldE1vdXNlQXJnc0ZvclBvc2l0aW9uLCBpc092ZXJIZWFkZXJNZW51LCBncm91cEhlYWRlckFjdGlvbkZvckV2ZW50XSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwSW1wbCwgd2luZG93LCBmYWxzZSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uTW91c2VVcEltcGwsIHdpbmRvdywgZmFsc2UpO1xuICAgIGNvbnN0IG9uQ2xpY2tJbXBsID0gUmVhY3QudXNlQ2FsbGJhY2soKGV2KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY2FudmFzID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0UmVmPy5jdXJyZW50O1xuICAgICAgICBjb25zdCBpc091dHNpZGUgPSBldi50YXJnZXQgIT09IGNhbnZhcyAmJiBldi50YXJnZXQgIT09IGV2ZW50VGFyZ2V0O1xuICAgICAgICBsZXQgY2xpZW50WDtcbiAgICAgICAgbGV0IGNsaWVudFk7XG4gICAgICAgIGxldCBjYW5DYW5jZWwgPSB0cnVlO1xuICAgICAgICBpZiAoZXYgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICBjbGllbnRYID0gZXYuY2xpZW50WDtcbiAgICAgICAgICAgIGNsaWVudFkgPSBldi5jbGllbnRZO1xuICAgICAgICAgICAgY2FuQ2FuY2VsID0gZXYuYnV0dG9uIDwgMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudFggPSBldi5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgICAgY2xpZW50WSA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IGdldE1vdXNlQXJnc0ZvclBvc2l0aW9uKGNhbnZhcywgY2xpZW50WCwgY2xpZW50WSwgZXYpO1xuICAgICAgICBpZiAobGFzdFdhc1RvdWNoUmVmLmN1cnJlbnQgIT09IGFyZ3MuaXNUb3VjaCkge1xuICAgICAgICAgICAgc2V0TGFzdFdhc1RvdWNoKGFyZ3MuaXNUb3VjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc091dHNpZGUgJiYgZXYuY2FuY2VsYWJsZSAmJiBjYW5DYW5jZWwpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2NvbF0gPSBhcmdzLmxvY2F0aW9uO1xuICAgICAgICBjb25zdCBoZWFkZXJCb3VuZHMgPSBpc092ZXJIZWFkZXJNZW51KGNhbnZhcywgY29sLCBjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgaWYgKGFyZ3Mua2luZCA9PT0gaGVhZGVyS2luZCAmJiBoZWFkZXJCb3VuZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGFyZ3MuYnV0dG9uID09PSAwICYmIGRvd25Qb3NpdGlvbi5jdXJyZW50Py5bMF0gPT09IGNvbCAmJiBkb3duUG9zaXRpb24uY3VycmVudD8uWzFdID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG9uSGVhZGVyTWVudUNsaWNrPy4oY29sLCBoZWFkZXJCb3VuZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3Mua2luZCA9PT0gZ3JvdXBIZWFkZXJLaW5kKSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBncm91cEhlYWRlckFjdGlvbkZvckV2ZW50KGFyZ3MuZ3JvdXAsIGFyZ3MuYm91bmRzLCBhcmdzLmxvY2FsRXZlbnRYLCBhcmdzLmxvY2FsRXZlbnRZKTtcbiAgICAgICAgICAgIGlmIChhY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBhcmdzLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi5vbkNsaWNrKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2V2ZW50VGFyZ2V0UmVmLCBnZXRNb3VzZUFyZ3NGb3JQb3NpdGlvbiwgaXNPdmVySGVhZGVyTWVudSwgb25IZWFkZXJNZW51Q2xpY2ssIGdyb3VwSGVhZGVyQWN0aW9uRm9yRXZlbnRdKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGlja0ltcGwsIHdpbmRvdywgZmFsc2UpO1xuICAgIGNvbnN0IG9uQ29udGV4dE1lbnVJbXBsID0gUmVhY3QudXNlQ2FsbGJhY2soKGV2KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHJlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBldmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0UmVmPy5jdXJyZW50O1xuICAgICAgICBpZiAoY2FudmFzID09PSBudWxsIHx8IChldi50YXJnZXQgIT09IGNhbnZhcyAmJiBldi50YXJnZXQgIT09IGV2ZW50VGFyZ2V0KSB8fCBvbkNvbnRleHRNZW51ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBnZXRNb3VzZUFyZ3NGb3JQb3NpdGlvbihjYW52YXMsIGV2LmNsaWVudFgsIGV2LmNsaWVudFksIGV2KTtcbiAgICAgICAgb25Db250ZXh0TWVudShhcmdzLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYuY2FuY2VsYWJsZSlcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICB9LCBbZXZlbnRUYXJnZXRSZWYsIGdldE1vdXNlQXJnc0ZvclBvc2l0aW9uLCBvbkNvbnRleHRNZW51XSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnVJbXBsLCBldmVudFRhcmdldFJlZj8uY3VycmVudCA/PyBudWxsLCBmYWxzZSk7XG4gICAgY29uc3Qgb25BbmltYXRpb25GcmFtZSA9IFJlYWN0LnVzZUNhbGxiYWNrKHZhbHVlcyA9PiB7XG4gICAgICAgIGRhbWFnZVJlZ2lvbi5jdXJyZW50ID0gbmV3IENlbGxTZXQodmFsdWVzLm1hcCh4ID0+IHguaXRlbSkpO1xuICAgICAgICBob3ZlclZhbHVlcy5jdXJyZW50ID0gdmFsdWVzO1xuICAgICAgICBsYXN0RHJhd1JlZi5jdXJyZW50KCk7XG4gICAgICAgIGRhbWFnZVJlZ2lvbi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBhbmltTWFuYWdlclZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiBuZXcgQW5pbWF0aW9uTWFuYWdlcihvbkFuaW1hdGlvbkZyYW1lKSwgW29uQW5pbWF0aW9uRnJhbWVdKTtcbiAgICBjb25zdCBhbmltYXRpb25NYW5hZ2VyID0gUmVhY3QudXNlUmVmKGFuaW1NYW5hZ2VyVmFsdWUpO1xuICAgIGFuaW1hdGlvbk1hbmFnZXIuY3VycmVudCA9IGFuaW1NYW5hZ2VyVmFsdWU7XG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgYW0gPSBhbmltYXRpb25NYW5hZ2VyLmN1cnJlbnQ7XG4gICAgICAgIGlmIChob3ZlcmVkSXRlbSA9PT0gdW5kZWZpbmVkIHx8IGhvdmVyZWRJdGVtWzFdIDwgMCkge1xuICAgICAgICAgICAgYW0uc2V0SG92ZXJlZChob3ZlcmVkSXRlbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VsbCA9IGdldENlbGxDb250ZW50KGhvdmVyZWRJdGVtLCB0cnVlKTtcbiAgICAgICAgY29uc3QgciA9IGdldENlbGxSZW5kZXJlcihjZWxsKTtcbiAgICAgICAgY29uc3QgY2VsbE5lZWRzSG92ZXIgPSAociA9PT0gdW5kZWZpbmVkICYmIGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLkN1c3RvbSkgfHxcbiAgICAgICAgICAgIChyPy5uZWVkc0hvdmVyICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiByLm5lZWRzSG92ZXIgPT09IFwiYm9vbGVhblwiID8gci5uZWVkc0hvdmVyIDogci5uZWVkc0hvdmVyKGNlbGwpKSk7XG4gICAgICAgIGFtLnNldEhvdmVyZWQoY2VsbE5lZWRzSG92ZXIgPyBob3ZlcmVkSXRlbSA6IHVuZGVmaW5lZCk7XG4gICAgfSwgW2dldENlbGxDb250ZW50LCBnZXRDZWxsUmVuZGVyZXIsIGhvdmVyZWRJdGVtXSk7XG4gICAgY29uc3QgaG92ZXJlZFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlSW1wbCA9IFJlYWN0LnVzZUNhbGxiYWNrKChldikgPT4ge1xuICAgICAgICBjb25zdCBjYW52YXMgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNhbnZhcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldFJlZj8uY3VycmVudDtcbiAgICAgICAgY29uc3QgaXNJbmRpcmVjdCA9IGV2LnRhcmdldCAhPT0gY2FudmFzICYmIGV2LnRhcmdldCAhPT0gZXZlbnRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBnZXRNb3VzZUFyZ3NGb3JQb3NpdGlvbihjYW52YXMsIGV2LmNsaWVudFgsIGV2LmNsaWVudFksIGV2KTtcbiAgICAgICAgaWYgKGFyZ3Mua2luZCAhPT0gXCJvdXQtb2YtYm91bmRzXCIgJiYgaXNJbmRpcmVjdCAmJiAhbW91c2VEb3duLmN1cnJlbnQgJiYgIWFyZ3MuaXNUb3VjaCkge1xuICAgICAgICAgICAgLy8gd2UgYXJlIG9ic2N1cmVkIGJ5IHNvbWV0aGluZyBlbHNlLCBzbyB3ZSB3YW50IHRvIG5vdCByZWdpc3RlciBldmVudHMgaWYgd2UgYXJlIG5vdCBkb2luZyBhbnl0aGluZ1xuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGFscmVhZHlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgcG9pbnQgaGVyZSBpcyBub3QgdG8gdHJpZ2dlciByZS1yZW5kZXJzIGV2ZXJ5IHRpbWUgdGhlIG1vdXNlIG1vdmVzIG92ZXIgYSBjZWxsXG4gICAgICAgIC8vIHRoYXQgZG9lc24ndCBjYXJlIGFib3V0IHRoZSBtb3VzZSBwb3NpdG9uLlxuICAgICAgICBjb25zdCBtYXliZVNldEhvdmVyZWRJbmZvID0gKG5ld1ZhbCwgbmVlZFBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZXRIb3ZlcmVkSXRlbUluZm8oY3YgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjdiA9PT0gbmV3VmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Y7XG4gICAgICAgICAgICAgICAgaWYgKGN2Py5bMF1bMF0gPT09IG5ld1ZhbD8uWzBdWzBdICYmXG4gICAgICAgICAgICAgICAgICAgIGN2Py5bMF1bMV0gPT09IG5ld1ZhbD8uWzBdWzFdICYmXG4gICAgICAgICAgICAgICAgICAgICgoY3Y/LlsxXVswXSA9PT0gbmV3VmFsPy5bMV1bMF0gJiYgY3Y/LlsxXVsxXSA9PT0gbmV3VmFsPy5bMV1bMV0pIHx8ICFuZWVkUG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIW1vdXNlRXZlbnRBcmdzQXJlRXF1YWwoYXJncywgaG92ZXJlZFJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgc2V0RHJhd0N1cnNvck92ZXJyaWRlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBvbkl0ZW1Ib3ZlcmVkPy4oYXJncyk7XG4gICAgICAgICAgICBtYXliZVNldEhvdmVyZWRJbmZvKGFyZ3Mua2luZCA9PT0gb3V0T2ZCb3VuZHNLaW5kID8gdW5kZWZpbmVkIDogW2FyZ3MubG9jYXRpb24sIFthcmdzLmxvY2FsRXZlbnRYLCBhcmdzLmxvY2FsRXZlbnRZXV0sIHRydWUpO1xuICAgICAgICAgICAgaG92ZXJlZFJlZi5jdXJyZW50ID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmdzLmtpbmQgPT09IFwiY2VsbFwiIHx8IGFyZ3Mua2luZCA9PT0gaGVhZGVyS2luZCB8fCBhcmdzLmtpbmQgPT09IGdyb3VwSGVhZGVyS2luZCkge1xuICAgICAgICAgICAgbGV0IG5lZWRzRGFtYWdlQ2VsbCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5lZWRzSG92ZXJQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYXJncy5raW5kID09PSBcImNlbGxcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvQ2hlY2sgPSBnZXRDZWxsQ29udGVudChhcmdzLmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlck5lZWRzID0gZ2V0Q2VsbFJlbmRlcmVyKHRvQ2hlY2spPy5uZWVkc0hvdmVyUG9zaXRpb247XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIGNlbGxzIHdlIHdpbGwgYXNzdW1lIG5lZWQgdGhlIHBvc2l0aW9uIGlmIHRoZXkgZG9uJ3QgZXhwbGljaXRseSBzYXkgdGhleSBkb24ndCwgZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgIC8vIGVsc2Ugd2Ugd2lsbCBhc3N1bWUgZG9lc24ndCBuZWVkIGl0LlxuICAgICAgICAgICAgICAgIG5lZWRzSG92ZXJQb3NpdGlvbiA9IHJlbmRlcmVyTmVlZHMgPz8gdG9DaGVjay5raW5kID09PSBHcmlkQ2VsbEtpbmQuQ3VzdG9tO1xuICAgICAgICAgICAgICAgIG5lZWRzRGFtYWdlQ2VsbCA9IG5lZWRzSG92ZXJQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3Mua2luZCA9PT0gZ3JvdXBIZWFkZXJLaW5kKSB7XG4gICAgICAgICAgICAgICAgbmVlZHNEYW1hZ2VDZWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld0luZm8gPSBbYXJncy5sb2NhdGlvbiwgW2FyZ3MubG9jYWxFdmVudFgsIGFyZ3MubG9jYWxFdmVudFldXTtcbiAgICAgICAgICAgIG1heWJlU2V0SG92ZXJlZEluZm8obmV3SW5mbywgbmVlZHNIb3ZlclBvc2l0aW9uKTtcbiAgICAgICAgICAgIGhvdmVySW5mb1JlZi5jdXJyZW50ID0gbmV3SW5mbztcbiAgICAgICAgICAgIGlmIChuZWVkc0RhbWFnZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBkYW1hZ2VJbnRlcm5hbChuZXcgQ2VsbFNldChbYXJncy5sb2NhdGlvbl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3RSb3dNYXJrZXJDb2wgPSBhcmdzLmxvY2F0aW9uWzBdID49IChmaXJzdENvbEFjY2Vzc2libGUgPyAwIDogMSk7XG4gICAgICAgIHNldEhvdmVyZWRPbkVkZ2UoYXJncy5raW5kID09PSBoZWFkZXJLaW5kICYmIGFyZ3MuaXNFZGdlICYmIG5vdFJvd01hcmtlckNvbCAmJiBhbGxvd1Jlc2l6ZSA9PT0gdHJ1ZSk7XG4gICAgICAgIHNldE92ZXJGaWxsKGFyZ3Mua2luZCA9PT0gXCJjZWxsXCIgJiYgYXJncy5pc0ZpbGxIYW5kbGUpO1xuICAgICAgICBvbk1vdXNlTW92ZVJhdz8uKGV2KTtcbiAgICAgICAgb25Nb3VzZU1vdmUoYXJncyk7XG4gICAgfSwgW1xuICAgICAgICBldmVudFRhcmdldFJlZixcbiAgICAgICAgZ2V0TW91c2VBcmdzRm9yUG9zaXRpb24sXG4gICAgICAgIGZpcnN0Q29sQWNjZXNzaWJsZSxcbiAgICAgICAgYWxsb3dSZXNpemUsXG4gICAgICAgIG9uTW91c2VNb3ZlUmF3LFxuICAgICAgICBvbk1vdXNlTW92ZSxcbiAgICAgICAgb25JdGVtSG92ZXJlZCxcbiAgICAgICAgZ2V0Q2VsbENvbnRlbnQsXG4gICAgICAgIGdldENlbGxSZW5kZXJlcixcbiAgICAgICAgZGFtYWdlSW50ZXJuYWwsXG4gICAgXSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZUltcGwsIHdpbmRvdywgdHJ1ZSk7XG4gICAgY29uc3Qgb25LZXlEb3duSW1wbCA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjYW52YXMgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNhbnZhcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGJvdW5kcztcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYm91bmRzID0gZ2V0Qm91bmRzRm9ySXRlbShjYW52YXMsIHNlbGVjdGlvbi5jdXJyZW50LmNlbGxbMF0sIHNlbGVjdGlvbi5jdXJyZW50LmNlbGxbMV0pO1xuICAgICAgICAgICAgbG9jYXRpb24gPSBzZWxlY3Rpb24uY3VycmVudC5jZWxsO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5RG93bj8uKHtcbiAgICAgICAgICAgIGJvdW5kcyxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogKCkgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSxcbiAgICAgICAgICAgIGNhbmNlbDogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3RybEtleTogZXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgIG1ldGFLZXk6IGV2ZW50Lm1ldGFLZXksXG4gICAgICAgICAgICBzaGlmdEtleTogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBhbHRLZXk6IGV2ZW50LmFsdEtleSxcbiAgICAgICAgICAgIGtleTogZXZlbnQua2V5LFxuICAgICAgICAgICAga2V5Q29kZTogZXZlbnQua2V5Q29kZSxcbiAgICAgICAgICAgIHJhd0V2ZW50OiBldmVudCxcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICB9KTtcbiAgICB9LCBbb25LZXlEb3duLCBzZWxlY3Rpb24sIGdldEJvdW5kc0Zvckl0ZW1dKTtcbiAgICBjb25zdCBvbktleVVwSW1wbCA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjYW52YXMgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNhbnZhcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGJvdW5kcztcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYm91bmRzID0gZ2V0Qm91bmRzRm9ySXRlbShjYW52YXMsIHNlbGVjdGlvbi5jdXJyZW50LmNlbGxbMF0sIHNlbGVjdGlvbi5jdXJyZW50LmNlbGxbMV0pO1xuICAgICAgICAgICAgbG9jYXRpb24gPSBzZWxlY3Rpb24uY3VycmVudC5jZWxsO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5VXA/Lih7XG4gICAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpID0+IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCksXG4gICAgICAgICAgICBjYW5jZWw6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0cmxLZXk6IGV2ZW50LmN0cmxLZXksXG4gICAgICAgICAgICBtZXRhS2V5OiBldmVudC5tZXRhS2V5LFxuICAgICAgICAgICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgYWx0S2V5OiBldmVudC5hbHRLZXksXG4gICAgICAgICAgICBrZXk6IGV2ZW50LmtleSxcbiAgICAgICAgICAgIGtleUNvZGU6IGV2ZW50LmtleUNvZGUsXG4gICAgICAgICAgICByYXdFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgfSk7XG4gICAgfSwgW29uS2V5VXAsIHNlbGVjdGlvbiwgZ2V0Qm91bmRzRm9ySXRlbV0pO1xuICAgIGNvbnN0IHJlZkltcGwgPSBSZWFjdC51c2VDYWxsYmFjaygoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKGNhbnZhc1JlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYW52YXNSZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfSwgW2NhbnZhc1JlZl0pO1xuICAgIGNvbnN0IG9uRHJhZ1N0YXJ0SW1wbCA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjYW52YXMgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNhbnZhcyA9PT0gbnVsbCB8fCBpc0RyYWdnYWJsZSA9PT0gZmFsc2UgfHwgaXNSZXNpemluZykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZHJhZ01pbWU7XG4gICAgICAgIGxldCBkcmFnRGF0YTtcbiAgICAgICAgY29uc3QgYXJncyA9IGdldE1vdXNlQXJnc0ZvclBvc2l0aW9uKGNhbnZhcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSAhPT0gdHJ1ZSAmJiBhcmdzLmtpbmQgIT09IGlzRHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNldERhdGEgPSAobWltZSwgcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgZHJhZ01pbWUgPSBtaW1lO1xuICAgICAgICAgICAgZHJhZ0RhdGEgPSBwYXlsb2FkO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgZHJhZ0ltYWdlO1xuICAgICAgICBsZXQgZHJhZ0ltYWdlWDtcbiAgICAgICAgbGV0IGRyYWdJbWFnZVk7XG4gICAgICAgIGNvbnN0IHNldERyYWdJbWFnZSA9IChpbWFnZSwgeCwgeSkgPT4ge1xuICAgICAgICAgICAgZHJhZ0ltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICBkcmFnSW1hZ2VYID0geDtcbiAgICAgICAgICAgIGRyYWdJbWFnZVkgPSB5O1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgIG9uRHJhZ1N0YXJ0Py4oe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIHNldERhdGEsXG4gICAgICAgICAgICBzZXREcmFnSW1hZ2UsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4gKHByZXZlbnRlZCA9IHRydWUpLFxuICAgICAgICAgICAgZGVmYXVsdFByZXZlbnRlZDogKCkgPT4gcHJldmVudGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwcmV2ZW50ZWQgJiYgZHJhZ01pbWUgIT09IHVuZGVmaW5lZCAmJiBkcmFnRGF0YSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LmRhdGFUcmFuc2ZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoZHJhZ01pbWUsIGRyYWdEYXRhKTtcbiAgICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJjb3B5TGlua1wiO1xuICAgICAgICAgICAgaWYgKGRyYWdJbWFnZSAhPT0gdW5kZWZpbmVkICYmIGRyYWdJbWFnZVggIT09IHVuZGVmaW5lZCAmJiBkcmFnSW1hZ2VZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGRyYWdJbWFnZSwgZHJhZ0ltYWdlWCwgZHJhZ0ltYWdlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY29sLCByb3ddID0gYXJncy5sb2NhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAocm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRzRm9yRHJhZ1RhcmdldCA9IGdldEJvdW5kc0Zvckl0ZW0oY2FudmFzLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChib3VuZHNGb3JEcmFnVGFyZ2V0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkcHIgPSBNYXRoLmNlaWwod2luZG93LmRldmljZVBpeGVsUmF0aW8gPz8gMSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbi53aWR0aCA9IGJvdW5kc0ZvckRyYWdUYXJnZXQud2lkdGggKiBkcHI7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbi5oZWlnaHQgPSBib3VuZHNGb3JEcmFnVGFyZ2V0LmhlaWdodCAqIGRwcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IHRoZW1lLmhlYWRlckZvbnRGdWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS5iZ0hlYWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgb2Zmc2NyZWVuLndpZHRoLCBvZmZzY3JlZW4uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3SGVhZGVyKGN0eCwgMCwgMCwgYm91bmRzRm9yRHJhZ1RhcmdldC53aWR0aCwgYm91bmRzRm9yRHJhZ1RhcmdldC5oZWlnaHQsIG1hcHBlZENvbHVtbnNbY29sXSwgZmFsc2UsIHRoZW1lLCBmYWxzZSwgZmFsc2UsIDAsIHNwcml0ZU1hbmFnZXIsIGRyYXdIZWFkZXJDYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aGVtZS5iYXNlRm9udEZ1bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lLmJnQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgb2Zmc2NyZWVuLndpZHRoLCBvZmZzY3JlZW4uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3Q2VsbChjdHgsIGdldENlbGxDb250ZW50KFtjb2wsIHJvd10pLCAwLCByb3csIGZhbHNlLCBmYWxzZSwgMCwgMCwgYm91bmRzRm9yRHJhZ1RhcmdldC53aWR0aCwgYm91bmRzRm9yRHJhZ1RhcmdldC5oZWlnaHQsIGZhbHNlLCB0aGVtZSwgdGhlbWUuYmdDZWxsLCBpbWFnZUxvYWRlciwgc3ByaXRlTWFuYWdlciwgMSwgdW5kZWZpbmVkLCBmYWxzZSwgMCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcmVuZGVyU3RhdGVQcm92aWRlciwgZ2V0Q2VsbFJlbmRlcmVyLCAoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbi5zdHlsZS5sZWZ0ID0gXCItMTAwJVwiO1xuICAgICAgICAgICAgICAgICAgICBvZmZzY3JlZW4uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbi5zdHlsZS53aWR0aCA9IGAke2JvdW5kc0ZvckRyYWdUYXJnZXQud2lkdGh9cHhgO1xuICAgICAgICAgICAgICAgICAgICBvZmZzY3JlZW4uc3R5bGUuaGVpZ2h0ID0gYCR7Ym91bmRzRm9yRHJhZ1RhcmdldC5oZWlnaHR9cHhgO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChvZmZzY3JlZW4pO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKG9mZnNjcmVlbiwgYm91bmRzRm9yRHJhZ1RhcmdldC53aWR0aCAvIDIsIGJvdW5kc0ZvckRyYWdUYXJnZXQuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgaXNEcmFnZ2FibGUsXG4gICAgICAgIGlzUmVzaXppbmcsXG4gICAgICAgIGdldE1vdXNlQXJnc0ZvclBvc2l0aW9uLFxuICAgICAgICBvbkRyYWdTdGFydCxcbiAgICAgICAgZ2V0Qm91bmRzRm9ySXRlbSxcbiAgICAgICAgdGhlbWUsXG4gICAgICAgIG1hcHBlZENvbHVtbnMsXG4gICAgICAgIHNwcml0ZU1hbmFnZXIsXG4gICAgICAgIGRyYXdIZWFkZXJDYWxsYmFjayxcbiAgICAgICAgZ2V0Q2VsbENvbnRlbnQsXG4gICAgICAgIGltYWdlTG9hZGVyLFxuICAgICAgICByZW5kZXJTdGF0ZVByb3ZpZGVyLFxuICAgICAgICBnZXRDZWxsUmVuZGVyZXIsXG4gICAgXSk7XG4gICAgdXNlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBvbkRyYWdTdGFydEltcGwsIGV2ZW50VGFyZ2V0UmVmPy5jdXJyZW50ID8/IG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgY29uc3QgYWN0aXZlRHJvcFRhcmdldCA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGNvbnN0IG9uRHJhZ092ZXJJbXBsID0gUmVhY3QudXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAob25Ecm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gcHJldmVudERlZmF1bHQgdG8gYWxsb3cgZHJvcFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FudmFzID09PSBudWxsIHx8IG9uRHJhZ092ZXJDZWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gZ2V0TW91c2VBcmdzRm9yUG9zaXRpb24oY2FudmFzLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgY29uc3QgW3Jhd0NvbCwgcm93XSA9IGFyZ3MubG9jYXRpb247XG4gICAgICAgIGNvbnN0IGNvbCA9IHJhd0NvbCAtIChmaXJzdENvbEFjY2Vzc2libGUgPyAwIDogMSk7XG4gICAgICAgIGNvbnN0IFthY3RpdmVDb2wsIGFjdGl2ZVJvd10gPSBhY3RpdmVEcm9wVGFyZ2V0LmN1cnJlbnQgPz8gW107XG4gICAgICAgIGlmIChhY3RpdmVDb2wgIT09IGNvbCB8fCBhY3RpdmVSb3cgIT09IHJvdykge1xuICAgICAgICAgICAgYWN0aXZlRHJvcFRhcmdldC5jdXJyZW50ID0gW2NvbCwgcm93XTtcbiAgICAgICAgICAgIG9uRHJhZ092ZXJDZWxsKFtjb2wsIHJvd10sIGV2ZW50LmRhdGFUcmFuc2Zlcik7XG4gICAgICAgIH1cbiAgICB9LCBbZmlyc3RDb2xBY2Nlc3NpYmxlLCBnZXRNb3VzZUFyZ3NGb3JQb3NpdGlvbiwgb25EcmFnT3ZlckNlbGwsIG9uRHJvcF0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCBvbkRyYWdPdmVySW1wbCwgZXZlbnRUYXJnZXRSZWY/LmN1cnJlbnQgPz8gbnVsbCwgZmFsc2UsIGZhbHNlKTtcbiAgICBjb25zdCBvbkRyYWdFbmRJbXBsID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBhY3RpdmVEcm9wVGFyZ2V0LmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIG9uRHJhZ0VuZD8uKCk7XG4gICAgfSwgW29uRHJhZ0VuZF0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIG9uRHJhZ0VuZEltcGwsIGV2ZW50VGFyZ2V0UmVmPy5jdXJyZW50ID8/IG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgY29uc3Qgb25Ecm9wSW1wbCA9IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBjYW52YXMgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNhbnZhcyA9PT0gbnVsbCB8fCBvbkRyb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgY2FuIG1lc3MgdXAgc29tZXRpbWVzLlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBhcmdzID0gZ2V0TW91c2VBcmdzRm9yUG9zaXRpb24oY2FudmFzLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgY29uc3QgW3Jhd0NvbCwgcm93XSA9IGFyZ3MubG9jYXRpb247XG4gICAgICAgIGNvbnN0IGNvbCA9IHJhd0NvbCAtIChmaXJzdENvbEFjY2Vzc2libGUgPyAwIDogMSk7XG4gICAgICAgIG9uRHJvcChbY29sLCByb3ddLCBldmVudC5kYXRhVHJhbnNmZXIpO1xuICAgIH0sIFtmaXJzdENvbEFjY2Vzc2libGUsIGdldE1vdXNlQXJnc0ZvclBvc2l0aW9uLCBvbkRyb3BdKTtcbiAgICB1c2VFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBvbkRyb3BJbXBsLCBldmVudFRhcmdldFJlZj8uY3VycmVudCA/PyBudWxsLCBmYWxzZSwgZmFsc2UpO1xuICAgIGNvbnN0IG9uRHJhZ0xlYXZlSW1wbCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgb25EcmFnTGVhdmU/LigpO1xuICAgIH0sIFtvbkRyYWdMZWF2ZV0pO1xuICAgIHVzZUV2ZW50TGlzdGVuZXIoXCJkcmFnbGVhdmVcIiwgb25EcmFnTGVhdmVJbXBsLCBldmVudFRhcmdldFJlZj8uY3VycmVudCA/PyBudWxsLCBmYWxzZSwgZmFsc2UpO1xuICAgIGNvbnN0IHNlbGVjdGlvblJlZiA9IFJlYWN0LnVzZVJlZihzZWxlY3Rpb24pO1xuICAgIHNlbGVjdGlvblJlZi5jdXJyZW50ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGZvY3VzUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGZvY3VzRWxlbWVudCA9IFJlYWN0LnVzZUNhbGxiYWNrKChlbCkgPT4ge1xuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHN0ZWFsIHRoZSBmb2N1cyBpZiB3ZSBkb24ndCBjdXJyZW50bHkgb3duIHRoZSBmb2N1cy5cbiAgICAgICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsIHx8ICFyZWYuY3VycmVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGVsID09PSBudWxsICYmIHNlbGVjdGlvblJlZi5jdXJyZW50LmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FudmFzUmVmPy5jdXJyZW50Py5mb2N1cyh7XG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlbC5mb2N1cyh7XG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvY3VzUmVmLmN1cnJlbnQgPSBlbDtcbiAgICB9LCBbY2FudmFzUmVmXSk7XG4gICAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+ICh7XG4gICAgICAgIGZvY3VzOiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGZvY3VzUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBpbiB0aGUgcmVmIG1heSBoYXZlIGJlZW4gcmVtb3ZlZCBob3dldmVyIG91ciBjYWxsYmFjayBtZXRob2QgcmVmXG4gICAgICAgICAgICAvLyB3b24ndCBzZWUgdGhlIHJlbW92YWwgc28gYmFkIHRoaW5ncyBoYXBwZW4uIENoZWNraW5nIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBpc1xuICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIGF0dGFjaGVkIGlzIGVub3VnaCB0byByZXNvbHZlIHRoZSBwcm9ibGVtLiBJbiB0aGUgZnV0dXJlIHRoaXNcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIHNvbWV0aGluZyBtdWNoIG1vcmUgcm9idXN0LlxuICAgICAgICAgICAgaWYgKGVsID09PSBudWxsIHx8ICFkb2N1bWVudC5jb250YWlucyhlbCkpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNSZWY/LmN1cnJlbnQ/LmZvY3VzKHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLmZvY3VzKHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Qm91bmRzOiAoY29sLCByb3cpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW52YXNSZWYgPT09IHVuZGVmaW5lZCB8fCBjYW52YXNSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0Qm91bmRzRm9ySXRlbShjYW52YXNSZWYuY3VycmVudCwgY29sID8/IDAsIHJvdyA/PyAtMSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRhbWFnZSxcbiAgICB9KSwgW2NhbnZhc1JlZiwgZGFtYWdlLCBnZXRCb3VuZHNGb3JJdGVtXSk7XG4gICAgY29uc3QgbGFzdEZvY3VzZWRTdWJkb21Ob2RlID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgYWNjZXNzaWJpbGl0eVRyZWUgPSB1c2VEZWJvdW5jZWRNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHdpZHRoIDwgNTAgfHwgZXhwZXJpbWVudGFsPy5kaXNhYmxlQWNjZXNzaWJpbGl0eVRyZWUgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGVmZmVjdGl2ZUNvbHMgPSBnZXRFZmZlY3RpdmVDb2x1bW5zKG1hcHBlZENvbHVtbnMsIGNlbGxYT2Zmc2V0LCB3aWR0aCwgZHJhZ0FuZERyb3BTdGF0ZSwgdHJhbnNsYXRlWCk7XG4gICAgICAgIGNvbnN0IGNvbE9mZnNldCA9IGZpcnN0Q29sQWNjZXNzaWJsZSA/IDAgOiAtMTtcbiAgICAgICAgaWYgKCFmaXJzdENvbEFjY2Vzc2libGUgJiYgZWZmZWN0aXZlQ29sc1swXT8uc291cmNlSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGVmZmVjdGl2ZUNvbHMgPSBlZmZlY3RpdmVDb2xzLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtmQ29sLCBmUm93XSA9IHNlbGVjdGlvbi5jdXJyZW50Py5jZWxsID8/IFtdO1xuICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5jdXJyZW50Py5yYW5nZTtcbiAgICAgICAgY29uc3QgdmlzaWJsZUNvbHMgPSBlZmZlY3RpdmVDb2xzLm1hcChjID0+IGMuc291cmNlSW5kZXgpO1xuICAgICAgICBjb25zdCB2aXNpYmxlUm93cyA9IG1ha2VSYW5nZShjZWxsWU9mZnNldCwgTWF0aC5taW4ocm93cywgY2VsbFlPZmZzZXQgKyBhY2Nlc3NpYmlsaXR5SGVpZ2h0KSk7XG4gICAgICAgIC8vIE1haW50YWluIGZvY3VzIHdpdGhpbiBncmlkIGlmIHdlIG93biBpdCBidXQgZm9jdXNlZCBjZWxsIGlzIG91dHNpZGUgdmlzaWJsZSB2aWV3cG9ydFxuICAgICAgICAvLyBhbmQgbm90IHJlbmRlcmVkLlxuICAgICAgICBpZiAoZkNvbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmUm93ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICEodmlzaWJsZUNvbHMuaW5jbHVkZXMoZkNvbCkgJiYgdmlzaWJsZVJvd3MuaW5jbHVkZXMoZlJvdykpKSB7XG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBrZXk6IFwiYWNjZXNzLXRyZWVcIiwgcm9sZTogXCJncmlkXCIsIFwiYXJpYS1yb3djb3VudFwiOiByb3dzICsgMSwgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiBcInRydWVcIiwgXCJhcmlhLWNvbGNvdW50XCI6IG1hcHBlZENvbHVtbnMubGVuZ3RoICsgY29sT2Zmc2V0IH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGhlYWRcIiwgeyByb2xlOiBcInJvd2dyb3VwXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInJvd1wiLCBcImFyaWEtcm93aW5kZXhcIjogMSB9LCBlZmZlY3RpdmVDb2xzLm1hcChjID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGhcIiwgeyByb2xlOiBcImNvbHVtbmhlYWRlclwiLCBcImFyaWEtc2VsZWN0ZWRcIjogc2VsZWN0aW9uLmNvbHVtbnMuaGFzSW5kZXgoYy5zb3VyY2VJbmRleCksIFwiYXJpYS1jb2xpbmRleFwiOiBjLnNvdXJjZUluZGV4ICsgMSArIGNvbE9mZnNldCwgdGFiSW5kZXg6IC0xLCBvbkZvY3VzOiBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gZm9jdXNSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25DZWxsRm9jdXNlZD8uKFtjLnNvdXJjZUluZGV4LCAtMV0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBrZXk6IGMuc291cmNlSW5kZXggfSwgYy50aXRsZSkpKSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHsgcm9sZTogXCJyb3dncm91cFwiIH0sIHZpc2libGVSb3dzLm1hcChyb3cgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIsIFwiYXJpYS1zZWxlY3RlZFwiOiBzZWxlY3Rpb24ucm93cy5oYXNJbmRleChyb3cpLCBrZXk6IHJvdywgXCJhcmlhLXJvd2luZGV4XCI6IHJvdyArIDIgfSwgZWZmZWN0aXZlQ29scy5tYXAoYyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gYy5zb3VyY2VJbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYWNrQ29sUm93VG9OdW1iZXIoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzZWQgPSBmQ29sID09PSBjb2wgJiYgZlJvdyA9PT0gcm93O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gcmFuZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBjb2wgPj0gcmFuZ2UueCAmJlxuICAgICAgICAgICAgICAgICAgICBjb2wgPCByYW5nZS54ICsgcmFuZ2Uud2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgcm93ID49IHJhbmdlLnkgJiZcbiAgICAgICAgICAgICAgICAgICAgcm93IDwgcmFuZ2UueSArIHJhbmdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGBnbGlkZS1jZWxsLSR7Y29sfS0ke3Jvd31gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gW2NvbCwgcm93XTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29udGVudCA9IGdldENlbGxDb250ZW50KGxvY2F0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGtleToga2V5LCByb2xlOiBcImdyaWRjZWxsXCIsIFwiYXJpYS1jb2xpbmRleFwiOiBjb2wgKyAxICsgY29sT2Zmc2V0LCBcImFyaWEtc2VsZWN0ZWRcIjogc2VsZWN0ZWQsIFwiYXJpYS1yZWFkb25seVwiOiBpc0lubmVyT25seUNlbGwoY2VsbENvbnRlbnQpIHx8ICFpc1JlYWRXcml0ZUNlbGwoY2VsbENvbnRlbnQpLCBpZDogaWQsIFwiZGF0YS10ZXN0aWRcIjogaWQsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZj8uY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW52YXMgPT09IG51bGwgfHwgY2FudmFzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uS2V5RG93bj8uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHM6IGdldEJvdW5kc0Zvckl0ZW0oY2FudmFzLCBjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IFwiRW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlDb2RlOiAxMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdFdmVudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9uRm9jdXNDYXB0dXJlOiBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gZm9jdXNSZWYuY3VycmVudCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsYXN0Rm9jdXNlZFN1YmRvbU5vZGUuY3VycmVudD8uWzBdID09PSBjb2wgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEZvY3VzZWRTdWJkb21Ob2RlLmN1cnJlbnQ/LlsxXSA9PT0gcm93KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Rm9jdXNlZFN1YmRvbU5vZGUuY3VycmVudCA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uQ2VsbEZvY3VzZWQ/Lihsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0sIHJlZjogZm9jdXNlZCA/IGZvY3VzRWxlbWVudCA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IC0xIH0sIGdldFJvd0RhdGEoY2VsbENvbnRlbnQsIGdldENlbGxSZW5kZXJlcikpKTtcbiAgICAgICAgICAgIH0pKSkpKSkpO1xuICAgIH0sIFtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIG1hcHBlZENvbHVtbnMsXG4gICAgICAgIGNlbGxYT2Zmc2V0LFxuICAgICAgICBkcmFnQW5kRHJvcFN0YXRlLFxuICAgICAgICB0cmFuc2xhdGVYLFxuICAgICAgICByb3dzLFxuICAgICAgICBjZWxsWU9mZnNldCxcbiAgICAgICAgYWNjZXNzaWJpbGl0eUhlaWdodCxcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBmb2N1c0VsZW1lbnQsXG4gICAgICAgIGdldENlbGxDb250ZW50LFxuICAgICAgICBjYW52YXNSZWYsXG4gICAgICAgIG9uS2V5RG93bixcbiAgICAgICAgZ2V0Qm91bmRzRm9ySXRlbSxcbiAgICAgICAgb25DZWxsRm9jdXNlZCxcbiAgICBdLCAyMDApO1xuICAgIGNvbnN0IG9wYWNpdHlYID0gZnJlZXplQ29sdW1ucyA9PT0gMCB8fCAhZml4ZWRTaGFkb3dYID8gMCA6IGNlbGxYT2Zmc2V0ID4gZnJlZXplQ29sdW1ucyA/IDEgOiBjbGFtcCgtdHJhbnNsYXRlWCAvIDEwMCwgMCwgMSk7XG4gICAgY29uc3QgYWJzb2x1dGVPZmZzZXRZID0gLWNlbGxZT2Zmc2V0ICogMzIgKyB0cmFuc2xhdGVZO1xuICAgIGNvbnN0IG9wYWNpdHlZID0gIWZpeGVkU2hhZG93WSA/IDAgOiBjbGFtcCgtYWJzb2x1dGVPZmZzZXRZIC8gMTAwLCAwLCAxKTtcbiAgICBjb25zdCBzdGlja3lTaGFkb3cgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFvcGFjaXR5WCAmJiAhb3BhY2l0eVkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlWCA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBsZWZ0OiBzdGlja3lYLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoIC0gc3RpY2t5WCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVgsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICFzbW9vdGhTY3JvbGxYID8gXCJvcGFjaXR5IDAuMnNcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGJveFNoYWRvdzogXCJpbnNldCAxM3B4IDAgMTBweCAtMTNweCByZ2JhKDAsIDAsIDAsIDAuMilcIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3R5bGVZID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogdG90YWxIZWFkZXJIZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5WSxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogIXNtb290aFNjcm9sbFkgPyBcIm9wYWNpdHkgMC4yc1wiIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYm94U2hhZG93OiBcImluc2V0IDAgMTNweCAxMHB4IC0xM3B4IHJnYmEoMCwgMCwgMCwgMC4yKVwiLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBvcGFjaXR5WCA+IDAgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGlkOiBcInNoYWRvdy14XCIsIHN0eWxlOiBzdHlsZVggfSksXG4gICAgICAgICAgICBvcGFjaXR5WSA+IDAgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGlkOiBcInNoYWRvdy15XCIsIHN0eWxlOiBzdHlsZVkgfSkpKTtcbiAgICB9LCBbb3BhY2l0eVgsIG9wYWNpdHlZLCBzdGlja3lYLCB3aWR0aCwgc21vb3RoU2Nyb2xsWCwgdG90YWxIZWFkZXJIZWlnaHQsIGhlaWdodCwgc21vb3RoU2Nyb2xsWV0pO1xuICAgIGNvbnN0IG92ZXJsYXlTdHlsZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgIH0pLCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcImRhdGEtZ3JpZC1jYW52YXNcIiwgdGFiSW5kZXg6IDAsIG9uS2V5RG93bjogb25LZXlEb3duSW1wbCwgb25LZXlVcDogb25LZXlVcEltcGwsIG9uRm9jdXM6IG9uQ2FudmFzRm9jdXNlZCwgb25CbHVyOiBvbkNhbnZhc0JsdXIsIHJlZjogcmVmSW1wbCwgc3R5bGU6IHN0eWxlIH0sIGFjY2Vzc2liaWxpdHlUcmVlKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7IHJlZjogb3ZlcmxheVJlZiwgc3R5bGU6IG92ZXJsYXlTdHlsZSB9KSxcbiAgICAgICAgc3RpY2t5U2hhZG93KSk7XG59O1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhSZWFjdC5mb3J3YXJkUmVmKERhdGFHcmlkKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLWdyaWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/event-args.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/event-args.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OutOfBoundsRegionAxis: () => (/* binding */ OutOfBoundsRegionAxis),\n/* harmony export */   groupHeaderKind: () => (/* binding */ groupHeaderKind),\n/* harmony export */   headerKind: () => (/* binding */ headerKind),\n/* harmony export */   mouseEventArgsAreEqual: () => (/* binding */ mouseEventArgsAreEqual),\n/* harmony export */   outOfBoundsKind: () => (/* binding */ outOfBoundsKind)\n/* harmony export */ });\n/** @category Types */\nconst headerKind = \"header\";\n/** @category Types */\nconst groupHeaderKind = \"group-header\";\n/** @category Types */\nconst outOfBoundsKind = \"out-of-bounds\";\n/** @category Types */\nvar OutOfBoundsRegionAxis;\n(function (OutOfBoundsRegionAxis) {\n    OutOfBoundsRegionAxis[OutOfBoundsRegionAxis[\"Start\"] = -2] = \"Start\";\n    OutOfBoundsRegionAxis[OutOfBoundsRegionAxis[\"StartPadding\"] = -1] = \"StartPadding\";\n    OutOfBoundsRegionAxis[OutOfBoundsRegionAxis[\"Center\"] = 0] = \"Center\";\n    OutOfBoundsRegionAxis[OutOfBoundsRegionAxis[\"EndPadding\"] = 1] = \"EndPadding\";\n    OutOfBoundsRegionAxis[OutOfBoundsRegionAxis[\"End\"] = 2] = \"End\";\n})(OutOfBoundsRegionAxis || (OutOfBoundsRegionAxis = {}));\nfunction mouseEventArgsAreEqual(args, other) {\n    if (args === other)\n        return true;\n    if (args?.kind === \"out-of-bounds\") {\n        return (args?.kind === other?.kind &&\n            args?.location[0] === other?.location[0] &&\n            args?.location[1] === other?.location[1] &&\n            args?.region[0] === other?.region[0] &&\n            args?.region[1] === other?.region[1]);\n    }\n    return (args?.kind === other?.kind &&\n        args?.location[0] === other?.location[0] &&\n        args?.location[1] === other?.location[1]);\n}\n//# sourceMappingURL=event-args.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2V2ZW50LWFyZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDaEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL2V2ZW50LWFyZ3MuanM/NzJkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGNhdGVnb3J5IFR5cGVzICovXG5leHBvcnQgY29uc3QgaGVhZGVyS2luZCA9IFwiaGVhZGVyXCI7XG4vKiogQGNhdGVnb3J5IFR5cGVzICovXG5leHBvcnQgY29uc3QgZ3JvdXBIZWFkZXJLaW5kID0gXCJncm91cC1oZWFkZXJcIjtcbi8qKiBAY2F0ZWdvcnkgVHlwZXMgKi9cbmV4cG9ydCBjb25zdCBvdXRPZkJvdW5kc0tpbmQgPSBcIm91dC1vZi1ib3VuZHNcIjtcbi8qKiBAY2F0ZWdvcnkgVHlwZXMgKi9cbmV4cG9ydCB2YXIgT3V0T2ZCb3VuZHNSZWdpb25BeGlzO1xuKGZ1bmN0aW9uIChPdXRPZkJvdW5kc1JlZ2lvbkF4aXMpIHtcbiAgICBPdXRPZkJvdW5kc1JlZ2lvbkF4aXNbT3V0T2ZCb3VuZHNSZWdpb25BeGlzW1wiU3RhcnRcIl0gPSAtMl0gPSBcIlN0YXJ0XCI7XG4gICAgT3V0T2ZCb3VuZHNSZWdpb25BeGlzW091dE9mQm91bmRzUmVnaW9uQXhpc1tcIlN0YXJ0UGFkZGluZ1wiXSA9IC0xXSA9IFwiU3RhcnRQYWRkaW5nXCI7XG4gICAgT3V0T2ZCb3VuZHNSZWdpb25BeGlzW091dE9mQm91bmRzUmVnaW9uQXhpc1tcIkNlbnRlclwiXSA9IDBdID0gXCJDZW50ZXJcIjtcbiAgICBPdXRPZkJvdW5kc1JlZ2lvbkF4aXNbT3V0T2ZCb3VuZHNSZWdpb25BeGlzW1wiRW5kUGFkZGluZ1wiXSA9IDFdID0gXCJFbmRQYWRkaW5nXCI7XG4gICAgT3V0T2ZCb3VuZHNSZWdpb25BeGlzW091dE9mQm91bmRzUmVnaW9uQXhpc1tcIkVuZFwiXSA9IDJdID0gXCJFbmRcIjtcbn0pKE91dE9mQm91bmRzUmVnaW9uQXhpcyB8fCAoT3V0T2ZCb3VuZHNSZWdpb25BeGlzID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBtb3VzZUV2ZW50QXJnc0FyZUVxdWFsKGFyZ3MsIG90aGVyKSB7XG4gICAgaWYgKGFyZ3MgPT09IG90aGVyKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYXJncz8ua2luZCA9PT0gXCJvdXQtb2YtYm91bmRzXCIpIHtcbiAgICAgICAgcmV0dXJuIChhcmdzPy5raW5kID09PSBvdGhlcj8ua2luZCAmJlxuICAgICAgICAgICAgYXJncz8ubG9jYXRpb25bMF0gPT09IG90aGVyPy5sb2NhdGlvblswXSAmJlxuICAgICAgICAgICAgYXJncz8ubG9jYXRpb25bMV0gPT09IG90aGVyPy5sb2NhdGlvblsxXSAmJlxuICAgICAgICAgICAgYXJncz8ucmVnaW9uWzBdID09PSBvdGhlcj8ucmVnaW9uWzBdICYmXG4gICAgICAgICAgICBhcmdzPy5yZWdpb25bMV0gPT09IG90aGVyPy5yZWdpb25bMV0pO1xuICAgIH1cbiAgICByZXR1cm4gKGFyZ3M/LmtpbmQgPT09IG90aGVyPy5raW5kICYmXG4gICAgICAgIGFyZ3M/LmxvY2F0aW9uWzBdID09PSBvdGhlcj8ubG9jYXRpb25bMF0gJiZcbiAgICAgICAgYXJncz8ubG9jYXRpb25bMV0gPT09IG90aGVyPy5sb2NhdGlvblsxXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudC1hcmdzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/event-args.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cellIsInRange: () => (/* binding */ cellIsInRange),\n/* harmony export */   cellIsSelected: () => (/* binding */ cellIsSelected),\n/* harmony export */   computeBounds: () => (/* binding */ computeBounds),\n/* harmony export */   drawLastUpdateUnderlay: () => (/* binding */ drawLastUpdateUnderlay),\n/* harmony export */   drawMenuDots: () => (/* binding */ drawMenuDots),\n/* harmony export */   drawTextCell: () => (/* binding */ drawTextCell),\n/* harmony export */   drawTextCellExternal: () => (/* binding */ drawTextCellExternal),\n/* harmony export */   getColumnIndexForX: () => (/* binding */ getColumnIndexForX),\n/* harmony export */   getEffectiveColumns: () => (/* binding */ getEffectiveColumns),\n/* harmony export */   getEmHeight: () => (/* binding */ getEmHeight),\n/* harmony export */   getFreezeTrailingHeight: () => (/* binding */ getFreezeTrailingHeight),\n/* harmony export */   getMeasuredTextCache: () => (/* binding */ getMeasuredTextCache),\n/* harmony export */   getMiddleCenterBias: () => (/* binding */ getMiddleCenterBias),\n/* harmony export */   getRowIndexForY: () => (/* binding */ getRowIndexForY),\n/* harmony export */   getStickyWidth: () => (/* binding */ getStickyWidth),\n/* harmony export */   gridSelectionHasItem: () => (/* binding */ gridSelectionHasItem),\n/* harmony export */   isGroupEqual: () => (/* binding */ isGroupEqual),\n/* harmony export */   itemIsInRect: () => (/* binding */ itemIsInRect),\n/* harmony export */   itemsAreEqual: () => (/* binding */ itemsAreEqual),\n/* harmony export */   measureTextCached: () => (/* binding */ measureTextCached),\n/* harmony export */   prepTextCell: () => (/* binding */ prepTextCell),\n/* harmony export */   rectBottomRight: () => (/* binding */ rectBottomRight),\n/* harmony export */   remapForDnDState: () => (/* binding */ remapForDnDState),\n/* harmony export */   roundedPoly: () => (/* binding */ roundedPoly),\n/* harmony export */   roundedRect: () => (/* binding */ roundedRect),\n/* harmony export */   useMappedColumns: () => (/* binding */ useMappedColumns)\n/* harmony export */ });\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var canvas_hypertxt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! canvas-hypertxt */ \"(ssr)/./node_modules/canvas-hypertxt/dist/js/index.js\");\n\n\n\n\nfunction useMappedColumns(columns, freezeColumns) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => columns.map((c, i) => ({\n        group: c.group,\n        grow: c.grow,\n        hasMenu: c.hasMenu,\n        icon: c.icon,\n        id: c.id,\n        menuIcon: c.menuIcon,\n        overlayIcon: c.overlayIcon,\n        sourceIndex: i,\n        sticky: i < freezeColumns,\n        style: c.style,\n        themeOverride: c.themeOverride,\n        title: c.title,\n        trailingRowOptions: c.trailingRowOptions,\n        width: c.width,\n        growOffset: c.growOffset,\n        rowMarker: c.rowMarker,\n        rowMarkerChecked: c.rowMarkerChecked,\n    })), [columns, freezeColumns]);\n}\nfunction gridSelectionHasItem(sel, item) {\n    const [col, row] = item;\n    if (sel.columns.hasIndex(col) || sel.rows.hasIndex(row))\n        return true;\n    if (sel.current !== undefined) {\n        if (itemsAreEqual(sel.current.cell, item))\n            return true;\n        const toCheck = [sel.current.range, ...sel.current.rangeStack]; // FIXME: pointless alloc\n        for (const r of toCheck) {\n            // dont we have a function for this?\n            if (col >= r.x && col < r.x + r.width && row >= r.y && row < r.y + r.height)\n                return true;\n        }\n    }\n    return false;\n}\nfunction isGroupEqual(left, right) {\n    return (left ?? \"\") === (right ?? \"\");\n}\nfunction cellIsSelected(location, cell, selection) {\n    if (selection.current === undefined)\n        return false;\n    if (location[1] !== selection.current.cell[1])\n        return false;\n    if (cell.span === undefined) {\n        return selection.current.cell[0] === location[0];\n    }\n    return selection.current.cell[0] >= cell.span[0] && selection.current.cell[0] <= cell.span[1];\n}\nfunction itemIsInRect(location, rect) {\n    const [x, y] = location;\n    return x >= rect.x && x < rect.x + rect.width && y >= rect.y && y < rect.y + rect.height;\n}\nfunction itemsAreEqual(a, b) {\n    return a?.[0] === b?.[0] && a?.[1] === b?.[1];\n}\nfunction rectBottomRight(rect) {\n    return [rect.x + rect.width - 1, rect.y + rect.height - 1];\n}\nfunction cellIsInRect(location, cell, rect) {\n    const startX = rect.x;\n    const endX = rect.x + rect.width - 1;\n    const startY = rect.y;\n    const endY = rect.y + rect.height - 1;\n    const [cellCol, cellRow] = location;\n    if (cellRow < startY || cellRow > endY)\n        return false;\n    if (cell.span === undefined) {\n        return cellCol >= startX && cellCol <= endX;\n    }\n    const [spanStart, spanEnd] = cell.span;\n    return ((spanStart >= startX && spanStart <= endX) ||\n        (spanEnd >= startX && spanStart <= endX) ||\n        (spanStart < startX && spanEnd > endX));\n}\nfunction cellIsInRange(location, cell, selection, includeSingleSelection) {\n    let result = 0;\n    if (selection.current === undefined)\n        return result;\n    const range = selection.current.range;\n    if ((includeSingleSelection || range.height * range.width > 1) && cellIsInRect(location, cell, range)) {\n        result++;\n    }\n    for (const r of selection.current.rangeStack) {\n        if (cellIsInRect(location, cell, r)) {\n            result++;\n        }\n    }\n    return result;\n}\nfunction remapForDnDState(columns, dndState) {\n    let mappedCols = columns;\n    if (dndState !== undefined) {\n        let writable = [...columns];\n        const temp = mappedCols[dndState.src];\n        if (dndState.src > dndState.dest) {\n            writable.splice(dndState.src, 1);\n            writable.splice(dndState.dest, 0, temp);\n        }\n        else {\n            writable.splice(dndState.dest + 1, 0, temp);\n            writable.splice(dndState.src, 1);\n        }\n        writable = writable.map((c, i) => ({\n            ...c,\n            sticky: columns[i].sticky,\n        }));\n        mappedCols = writable;\n    }\n    return mappedCols;\n}\nfunction getStickyWidth(columns, dndState) {\n    let result = 0;\n    const remapped = remapForDnDState(columns, dndState);\n    for (let i = 0; i < remapped.length; i++) {\n        const c = remapped[i];\n        if (c.sticky)\n            result += c.width;\n        else\n            break;\n    }\n    return result;\n}\nfunction getFreezeTrailingHeight(rows, freezeTrailingRows, getRowHeight) {\n    if (typeof getRowHeight === \"number\") {\n        return freezeTrailingRows * getRowHeight;\n    }\n    else {\n        let result = 0;\n        for (let i = rows - freezeTrailingRows; i < rows; i++) {\n            result += getRowHeight(i);\n        }\n        return result;\n    }\n}\nfunction getEffectiveColumns(columns, cellXOffset, width, dndState, tx) {\n    const mappedCols = remapForDnDState(columns, dndState);\n    const sticky = [];\n    for (const c of mappedCols) {\n        if (c.sticky) {\n            sticky.push(c);\n        }\n        else {\n            break;\n        }\n    }\n    if (sticky.length > 0) {\n        for (const c of sticky) {\n            width -= c.width;\n        }\n    }\n    let endIndex = cellXOffset;\n    let curX = tx ?? 0;\n    while (curX <= width && endIndex < mappedCols.length) {\n        curX += mappedCols[endIndex].width;\n        endIndex++;\n    }\n    for (let i = cellXOffset; i < endIndex; i++) {\n        const c = mappedCols[i];\n        if (!c.sticky) {\n            sticky.push(c);\n        }\n    }\n    return sticky;\n}\nfunction getColumnIndexForX(targetX, effectiveColumns, translateX) {\n    let x = 0;\n    for (const c of effectiveColumns) {\n        const cx = c.sticky ? x : x + (translateX ?? 0);\n        if (targetX <= cx + c.width) {\n            return c.sourceIndex;\n        }\n        x += c.width;\n    }\n    return -1;\n}\nfunction getRowIndexForY(targetY, height, hasGroups, headerHeight, groupHeaderHeight, rows, rowHeight, cellYOffset, translateY, freezeTrailingRows) {\n    const totalHeaderHeight = headerHeight + groupHeaderHeight;\n    if (hasGroups && targetY <= groupHeaderHeight)\n        return -2;\n    if (targetY <= totalHeaderHeight)\n        return -1;\n    let y = height;\n    for (let fr = 0; fr < freezeTrailingRows; fr++) {\n        const row = rows - 1 - fr;\n        const rh = typeof rowHeight === \"number\" ? rowHeight : rowHeight(row);\n        y -= rh;\n        if (targetY >= y) {\n            return row;\n        }\n    }\n    const effectiveRows = rows - freezeTrailingRows;\n    const ty = targetY - (translateY ?? 0);\n    if (typeof rowHeight === \"number\") {\n        const target = Math.floor((ty - totalHeaderHeight) / rowHeight) + cellYOffset;\n        if (target >= effectiveRows)\n            return undefined;\n        return target;\n    }\n    else {\n        let curY = totalHeaderHeight;\n        for (let i = cellYOffset; i < effectiveRows; i++) {\n            const rh = rowHeight(i);\n            if (ty <= curY + rh)\n                return i;\n            curY += rh;\n        }\n        return undefined;\n    }\n}\nlet metricsSize = 0;\nlet metricsCache = {};\nconst isSSR = typeof window === \"undefined\";\nasync function clearCacheOnLoad() {\n    if (isSSR || document?.fonts?.ready === undefined)\n        return;\n    await document.fonts.ready;\n    metricsSize = 0;\n    metricsCache = {};\n    (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_1__.clearCache)();\n}\nvoid clearCacheOnLoad();\nfunction makeCacheKey(s, ctx, baseline, font) {\n    return `${s}_${font ?? ctx?.font}_${baseline}`;\n}\n/** @category Drawing */\nfunction measureTextCached(s, ctx, font, baseline = \"middle\") {\n    const key = makeCacheKey(s, ctx, baseline, font);\n    let metrics = metricsCache[key];\n    if (metrics === undefined) {\n        metrics = ctx.measureText(s);\n        metricsCache[key] = metrics;\n        metricsSize++;\n    }\n    if (metricsSize > 10000) {\n        metricsCache = {};\n        metricsSize = 0;\n    }\n    return metrics;\n}\nfunction getMeasuredTextCache(s, font) {\n    const key = makeCacheKey(s, undefined, \"middle\", font);\n    return metricsCache[key];\n}\n/** @category Drawing */\nfunction getMiddleCenterBias(ctx, font) {\n    if (typeof font !== \"string\") {\n        font = font.baseFontFull;\n    }\n    return getMiddleCenterBiasInner(ctx, font);\n}\nfunction loadMetric(ctx, baseline) {\n    const sample = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    ctx.save();\n    ctx.textBaseline = baseline;\n    const result = ctx.measureText(sample);\n    ctx.restore();\n    return result;\n}\nconst biasCache = [];\nfunction getMiddleCenterBiasInner(ctx, font) {\n    for (const x of biasCache) {\n        if (x.key === font)\n            return x.val;\n    }\n    const alphabeticMetrics = loadMetric(ctx, \"alphabetic\");\n    const middleMetrics = loadMetric(ctx, \"middle\");\n    const bias = -(middleMetrics.actualBoundingBoxDescent - alphabeticMetrics.actualBoundingBoxDescent) +\n        alphabeticMetrics.actualBoundingBoxAscent / 2;\n    biasCache.push({\n        key: font,\n        val: bias,\n    });\n    return bias;\n}\nfunction drawLastUpdateUnderlay(args, lastUpdate, frameTime, lastPrep, isLastCol, isLastRow) {\n    const { ctx, rect, theme } = args;\n    let progress = Number.MAX_SAFE_INTEGER;\n    const animTime = 500;\n    if (lastUpdate !== undefined) {\n        progress = frameTime - lastUpdate;\n        if (progress < animTime) {\n            const fade = 1 - progress / animTime;\n            ctx.globalAlpha = fade;\n            ctx.fillStyle = theme.bgSearchResult;\n            ctx.fillRect(rect.x + 1, rect.y + 1, rect.width - (isLastCol ? 2 : 1), rect.height - (isLastRow ? 2 : 1));\n            ctx.globalAlpha = 1;\n            if (lastPrep !== undefined) {\n                lastPrep.fillStyle = theme.bgSearchResult;\n            }\n        }\n    }\n    return progress < animTime;\n}\nfunction prepTextCell(args, lastPrep, overrideColor) {\n    const { ctx, theme } = args;\n    const result = lastPrep ?? {};\n    const newFill = overrideColor ?? theme.textDark;\n    if (newFill !== result.fillStyle) {\n        ctx.fillStyle = newFill;\n        result.fillStyle = newFill;\n    }\n    return result;\n}\n/** @category Drawing */\nfunction drawTextCellExternal(args, data, contentAlign) {\n    const { rect, ctx, theme } = args;\n    ctx.fillStyle = theme.textDark;\n    drawTextCell({\n        ctx: ctx,\n        rect,\n        theme: theme,\n    }, data, contentAlign);\n}\nfunction drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign) {\n    if (contentAlign === \"right\") {\n        ctx.fillText(data, x + w - (theme.cellHorizontalPadding + 0.5), y + h / 2 + bias);\n    }\n    else if (contentAlign === \"center\") {\n        ctx.fillText(data, x + w / 2, y + h / 2 + bias);\n    }\n    else {\n        ctx.fillText(data, x + theme.cellHorizontalPadding + 0.5, y + h / 2 + bias);\n    }\n}\nfunction getEmHeight(ctx, fontStyle) {\n    const textMetrics = measureTextCached(\"ABCi09jgqpy\", ctx, fontStyle); // do not question the magic string\n    return textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent;\n}\nfunction truncateString(data, w) {\n    if (data.includes(\"\\n\")) {\n        // new lines are rare and split is relatively expensive compared to the search\n        // it pays off to not do the split contantly. More accurately... it pays off not to run the regex.\n        // what even is the point of this? So what if there is a /r at the end of a line? It wont be drawn anyway.\n        data = data.split(/\\r?\\n/, 1)[0];\n    }\n    const max = w / 4; // no need to round, slice will just truncate this\n    if (data.length > max) {\n        data = data.slice(0, max);\n    }\n    return data;\n}\nfunction drawMultiLineText(ctx, data, x, y, w, h, bias, theme, contentAlign, hyperWrapping) {\n    const fontStyle = theme.baseFontFull;\n    const split = (0,canvas_hypertxt__WEBPACK_IMPORTED_MODULE_1__.split)(ctx, data, fontStyle, w - theme.cellHorizontalPadding * 2, hyperWrapping ?? false);\n    const emHeight = getEmHeight(ctx, fontStyle);\n    const lineHeight = theme.lineHeight * emHeight;\n    const actualHeight = emHeight + lineHeight * (split.length - 1);\n    const mustClip = actualHeight + theme.cellVerticalPadding > h;\n    if (mustClip) {\n        // well now we have to clip because we might render outside the cell vertically\n        ctx.save();\n        ctx.rect(x, y, w, h);\n        ctx.clip();\n    }\n    const optimalY = y + h / 2 - actualHeight / 2;\n    let drawY = Math.max(y + theme.cellVerticalPadding, optimalY);\n    for (const line of split) {\n        drawSingleTextLine(ctx, line, x, drawY, w, emHeight, bias, theme, contentAlign);\n        drawY += lineHeight;\n        if (drawY > y + h)\n            break;\n    }\n    if (mustClip) {\n        ctx.restore();\n    }\n}\n/** @category Drawing */\nfunction drawTextCell(args, data, contentAlign, allowWrapping, hyperWrapping) {\n    const { ctx, rect, theme } = args;\n    const { x, y, width: w, height: h } = rect;\n    allowWrapping = allowWrapping ?? false;\n    if (!allowWrapping) {\n        data = truncateString(data, w);\n    }\n    const bias = getMiddleCenterBias(ctx, theme);\n    const isRtl = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_2__.direction)(data) === \"rtl\";\n    if (contentAlign === undefined && isRtl) {\n        contentAlign = \"right\";\n    }\n    if (isRtl) {\n        ctx.direction = \"rtl\";\n    }\n    if (data.length > 0) {\n        let changed = false;\n        if (contentAlign === \"right\") {\n            // Use right alignment as default for RTL text\n            ctx.textAlign = \"right\";\n            changed = true;\n        }\n        else if (contentAlign !== undefined && contentAlign !== \"left\") {\n            // Since default is start (=left), only apply if alignment is center or right\n            ctx.textAlign = contentAlign;\n            changed = true;\n        }\n        if (!allowWrapping) {\n            drawSingleTextLine(ctx, data, x, y, w, h, bias, theme, contentAlign);\n        }\n        else {\n            drawMultiLineText(ctx, data, x, y, w, h, bias, theme, contentAlign, hyperWrapping);\n        }\n        if (changed) {\n            // Reset alignment to default\n            ctx.textAlign = \"start\";\n        }\n        if (isRtl) {\n            ctx.direction = \"inherit\";\n        }\n    }\n}\nfunction roundedRect(ctx, x, y, width, height, radius) {\n    if (typeof radius === \"number\") {\n        radius = { tl: radius, tr: radius, br: radius, bl: radius };\n    }\n    // restrict radius to a reasonable max\n    radius = {\n        tl: Math.max(0, Math.min(radius.tl, height / 2, width / 2)),\n        tr: Math.max(0, Math.min(radius.tr, height / 2, width / 2)),\n        bl: Math.max(0, Math.min(radius.bl, height / 2, width / 2)),\n        br: Math.max(0, Math.min(radius.br, height / 2, width / 2)),\n    };\n    ctx.moveTo(x + radius.tl, y);\n    ctx.arcTo(x + width, y, x + width, y + radius.tr, radius.tr);\n    ctx.arcTo(x + width, y + height, x + width - radius.br, y + height, radius.br);\n    ctx.arcTo(x, y + height, x, y + height - radius.bl, radius.bl);\n    ctx.arcTo(x, y, x + radius.tl, y, radius.tl);\n}\nfunction drawMenuDots(ctx, dotsX, dotsY) {\n    const radius = 1.25;\n    ctx.arc(dotsX, dotsY - radius * 3.5, radius, 0, 2 * Math.PI, false);\n    ctx.arc(dotsX, dotsY, radius, 0, 2 * Math.PI, false);\n    ctx.arc(dotsX, dotsY + radius * 3.5, radius, 0, 2 * Math.PI, false);\n}\nfunction roundedPoly(ctx, points, radiusAll) {\n    // convert 2 points into vector form, polar form, and normalised\n    const asVec = function (p, pp) {\n        const vx = pp.x - p.x;\n        const vy = pp.y - p.y;\n        const vlen = Math.sqrt(vx * vx + vy * vy);\n        const vnx = vx / vlen;\n        const vny = vy / vlen;\n        return {\n            x: vx,\n            y: pp.y - p.y,\n            len: vlen,\n            nx: vnx,\n            ny: vny,\n            ang: Math.atan2(vny, vnx),\n        };\n    };\n    let radius;\n    // const v1: Vector = {} as any;\n    // const v2: Vector = {} as any;\n    const len = points.length;\n    let p1 = points[len - 1];\n    // for each point\n    for (let i = 0; i < len; i++) {\n        let p2 = points[i % len];\n        const p3 = points[(i + 1) % len];\n        //-----------------------------------------\n        // Part 1\n        const v1 = asVec(p2, p1);\n        const v2 = asVec(p2, p3);\n        const sinA = v1.nx * v2.ny - v1.ny * v2.nx;\n        const sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;\n        let angle = Math.asin(sinA < -1 ? -1 : sinA > 1 ? 1 : sinA);\n        //-----------------------------------------\n        let radDirection = 1;\n        let drawDirection = false;\n        if (sinA90 < 0) {\n            if (angle < 0) {\n                angle = Math.PI + angle;\n            }\n            else {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else {\n            if (angle > 0) {\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        radius = p2.radius !== undefined ? p2.radius : radiusAll;\n        //-----------------------------------------\n        // Part 2\n        const halfAngle = angle / 2;\n        //-----------------------------------------\n        //-----------------------------------------\n        // Part 3\n        let lenOut = Math.abs((Math.cos(halfAngle) * radius) / Math.sin(halfAngle));\n        //-----------------------------------------\n        //-----------------------------------------\n        // Special part A\n        let cRadius;\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else {\n            cRadius = radius;\n        }\n        //-----------------------------------------\n        // Part 4\n        let x = p2.x + v2.nx * lenOut;\n        let y = p2.y + v2.ny * lenOut;\n        //-----------------------------------------\n        // Part 5\n        x += -v2.ny * cRadius * radDirection;\n        y += v2.nx * cRadius * radDirection;\n        //-----------------------------------------\n        // Part 6\n        ctx.arc(x, y, cRadius, v1.ang + (Math.PI / 2) * radDirection, v2.ang - (Math.PI / 2) * radDirection, drawDirection);\n        //-----------------------------------------\n        p1 = p2;\n        p2 = p3;\n    }\n    ctx.closePath();\n}\nfunction computeBounds(col, row, width, height, groupHeaderHeight, totalHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, freezeTrailingRows, mappedColumns, rowHeight) {\n    const result = {\n        x: 0,\n        y: totalHeaderHeight + translateY,\n        width: 0,\n        height: 0,\n    };\n    if (col >= mappedColumns.length || row >= rows || row < -2 || col < 0) {\n        return result;\n    }\n    const headerHeight = totalHeaderHeight - groupHeaderHeight;\n    if (col >= freezeColumns) {\n        const dir = cellXOffset > col ? -1 : 1;\n        const freezeWidth = getStickyWidth(mappedColumns);\n        result.x += freezeWidth + translateX;\n        for (let i = cellXOffset; i !== col; i += dir) {\n            result.x += mappedColumns[dir === 1 ? i : i - 1].width * dir;\n        }\n    }\n    else {\n        for (let i = 0; i < col; i++) {\n            result.x += mappedColumns[i].width;\n        }\n    }\n    result.width = mappedColumns[col].width + 1;\n    if (row === -1) {\n        result.y = groupHeaderHeight;\n        result.height = headerHeight;\n    }\n    else if (row === -2) {\n        result.y = 0;\n        result.height = groupHeaderHeight;\n        let start = col;\n        const group = mappedColumns[col].group;\n        const sticky = mappedColumns[col].sticky;\n        while (start > 0 &&\n            isGroupEqual(mappedColumns[start - 1].group, group) &&\n            mappedColumns[start - 1].sticky === sticky) {\n            const c = mappedColumns[start - 1];\n            result.x -= c.width;\n            result.width += c.width;\n            start--;\n        }\n        let end = col;\n        while (end + 1 < mappedColumns.length &&\n            isGroupEqual(mappedColumns[end + 1].group, group) &&\n            mappedColumns[end + 1].sticky === sticky) {\n            const c = mappedColumns[end + 1];\n            result.width += c.width;\n            end++;\n        }\n        if (!sticky) {\n            const freezeWidth = getStickyWidth(mappedColumns);\n            const clip = result.x - freezeWidth;\n            if (clip < 0) {\n                result.x -= clip;\n                result.width += clip;\n            }\n            if (result.x + result.width > width) {\n                result.width = width - result.x;\n            }\n        }\n    }\n    else if (row >= rows - freezeTrailingRows) {\n        let dy = rows - row;\n        result.y = height;\n        while (dy > 0) {\n            const r = row + dy - 1;\n            result.height = typeof rowHeight === \"number\" ? rowHeight : rowHeight(r);\n            result.y -= result.height;\n            dy--;\n        }\n        result.height += 1;\n    }\n    else {\n        const dir = cellYOffset > row ? -1 : 1;\n        if (typeof rowHeight === \"number\") {\n            const delta = row - cellYOffset;\n            result.y += delta * rowHeight;\n        }\n        else {\n            for (let r = cellYOffset; r !== row; r += dir) {\n                result.y += rowHeight(r) * dir;\n            }\n        }\n        result.height = (typeof rowHeight === \"number\" ? rowHeight : rowHeight(row)) + 1;\n    }\n    return result;\n}\n//# sourceMappingURL=data-grid-lib.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtbGliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ2M7QUFDM0I7QUFDdUM7QUFDMUQ7QUFDUCxXQUFXLDBDQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMkRBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUUsR0FBRyxrQkFBa0IsR0FBRyxTQUFTO0FBQ2pEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLG1CQUFtQjtBQUMvQixZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJEQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RhdGEtZ3JpZC1saWIuanM/OWFhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge30gZnJvbSBcIi4uL2RhdGEtZ3JpZC10eXBlcy5qc1wiO1xuaW1wb3J0IHsgZGlyZWN0aW9uIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi91dGlscy5qc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgc3BsaXQgYXMgc3BsaXRUZXh0LCBjbGVhckNhY2hlIH0gZnJvbSBcImNhbnZhcy1oeXBlcnR4dFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hcHBlZENvbHVtbnMoY29sdW1ucywgZnJlZXplQ29sdW1ucykge1xuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGNvbHVtbnMubWFwKChjLCBpKSA9PiAoe1xuICAgICAgICBncm91cDogYy5ncm91cCxcbiAgICAgICAgZ3JvdzogYy5ncm93LFxuICAgICAgICBoYXNNZW51OiBjLmhhc01lbnUsXG4gICAgICAgIGljb246IGMuaWNvbixcbiAgICAgICAgaWQ6IGMuaWQsXG4gICAgICAgIG1lbnVJY29uOiBjLm1lbnVJY29uLFxuICAgICAgICBvdmVybGF5SWNvbjogYy5vdmVybGF5SWNvbixcbiAgICAgICAgc291cmNlSW5kZXg6IGksXG4gICAgICAgIHN0aWNreTogaSA8IGZyZWV6ZUNvbHVtbnMsXG4gICAgICAgIHN0eWxlOiBjLnN0eWxlLFxuICAgICAgICB0aGVtZU92ZXJyaWRlOiBjLnRoZW1lT3ZlcnJpZGUsXG4gICAgICAgIHRpdGxlOiBjLnRpdGxlLFxuICAgICAgICB0cmFpbGluZ1Jvd09wdGlvbnM6IGMudHJhaWxpbmdSb3dPcHRpb25zLFxuICAgICAgICB3aWR0aDogYy53aWR0aCxcbiAgICAgICAgZ3Jvd09mZnNldDogYy5ncm93T2Zmc2V0LFxuICAgICAgICByb3dNYXJrZXI6IGMucm93TWFya2VyLFxuICAgICAgICByb3dNYXJrZXJDaGVja2VkOiBjLnJvd01hcmtlckNoZWNrZWQsXG4gICAgfSkpLCBbY29sdW1ucywgZnJlZXplQ29sdW1uc10pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdyaWRTZWxlY3Rpb25IYXNJdGVtKHNlbCwgaXRlbSkge1xuICAgIGNvbnN0IFtjb2wsIHJvd10gPSBpdGVtO1xuICAgIGlmIChzZWwuY29sdW1ucy5oYXNJbmRleChjb2wpIHx8IHNlbC5yb3dzLmhhc0luZGV4KHJvdykpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChzZWwuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpdGVtc0FyZUVxdWFsKHNlbC5jdXJyZW50LmNlbGwsIGl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHRvQ2hlY2sgPSBbc2VsLmN1cnJlbnQucmFuZ2UsIC4uLnNlbC5jdXJyZW50LnJhbmdlU3RhY2tdOyAvLyBGSVhNRTogcG9pbnRsZXNzIGFsbG9jXG4gICAgICAgIGZvciAoY29uc3QgciBvZiB0b0NoZWNrKSB7XG4gICAgICAgICAgICAvLyBkb250IHdlIGhhdmUgYSBmdW5jdGlvbiBmb3IgdGhpcz9cbiAgICAgICAgICAgIGlmIChjb2wgPj0gci54ICYmIGNvbCA8IHIueCArIHIud2lkdGggJiYgcm93ID49IHIueSAmJiByb3cgPCByLnkgKyByLmhlaWdodClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNHcm91cEVxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIChsZWZ0ID8/IFwiXCIpID09PSAocmlnaHQgPz8gXCJcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gY2VsbElzU2VsZWN0ZWQobG9jYXRpb24sIGNlbGwsIHNlbGVjdGlvbikge1xuICAgIGlmIChzZWxlY3Rpb24uY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGxvY2F0aW9uWzFdICE9PSBzZWxlY3Rpb24uY3VycmVudC5jZWxsWzFdKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNlbGwuc3BhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb24uY3VycmVudC5jZWxsWzBdID09PSBsb2NhdGlvblswXTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbi5jdXJyZW50LmNlbGxbMF0gPj0gY2VsbC5zcGFuWzBdICYmIHNlbGVjdGlvbi5jdXJyZW50LmNlbGxbMF0gPD0gY2VsbC5zcGFuWzFdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGl0ZW1Jc0luUmVjdChsb2NhdGlvbiwgcmVjdCkge1xuICAgIGNvbnN0IFt4LCB5XSA9IGxvY2F0aW9uO1xuICAgIHJldHVybiB4ID49IHJlY3QueCAmJiB4IDwgcmVjdC54ICsgcmVjdC53aWR0aCAmJiB5ID49IHJlY3QueSAmJiB5IDwgcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXRlbXNBcmVFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGE/LlswXSA9PT0gYj8uWzBdICYmIGE/LlsxXSA9PT0gYj8uWzFdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RCb3R0b21SaWdodChyZWN0KSB7XG4gICAgcmV0dXJuIFtyZWN0LnggKyByZWN0LndpZHRoIC0gMSwgcmVjdC55ICsgcmVjdC5oZWlnaHQgLSAxXTtcbn1cbmZ1bmN0aW9uIGNlbGxJc0luUmVjdChsb2NhdGlvbiwgY2VsbCwgcmVjdCkge1xuICAgIGNvbnN0IHN0YXJ0WCA9IHJlY3QueDtcbiAgICBjb25zdCBlbmRYID0gcmVjdC54ICsgcmVjdC53aWR0aCAtIDE7XG4gICAgY29uc3Qgc3RhcnRZID0gcmVjdC55O1xuICAgIGNvbnN0IGVuZFkgPSByZWN0LnkgKyByZWN0LmhlaWdodCAtIDE7XG4gICAgY29uc3QgW2NlbGxDb2wsIGNlbGxSb3ddID0gbG9jYXRpb247XG4gICAgaWYgKGNlbGxSb3cgPCBzdGFydFkgfHwgY2VsbFJvdyA+IGVuZFkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY2VsbC5zcGFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNlbGxDb2wgPj0gc3RhcnRYICYmIGNlbGxDb2wgPD0gZW5kWDtcbiAgICB9XG4gICAgY29uc3QgW3NwYW5TdGFydCwgc3BhbkVuZF0gPSBjZWxsLnNwYW47XG4gICAgcmV0dXJuICgoc3BhblN0YXJ0ID49IHN0YXJ0WCAmJiBzcGFuU3RhcnQgPD0gZW5kWCkgfHxcbiAgICAgICAgKHNwYW5FbmQgPj0gc3RhcnRYICYmIHNwYW5TdGFydCA8PSBlbmRYKSB8fFxuICAgICAgICAoc3BhblN0YXJ0IDwgc3RhcnRYICYmIHNwYW5FbmQgPiBlbmRYKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2VsbElzSW5SYW5nZShsb2NhdGlvbiwgY2VsbCwgc2VsZWN0aW9uLCBpbmNsdWRlU2luZ2xlU2VsZWN0aW9uKSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgaWYgKHNlbGVjdGlvbi5jdXJyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uY3VycmVudC5yYW5nZTtcbiAgICBpZiAoKGluY2x1ZGVTaW5nbGVTZWxlY3Rpb24gfHwgcmFuZ2UuaGVpZ2h0ICogcmFuZ2Uud2lkdGggPiAxKSAmJiBjZWxsSXNJblJlY3QobG9jYXRpb24sIGNlbGwsIHJhbmdlKSkge1xuICAgICAgICByZXN1bHQrKztcbiAgICB9XG4gICAgZm9yIChjb25zdCByIG9mIHNlbGVjdGlvbi5jdXJyZW50LnJhbmdlU3RhY2spIHtcbiAgICAgICAgaWYgKGNlbGxJc0luUmVjdChsb2NhdGlvbiwgY2VsbCwgcikpIHtcbiAgICAgICAgICAgIHJlc3VsdCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVtYXBGb3JEbkRTdGF0ZShjb2x1bW5zLCBkbmRTdGF0ZSkge1xuICAgIGxldCBtYXBwZWRDb2xzID0gY29sdW1ucztcbiAgICBpZiAoZG5kU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgd3JpdGFibGUgPSBbLi4uY29sdW1uc107XG4gICAgICAgIGNvbnN0IHRlbXAgPSBtYXBwZWRDb2xzW2RuZFN0YXRlLnNyY107XG4gICAgICAgIGlmIChkbmRTdGF0ZS5zcmMgPiBkbmRTdGF0ZS5kZXN0KSB7XG4gICAgICAgICAgICB3cml0YWJsZS5zcGxpY2UoZG5kU3RhdGUuc3JjLCAxKTtcbiAgICAgICAgICAgIHdyaXRhYmxlLnNwbGljZShkbmRTdGF0ZS5kZXN0LCAwLCB0ZW1wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRhYmxlLnNwbGljZShkbmRTdGF0ZS5kZXN0ICsgMSwgMCwgdGVtcCk7XG4gICAgICAgICAgICB3cml0YWJsZS5zcGxpY2UoZG5kU3RhdGUuc3JjLCAxKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0YWJsZSA9IHdyaXRhYmxlLm1hcCgoYywgaSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBzdGlja3k6IGNvbHVtbnNbaV0uc3RpY2t5LFxuICAgICAgICB9KSk7XG4gICAgICAgIG1hcHBlZENvbHMgPSB3cml0YWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZENvbHM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RpY2t5V2lkdGgoY29sdW1ucywgZG5kU3RhdGUpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBjb25zdCByZW1hcHBlZCA9IHJlbWFwRm9yRG5EU3RhdGUoY29sdW1ucywgZG5kU3RhdGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtYXBwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHJlbWFwcGVkW2ldO1xuICAgICAgICBpZiAoYy5zdGlja3kpXG4gICAgICAgICAgICByZXN1bHQgKz0gYy53aWR0aDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJlZXplVHJhaWxpbmdIZWlnaHQocm93cywgZnJlZXplVHJhaWxpbmdSb3dzLCBnZXRSb3dIZWlnaHQpIHtcbiAgICBpZiAodHlwZW9mIGdldFJvd0hlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZnJlZXplVHJhaWxpbmdSb3dzICogZ2V0Um93SGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSByb3dzIC0gZnJlZXplVHJhaWxpbmdSb3dzOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gZ2V0Um93SGVpZ2h0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVmZmVjdGl2ZUNvbHVtbnMoY29sdW1ucywgY2VsbFhPZmZzZXQsIHdpZHRoLCBkbmRTdGF0ZSwgdHgpIHtcbiAgICBjb25zdCBtYXBwZWRDb2xzID0gcmVtYXBGb3JEbkRTdGF0ZShjb2x1bW5zLCBkbmRTdGF0ZSk7XG4gICAgY29uc3Qgc3RpY2t5ID0gW107XG4gICAgZm9yIChjb25zdCBjIG9mIG1hcHBlZENvbHMpIHtcbiAgICAgICAgaWYgKGMuc3RpY2t5KSB7XG4gICAgICAgICAgICBzdGlja3kucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGlja3kubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc3RpY2t5KSB7XG4gICAgICAgICAgICB3aWR0aCAtPSBjLndpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBlbmRJbmRleCA9IGNlbGxYT2Zmc2V0O1xuICAgIGxldCBjdXJYID0gdHggPz8gMDtcbiAgICB3aGlsZSAoY3VyWCA8PSB3aWR0aCAmJiBlbmRJbmRleCA8IG1hcHBlZENvbHMubGVuZ3RoKSB7XG4gICAgICAgIGN1clggKz0gbWFwcGVkQ29sc1tlbmRJbmRleF0ud2lkdGg7XG4gICAgICAgIGVuZEluZGV4Kys7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBjZWxsWE9mZnNldDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IG1hcHBlZENvbHNbaV07XG4gICAgICAgIGlmICghYy5zdGlja3kpIHtcbiAgICAgICAgICAgIHN0aWNreS5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGlja3k7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sdW1uSW5kZXhGb3JYKHRhcmdldFgsIGVmZmVjdGl2ZUNvbHVtbnMsIHRyYW5zbGF0ZVgpIHtcbiAgICBsZXQgeCA9IDA7XG4gICAgZm9yIChjb25zdCBjIG9mIGVmZmVjdGl2ZUNvbHVtbnMpIHtcbiAgICAgICAgY29uc3QgY3ggPSBjLnN0aWNreSA/IHggOiB4ICsgKHRyYW5zbGF0ZVggPz8gMCk7XG4gICAgICAgIGlmICh0YXJnZXRYIDw9IGN4ICsgYy53aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuc291cmNlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgeCArPSBjLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Um93SW5kZXhGb3JZKHRhcmdldFksIGhlaWdodCwgaGFzR3JvdXBzLCBoZWFkZXJIZWlnaHQsIGdyb3VwSGVhZGVySGVpZ2h0LCByb3dzLCByb3dIZWlnaHQsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVZLCBmcmVlemVUcmFpbGluZ1Jvd3MpIHtcbiAgICBjb25zdCB0b3RhbEhlYWRlckhlaWdodCA9IGhlYWRlckhlaWdodCArIGdyb3VwSGVhZGVySGVpZ2h0O1xuICAgIGlmIChoYXNHcm91cHMgJiYgdGFyZ2V0WSA8PSBncm91cEhlYWRlckhlaWdodClcbiAgICAgICAgcmV0dXJuIC0yO1xuICAgIGlmICh0YXJnZXRZIDw9IHRvdGFsSGVhZGVySGVpZ2h0KVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IHkgPSBoZWlnaHQ7XG4gICAgZm9yIChsZXQgZnIgPSAwOyBmciA8IGZyZWV6ZVRyYWlsaW5nUm93czsgZnIrKykge1xuICAgICAgICBjb25zdCByb3cgPSByb3dzIC0gMSAtIGZyO1xuICAgICAgICBjb25zdCByaCA9IHR5cGVvZiByb3dIZWlnaHQgPT09IFwibnVtYmVyXCIgPyByb3dIZWlnaHQgOiByb3dIZWlnaHQocm93KTtcbiAgICAgICAgeSAtPSByaDtcbiAgICAgICAgaWYgKHRhcmdldFkgPj0geSkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZmZlY3RpdmVSb3dzID0gcm93cyAtIGZyZWV6ZVRyYWlsaW5nUm93cztcbiAgICBjb25zdCB0eSA9IHRhcmdldFkgLSAodHJhbnNsYXRlWSA/PyAwKTtcbiAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBNYXRoLmZsb29yKCh0eSAtIHRvdGFsSGVhZGVySGVpZ2h0KSAvIHJvd0hlaWdodCkgKyBjZWxsWU9mZnNldDtcbiAgICAgICAgaWYgKHRhcmdldCA+PSBlZmZlY3RpdmVSb3dzKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBjdXJZID0gdG90YWxIZWFkZXJIZWlnaHQ7XG4gICAgICAgIGZvciAobGV0IGkgPSBjZWxsWU9mZnNldDsgaSA8IGVmZmVjdGl2ZVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmggPSByb3dIZWlnaHQoaSk7XG4gICAgICAgICAgICBpZiAodHkgPD0gY3VyWSArIHJoKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgY3VyWSArPSByaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmxldCBtZXRyaWNzU2l6ZSA9IDA7XG5sZXQgbWV0cmljc0NhY2hlID0ge307XG5jb25zdCBpc1NTUiA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCI7XG5hc3luYyBmdW5jdGlvbiBjbGVhckNhY2hlT25Mb2FkKCkge1xuICAgIGlmIChpc1NTUiB8fCBkb2N1bWVudD8uZm9udHM/LnJlYWR5ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBhd2FpdCBkb2N1bWVudC5mb250cy5yZWFkeTtcbiAgICBtZXRyaWNzU2l6ZSA9IDA7XG4gICAgbWV0cmljc0NhY2hlID0ge307XG4gICAgY2xlYXJDYWNoZSgpO1xufVxudm9pZCBjbGVhckNhY2hlT25Mb2FkKCk7XG5mdW5jdGlvbiBtYWtlQ2FjaGVLZXkocywgY3R4LCBiYXNlbGluZSwgZm9udCkge1xuICAgIHJldHVybiBgJHtzfV8ke2ZvbnQgPz8gY3R4Py5mb250fV8ke2Jhc2VsaW5lfWA7XG59XG4vKiogQGNhdGVnb3J5IERyYXdpbmcgKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlVGV4dENhY2hlZChzLCBjdHgsIGZvbnQsIGJhc2VsaW5lID0gXCJtaWRkbGVcIikge1xuICAgIGNvbnN0IGtleSA9IG1ha2VDYWNoZUtleShzLCBjdHgsIGJhc2VsaW5lLCBmb250KTtcbiAgICBsZXQgbWV0cmljcyA9IG1ldHJpY3NDYWNoZVtrZXldO1xuICAgIGlmIChtZXRyaWNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChzKTtcbiAgICAgICAgbWV0cmljc0NhY2hlW2tleV0gPSBtZXRyaWNzO1xuICAgICAgICBtZXRyaWNzU2l6ZSsrO1xuICAgIH1cbiAgICBpZiAobWV0cmljc1NpemUgPiAxMDAwMCkge1xuICAgICAgICBtZXRyaWNzQ2FjaGUgPSB7fTtcbiAgICAgICAgbWV0cmljc1NpemUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWV0cmljcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZWFzdXJlZFRleHRDYWNoZShzLCBmb250KSB7XG4gICAgY29uc3Qga2V5ID0gbWFrZUNhY2hlS2V5KHMsIHVuZGVmaW5lZCwgXCJtaWRkbGVcIiwgZm9udCk7XG4gICAgcmV0dXJuIG1ldHJpY3NDYWNoZVtrZXldO1xufVxuLyoqIEBjYXRlZ29yeSBEcmF3aW5nICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWlkZGxlQ2VudGVyQmlhcyhjdHgsIGZvbnQpIHtcbiAgICBpZiAodHlwZW9mIGZvbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9udCA9IGZvbnQuYmFzZUZvbnRGdWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TWlkZGxlQ2VudGVyQmlhc0lubmVyKGN0eCwgZm9udCk7XG59XG5mdW5jdGlvbiBsb2FkTWV0cmljKGN0eCwgYmFzZWxpbmUpIHtcbiAgICBjb25zdCBzYW1wbGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmU7XG4gICAgY29uc3QgcmVzdWx0ID0gY3R4Lm1lYXN1cmVUZXh0KHNhbXBsZSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgYmlhc0NhY2hlID0gW107XG5mdW5jdGlvbiBnZXRNaWRkbGVDZW50ZXJCaWFzSW5uZXIoY3R4LCBmb250KSB7XG4gICAgZm9yIChjb25zdCB4IG9mIGJpYXNDYWNoZSkge1xuICAgICAgICBpZiAoeC5rZXkgPT09IGZvbnQpXG4gICAgICAgICAgICByZXR1cm4geC52YWw7XG4gICAgfVxuICAgIGNvbnN0IGFscGhhYmV0aWNNZXRyaWNzID0gbG9hZE1ldHJpYyhjdHgsIFwiYWxwaGFiZXRpY1wiKTtcbiAgICBjb25zdCBtaWRkbGVNZXRyaWNzID0gbG9hZE1ldHJpYyhjdHgsIFwibWlkZGxlXCIpO1xuICAgIGNvbnN0IGJpYXMgPSAtKG1pZGRsZU1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IC0gYWxwaGFiZXRpY01ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50KSArXG4gICAgICAgIGFscGhhYmV0aWNNZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50IC8gMjtcbiAgICBiaWFzQ2FjaGUucHVzaCh7XG4gICAgICAgIGtleTogZm9udCxcbiAgICAgICAgdmFsOiBiaWFzLFxuICAgIH0pO1xuICAgIHJldHVybiBiaWFzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdMYXN0VXBkYXRlVW5kZXJsYXkoYXJncywgbGFzdFVwZGF0ZSwgZnJhbWVUaW1lLCBsYXN0UHJlcCwgaXNMYXN0Q29sLCBpc0xhc3RSb3cpIHtcbiAgICBjb25zdCB7IGN0eCwgcmVjdCwgdGhlbWUgfSA9IGFyZ3M7XG4gICAgbGV0IHByb2dyZXNzID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgY29uc3QgYW5pbVRpbWUgPSA1MDA7XG4gICAgaWYgKGxhc3RVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9ncmVzcyA9IGZyYW1lVGltZSAtIGxhc3RVcGRhdGU7XG4gICAgICAgIGlmIChwcm9ncmVzcyA8IGFuaW1UaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBmYWRlID0gMSAtIHByb2dyZXNzIC8gYW5pbVRpbWU7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBmYWRlO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lLmJnU2VhcmNoUmVzdWx0O1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHJlY3QueCArIDEsIHJlY3QueSArIDEsIHJlY3Qud2lkdGggLSAoaXNMYXN0Q29sID8gMiA6IDEpLCByZWN0LmhlaWdodCAtIChpc0xhc3RSb3cgPyAyIDogMSkpO1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0UHJlcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGFzdFByZXAuZmlsbFN0eWxlID0gdGhlbWUuYmdTZWFyY2hSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb2dyZXNzIDwgYW5pbVRpbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJlcFRleHRDZWxsKGFyZ3MsIGxhc3RQcmVwLCBvdmVycmlkZUNvbG9yKSB7XG4gICAgY29uc3QgeyBjdHgsIHRoZW1lIH0gPSBhcmdzO1xuICAgIGNvbnN0IHJlc3VsdCA9IGxhc3RQcmVwID8/IHt9O1xuICAgIGNvbnN0IG5ld0ZpbGwgPSBvdmVycmlkZUNvbG9yID8/IHRoZW1lLnRleHREYXJrO1xuICAgIGlmIChuZXdGaWxsICE9PSByZXN1bHQuZmlsbFN0eWxlKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBuZXdGaWxsO1xuICAgICAgICByZXN1bHQuZmlsbFN0eWxlID0gbmV3RmlsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAY2F0ZWdvcnkgRHJhd2luZyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdUZXh0Q2VsbEV4dGVybmFsKGFyZ3MsIGRhdGEsIGNvbnRlbnRBbGlnbikge1xuICAgIGNvbnN0IHsgcmVjdCwgY3R4LCB0aGVtZSB9ID0gYXJncztcbiAgICBjdHguZmlsbFN0eWxlID0gdGhlbWUudGV4dERhcms7XG4gICAgZHJhd1RleHRDZWxsKHtcbiAgICAgICAgY3R4OiBjdHgsXG4gICAgICAgIHJlY3QsXG4gICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICB9LCBkYXRhLCBjb250ZW50QWxpZ24pO1xufVxuZnVuY3Rpb24gZHJhd1NpbmdsZVRleHRMaW5lKGN0eCwgZGF0YSwgeCwgeSwgdywgaCwgYmlhcywgdGhlbWUsIGNvbnRlbnRBbGlnbikge1xuICAgIGlmIChjb250ZW50QWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICBjdHguZmlsbFRleHQoZGF0YSwgeCArIHcgLSAodGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nICsgMC41KSwgeSArIGggLyAyICsgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRlbnRBbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICBjdHguZmlsbFRleHQoZGF0YSwgeCArIHcgLyAyLCB5ICsgaCAvIDIgKyBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChkYXRhLCB4ICsgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nICsgMC41LCB5ICsgaCAvIDIgKyBiaWFzKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW1IZWlnaHQoY3R4LCBmb250U3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0TWV0cmljcyA9IG1lYXN1cmVUZXh0Q2FjaGVkKFwiQUJDaTA5amdxcHlcIiwgY3R4LCBmb250U3R5bGUpOyAvLyBkbyBub3QgcXVlc3Rpb24gdGhlIG1hZ2ljIHN0cmluZ1xuICAgIHJldHVybiB0ZXh0TWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIHRleHRNZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbn1cbmZ1bmN0aW9uIHRydW5jYXRlU3RyaW5nKGRhdGEsIHcpIHtcbiAgICBpZiAoZGF0YS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAvLyBuZXcgbGluZXMgYXJlIHJhcmUgYW5kIHNwbGl0IGlzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGNvbXBhcmVkIHRvIHRoZSBzZWFyY2hcbiAgICAgICAgLy8gaXQgcGF5cyBvZmYgdG8gbm90IGRvIHRoZSBzcGxpdCBjb250YW50bHkuIE1vcmUgYWNjdXJhdGVseS4uLiBpdCBwYXlzIG9mZiBub3QgdG8gcnVuIHRoZSByZWdleC5cbiAgICAgICAgLy8gd2hhdCBldmVuIGlzIHRoZSBwb2ludCBvZiB0aGlzPyBTbyB3aGF0IGlmIHRoZXJlIGlzIGEgL3IgYXQgdGhlIGVuZCBvZiBhIGxpbmU/IEl0IHdvbnQgYmUgZHJhd24gYW55d2F5LlxuICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgvXFxyP1xcbi8sIDEpWzBdO1xuICAgIH1cbiAgICBjb25zdCBtYXggPSB3IC8gNDsgLy8gbm8gbmVlZCB0byByb3VuZCwgc2xpY2Ugd2lsbCBqdXN0IHRydW5jYXRlIHRoaXNcbiAgICBpZiAoZGF0YS5sZW5ndGggPiBtYXgpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgbWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBkcmF3TXVsdGlMaW5lVGV4dChjdHgsIGRhdGEsIHgsIHksIHcsIGgsIGJpYXMsIHRoZW1lLCBjb250ZW50QWxpZ24sIGh5cGVyV3JhcHBpbmcpIHtcbiAgICBjb25zdCBmb250U3R5bGUgPSB0aGVtZS5iYXNlRm9udEZ1bGw7XG4gICAgY29uc3Qgc3BsaXQgPSBzcGxpdFRleHQoY3R4LCBkYXRhLCBmb250U3R5bGUsIHcgLSB0aGVtZS5jZWxsSG9yaXpvbnRhbFBhZGRpbmcgKiAyLCBoeXBlcldyYXBwaW5nID8/IGZhbHNlKTtcbiAgICBjb25zdCBlbUhlaWdodCA9IGdldEVtSGVpZ2h0KGN0eCwgZm9udFN0eWxlKTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhlbWUubGluZUhlaWdodCAqIGVtSGVpZ2h0O1xuICAgIGNvbnN0IGFjdHVhbEhlaWdodCA9IGVtSGVpZ2h0ICsgbGluZUhlaWdodCAqIChzcGxpdC5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBtdXN0Q2xpcCA9IGFjdHVhbEhlaWdodCArIHRoZW1lLmNlbGxWZXJ0aWNhbFBhZGRpbmcgPiBoO1xuICAgIGlmIChtdXN0Q2xpcCkge1xuICAgICAgICAvLyB3ZWxsIG5vdyB3ZSBoYXZlIHRvIGNsaXAgYmVjYXVzZSB3ZSBtaWdodCByZW5kZXIgb3V0c2lkZSB0aGUgY2VsbCB2ZXJ0aWNhbGx5XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpbWFsWSA9IHkgKyBoIC8gMiAtIGFjdHVhbEhlaWdodCAvIDI7XG4gICAgbGV0IGRyYXdZID0gTWF0aC5tYXgoeSArIHRoZW1lLmNlbGxWZXJ0aWNhbFBhZGRpbmcsIG9wdGltYWxZKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygc3BsaXQpIHtcbiAgICAgICAgZHJhd1NpbmdsZVRleHRMaW5lKGN0eCwgbGluZSwgeCwgZHJhd1ksIHcsIGVtSGVpZ2h0LCBiaWFzLCB0aGVtZSwgY29udGVudEFsaWduKTtcbiAgICAgICAgZHJhd1kgKz0gbGluZUhlaWdodDtcbiAgICAgICAgaWYgKGRyYXdZID4geSArIGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKG11c3RDbGlwKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxufVxuLyoqIEBjYXRlZ29yeSBEcmF3aW5nICovXG5leHBvcnQgZnVuY3Rpb24gZHJhd1RleHRDZWxsKGFyZ3MsIGRhdGEsIGNvbnRlbnRBbGlnbiwgYWxsb3dXcmFwcGluZywgaHlwZXJXcmFwcGluZykge1xuICAgIGNvbnN0IHsgY3R4LCByZWN0LCB0aGVtZSB9ID0gYXJncztcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoOiB3LCBoZWlnaHQ6IGggfSA9IHJlY3Q7XG4gICAgYWxsb3dXcmFwcGluZyA9IGFsbG93V3JhcHBpbmcgPz8gZmFsc2U7XG4gICAgaWYgKCFhbGxvd1dyYXBwaW5nKSB7XG4gICAgICAgIGRhdGEgPSB0cnVuY2F0ZVN0cmluZyhkYXRhLCB3KTtcbiAgICB9XG4gICAgY29uc3QgYmlhcyA9IGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCB0aGVtZSk7XG4gICAgY29uc3QgaXNSdGwgPSBkaXJlY3Rpb24oZGF0YSkgPT09IFwicnRsXCI7XG4gICAgaWYgKGNvbnRlbnRBbGlnbiA9PT0gdW5kZWZpbmVkICYmIGlzUnRsKSB7XG4gICAgICAgIGNvbnRlbnRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICB9XG4gICAgaWYgKGlzUnRsKSB7XG4gICAgICAgIGN0eC5kaXJlY3Rpb24gPSBcInJ0bFwiO1xuICAgIH1cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChjb250ZW50QWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgLy8gVXNlIHJpZ2h0IGFsaWdubWVudCBhcyBkZWZhdWx0IGZvciBSVEwgdGV4dFxuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRBbGlnbiAhPT0gdW5kZWZpbmVkICYmIGNvbnRlbnRBbGlnbiAhPT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIGRlZmF1bHQgaXMgc3RhcnQgKD1sZWZ0KSwgb25seSBhcHBseSBpZiBhbGlnbm1lbnQgaXMgY2VudGVyIG9yIHJpZ2h0XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gY29udGVudEFsaWduO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbGxvd1dyYXBwaW5nKSB7XG4gICAgICAgICAgICBkcmF3U2luZ2xlVGV4dExpbmUoY3R4LCBkYXRhLCB4LCB5LCB3LCBoLCBiaWFzLCB0aGVtZSwgY29udGVudEFsaWduKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRyYXdNdWx0aUxpbmVUZXh0KGN0eCwgZGF0YSwgeCwgeSwgdywgaCwgYmlhcywgdGhlbWUsIGNvbnRlbnRBbGlnbiwgaHlwZXJXcmFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGFsaWdubWVudCB0byBkZWZhdWx0XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gXCJzdGFydFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1J0bCkge1xuICAgICAgICAgICAgY3R4LmRpcmVjdGlvbiA9IFwiaW5oZXJpdFwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kZWRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgaWYgKHR5cGVvZiByYWRpdXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmFkaXVzID0geyB0bDogcmFkaXVzLCB0cjogcmFkaXVzLCBicjogcmFkaXVzLCBibDogcmFkaXVzIH07XG4gICAgfVxuICAgIC8vIHJlc3RyaWN0IHJhZGl1cyB0byBhIHJlYXNvbmFibGUgbWF4XG4gICAgcmFkaXVzID0ge1xuICAgICAgICB0bDogTWF0aC5tYXgoMCwgTWF0aC5taW4ocmFkaXVzLnRsLCBoZWlnaHQgLyAyLCB3aWR0aCAvIDIpKSxcbiAgICAgICAgdHI6IE1hdGgubWF4KDAsIE1hdGgubWluKHJhZGl1cy50ciwgaGVpZ2h0IC8gMiwgd2lkdGggLyAyKSksXG4gICAgICAgIGJsOiBNYXRoLm1heCgwLCBNYXRoLm1pbihyYWRpdXMuYmwsIGhlaWdodCAvIDIsIHdpZHRoIC8gMikpLFxuICAgICAgICBicjogTWF0aC5tYXgoMCwgTWF0aC5taW4ocmFkaXVzLmJyLCBoZWlnaHQgLyAyLCB3aWR0aCAvIDIpKSxcbiAgICB9O1xuICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1cy50bCwgeSk7XG4gICAgY3R4LmFyY1RvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzLnRyLCByYWRpdXMudHIpO1xuICAgIGN0eC5hcmNUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cy5iciwgeSArIGhlaWdodCwgcmFkaXVzLmJyKTtcbiAgICBjdHguYXJjVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cy5ibCwgcmFkaXVzLmJsKTtcbiAgICBjdHguYXJjVG8oeCwgeSwgeCArIHJhZGl1cy50bCwgeSwgcmFkaXVzLnRsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkcmF3TWVudURvdHMoY3R4LCBkb3RzWCwgZG90c1kpIHtcbiAgICBjb25zdCByYWRpdXMgPSAxLjI1O1xuICAgIGN0eC5hcmMoZG90c1gsIGRvdHNZIC0gcmFkaXVzICogMy41LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgY3R4LmFyYyhkb3RzWCwgZG90c1ksIHJhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICBjdHguYXJjKGRvdHNYLCBkb3RzWSArIHJhZGl1cyAqIDMuNSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kZWRQb2x5KGN0eCwgcG9pbnRzLCByYWRpdXNBbGwpIHtcbiAgICAvLyBjb252ZXJ0IDIgcG9pbnRzIGludG8gdmVjdG9yIGZvcm0sIHBvbGFyIGZvcm0sIGFuZCBub3JtYWxpc2VkXG4gICAgY29uc3QgYXNWZWMgPSBmdW5jdGlvbiAocCwgcHApIHtcbiAgICAgICAgY29uc3QgdnggPSBwcC54IC0gcC54O1xuICAgICAgICBjb25zdCB2eSA9IHBwLnkgLSBwLnk7XG4gICAgICAgIGNvbnN0IHZsZW4gPSBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuICAgICAgICBjb25zdCB2bnggPSB2eCAvIHZsZW47XG4gICAgICAgIGNvbnN0IHZueSA9IHZ5IC8gdmxlbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHZ4LFxuICAgICAgICAgICAgeTogcHAueSAtIHAueSxcbiAgICAgICAgICAgIGxlbjogdmxlbixcbiAgICAgICAgICAgIG54OiB2bngsXG4gICAgICAgICAgICBueTogdm55LFxuICAgICAgICAgICAgYW5nOiBNYXRoLmF0YW4yKHZueSwgdm54KSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGxldCByYWRpdXM7XG4gICAgLy8gY29uc3QgdjE6IFZlY3RvciA9IHt9IGFzIGFueTtcbiAgICAvLyBjb25zdCB2MjogVmVjdG9yID0ge30gYXMgYW55O1xuICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IHAxID0gcG9pbnRzW2xlbiAtIDFdO1xuICAgIC8vIGZvciBlYWNoIHBvaW50XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgcDIgPSBwb2ludHNbaSAlIGxlbl07XG4gICAgICAgIGNvbnN0IHAzID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFBhcnQgMVxuICAgICAgICBjb25zdCB2MSA9IGFzVmVjKHAyLCBwMSk7XG4gICAgICAgIGNvbnN0IHYyID0gYXNWZWMocDIsIHAzKTtcbiAgICAgICAgY29uc3Qgc2luQSA9IHYxLm54ICogdjIubnkgLSB2MS5ueSAqIHYyLm54O1xuICAgICAgICBjb25zdCBzaW5BOTAgPSB2MS5ueCAqIHYyLm54IC0gdjEubnkgKiAtdjIubnk7XG4gICAgICAgIGxldCBhbmdsZSA9IE1hdGguYXNpbihzaW5BIDwgLTEgPyAtMSA6IHNpbkEgPiAxID8gMSA6IHNpbkEpO1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGxldCByYWREaXJlY3Rpb24gPSAxO1xuICAgICAgICBsZXQgZHJhd0RpcmVjdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAoc2luQTkwIDwgMCkge1xuICAgICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5QSSArIGFuZ2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLlBJIC0gYW5nbGU7XG4gICAgICAgICAgICAgICAgcmFkRGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgZHJhd0RpcmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmFkRGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgZHJhd0RpcmVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmFkaXVzID0gcDIucmFkaXVzICE9PSB1bmRlZmluZWQgPyBwMi5yYWRpdXMgOiByYWRpdXNBbGw7XG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gUGFydCAyXG4gICAgICAgIGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlIC8gMjtcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFBhcnQgM1xuICAgICAgICBsZXQgbGVuT3V0ID0gTWF0aC5hYnMoKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXMpIC8gTWF0aC5zaW4oaGFsZkFuZ2xlKSk7XG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBTcGVjaWFsIHBhcnQgQVxuICAgICAgICBsZXQgY1JhZGl1cztcbiAgICAgICAgaWYgKGxlbk91dCA+IE1hdGgubWluKHYxLmxlbiAvIDIsIHYyLmxlbiAvIDIpKSB7XG4gICAgICAgICAgICBsZW5PdXQgPSBNYXRoLm1pbih2MS5sZW4gLyAyLCB2Mi5sZW4gLyAyKTtcbiAgICAgICAgICAgIGNSYWRpdXMgPSBNYXRoLmFicygobGVuT3V0ICogTWF0aC5zaW4oaGFsZkFuZ2xlKSkgLyBNYXRoLmNvcyhoYWxmQW5nbGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNSYWRpdXMgPSByYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBQYXJ0IDRcbiAgICAgICAgbGV0IHggPSBwMi54ICsgdjIubnggKiBsZW5PdXQ7XG4gICAgICAgIGxldCB5ID0gcDIueSArIHYyLm55ICogbGVuT3V0O1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFBhcnQgNVxuICAgICAgICB4ICs9IC12Mi5ueSAqIGNSYWRpdXMgKiByYWREaXJlY3Rpb247XG4gICAgICAgIHkgKz0gdjIubnggKiBjUmFkaXVzICogcmFkRGlyZWN0aW9uO1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIFBhcnQgNlxuICAgICAgICBjdHguYXJjKHgsIHksIGNSYWRpdXMsIHYxLmFuZyArIChNYXRoLlBJIC8gMikgKiByYWREaXJlY3Rpb24sIHYyLmFuZyAtIChNYXRoLlBJIC8gMikgKiByYWREaXJlY3Rpb24sIGRyYXdEaXJlY3Rpb24pO1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHAxID0gcDI7XG4gICAgICAgIHAyID0gcDM7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQm91bmRzKGNvbCwgcm93LCB3aWR0aCwgaGVpZ2h0LCBncm91cEhlYWRlckhlaWdodCwgdG90YWxIZWFkZXJIZWlnaHQsIGNlbGxYT2Zmc2V0LCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgcm93cywgZnJlZXplQ29sdW1ucywgZnJlZXplVHJhaWxpbmdSb3dzLCBtYXBwZWRDb2x1bW5zLCByb3dIZWlnaHQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IHRvdGFsSGVhZGVySGVpZ2h0ICsgdHJhbnNsYXRlWSxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICB9O1xuICAgIGlmIChjb2wgPj0gbWFwcGVkQ29sdW1ucy5sZW5ndGggfHwgcm93ID49IHJvd3MgfHwgcm93IDwgLTIgfHwgY29sIDwgMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJIZWlnaHQgPSB0b3RhbEhlYWRlckhlaWdodCAtIGdyb3VwSGVhZGVySGVpZ2h0O1xuICAgIGlmIChjb2wgPj0gZnJlZXplQ29sdW1ucykge1xuICAgICAgICBjb25zdCBkaXIgPSBjZWxsWE9mZnNldCA+IGNvbCA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgZnJlZXplV2lkdGggPSBnZXRTdGlja3lXaWR0aChtYXBwZWRDb2x1bW5zKTtcbiAgICAgICAgcmVzdWx0LnggKz0gZnJlZXplV2lkdGggKyB0cmFuc2xhdGVYO1xuICAgICAgICBmb3IgKGxldCBpID0gY2VsbFhPZmZzZXQ7IGkgIT09IGNvbDsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC54ICs9IG1hcHBlZENvbHVtbnNbZGlyID09PSAxID8gaSA6IGkgLSAxXS53aWR0aCAqIGRpcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2w7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnggKz0gbWFwcGVkQ29sdW1uc1tpXS53aWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQud2lkdGggPSBtYXBwZWRDb2x1bW5zW2NvbF0ud2lkdGggKyAxO1xuICAgIGlmIChyb3cgPT09IC0xKSB7XG4gICAgICAgIHJlc3VsdC55ID0gZ3JvdXBIZWFkZXJIZWlnaHQ7XG4gICAgICAgIHJlc3VsdC5oZWlnaHQgPSBoZWFkZXJIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJvdyA9PT0gLTIpIHtcbiAgICAgICAgcmVzdWx0LnkgPSAwO1xuICAgICAgICByZXN1bHQuaGVpZ2h0ID0gZ3JvdXBIZWFkZXJIZWlnaHQ7XG4gICAgICAgIGxldCBzdGFydCA9IGNvbDtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBtYXBwZWRDb2x1bW5zW2NvbF0uZ3JvdXA7XG4gICAgICAgIGNvbnN0IHN0aWNreSA9IG1hcHBlZENvbHVtbnNbY29sXS5zdGlja3k7XG4gICAgICAgIHdoaWxlIChzdGFydCA+IDAgJiZcbiAgICAgICAgICAgIGlzR3JvdXBFcXVhbChtYXBwZWRDb2x1bW5zW3N0YXJ0IC0gMV0uZ3JvdXAsIGdyb3VwKSAmJlxuICAgICAgICAgICAgbWFwcGVkQ29sdW1uc1tzdGFydCAtIDFdLnN0aWNreSA9PT0gc3RpY2t5KSB7XG4gICAgICAgICAgICBjb25zdCBjID0gbWFwcGVkQ29sdW1uc1tzdGFydCAtIDFdO1xuICAgICAgICAgICAgcmVzdWx0LnggLT0gYy53aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdC53aWR0aCArPSBjLndpZHRoO1xuICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZW5kID0gY29sO1xuICAgICAgICB3aGlsZSAoZW5kICsgMSA8IG1hcHBlZENvbHVtbnMubGVuZ3RoICYmXG4gICAgICAgICAgICBpc0dyb3VwRXF1YWwobWFwcGVkQ29sdW1uc1tlbmQgKyAxXS5ncm91cCwgZ3JvdXApICYmXG4gICAgICAgICAgICBtYXBwZWRDb2x1bW5zW2VuZCArIDFdLnN0aWNreSA9PT0gc3RpY2t5KSB7XG4gICAgICAgICAgICBjb25zdCBjID0gbWFwcGVkQ29sdW1uc1tlbmQgKyAxXTtcbiAgICAgICAgICAgIHJlc3VsdC53aWR0aCArPSBjLndpZHRoO1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGlja3kpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyZWV6ZVdpZHRoID0gZ2V0U3RpY2t5V2lkdGgobWFwcGVkQ29sdW1ucyk7XG4gICAgICAgICAgICBjb25zdCBjbGlwID0gcmVzdWx0LnggLSBmcmVlemVXaWR0aDtcbiAgICAgICAgICAgIGlmIChjbGlwIDwgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC54IC09IGNsaXA7XG4gICAgICAgICAgICAgICAgcmVzdWx0LndpZHRoICs9IGNsaXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnggKyByZXN1bHQud2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC53aWR0aCA9IHdpZHRoIC0gcmVzdWx0Lng7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocm93ID49IHJvd3MgLSBmcmVlemVUcmFpbGluZ1Jvd3MpIHtcbiAgICAgICAgbGV0IGR5ID0gcm93cyAtIHJvdztcbiAgICAgICAgcmVzdWx0LnkgPSBoZWlnaHQ7XG4gICAgICAgIHdoaWxlIChkeSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSByb3cgKyBkeSAtIDE7XG4gICAgICAgICAgICByZXN1bHQuaGVpZ2h0ID0gdHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIiA/IHJvd0hlaWdodCA6IHJvd0hlaWdodChyKTtcbiAgICAgICAgICAgIHJlc3VsdC55IC09IHJlc3VsdC5oZWlnaHQ7XG4gICAgICAgICAgICBkeS0tO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5oZWlnaHQgKz0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGRpciA9IGNlbGxZT2Zmc2V0ID4gcm93ID8gLTEgOiAxO1xuICAgICAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSByb3cgLSBjZWxsWU9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdC55ICs9IGRlbHRhICogcm93SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgciA9IGNlbGxZT2Zmc2V0OyByICE9PSByb3c7IHIgKz0gZGlyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnkgKz0gcm93SGVpZ2h0KHIpICogZGlyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5oZWlnaHQgPSAodHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIiA/IHJvd0hlaWdodCA6IHJvd0hlaWdodChyb3cpKSArIDE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLWdyaWQtbGliLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.blit.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.blit.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blitLastFrame: () => (/* binding */ blitLastFrame),\n/* harmony export */   blitResizedCol: () => (/* binding */ blitResizedCol),\n/* harmony export */   computeCanBlit: () => (/* binding */ computeCanBlit)\n/* harmony export */ });\n/* harmony import */ var _common_support_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n/* harmony import */ var _data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-grid-render.walk.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.walk.js\");\n/* eslint-disable sonarjs/no-duplicate-string */\n/* eslint-disable unicorn/no-for-loop */\n\n\n\n\nfunction blitLastFrame(ctx, blitSource, blitSourceScroll, targetScroll, last, cellXOffset, cellYOffset, translateX, translateY, freezeTrailingRows, width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, getRowHeight, doubleBuffer) {\n    const drawRegions = [];\n    ctx.imageSmoothingEnabled = false;\n    const minY = Math.min(last.cellYOffset, cellYOffset);\n    const maxY = Math.max(last.cellYOffset, cellYOffset);\n    let deltaY = 0;\n    if (typeof getRowHeight === \"number\") {\n        deltaY += (maxY - minY) * getRowHeight;\n    }\n    else {\n        for (let i = minY; i < maxY; i++) {\n            deltaY += getRowHeight(i);\n        }\n    }\n    if (cellYOffset > last.cellYOffset) {\n        deltaY = -deltaY;\n    }\n    deltaY += translateY - last.translateY;\n    const minX = Math.min(last.cellXOffset, cellXOffset);\n    const maxX = Math.max(last.cellXOffset, cellXOffset);\n    let deltaX = 0;\n    for (let i = minX; i < maxX; i++) {\n        deltaX += mappedColumns[i].width;\n    }\n    if (cellXOffset > last.cellXOffset) {\n        deltaX = -deltaX;\n    }\n    deltaX += translateX - last.translateX;\n    const stickyWidth = (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__.getStickyWidth)(effectiveCols);\n    if (deltaX !== 0 && deltaY !== 0) {\n        return {\n            regions: [],\n        };\n    }\n    const freezeTrailingRowsHeight = freezeTrailingRows > 0 ? (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__.getFreezeTrailingHeight)(rows, freezeTrailingRows, getRowHeight) : 0;\n    const blitWidth = width - stickyWidth - Math.abs(deltaX);\n    const blitHeight = height - totalHeaderHeight - freezeTrailingRowsHeight - Math.abs(deltaY) - 1;\n    if (blitWidth > 150 && blitHeight > 150) {\n        const args = {\n            sx: 0,\n            sy: 0,\n            sw: width * dpr,\n            sh: height * dpr,\n            dx: 0,\n            dy: 0,\n            dw: width * dpr,\n            dh: height * dpr,\n        };\n        // blit Y\n        if (deltaY > 0) {\n            // scrolling up\n            args.sy = (totalHeaderHeight + 1) * dpr;\n            args.sh = blitHeight * dpr;\n            args.dy = (deltaY + totalHeaderHeight + 1) * dpr;\n            args.dh = blitHeight * dpr;\n            drawRegions.push({\n                x: 0,\n                y: totalHeaderHeight,\n                width: width,\n                height: deltaY + 1,\n            });\n        }\n        else if (deltaY < 0) {\n            // scrolling down\n            args.sy = (-deltaY + totalHeaderHeight + 1) * dpr;\n            args.sh = blitHeight * dpr;\n            args.dy = (totalHeaderHeight + 1) * dpr;\n            args.dh = blitHeight * dpr;\n            drawRegions.push({\n                x: 0,\n                y: height + deltaY - freezeTrailingRowsHeight,\n                width: width,\n                height: -deltaY + freezeTrailingRowsHeight,\n            });\n        }\n        // blit X\n        if (deltaX > 0) {\n            // pixels moving right\n            args.sx = stickyWidth * dpr;\n            args.sw = blitWidth * dpr;\n            args.dx = (deltaX + stickyWidth) * dpr;\n            args.dw = blitWidth * dpr;\n            drawRegions.push({\n                x: stickyWidth - 1,\n                y: 0,\n                width: deltaX + 2,\n                height: height,\n            });\n        }\n        else if (deltaX < 0) {\n            // pixels moving left\n            args.sx = (stickyWidth - deltaX) * dpr;\n            args.sw = blitWidth * dpr;\n            args.dx = stickyWidth * dpr;\n            args.dw = blitWidth * dpr;\n            drawRegions.push({\n                x: width + deltaX,\n                y: 0,\n                width: -deltaX,\n                height: height,\n            });\n        }\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        if (doubleBuffer) {\n            if (stickyWidth > 0 &&\n                deltaX !== 0 &&\n                deltaY === 0 &&\n                (targetScroll === undefined || blitSourceScroll?.[1] !== false)) {\n                // When double buffering the freeze columns can be offset by a couple pixels vertically between the two\n                // buffers. We don't want to redraw them so we need to make sure to copy them between the buffers.\n                const w = stickyWidth * dpr;\n                const h = height * dpr;\n                ctx.drawImage(blitSource, 0, 0, w, h, 0, 0, w, h);\n            }\n            if (freezeTrailingRowsHeight > 0 &&\n                deltaX === 0 &&\n                deltaY !== 0 &&\n                (targetScroll === undefined || blitSourceScroll?.[0] !== false)) {\n                const y = (height - freezeTrailingRowsHeight) * dpr;\n                const w = width * dpr;\n                const h = freezeTrailingRowsHeight * dpr;\n                ctx.drawImage(blitSource, 0, y, w, h, 0, y, w, h);\n            }\n        }\n        ctx.drawImage(blitSource, args.sx, args.sy, args.sw, args.sh, args.dx, args.dy, args.dw, args.dh);\n        ctx.scale(dpr, dpr);\n    }\n    ctx.imageSmoothingEnabled = true;\n    return {\n        regions: drawRegions,\n    };\n}\nfunction blitResizedCol(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedIndex) {\n    const drawRegions = [];\n    // ctx.imageSmoothingEnabled = false;\n    if (cellXOffset !== last.cellXOffset ||\n        cellYOffset !== last.cellYOffset ||\n        translateX !== last.translateX ||\n        translateY !== last.translateY) {\n        return drawRegions;\n    }\n    (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_1__.walkColumns)(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, _drawY, clipX) => {\n        if (c.sourceIndex === resizedIndex) {\n            const x = Math.max(drawX, clipX) + 1;\n            drawRegions.push({\n                x,\n                y: 0,\n                width: width - x,\n                height,\n            });\n            return true;\n        }\n    });\n    return drawRegions;\n}\nfunction computeCanBlit(current, last) {\n    if (last === undefined)\n        return false;\n    if (current.width !== last.width ||\n        current.height !== last.height ||\n        current.theme !== last.theme ||\n        current.headerHeight !== last.headerHeight ||\n        current.rowHeight !== last.rowHeight ||\n        current.rows !== last.rows ||\n        current.freezeColumns !== last.freezeColumns ||\n        current.getRowThemeOverride !== last.getRowThemeOverride ||\n        current.isFocused !== last.isFocused ||\n        current.isResizing !== last.isResizing ||\n        current.verticalBorder !== last.verticalBorder ||\n        current.getCellContent !== last.getCellContent ||\n        current.highlightRegions !== last.highlightRegions ||\n        current.selection !== last.selection ||\n        current.dragAndDropState !== last.dragAndDropState ||\n        current.prelightCells !== last.prelightCells ||\n        current.touchMode !== last.touchMode ||\n        current.maxScaleFactor !== last.maxScaleFactor) {\n        return false;\n    }\n    if (current.mappedColumns !== last.mappedColumns) {\n        if (current.mappedColumns.length > 100 || current.mappedColumns.length !== last.mappedColumns.length) {\n            // The array is big, let's just redraw the damned thing rather than check these all. Or the number of cols\n            // changed in which case I dont want to figure out what happened.\n            return false;\n        }\n        // We want to know if only one column has resized. If this is the case we can do a special left/right sliding\n        // blit. Or just not redraw shit on the left.\n        let resized;\n        for (let i = 0; i < current.mappedColumns.length; i++) {\n            const curCol = current.mappedColumns[i];\n            const lastCol = last.mappedColumns[i];\n            if ((0,_common_support_js__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(curCol, lastCol))\n                continue;\n            // two columns changed, abort\n            if (resized !== undefined)\n                return false;\n            if (curCol.width === lastCol.width)\n                return false;\n            const { width, ...curRest } = curCol;\n            const { width: lastWidth, ...lastRest } = lastCol;\n            // more than width changed, abort\n            if (!(0,_common_support_js__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(curRest, lastRest))\n                return false;\n            resized = i;\n        }\n        if (resized === undefined) {\n            // we never found a changed column, cool, we can blit\n            return true;\n        }\n        return resized;\n    }\n    return true;\n}\n//# sourceMappingURL=data-grid-render.blit.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmJsaXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUN1RDtBQUNoQjtBQUNzQztBQUNwQjtBQUNsRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMEVBQXVCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBLGdCQUFnQiw2REFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQSxpQkFBaUIsNkRBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmJsaXQuanM/NzBmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBzb25hcmpzL25vLWR1cGxpY2F0ZS1zdHJpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIHVuaWNvcm4vbm8tZm9yLWxvb3AgKi9cbmltcG9ydCB7IGRlZXBFcXVhbCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vc3VwcG9ydC5qc1wiO1xuaW1wb3J0IHt9IGZyb20gXCIuLi9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmltcG9ydCB7IGdldFN0aWNreVdpZHRoLCBnZXRGcmVlemVUcmFpbGluZ0hlaWdodCB9IGZyb20gXCIuL2RhdGEtZ3JpZC1saWIuanNcIjtcbmltcG9ydCB7IHdhbGtDb2x1bW5zIH0gZnJvbSBcIi4vZGF0YS1ncmlkLXJlbmRlci53YWxrLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gYmxpdExhc3RGcmFtZShjdHgsIGJsaXRTb3VyY2UsIGJsaXRTb3VyY2VTY3JvbGwsIHRhcmdldFNjcm9sbCwgbGFzdCwgY2VsbFhPZmZzZXQsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBmcmVlemVUcmFpbGluZ1Jvd3MsIHdpZHRoLCBoZWlnaHQsIHJvd3MsIHRvdGFsSGVhZGVySGVpZ2h0LCBkcHIsIG1hcHBlZENvbHVtbnMsIGVmZmVjdGl2ZUNvbHMsIGdldFJvd0hlaWdodCwgZG91YmxlQnVmZmVyKSB7XG4gICAgY29uc3QgZHJhd1JlZ2lvbnMgPSBbXTtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgY29uc3QgbWluWSA9IE1hdGgubWluKGxhc3QuY2VsbFlPZmZzZXQsIGNlbGxZT2Zmc2V0KTtcbiAgICBjb25zdCBtYXhZID0gTWF0aC5tYXgobGFzdC5jZWxsWU9mZnNldCwgY2VsbFlPZmZzZXQpO1xuICAgIGxldCBkZWx0YVkgPSAwO1xuICAgIGlmICh0eXBlb2YgZ2V0Um93SGVpZ2h0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGRlbHRhWSArPSAobWF4WSAtIG1pblkpICogZ2V0Um93SGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1pblk7IGkgPCBtYXhZOyBpKyspIHtcbiAgICAgICAgICAgIGRlbHRhWSArPSBnZXRSb3dIZWlnaHQoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNlbGxZT2Zmc2V0ID4gbGFzdC5jZWxsWU9mZnNldCkge1xuICAgICAgICBkZWx0YVkgPSAtZGVsdGFZO1xuICAgIH1cbiAgICBkZWx0YVkgKz0gdHJhbnNsYXRlWSAtIGxhc3QudHJhbnNsYXRlWTtcbiAgICBjb25zdCBtaW5YID0gTWF0aC5taW4obGFzdC5jZWxsWE9mZnNldCwgY2VsbFhPZmZzZXQpO1xuICAgIGNvbnN0IG1heFggPSBNYXRoLm1heChsYXN0LmNlbGxYT2Zmc2V0LCBjZWxsWE9mZnNldCk7XG4gICAgbGV0IGRlbHRhWCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IG1pblg7IGkgPCBtYXhYOyBpKyspIHtcbiAgICAgICAgZGVsdGFYICs9IG1hcHBlZENvbHVtbnNbaV0ud2lkdGg7XG4gICAgfVxuICAgIGlmIChjZWxsWE9mZnNldCA+IGxhc3QuY2VsbFhPZmZzZXQpIHtcbiAgICAgICAgZGVsdGFYID0gLWRlbHRhWDtcbiAgICB9XG4gICAgZGVsdGFYICs9IHRyYW5zbGF0ZVggLSBsYXN0LnRyYW5zbGF0ZVg7XG4gICAgY29uc3Qgc3RpY2t5V2lkdGggPSBnZXRTdGlja3lXaWR0aChlZmZlY3RpdmVDb2xzKTtcbiAgICBpZiAoZGVsdGFYICE9PSAwICYmIGRlbHRhWSAhPT0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVnaW9uczogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGZyZWV6ZVRyYWlsaW5nUm93c0hlaWdodCA9IGZyZWV6ZVRyYWlsaW5nUm93cyA+IDAgPyBnZXRGcmVlemVUcmFpbGluZ0hlaWdodChyb3dzLCBmcmVlemVUcmFpbGluZ1Jvd3MsIGdldFJvd0hlaWdodCkgOiAwO1xuICAgIGNvbnN0IGJsaXRXaWR0aCA9IHdpZHRoIC0gc3RpY2t5V2lkdGggLSBNYXRoLmFicyhkZWx0YVgpO1xuICAgIGNvbnN0IGJsaXRIZWlnaHQgPSBoZWlnaHQgLSB0b3RhbEhlYWRlckhlaWdodCAtIGZyZWV6ZVRyYWlsaW5nUm93c0hlaWdodCAtIE1hdGguYWJzKGRlbHRhWSkgLSAxO1xuICAgIGlmIChibGl0V2lkdGggPiAxNTAgJiYgYmxpdEhlaWdodCA+IDE1MCkge1xuICAgICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICAgICAgc3g6IDAsXG4gICAgICAgICAgICBzeTogMCxcbiAgICAgICAgICAgIHN3OiB3aWR0aCAqIGRwcixcbiAgICAgICAgICAgIHNoOiBoZWlnaHQgKiBkcHIsXG4gICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgIGR5OiAwLFxuICAgICAgICAgICAgZHc6IHdpZHRoICogZHByLFxuICAgICAgICAgICAgZGg6IGhlaWdodCAqIGRwcixcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYmxpdCBZXG4gICAgICAgIGlmIChkZWx0YVkgPiAwKSB7XG4gICAgICAgICAgICAvLyBzY3JvbGxpbmcgdXBcbiAgICAgICAgICAgIGFyZ3Muc3kgPSAodG90YWxIZWFkZXJIZWlnaHQgKyAxKSAqIGRwcjtcbiAgICAgICAgICAgIGFyZ3Muc2ggPSBibGl0SGVpZ2h0ICogZHByO1xuICAgICAgICAgICAgYXJncy5keSA9IChkZWx0YVkgKyB0b3RhbEhlYWRlckhlaWdodCArIDEpICogZHByO1xuICAgICAgICAgICAgYXJncy5kaCA9IGJsaXRIZWlnaHQgKiBkcHI7XG4gICAgICAgICAgICBkcmF3UmVnaW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IHRvdGFsSGVhZGVySGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGRlbHRhWSArIDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YVkgPCAwKSB7XG4gICAgICAgICAgICAvLyBzY3JvbGxpbmcgZG93blxuICAgICAgICAgICAgYXJncy5zeSA9ICgtZGVsdGFZICsgdG90YWxIZWFkZXJIZWlnaHQgKyAxKSAqIGRwcjtcbiAgICAgICAgICAgIGFyZ3Muc2ggPSBibGl0SGVpZ2h0ICogZHByO1xuICAgICAgICAgICAgYXJncy5keSA9ICh0b3RhbEhlYWRlckhlaWdodCArIDEpICogZHByO1xuICAgICAgICAgICAgYXJncy5kaCA9IGJsaXRIZWlnaHQgKiBkcHI7XG4gICAgICAgICAgICBkcmF3UmVnaW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IGhlaWdodCArIGRlbHRhWSAtIGZyZWV6ZVRyYWlsaW5nUm93c0hlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAtZGVsdGFZICsgZnJlZXplVHJhaWxpbmdSb3dzSGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmxpdCBYXG4gICAgICAgIGlmIChkZWx0YVggPiAwKSB7XG4gICAgICAgICAgICAvLyBwaXhlbHMgbW92aW5nIHJpZ2h0XG4gICAgICAgICAgICBhcmdzLnN4ID0gc3RpY2t5V2lkdGggKiBkcHI7XG4gICAgICAgICAgICBhcmdzLnN3ID0gYmxpdFdpZHRoICogZHByO1xuICAgICAgICAgICAgYXJncy5keCA9IChkZWx0YVggKyBzdGlja3lXaWR0aCkgKiBkcHI7XG4gICAgICAgICAgICBhcmdzLmR3ID0gYmxpdFdpZHRoICogZHByO1xuICAgICAgICAgICAgZHJhd1JlZ2lvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogc3RpY2t5V2lkdGggLSAxLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGRlbHRhWCArIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWx0YVggPCAwKSB7XG4gICAgICAgICAgICAvLyBwaXhlbHMgbW92aW5nIGxlZnRcbiAgICAgICAgICAgIGFyZ3Muc3ggPSAoc3RpY2t5V2lkdGggLSBkZWx0YVgpICogZHByO1xuICAgICAgICAgICAgYXJncy5zdyA9IGJsaXRXaWR0aCAqIGRwcjtcbiAgICAgICAgICAgIGFyZ3MuZHggPSBzdGlja3lXaWR0aCAqIGRwcjtcbiAgICAgICAgICAgIGFyZ3MuZHcgPSBibGl0V2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkcmF3UmVnaW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiB3aWR0aCArIGRlbHRhWCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAtZGVsdGFYLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgaWYgKGRvdWJsZUJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKHN0aWNreVdpZHRoID4gMCAmJlxuICAgICAgICAgICAgICAgIGRlbHRhWCAhPT0gMCAmJlxuICAgICAgICAgICAgICAgIGRlbHRhWSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICh0YXJnZXRTY3JvbGwgPT09IHVuZGVmaW5lZCB8fCBibGl0U291cmNlU2Nyb2xsPy5bMV0gIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gZG91YmxlIGJ1ZmZlcmluZyB0aGUgZnJlZXplIGNvbHVtbnMgY2FuIGJlIG9mZnNldCBieSBhIGNvdXBsZSBwaXhlbHMgdmVydGljYWxseSBiZXR3ZWVuIHRoZSB0d29cbiAgICAgICAgICAgICAgICAvLyBidWZmZXJzLiBXZSBkb24ndCB3YW50IHRvIHJlZHJhdyB0aGVtIHNvIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRvIGNvcHkgdGhlbSBiZXR3ZWVuIHRoZSBidWZmZXJzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBzdGlja3lXaWR0aCAqIGRwcjtcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gaGVpZ2h0ICogZHByO1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoYmxpdFNvdXJjZSwgMCwgMCwgdywgaCwgMCwgMCwgdywgaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJlZXplVHJhaWxpbmdSb3dzSGVpZ2h0ID4gMCAmJlxuICAgICAgICAgICAgICAgIGRlbHRhWCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGRlbHRhWSAhPT0gMCAmJlxuICAgICAgICAgICAgICAgICh0YXJnZXRTY3JvbGwgPT09IHVuZGVmaW5lZCB8fCBibGl0U291cmNlU2Nyb2xsPy5bMF0gIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSAoaGVpZ2h0IC0gZnJlZXplVHJhaWxpbmdSb3dzSGVpZ2h0KSAqIGRwcjtcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IGZyZWV6ZVRyYWlsaW5nUm93c0hlaWdodCAqIGRwcjtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGJsaXRTb3VyY2UsIDAsIHksIHcsIGgsIDAsIHksIHcsIGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYmxpdFNvdXJjZSwgYXJncy5zeCwgYXJncy5zeSwgYXJncy5zdywgYXJncy5zaCwgYXJncy5keCwgYXJncy5keSwgYXJncy5kdywgYXJncy5kaCk7XG4gICAgICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgfVxuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lvbnM6IGRyYXdSZWdpb25zLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gYmxpdFJlc2l6ZWRDb2wobGFzdCwgY2VsbFhPZmZzZXQsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCB3aWR0aCwgaGVpZ2h0LCB0b3RhbEhlYWRlckhlaWdodCwgZWZmZWN0aXZlQ29scywgcmVzaXplZEluZGV4KSB7XG4gICAgY29uc3QgZHJhd1JlZ2lvbnMgPSBbXTtcbiAgICAvLyBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKGNlbGxYT2Zmc2V0ICE9PSBsYXN0LmNlbGxYT2Zmc2V0IHx8XG4gICAgICAgIGNlbGxZT2Zmc2V0ICE9PSBsYXN0LmNlbGxZT2Zmc2V0IHx8XG4gICAgICAgIHRyYW5zbGF0ZVggIT09IGxhc3QudHJhbnNsYXRlWCB8fFxuICAgICAgICB0cmFuc2xhdGVZICE9PSBsYXN0LnRyYW5zbGF0ZVkpIHtcbiAgICAgICAgcmV0dXJuIGRyYXdSZWdpb25zO1xuICAgIH1cbiAgICB3YWxrQ29sdW1ucyhlZmZlY3RpdmVDb2xzLCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgdG90YWxIZWFkZXJIZWlnaHQsIChjLCBkcmF3WCwgX2RyYXdZLCBjbGlwWCkgPT4ge1xuICAgICAgICBpZiAoYy5zb3VyY2VJbmRleCA9PT0gcmVzaXplZEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoZHJhd1gsIGNsaXBYKSArIDE7XG4gICAgICAgICAgICBkcmF3UmVnaW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoIC0geCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRyYXdSZWdpb25zO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVDYW5CbGl0KGN1cnJlbnQsIGxhc3QpIHtcbiAgICBpZiAobGFzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnQud2lkdGggIT09IGxhc3Qud2lkdGggfHxcbiAgICAgICAgY3VycmVudC5oZWlnaHQgIT09IGxhc3QuaGVpZ2h0IHx8XG4gICAgICAgIGN1cnJlbnQudGhlbWUgIT09IGxhc3QudGhlbWUgfHxcbiAgICAgICAgY3VycmVudC5oZWFkZXJIZWlnaHQgIT09IGxhc3QuaGVhZGVySGVpZ2h0IHx8XG4gICAgICAgIGN1cnJlbnQucm93SGVpZ2h0ICE9PSBsYXN0LnJvd0hlaWdodCB8fFxuICAgICAgICBjdXJyZW50LnJvd3MgIT09IGxhc3Qucm93cyB8fFxuICAgICAgICBjdXJyZW50LmZyZWV6ZUNvbHVtbnMgIT09IGxhc3QuZnJlZXplQ29sdW1ucyB8fFxuICAgICAgICBjdXJyZW50LmdldFJvd1RoZW1lT3ZlcnJpZGUgIT09IGxhc3QuZ2V0Um93VGhlbWVPdmVycmlkZSB8fFxuICAgICAgICBjdXJyZW50LmlzRm9jdXNlZCAhPT0gbGFzdC5pc0ZvY3VzZWQgfHxcbiAgICAgICAgY3VycmVudC5pc1Jlc2l6aW5nICE9PSBsYXN0LmlzUmVzaXppbmcgfHxcbiAgICAgICAgY3VycmVudC52ZXJ0aWNhbEJvcmRlciAhPT0gbGFzdC52ZXJ0aWNhbEJvcmRlciB8fFxuICAgICAgICBjdXJyZW50LmdldENlbGxDb250ZW50ICE9PSBsYXN0LmdldENlbGxDb250ZW50IHx8XG4gICAgICAgIGN1cnJlbnQuaGlnaGxpZ2h0UmVnaW9ucyAhPT0gbGFzdC5oaWdobGlnaHRSZWdpb25zIHx8XG4gICAgICAgIGN1cnJlbnQuc2VsZWN0aW9uICE9PSBsYXN0LnNlbGVjdGlvbiB8fFxuICAgICAgICBjdXJyZW50LmRyYWdBbmREcm9wU3RhdGUgIT09IGxhc3QuZHJhZ0FuZERyb3BTdGF0ZSB8fFxuICAgICAgICBjdXJyZW50LnByZWxpZ2h0Q2VsbHMgIT09IGxhc3QucHJlbGlnaHRDZWxscyB8fFxuICAgICAgICBjdXJyZW50LnRvdWNoTW9kZSAhPT0gbGFzdC50b3VjaE1vZGUgfHxcbiAgICAgICAgY3VycmVudC5tYXhTY2FsZUZhY3RvciAhPT0gbGFzdC5tYXhTY2FsZUZhY3Rvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Lm1hcHBlZENvbHVtbnMgIT09IGxhc3QubWFwcGVkQ29sdW1ucykge1xuICAgICAgICBpZiAoY3VycmVudC5tYXBwZWRDb2x1bW5zLmxlbmd0aCA+IDEwMCB8fCBjdXJyZW50Lm1hcHBlZENvbHVtbnMubGVuZ3RoICE9PSBsYXN0Lm1hcHBlZENvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUaGUgYXJyYXkgaXMgYmlnLCBsZXQncyBqdXN0IHJlZHJhdyB0aGUgZGFtbmVkIHRoaW5nIHJhdGhlciB0aGFuIGNoZWNrIHRoZXNlIGFsbC4gT3IgdGhlIG51bWJlciBvZiBjb2xzXG4gICAgICAgICAgICAvLyBjaGFuZ2VkIGluIHdoaWNoIGNhc2UgSSBkb250IHdhbnQgdG8gZmlndXJlIG91dCB3aGF0IGhhcHBlbmVkLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHdhbnQgdG8ga25vdyBpZiBvbmx5IG9uZSBjb2x1bW4gaGFzIHJlc2l6ZWQuIElmIHRoaXMgaXMgdGhlIGNhc2Ugd2UgY2FuIGRvIGEgc3BlY2lhbCBsZWZ0L3JpZ2h0IHNsaWRpbmdcbiAgICAgICAgLy8gYmxpdC4gT3IganVzdCBub3QgcmVkcmF3IHNoaXQgb24gdGhlIGxlZnQuXG4gICAgICAgIGxldCByZXNpemVkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnQubWFwcGVkQ29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyQ29sID0gY3VycmVudC5tYXBwZWRDb2x1bW5zW2ldO1xuICAgICAgICAgICAgY29uc3QgbGFzdENvbCA9IGxhc3QubWFwcGVkQ29sdW1uc1tpXTtcbiAgICAgICAgICAgIGlmIChkZWVwRXF1YWwoY3VyQ29sLCBsYXN0Q29sKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIHR3byBjb2x1bW5zIGNoYW5nZWQsIGFib3J0XG4gICAgICAgICAgICBpZiAocmVzaXplZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjdXJDb2wud2lkdGggPT09IGxhc3RDb2wud2lkdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgLi4uY3VyUmVzdCB9ID0gY3VyQ29sO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aDogbGFzdFdpZHRoLCAuLi5sYXN0UmVzdCB9ID0gbGFzdENvbDtcbiAgICAgICAgICAgIC8vIG1vcmUgdGhhbiB3aWR0aCBjaGFuZ2VkLCBhYm9ydFxuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoY3VyUmVzdCwgbGFzdFJlc3QpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJlc2l6ZWQgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNpemVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHdlIG5ldmVyIGZvdW5kIGEgY2hhbmdlZCBjb2x1bW4sIGNvb2wsIHdlIGNhbiBibGl0XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzaXplZDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLWdyaWQtcmVuZGVyLmJsaXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.blit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.cells.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.cells.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawCell: () => (/* binding */ drawCell),\n/* harmony export */   drawCells: () => (/* binding */ drawCells)\n/* harmony export */ });\n/* harmony import */ var _data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _common_styles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/styles.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js\");\n/* harmony import */ var _color_parser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../color-parser.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\");\n/* harmony import */ var _common_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/math.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js\");\n/* harmony import */ var _data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data-grid-render.walk.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.walk.js\");\n/* eslint-disable sonarjs/no-duplicate-string */\n/* eslint-disable unicorn/no-for-loop */\n\n\n\n\n\n\n\nconst loadingCell = {\n    kind: _data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Loading,\n    allowOverlay: false,\n};\n// preppable items:\n// - font\n// - fillStyle\n// Column draw loop prep cycle\n// - Prep item\n// - Prep sets props\n// - Prep returns list of cared about props\n// - Draw item\n// - Loop may set some items, if present in args list, set undefined\n// - Prep next item, giving previous result\n// - If next item type is different, de-prep\n// - Result per column\nfunction drawCells(ctx, effectiveColumns, allColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, freezeTrailingRows, hasAppendRow, drawRegions, damage, selection, prelightCells, highlightRegions, imageLoader, spriteManager, hoverValues, hoverInfo, drawCellCallback, hyperWrapping, outerTheme, enqueue, renderStateProvider, getCellRenderer, overrideCursor, minimumCellWidth) {\n    let toDraw = damage?.size ?? Number.MAX_SAFE_INTEGER;\n    const frameTime = performance.now();\n    let font = outerTheme.baseFontFull;\n    ctx.font = font;\n    const deprepArg = { ctx };\n    const cellIndex = [0, 0];\n    const freezeTrailingRowsHeight = freezeTrailingRows > 0 ? (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.getFreezeTrailingHeight)(rows, freezeTrailingRows, getRowHeight) : 0;\n    let result;\n    let handledSpans = undefined;\n    const skipPoint = (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_2__.getSkipPoint)(drawRegions);\n    (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_2__.walkColumns)(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawStartY, clipX, startRow) => {\n        const diff = Math.max(0, clipX - drawX);\n        const colDrawX = drawX + diff;\n        const colDrawY = totalHeaderHeight + 1;\n        const colWidth = c.width - diff;\n        const colHeight = height - totalHeaderHeight - 1;\n        if (drawRegions.length > 0) {\n            let found = false;\n            for (let i = 0; i < drawRegions.length; i++) {\n                const dr = drawRegions[i];\n                if ((0,_common_math_js__WEBPACK_IMPORTED_MODULE_3__.intersectRect)(colDrawX, colDrawY, colWidth, colHeight, dr.x, dr.y, dr.width, dr.height)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                return;\n        }\n        const reclip = () => {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(colDrawX, colDrawY, colWidth, colHeight);\n            ctx.clip();\n        };\n        const colSelected = selection.columns.hasIndex(c.sourceIndex);\n        const groupTheme = getGroupDetails(c.group ?? \"\").overrideTheme;\n        const colTheme = c.themeOverride === undefined && groupTheme === undefined\n            ? outerTheme\n            : (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_4__.mergeAndRealizeTheme)(outerTheme, groupTheme, c.themeOverride);\n        const colFont = colTheme.baseFontFull;\n        if (colFont !== font) {\n            font = colFont;\n            ctx.font = colFont;\n        }\n        reclip();\n        let prepResult = undefined;\n        (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_2__.walkRowsInCol)(startRow, colDrawStartY, height, rows, getRowHeight, freezeTrailingRows, hasAppendRow, skipPoint, (drawY, row, rh, isSticky, isTrailingRow) => {\n            if (row < 0)\n                return;\n            cellIndex[0] = c.sourceIndex;\n            cellIndex[1] = row;\n            // if (damage !== undefined && !damage.some(d => d[0] === c.sourceIndex && d[1] === row)) {\n            //     return;\n            // }\n            // if (\n            //     drawRegions.length > 0 &&\n            //     !drawRegions.some(dr => intersectRect(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height))\n            // ) {\n            //     return;\n            // }\n            // These are dumb versions of the above. I cannot for the life of believe that this matters but this is\n            // the tightest part of the draw loop and the allocations above actually has a very measurable impact\n            // on performance. For the love of all that is unholy please keep checking this again in the future.\n            // As soon as this doesn't have any impact of note go back to the saner looking code. The smoke test\n            // here is to scroll to the bottom of a test case first, then scroll back up while profiling and see\n            // how many major GC collections you get. These allocate a lot of objects.\n            if (damage !== undefined && !damage.has(cellIndex)) {\n                return;\n            }\n            if (drawRegions.length > 0) {\n                let found = false;\n                for (let i = 0; i < drawRegions.length; i++) {\n                    const dr = drawRegions[i];\n                    if ((0,_common_math_js__WEBPACK_IMPORTED_MODULE_3__.intersectRect)(drawX, drawY, c.width, rh, dr.x, dr.y, dr.width, dr.height)) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found)\n                    return;\n            }\n            const rowSelected = selection.rows.hasIndex(row);\n            const rowDisabled = disabledRows.hasIndex(row);\n            const cell = row < rows ? getCellContent(cellIndex) : loadingCell;\n            let cellX = drawX;\n            let cellWidth = c.width;\n            let drawingSpan = false;\n            let skipContents = false;\n            if (cell.span !== undefined) {\n                const [startCol, endCol] = cell.span;\n                const spanKey = `${row},${startCol},${endCol},${c.sticky}`; //alloc\n                if (handledSpans === undefined)\n                    handledSpans = new Set();\n                if (!handledSpans.has(spanKey)) {\n                    const areas = (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_2__.getSpanBounds)(cell.span, drawX, drawY, c.width, rh, c, allColumns);\n                    const area = c.sticky ? areas[0] : areas[1];\n                    if (!c.sticky && areas[0] !== undefined) {\n                        skipContents = true;\n                    }\n                    if (area !== undefined) {\n                        cellX = area.x;\n                        cellWidth = area.width;\n                        handledSpans.add(spanKey);\n                        ctx.restore();\n                        prepResult = undefined;\n                        ctx.save();\n                        ctx.beginPath();\n                        const d = Math.max(0, clipX - area.x);\n                        ctx.rect(area.x + d, drawY, area.width - d, rh);\n                        if (result === undefined) {\n                            result = [];\n                        }\n                        result.push({\n                            x: area.x + d,\n                            y: drawY,\n                            width: area.width - d,\n                            height: rh,\n                        });\n                        ctx.clip();\n                        drawingSpan = true;\n                    }\n                }\n                else {\n                    toDraw--;\n                    return;\n                }\n            }\n            const rowTheme = getRowThemeOverride?.(row);\n            const trailingTheme = isTrailingRow && c.trailingRowOptions?.themeOverride !== undefined\n                ? c.trailingRowOptions?.themeOverride\n                : undefined;\n            const theme = cell.themeOverride === undefined && rowTheme === undefined && trailingTheme === undefined\n                ? colTheme\n                : (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_4__.mergeAndRealizeTheme)(colTheme, rowTheme, trailingTheme, cell.themeOverride); //alloc\n            ctx.beginPath();\n            const isSelected = (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.cellIsSelected)(cellIndex, cell, selection);\n            let accentCount = (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.cellIsInRange)(cellIndex, cell, selection, drawFocus);\n            const spanIsHighlighted = cell.span !== undefined &&\n                selection.columns.some(index => cell.span !== undefined && index >= cell.span[0] && index <= cell.span[1] //alloc\n                );\n            if (isSelected && !isFocused && drawFocus) {\n                accentCount = 0;\n            }\n            else if (isSelected && drawFocus) {\n                accentCount = Math.max(accentCount, 1);\n            }\n            if (spanIsHighlighted) {\n                accentCount++;\n            }\n            if (!isSelected) {\n                if (rowSelected)\n                    accentCount++;\n                if (colSelected && !isTrailingRow)\n                    accentCount++;\n            }\n            const bgCell = cell.kind === _data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.GridCellKind.Protected ? theme.bgCellMedium : theme.bgCell;\n            let fill;\n            if (isSticky || bgCell !== outerTheme.bgCell) {\n                fill = (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blend)(bgCell, fill);\n            }\n            if (accentCount > 0 || rowDisabled) {\n                if (rowDisabled) {\n                    fill = (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blend)(theme.bgHeader, fill);\n                }\n                for (let i = 0; i < accentCount; i++) {\n                    fill = (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blend)(theme.accentLight, fill);\n                }\n            }\n            else if (prelightCells !== undefined) {\n                for (const pre of prelightCells) {\n                    if (pre[0] === c.sourceIndex && pre[1] === row) {\n                        fill = (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blend)(theme.bgSearchResult, fill);\n                        break;\n                    }\n                }\n            }\n            if (highlightRegions !== undefined) {\n                for (let i = 0; i < highlightRegions.length; i++) {\n                    const region = highlightRegions[i];\n                    const r = region.range;\n                    if (region.style !== \"solid-outline\" &&\n                        r.x <= c.sourceIndex &&\n                        c.sourceIndex < r.x + r.width &&\n                        r.y <= row &&\n                        row < r.y + r.height) {\n                        fill = (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blend)(region.color, fill);\n                    }\n                }\n            }\n            let didDamageClip = false;\n            if (damage !== undefined) {\n                // we want to clip each cell individually rather than form a super clip region. The reason for\n                // this is passing too many clip regions to the GPU at once can cause a performance hit. This\n                // allows us to damage a large number of cells at once without issue.\n                const top = drawY + 1;\n                const bottom = isSticky\n                    ? top + rh - 1\n                    : Math.min(top + rh - 1, height - freezeTrailingRowsHeight);\n                const h = bottom - top;\n                // however, not clipping at all is even better. We want to clip if we are the left most col\n                // or overlapping the bottom clip area.\n                if (h !== rh - 1 || cellX + 1 <= clipX) {\n                    didDamageClip = true;\n                    ctx.save();\n                    ctx.beginPath();\n                    ctx.rect(cellX + 1, top, cellWidth - 1, h);\n                    ctx.clip();\n                }\n                // we also need to make sure to wipe the contents. Since the fill can do that lets repurpose\n                // that call to avoid an extra draw call.\n                fill = fill === undefined ? theme.bgCell : (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blend)(fill, theme.bgCell);\n            }\n            const isLastColumn = c.sourceIndex === allColumns.length - 1;\n            const isLastRow = row === rows - 1;\n            if (fill !== undefined) {\n                ctx.fillStyle = fill;\n                if (prepResult !== undefined) {\n                    prepResult.fillStyle = fill;\n                }\n                if (damage !== undefined) {\n                    // this accounts for the fill handle outline being drawn inset on these cells. We do this\n                    // because technically the bottom right corner of the outline are on other cells.\n                    ctx.fillRect(cellX + 1, drawY + 1, cellWidth - (isLastColumn ? 2 : 1), rh - (isLastRow ? 2 : 1));\n                }\n                else {\n                    ctx.fillRect(cellX, drawY, cellWidth, rh);\n                }\n            }\n            if (cell.style === \"faded\") {\n                ctx.globalAlpha = 0.6;\n            }\n            let hoverValue;\n            for (let i = 0; i < hoverValues.length; i++) {\n                const hv = hoverValues[i];\n                if (hv.item[0] === c.sourceIndex && hv.item[1] === row) {\n                    hoverValue = hv;\n                    break;\n                }\n            }\n            if (cellWidth > minimumCellWidth && !skipContents) {\n                const cellFont = theme.baseFontFull;\n                if (cellFont !== font) {\n                    ctx.font = cellFont;\n                    font = cellFont;\n                }\n                prepResult = drawCell(ctx, cell, c.sourceIndex, row, isLastColumn, isLastRow, cellX, drawY, cellWidth, rh, accentCount > 0, theme, fill ?? theme.bgCell, imageLoader, spriteManager, hoverValue?.hoverAmount ?? 0, hoverInfo, hyperWrapping, frameTime, drawCellCallback, prepResult, enqueue, renderStateProvider, getCellRenderer, overrideCursor);\n            }\n            if (didDamageClip) {\n                ctx.restore();\n            }\n            if (cell.style === \"faded\") {\n                ctx.globalAlpha = 1;\n            }\n            toDraw--;\n            if (drawingSpan) {\n                ctx.restore();\n                prepResult?.deprep?.(deprepArg);\n                prepResult = undefined;\n                reclip();\n                font = colFont;\n                ctx.font = colFont;\n            }\n            return toDraw <= 0;\n        });\n        ctx.restore();\n        return toDraw <= 0;\n    });\n    return result;\n}\nconst allocatedItem = [0, 0];\nconst reusableRect = { x: 0, y: 0, width: 0, height: 0 };\nconst drawState = [undefined, () => undefined];\nlet animationFrameRequested = false;\nfunction animRequest() {\n    animationFrameRequested = true;\n}\nfunction drawCell(ctx, cell, col, row, isLastCol, isLastRow, x, y, w, h, highlighted, theme, finalCellFillColor, imageLoader, spriteManager, hoverAmount, hoverInfo, hyperWrapping, frameTime, drawCellCallback, lastPrep, enqueue, renderStateProvider, getCellRenderer, overrideCursor) {\n    let hoverX;\n    let hoverY;\n    if (hoverInfo !== undefined && hoverInfo[0][0] === col && hoverInfo[0][1] === row) {\n        hoverX = hoverInfo[1][0];\n        hoverY = hoverInfo[1][1];\n    }\n    let result = undefined;\n    allocatedItem[0] = col;\n    allocatedItem[1] = row;\n    reusableRect.x = x;\n    reusableRect.y = y;\n    reusableRect.width = w;\n    reusableRect.height = h;\n    drawState[0] = renderStateProvider.getValue(allocatedItem);\n    drawState[1] = (val) => renderStateProvider.setValue(allocatedItem, val); //alloc\n    animationFrameRequested = false;\n    const args = {\n        //alloc\n        ctx,\n        theme,\n        col,\n        row,\n        cell,\n        rect: reusableRect,\n        highlighted,\n        cellFillColor: finalCellFillColor,\n        hoverAmount,\n        frameTime,\n        hoverX,\n        drawState,\n        hoverY,\n        imageLoader,\n        spriteManager,\n        hyperWrapping,\n        overrideCursor: hoverX !== undefined ? overrideCursor : undefined,\n        requestAnimationFrame: animRequest,\n    };\n    const needsAnim = (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.drawLastUpdateUnderlay)(args, cell.lastUpdated, frameTime, lastPrep, isLastCol, isLastRow);\n    const r = getCellRenderer(cell);\n    if (r !== undefined) {\n        if (lastPrep?.renderer !== r) {\n            lastPrep?.deprep?.(args);\n            lastPrep = undefined;\n        }\n        const partialPrepResult = r.drawPrep?.(args, lastPrep);\n        if (drawCellCallback !== undefined && !(0,_data_grid_types_js__WEBPACK_IMPORTED_MODULE_0__.isInnerOnlyCell)(args.cell)) {\n            drawCellCallback(args, () => r.draw(args, cell));\n        }\n        else {\n            r.draw(args, cell);\n        }\n        result =\n            partialPrepResult === undefined\n                ? undefined\n                : {\n                    deprep: partialPrepResult?.deprep,\n                    fillStyle: partialPrepResult?.fillStyle,\n                    font: partialPrepResult?.font,\n                    renderer: r,\n                };\n    }\n    if (needsAnim || animationFrameRequested)\n        enqueue?.(allocatedItem);\n    return result;\n}\n//# sourceMappingURL=data-grid-render.cells.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmNlbGxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUN5RztBQUNoRTtBQUM0RTtBQUNwRDtBQUN0QjtBQUNhO0FBQzZDO0FBQ3JHO0FBQ0EsVUFBVSw2REFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDhEQUE4RCwwRUFBdUI7QUFDckY7QUFDQTtBQUNBLHNCQUFzQix1RUFBWTtBQUNsQyxJQUFJLHNFQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0Esb0JBQW9CLDhEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVFQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0VBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBLHdCQUF3Qiw4REFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJLEdBQUcsU0FBUyxHQUFHLE9BQU8sR0FBRyxTQUFTLEdBQUc7QUFDNUU7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdFQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1RUFBb0IseURBQXlEO0FBQy9GO0FBQ0EsK0JBQStCLGlFQUFjO0FBQzdDLDhCQUE4QixnRUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkRBQVk7QUFDckQ7QUFDQTtBQUNBLHVCQUF1Qix1REFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdURBQUs7QUFDaEM7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pELDJCQUEyQix1REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx1REFBSztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlFQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvRUFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmNlbGxzLmpzPzM3ODkiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSB1bmljb3JuL25vLWZvci1sb29wICovXG5pbXBvcnQgeyBDb21wYWN0U2VsZWN0aW9uLCBHcmlkQ29sdW1uSWNvbiwgR3JpZENlbGxLaW5kLCBpc0lubmVyT25seUNlbGwsIH0gZnJvbSBcIi4uL2RhdGEtZ3JpZC10eXBlcy5qc1wiO1xuaW1wb3J0IHsgQ2VsbFNldCB9IGZyb20gXCIuLi9jZWxsLXNldC5qc1wiO1xuaW1wb3J0IHsgY2VsbElzU2VsZWN0ZWQsIGNlbGxJc0luUmFuZ2UsIGdldEZyZWV6ZVRyYWlsaW5nSGVpZ2h0LCBkcmF3TGFzdFVwZGF0ZVVuZGVybGF5LCB9IGZyb20gXCIuL2RhdGEtZ3JpZC1saWIuanNcIjtcbmltcG9ydCB7IG1lcmdlQW5kUmVhbGl6ZVRoZW1lIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9zdHlsZXMuanNcIjtcbmltcG9ydCB7IGJsZW5kIH0gZnJvbSBcIi4uL2NvbG9yLXBhcnNlci5qc1wiO1xuaW1wb3J0IHsgaW50ZXJzZWN0UmVjdCB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vbWF0aC5qc1wiO1xuaW1wb3J0IHsgZ2V0U2tpcFBvaW50LCBnZXRTcGFuQm91bmRzLCB3YWxrQ29sdW1ucywgd2Fsa1Jvd3NJbkNvbCB9IGZyb20gXCIuL2RhdGEtZ3JpZC1yZW5kZXIud2Fsay5qc1wiO1xuY29uc3QgbG9hZGluZ0NlbGwgPSB7XG4gICAga2luZDogR3JpZENlbGxLaW5kLkxvYWRpbmcsXG4gICAgYWxsb3dPdmVybGF5OiBmYWxzZSxcbn07XG4vLyBwcmVwcGFibGUgaXRlbXM6XG4vLyAtIGZvbnRcbi8vIC0gZmlsbFN0eWxlXG4vLyBDb2x1bW4gZHJhdyBsb29wIHByZXAgY3ljbGVcbi8vIC0gUHJlcCBpdGVtXG4vLyAtIFByZXAgc2V0cyBwcm9wc1xuLy8gLSBQcmVwIHJldHVybnMgbGlzdCBvZiBjYXJlZCBhYm91dCBwcm9wc1xuLy8gLSBEcmF3IGl0ZW1cbi8vIC0gTG9vcCBtYXkgc2V0IHNvbWUgaXRlbXMsIGlmIHByZXNlbnQgaW4gYXJncyBsaXN0LCBzZXQgdW5kZWZpbmVkXG4vLyAtIFByZXAgbmV4dCBpdGVtLCBnaXZpbmcgcHJldmlvdXMgcmVzdWx0XG4vLyAtIElmIG5leHQgaXRlbSB0eXBlIGlzIGRpZmZlcmVudCwgZGUtcHJlcFxuLy8gLSBSZXN1bHQgcGVyIGNvbHVtblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdDZWxscyhjdHgsIGVmZmVjdGl2ZUNvbHVtbnMsIGFsbENvbHVtbnMsIGhlaWdodCwgdG90YWxIZWFkZXJIZWlnaHQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIGNlbGxZT2Zmc2V0LCByb3dzLCBnZXRSb3dIZWlnaHQsIGdldENlbGxDb250ZW50LCBnZXRHcm91cERldGFpbHMsIGdldFJvd1RoZW1lT3ZlcnJpZGUsIGRpc2FibGVkUm93cywgaXNGb2N1c2VkLCBkcmF3Rm9jdXMsIGZyZWV6ZVRyYWlsaW5nUm93cywgaGFzQXBwZW5kUm93LCBkcmF3UmVnaW9ucywgZGFtYWdlLCBzZWxlY3Rpb24sIHByZWxpZ2h0Q2VsbHMsIGhpZ2hsaWdodFJlZ2lvbnMsIGltYWdlTG9hZGVyLCBzcHJpdGVNYW5hZ2VyLCBob3ZlclZhbHVlcywgaG92ZXJJbmZvLCBkcmF3Q2VsbENhbGxiYWNrLCBoeXBlcldyYXBwaW5nLCBvdXRlclRoZW1lLCBlbnF1ZXVlLCByZW5kZXJTdGF0ZVByb3ZpZGVyLCBnZXRDZWxsUmVuZGVyZXIsIG92ZXJyaWRlQ3Vyc29yLCBtaW5pbXVtQ2VsbFdpZHRoKSB7XG4gICAgbGV0IHRvRHJhdyA9IGRhbWFnZT8uc2l6ZSA/PyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBjb25zdCBmcmFtZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBsZXQgZm9udCA9IG91dGVyVGhlbWUuYmFzZUZvbnRGdWxsO1xuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICBjb25zdCBkZXByZXBBcmcgPSB7IGN0eCB9O1xuICAgIGNvbnN0IGNlbGxJbmRleCA9IFswLCAwXTtcbiAgICBjb25zdCBmcmVlemVUcmFpbGluZ1Jvd3NIZWlnaHQgPSBmcmVlemVUcmFpbGluZ1Jvd3MgPiAwID8gZ2V0RnJlZXplVHJhaWxpbmdIZWlnaHQocm93cywgZnJlZXplVHJhaWxpbmdSb3dzLCBnZXRSb3dIZWlnaHQpIDogMDtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBoYW5kbGVkU3BhbnMgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc2tpcFBvaW50ID0gZ2V0U2tpcFBvaW50KGRyYXdSZWdpb25zKTtcbiAgICB3YWxrQ29sdW1ucyhlZmZlY3RpdmVDb2x1bW5zLCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgdG90YWxIZWFkZXJIZWlnaHQsIChjLCBkcmF3WCwgY29sRHJhd1N0YXJ0WSwgY2xpcFgsIHN0YXJ0Um93KSA9PiB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLm1heCgwLCBjbGlwWCAtIGRyYXdYKTtcbiAgICAgICAgY29uc3QgY29sRHJhd1ggPSBkcmF3WCArIGRpZmY7XG4gICAgICAgIGNvbnN0IGNvbERyYXdZID0gdG90YWxIZWFkZXJIZWlnaHQgKyAxO1xuICAgICAgICBjb25zdCBjb2xXaWR0aCA9IGMud2lkdGggLSBkaWZmO1xuICAgICAgICBjb25zdCBjb2xIZWlnaHQgPSBoZWlnaHQgLSB0b3RhbEhlYWRlckhlaWdodCAtIDE7XG4gICAgICAgIGlmIChkcmF3UmVnaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJhd1JlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkciA9IGRyYXdSZWdpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RSZWN0KGNvbERyYXdYLCBjb2xEcmF3WSwgY29sV2lkdGgsIGNvbEhlaWdodCwgZHIueCwgZHIueSwgZHIud2lkdGgsIGRyLmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWNsaXAgPSAoKSA9PiB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QoY29sRHJhd1gsIGNvbERyYXdZLCBjb2xXaWR0aCwgY29sSGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbFNlbGVjdGVkID0gc2VsZWN0aW9uLmNvbHVtbnMuaGFzSW5kZXgoYy5zb3VyY2VJbmRleCk7XG4gICAgICAgIGNvbnN0IGdyb3VwVGhlbWUgPSBnZXRHcm91cERldGFpbHMoYy5ncm91cCA/PyBcIlwiKS5vdmVycmlkZVRoZW1lO1xuICAgICAgICBjb25zdCBjb2xUaGVtZSA9IGMudGhlbWVPdmVycmlkZSA9PT0gdW5kZWZpbmVkICYmIGdyb3VwVGhlbWUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBvdXRlclRoZW1lXG4gICAgICAgICAgICA6IG1lcmdlQW5kUmVhbGl6ZVRoZW1lKG91dGVyVGhlbWUsIGdyb3VwVGhlbWUsIGMudGhlbWVPdmVycmlkZSk7XG4gICAgICAgIGNvbnN0IGNvbEZvbnQgPSBjb2xUaGVtZS5iYXNlRm9udEZ1bGw7XG4gICAgICAgIGlmIChjb2xGb250ICE9PSBmb250KSB7XG4gICAgICAgICAgICBmb250ID0gY29sRm9udDtcbiAgICAgICAgICAgIGN0eC5mb250ID0gY29sRm9udDtcbiAgICAgICAgfVxuICAgICAgICByZWNsaXAoKTtcbiAgICAgICAgbGV0IHByZXBSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdhbGtSb3dzSW5Db2woc3RhcnRSb3csIGNvbERyYXdTdGFydFksIGhlaWdodCwgcm93cywgZ2V0Um93SGVpZ2h0LCBmcmVlemVUcmFpbGluZ1Jvd3MsIGhhc0FwcGVuZFJvdywgc2tpcFBvaW50LCAoZHJhd1ksIHJvdywgcmgsIGlzU3RpY2t5LCBpc1RyYWlsaW5nUm93KSA9PiB7XG4gICAgICAgICAgICBpZiAocm93IDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjZWxsSW5kZXhbMF0gPSBjLnNvdXJjZUluZGV4O1xuICAgICAgICAgICAgY2VsbEluZGV4WzFdID0gcm93O1xuICAgICAgICAgICAgLy8gaWYgKGRhbWFnZSAhPT0gdW5kZWZpbmVkICYmICFkYW1hZ2Uuc29tZShkID0+IGRbMF0gPT09IGMuc291cmNlSW5kZXggJiYgZFsxXSA9PT0gcm93KSkge1xuICAgICAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGlmIChcbiAgICAgICAgICAgIC8vICAgICBkcmF3UmVnaW9ucy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAvLyAgICAgIWRyYXdSZWdpb25zLnNvbWUoZHIgPT4gaW50ZXJzZWN0UmVjdChkcmF3WCwgZHJhd1ksIGMud2lkdGgsIHJoLCBkci54LCBkci55LCBkci53aWR0aCwgZHIuaGVpZ2h0KSlcbiAgICAgICAgICAgIC8vICkge1xuICAgICAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBkdW1iIHZlcnNpb25zIG9mIHRoZSBhYm92ZS4gSSBjYW5ub3QgZm9yIHRoZSBsaWZlIG9mIGJlbGlldmUgdGhhdCB0aGlzIG1hdHRlcnMgYnV0IHRoaXMgaXNcbiAgICAgICAgICAgIC8vIHRoZSB0aWdodGVzdCBwYXJ0IG9mIHRoZSBkcmF3IGxvb3AgYW5kIHRoZSBhbGxvY2F0aW9ucyBhYm92ZSBhY3R1YWxseSBoYXMgYSB2ZXJ5IG1lYXN1cmFibGUgaW1wYWN0XG4gICAgICAgICAgICAvLyBvbiBwZXJmb3JtYW5jZS4gRm9yIHRoZSBsb3ZlIG9mIGFsbCB0aGF0IGlzIHVuaG9seSBwbGVhc2Uga2VlcCBjaGVja2luZyB0aGlzIGFnYWluIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBBcyBzb29uIGFzIHRoaXMgZG9lc24ndCBoYXZlIGFueSBpbXBhY3Qgb2Ygbm90ZSBnbyBiYWNrIHRvIHRoZSBzYW5lciBsb29raW5nIGNvZGUuIFRoZSBzbW9rZSB0ZXN0XG4gICAgICAgICAgICAvLyBoZXJlIGlzIHRvIHNjcm9sbCB0byB0aGUgYm90dG9tIG9mIGEgdGVzdCBjYXNlIGZpcnN0LCB0aGVuIHNjcm9sbCBiYWNrIHVwIHdoaWxlIHByb2ZpbGluZyBhbmQgc2VlXG4gICAgICAgICAgICAvLyBob3cgbWFueSBtYWpvciBHQyBjb2xsZWN0aW9ucyB5b3UgZ2V0LiBUaGVzZSBhbGxvY2F0ZSBhIGxvdCBvZiBvYmplY3RzLlxuICAgICAgICAgICAgaWYgKGRhbWFnZSAhPT0gdW5kZWZpbmVkICYmICFkYW1hZ2UuaGFzKGNlbGxJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhd1JlZ2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJhd1JlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHIgPSBkcmF3UmVnaW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdFJlY3QoZHJhd1gsIGRyYXdZLCBjLndpZHRoLCByaCwgZHIueCwgZHIueSwgZHIud2lkdGgsIGRyLmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvd1NlbGVjdGVkID0gc2VsZWN0aW9uLnJvd3MuaGFzSW5kZXgocm93KTtcbiAgICAgICAgICAgIGNvbnN0IHJvd0Rpc2FibGVkID0gZGlzYWJsZWRSb3dzLmhhc0luZGV4KHJvdyk7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gcm93IDwgcm93cyA/IGdldENlbGxDb250ZW50KGNlbGxJbmRleCkgOiBsb2FkaW5nQ2VsbDtcbiAgICAgICAgICAgIGxldCBjZWxsWCA9IGRyYXdYO1xuICAgICAgICAgICAgbGV0IGNlbGxXaWR0aCA9IGMud2lkdGg7XG4gICAgICAgICAgICBsZXQgZHJhd2luZ1NwYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBza2lwQ29udGVudHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjZWxsLnNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzdGFydENvbCwgZW5kQ29sXSA9IGNlbGwuc3BhbjtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFuS2V5ID0gYCR7cm93fSwke3N0YXJ0Q29sfSwke2VuZENvbH0sJHtjLnN0aWNreX1gOyAvL2FsbG9jXG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZWRTcGFucyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVkU3BhbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGVkU3BhbnMuaGFzKHNwYW5LZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZWFzID0gZ2V0U3BhbkJvdW5kcyhjZWxsLnNwYW4sIGRyYXdYLCBkcmF3WSwgYy53aWR0aCwgcmgsIGMsIGFsbENvbHVtbnMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmVhID0gYy5zdGlja3kgPyBhcmVhc1swXSA6IGFyZWFzWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWMuc3RpY2t5ICYmIGFyZWFzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBDb250ZW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFggPSBhcmVhLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsV2lkdGggPSBhcmVhLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlZFNwYW5zLmFkZChzcGFuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVwUmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBNYXRoLm1heCgwLCBjbGlwWCAtIGFyZWEueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChhcmVhLnggKyBkLCBkcmF3WSwgYXJlYS53aWR0aCAtIGQsIHJoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGFyZWEueCArIGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogZHJhd1ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGFyZWEud2lkdGggLSBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcmgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3aW5nU3BhbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvRHJhdy0tO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm93VGhlbWUgPSBnZXRSb3dUaGVtZU92ZXJyaWRlPy4ocm93KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsaW5nVGhlbWUgPSBpc1RyYWlsaW5nUm93ICYmIGMudHJhaWxpbmdSb3dPcHRpb25zPy50aGVtZU92ZXJyaWRlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGMudHJhaWxpbmdSb3dPcHRpb25zPy50aGVtZU92ZXJyaWRlXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB0aGVtZSA9IGNlbGwudGhlbWVPdmVycmlkZSA9PT0gdW5kZWZpbmVkICYmIHJvd1RoZW1lID09PSB1bmRlZmluZWQgJiYgdHJhaWxpbmdUaGVtZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjb2xUaGVtZVxuICAgICAgICAgICAgICAgIDogbWVyZ2VBbmRSZWFsaXplVGhlbWUoY29sVGhlbWUsIHJvd1RoZW1lLCB0cmFpbGluZ1RoZW1lLCBjZWxsLnRoZW1lT3ZlcnJpZGUpOyAvL2FsbG9jXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb25zdCBpc1NlbGVjdGVkID0gY2VsbElzU2VsZWN0ZWQoY2VsbEluZGV4LCBjZWxsLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgbGV0IGFjY2VudENvdW50ID0gY2VsbElzSW5SYW5nZShjZWxsSW5kZXgsIGNlbGwsIHNlbGVjdGlvbiwgZHJhd0ZvY3VzKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYW5Jc0hpZ2hsaWdodGVkID0gY2VsbC5zcGFuICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uY29sdW1ucy5zb21lKGluZGV4ID0+IGNlbGwuc3BhbiAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID49IGNlbGwuc3BhblswXSAmJiBpbmRleCA8PSBjZWxsLnNwYW5bMV0gLy9hbGxvY1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RlZCAmJiAhaXNGb2N1c2VkICYmIGRyYXdGb2N1cykge1xuICAgICAgICAgICAgICAgIGFjY2VudENvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2VsZWN0ZWQgJiYgZHJhd0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgYWNjZW50Q291bnQgPSBNYXRoLm1heChhY2NlbnRDb3VudCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BhbklzSGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgICAgICAgICBhY2NlbnRDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd1NlbGVjdGVkKVxuICAgICAgICAgICAgICAgICAgICBhY2NlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb2xTZWxlY3RlZCAmJiAhaXNUcmFpbGluZ1JvdylcbiAgICAgICAgICAgICAgICAgICAgYWNjZW50Q291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJnQ2VsbCA9IGNlbGwua2luZCA9PT0gR3JpZENlbGxLaW5kLlByb3RlY3RlZCA/IHRoZW1lLmJnQ2VsbE1lZGl1bSA6IHRoZW1lLmJnQ2VsbDtcbiAgICAgICAgICAgIGxldCBmaWxsO1xuICAgICAgICAgICAgaWYgKGlzU3RpY2t5IHx8IGJnQ2VsbCAhPT0gb3V0ZXJUaGVtZS5iZ0NlbGwpIHtcbiAgICAgICAgICAgICAgICBmaWxsID0gYmxlbmQoYmdDZWxsLCBmaWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY2NlbnRDb3VudCA+IDAgfHwgcm93RGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93RGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbCA9IGJsZW5kKHRoZW1lLmJnSGVhZGVyLCBmaWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2NlbnRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwgPSBibGVuZCh0aGVtZS5hY2NlbnRMaWdodCwgZmlsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlbGlnaHRDZWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmUgb2YgcHJlbGlnaHRDZWxscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlWzBdID09PSBjLnNvdXJjZUluZGV4ICYmIHByZVsxXSA9PT0gcm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsID0gYmxlbmQodGhlbWUuYmdTZWFyY2hSZXN1bHQsIGZpbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGlnaGxpZ2h0UmVnaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoaWdobGlnaHRSZWdpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lvbiA9IGhpZ2hsaWdodFJlZ2lvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZWdpb24ucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdpb24uc3R5bGUgIT09IFwic29saWQtb3V0bGluZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByLnggPD0gYy5zb3VyY2VJbmRleCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYy5zb3VyY2VJbmRleCA8IHIueCArIHIud2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHIueSA8PSByb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA8IHIueSArIHIuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsID0gYmxlbmQocmVnaW9uLmNvbG9yLCBmaWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkaWREYW1hZ2VDbGlwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGFtYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGNsaXAgZWFjaCBjZWxsIGluZGl2aWR1YWxseSByYXRoZXIgdGhhbiBmb3JtIGEgc3VwZXIgY2xpcCByZWdpb24uIFRoZSByZWFzb24gZm9yXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBwYXNzaW5nIHRvbyBtYW55IGNsaXAgcmVnaW9ucyB0byB0aGUgR1BVIGF0IG9uY2UgY2FuIGNhdXNlIGEgcGVyZm9ybWFuY2UgaGl0LiBUaGlzXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIHVzIHRvIGRhbWFnZSBhIGxhcmdlIG51bWJlciBvZiBjZWxscyBhdCBvbmNlIHdpdGhvdXQgaXNzdWUuXG4gICAgICAgICAgICAgICAgY29uc3QgdG9wID0gZHJhd1kgKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGlzU3RpY2t5XG4gICAgICAgICAgICAgICAgICAgID8gdG9wICsgcmggLSAxXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4odG9wICsgcmggLSAxLCBoZWlnaHQgLSBmcmVlemVUcmFpbGluZ1Jvd3NIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGggPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICAgICAgLy8gaG93ZXZlciwgbm90IGNsaXBwaW5nIGF0IGFsbCBpcyBldmVuIGJldHRlci4gV2Ugd2FudCB0byBjbGlwIGlmIHdlIGFyZSB0aGUgbGVmdCBtb3N0IGNvbFxuICAgICAgICAgICAgICAgIC8vIG9yIG92ZXJsYXBwaW5nIHRoZSBib3R0b20gY2xpcCBhcmVhLlxuICAgICAgICAgICAgICAgIGlmIChoICE9PSByaCAtIDEgfHwgY2VsbFggKyAxIDw9IGNsaXBYKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZERhbWFnZUNsaXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGNlbGxYICsgMSwgdG9wLCBjZWxsV2lkdGggLSAxLCBoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2UgYWxzbyBuZWVkIHRvIG1ha2Ugc3VyZSB0byB3aXBlIHRoZSBjb250ZW50cy4gU2luY2UgdGhlIGZpbGwgY2FuIGRvIHRoYXQgbGV0cyByZXB1cnBvc2VcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNhbGwgdG8gYXZvaWQgYW4gZXh0cmEgZHJhdyBjYWxsLlxuICAgICAgICAgICAgICAgIGZpbGwgPSBmaWxsID09PSB1bmRlZmluZWQgPyB0aGVtZS5iZ0NlbGwgOiBibGVuZChmaWxsLCB0aGVtZS5iZ0NlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNMYXN0Q29sdW1uID0gYy5zb3VyY2VJbmRleCA9PT0gYWxsQ29sdW1ucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgaXNMYXN0Um93ID0gcm93ID09PSByb3dzIC0gMTtcbiAgICAgICAgICAgIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgICAgICAgICBpZiAocHJlcFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXBSZXN1bHQuZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhbWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYWNjb3VudHMgZm9yIHRoZSBmaWxsIGhhbmRsZSBvdXRsaW5lIGJlaW5nIGRyYXduIGluc2V0IG9uIHRoZXNlIGNlbGxzLiBXZSBkbyB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGVjaG5pY2FsbHkgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIG91dGxpbmUgYXJlIG9uIG90aGVyIGNlbGxzLlxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2VsbFggKyAxLCBkcmF3WSArIDEsIGNlbGxXaWR0aCAtIChpc0xhc3RDb2x1bW4gPyAyIDogMSksIHJoIC0gKGlzTGFzdFJvdyA/IDIgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2VsbFgsIGRyYXdZLCBjZWxsV2lkdGgsIHJoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VsbC5zdHlsZSA9PT0gXCJmYWRlZFwiKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhvdmVyVmFsdWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvdmVyVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHYgPSBob3ZlclZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaHYuaXRlbVswXSA9PT0gYy5zb3VyY2VJbmRleCAmJiBodi5pdGVtWzFdID09PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJWYWx1ZSA9IGh2O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VsbFdpZHRoID4gbWluaW11bUNlbGxXaWR0aCAmJiAhc2tpcENvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbEZvbnQgPSB0aGVtZS5iYXNlRm9udEZ1bGw7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxGb250ICE9PSBmb250KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5mb250ID0gY2VsbEZvbnQ7XG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBjZWxsRm9udDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJlcFJlc3VsdCA9IGRyYXdDZWxsKGN0eCwgY2VsbCwgYy5zb3VyY2VJbmRleCwgcm93LCBpc0xhc3RDb2x1bW4sIGlzTGFzdFJvdywgY2VsbFgsIGRyYXdZLCBjZWxsV2lkdGgsIHJoLCBhY2NlbnRDb3VudCA+IDAsIHRoZW1lLCBmaWxsID8/IHRoZW1lLmJnQ2VsbCwgaW1hZ2VMb2FkZXIsIHNwcml0ZU1hbmFnZXIsIGhvdmVyVmFsdWU/LmhvdmVyQW1vdW50ID8/IDAsIGhvdmVySW5mbywgaHlwZXJXcmFwcGluZywgZnJhbWVUaW1lLCBkcmF3Q2VsbENhbGxiYWNrLCBwcmVwUmVzdWx0LCBlbnF1ZXVlLCByZW5kZXJTdGF0ZVByb3ZpZGVyLCBnZXRDZWxsUmVuZGVyZXIsIG92ZXJyaWRlQ3Vyc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWREYW1hZ2VDbGlwKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjZWxsLnN0eWxlID09PSBcImZhZGVkXCIpIHtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9EcmF3LS07XG4gICAgICAgICAgICBpZiAoZHJhd2luZ1NwYW4pIHtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIHByZXBSZXN1bHQ/LmRlcHJlcD8uKGRlcHJlcEFyZyk7XG4gICAgICAgICAgICAgICAgcHJlcFJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZWNsaXAoKTtcbiAgICAgICAgICAgICAgICBmb250ID0gY29sRm9udDtcbiAgICAgICAgICAgICAgICBjdHguZm9udCA9IGNvbEZvbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9EcmF3IDw9IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gdG9EcmF3IDw9IDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGFsbG9jYXRlZEl0ZW0gPSBbMCwgMF07XG5jb25zdCByZXVzYWJsZVJlY3QgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbmNvbnN0IGRyYXdTdGF0ZSA9IFt1bmRlZmluZWQsICgpID0+IHVuZGVmaW5lZF07XG5sZXQgYW5pbWF0aW9uRnJhbWVSZXF1ZXN0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGFuaW1SZXF1ZXN0KCkge1xuICAgIGFuaW1hdGlvbkZyYW1lUmVxdWVzdGVkID0gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkcmF3Q2VsbChjdHgsIGNlbGwsIGNvbCwgcm93LCBpc0xhc3RDb2wsIGlzTGFzdFJvdywgeCwgeSwgdywgaCwgaGlnaGxpZ2h0ZWQsIHRoZW1lLCBmaW5hbENlbGxGaWxsQ29sb3IsIGltYWdlTG9hZGVyLCBzcHJpdGVNYW5hZ2VyLCBob3ZlckFtb3VudCwgaG92ZXJJbmZvLCBoeXBlcldyYXBwaW5nLCBmcmFtZVRpbWUsIGRyYXdDZWxsQ2FsbGJhY2ssIGxhc3RQcmVwLCBlbnF1ZXVlLCByZW5kZXJTdGF0ZVByb3ZpZGVyLCBnZXRDZWxsUmVuZGVyZXIsIG92ZXJyaWRlQ3Vyc29yKSB7XG4gICAgbGV0IGhvdmVyWDtcbiAgICBsZXQgaG92ZXJZO1xuICAgIGlmIChob3ZlckluZm8gIT09IHVuZGVmaW5lZCAmJiBob3ZlckluZm9bMF1bMF0gPT09IGNvbCAmJiBob3ZlckluZm9bMF1bMV0gPT09IHJvdykge1xuICAgICAgICBob3ZlclggPSBob3ZlckluZm9bMV1bMF07XG4gICAgICAgIGhvdmVyWSA9IGhvdmVySW5mb1sxXVsxXTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICBhbGxvY2F0ZWRJdGVtWzBdID0gY29sO1xuICAgIGFsbG9jYXRlZEl0ZW1bMV0gPSByb3c7XG4gICAgcmV1c2FibGVSZWN0LnggPSB4O1xuICAgIHJldXNhYmxlUmVjdC55ID0geTtcbiAgICByZXVzYWJsZVJlY3Qud2lkdGggPSB3O1xuICAgIHJldXNhYmxlUmVjdC5oZWlnaHQgPSBoO1xuICAgIGRyYXdTdGF0ZVswXSA9IHJlbmRlclN0YXRlUHJvdmlkZXIuZ2V0VmFsdWUoYWxsb2NhdGVkSXRlbSk7XG4gICAgZHJhd1N0YXRlWzFdID0gKHZhbCkgPT4gcmVuZGVyU3RhdGVQcm92aWRlci5zZXRWYWx1ZShhbGxvY2F0ZWRJdGVtLCB2YWwpOyAvL2FsbG9jXG4gICAgYW5pbWF0aW9uRnJhbWVSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICAvL2FsbG9jXG4gICAgICAgIGN0eCxcbiAgICAgICAgdGhlbWUsXG4gICAgICAgIGNvbCxcbiAgICAgICAgcm93LFxuICAgICAgICBjZWxsLFxuICAgICAgICByZWN0OiByZXVzYWJsZVJlY3QsXG4gICAgICAgIGhpZ2hsaWdodGVkLFxuICAgICAgICBjZWxsRmlsbENvbG9yOiBmaW5hbENlbGxGaWxsQ29sb3IsXG4gICAgICAgIGhvdmVyQW1vdW50LFxuICAgICAgICBmcmFtZVRpbWUsXG4gICAgICAgIGhvdmVyWCxcbiAgICAgICAgZHJhd1N0YXRlLFxuICAgICAgICBob3ZlclksXG4gICAgICAgIGltYWdlTG9hZGVyLFxuICAgICAgICBzcHJpdGVNYW5hZ2VyLFxuICAgICAgICBoeXBlcldyYXBwaW5nLFxuICAgICAgICBvdmVycmlkZUN1cnNvcjogaG92ZXJYICE9PSB1bmRlZmluZWQgPyBvdmVycmlkZUN1cnNvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBhbmltUmVxdWVzdCxcbiAgICB9O1xuICAgIGNvbnN0IG5lZWRzQW5pbSA9IGRyYXdMYXN0VXBkYXRlVW5kZXJsYXkoYXJncywgY2VsbC5sYXN0VXBkYXRlZCwgZnJhbWVUaW1lLCBsYXN0UHJlcCwgaXNMYXN0Q29sLCBpc0xhc3RSb3cpO1xuICAgIGNvbnN0IHIgPSBnZXRDZWxsUmVuZGVyZXIoY2VsbCk7XG4gICAgaWYgKHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobGFzdFByZXA/LnJlbmRlcmVyICE9PSByKSB7XG4gICAgICAgICAgICBsYXN0UHJlcD8uZGVwcmVwPy4oYXJncyk7XG4gICAgICAgICAgICBsYXN0UHJlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0aWFsUHJlcFJlc3VsdCA9IHIuZHJhd1ByZXA/LihhcmdzLCBsYXN0UHJlcCk7XG4gICAgICAgIGlmIChkcmF3Q2VsbENhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgIWlzSW5uZXJPbmx5Q2VsbChhcmdzLmNlbGwpKSB7XG4gICAgICAgICAgICBkcmF3Q2VsbENhbGxiYWNrKGFyZ3MsICgpID0+IHIuZHJhdyhhcmdzLCBjZWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByLmRyYXcoYXJncywgY2VsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgIHBhcnRpYWxQcmVwUmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBkZXByZXA6IHBhcnRpYWxQcmVwUmVzdWx0Py5kZXByZXAsXG4gICAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogcGFydGlhbFByZXBSZXN1bHQ/LmZpbGxTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udDogcGFydGlhbFByZXBSZXN1bHQ/LmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiByLFxuICAgICAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGlmIChuZWVkc0FuaW0gfHwgYW5pbWF0aW9uRnJhbWVSZXF1ZXN0ZWQpXG4gICAgICAgIGVucXVldWU/LihhbGxvY2F0ZWRJdGVtKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS1ncmlkLXJlbmRlci5jZWxscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.cells.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.header.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.header.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawGridHeaders: () => (/* binding */ drawGridHeaders),\n/* harmony export */   drawGroups: () => (/* binding */ drawGroups),\n/* harmony export */   drawHeader: () => (/* binding */ drawHeader),\n/* harmony export */   getActionBoundsForGroup: () => (/* binding */ getActionBoundsForGroup),\n/* harmony export */   getHeaderMenuBounds: () => (/* binding */ getHeaderMenuBounds)\n/* harmony export */ });\n/* harmony import */ var _common_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/math.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js\");\n/* harmony import */ var _common_styles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/styles.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* harmony import */ var _color_parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../color-parser.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\");\n/* harmony import */ var _data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n/* harmony import */ var _data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-grid-render.walk.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.walk.js\");\n/* harmony import */ var _draw_checkbox_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./draw-checkbox.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/draw-checkbox.js\");\n\n\n\n\n\n\n\n\nfunction drawGridHeaders(ctx, effectiveCols, enableGroups, hovered, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode) {\n    const totalHeaderHeight = headerHeight + groupHeaderHeight;\n    if (totalHeaderHeight <= 0)\n        return;\n    ctx.fillStyle = outerTheme.bgHeader;\n    ctx.fillRect(0, 0, width, totalHeaderHeight);\n    const [hCol, hRow] = hovered?.[0] ?? [];\n    const font = outerTheme.headerFontFull;\n    // Assinging the context font too much can be expensive, it can be worth it to minimze this\n    ctx.font = font;\n    (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_0__.walkColumns)(effectiveCols, 0, translateX, 0, totalHeaderHeight, (c, x, _y, clipX) => {\n        if (damage !== undefined && !damage.has([c.sourceIndex, -1]))\n            return;\n        const diff = Math.max(0, clipX - x);\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x + diff, groupHeaderHeight, c.width - diff, headerHeight);\n        ctx.clip();\n        const groupTheme = getGroupDetails(c.group ?? \"\").overrideTheme;\n        const theme = c.themeOverride === undefined && groupTheme === undefined\n            ? outerTheme\n            : (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_1__.mergeAndRealizeTheme)(outerTheme, groupTheme, c.themeOverride);\n        if (theme.bgHeader !== outerTheme.bgHeader) {\n            ctx.fillStyle = theme.bgHeader;\n            ctx.fill();\n        }\n        if (theme !== outerTheme) {\n            ctx.font = theme.baseFontFull;\n        }\n        const selected = selection.columns.hasIndex(c.sourceIndex);\n        const noHover = dragAndDropState !== undefined || isResizing;\n        const hoveredBoolean = !noHover && hRow === -1 && hCol === c.sourceIndex;\n        const hover = noHover\n            ? 0\n            : hoverValues.find(s => s.item[0] === c.sourceIndex && s.item[1] === -1)?.hoverAmount ?? 0;\n        const hasSelectedCell = selection?.current !== undefined && selection.current.cell[0] === c.sourceIndex;\n        const bgFillStyle = selected ? theme.accentColor : hasSelectedCell ? theme.bgHeaderHasFocus : theme.bgHeader;\n        const y = enableGroups ? groupHeaderHeight : 0;\n        const xOffset = c.sourceIndex === 0 ? 0 : 1;\n        if (selected) {\n            ctx.fillStyle = bgFillStyle;\n            ctx.fillRect(x + xOffset, y, c.width - xOffset, headerHeight);\n        }\n        else if (hasSelectedCell || hover > 0) {\n            ctx.beginPath();\n            ctx.rect(x + xOffset, y, c.width - xOffset, headerHeight);\n            if (hasSelectedCell) {\n                ctx.fillStyle = theme.bgHeaderHasFocus;\n                ctx.fill();\n            }\n            if (hover > 0) {\n                ctx.globalAlpha = hover;\n                ctx.fillStyle = theme.bgHeaderHovered;\n                ctx.fill();\n                ctx.globalAlpha = 1;\n            }\n        }\n        drawHeader(ctx, x, y, c.width, headerHeight, c, selected, theme, hoveredBoolean, hasSelectedCell, hover, spriteManager, drawHeaderCallback, touchMode);\n        ctx.restore();\n    });\n    if (enableGroups) {\n        drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, outerTheme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage);\n    }\n}\nfunction drawGroups(ctx, effectiveCols, width, translateX, groupHeaderHeight, hovered, theme, spriteManager, _hoverValues, verticalBorder, getGroupDetails, damage) {\n    const xPad = 8;\n    const [hCol, hRow] = hovered?.[0] ?? [];\n    let finalX = 0;\n    (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_0__.walkGroups)(effectiveCols, width, translateX, groupHeaderHeight, (span, groupName, x, y, w, h) => {\n        if (damage !== undefined &&\n            !damage.hasItemInRectangle({\n                x: span[0],\n                y: -2,\n                width: span[1] - span[0] + 1,\n                height: 1,\n            }))\n            return;\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x, y, w, h);\n        ctx.clip();\n        const group = getGroupDetails(groupName);\n        const groupTheme = group?.overrideTheme === undefined ? theme : (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_1__.mergeAndRealizeTheme)(theme, group.overrideTheme);\n        const isHovered = hRow === -2 && hCol !== undefined && hCol >= span[0] && hCol <= span[1];\n        const fillColor = isHovered ? groupTheme.bgHeaderHovered : groupTheme.bgHeader;\n        if (fillColor !== theme.bgHeader) {\n            ctx.fillStyle = fillColor;\n            ctx.fill();\n        }\n        ctx.fillStyle = groupTheme.textGroupHeader ?? groupTheme.textHeader;\n        if (group !== undefined) {\n            let drawX = x;\n            if (group.icon !== undefined) {\n                spriteManager.drawSprite(group.icon, \"normal\", ctx, drawX + xPad, (groupHeaderHeight - 20) / 2, 20, groupTheme);\n                drawX += 26;\n            }\n            ctx.fillText(group.name, drawX + xPad, groupHeaderHeight / 2 + (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, theme.headerFontFull));\n            if (group.actions !== undefined && isHovered) {\n                const actionBoxes = getActionBoundsForGroup({ x, y, width: w, height: h }, group.actions);\n                ctx.beginPath();\n                const fadeStartX = actionBoxes[0].x - 10;\n                const fadeWidth = x + w - fadeStartX;\n                ctx.rect(fadeStartX, 0, fadeWidth, groupHeaderHeight);\n                const grad = ctx.createLinearGradient(fadeStartX, 0, fadeStartX + fadeWidth, 0);\n                const trans = (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_3__.withAlpha)(fillColor, 0);\n                grad.addColorStop(0, trans);\n                grad.addColorStop(10 / fadeWidth, fillColor);\n                grad.addColorStop(1, fillColor);\n                ctx.fillStyle = grad;\n                ctx.fill();\n                ctx.globalAlpha = 0.6;\n                // eslint-disable-next-line prefer-const\n                const [mouseX, mouseY] = hovered?.[1] ?? [-1, -1];\n                for (let i = 0; i < group.actions.length; i++) {\n                    const action = group.actions[i];\n                    const box = actionBoxes[i];\n                    const actionHovered = (0,_common_math_js__WEBPACK_IMPORTED_MODULE_4__.pointInRect)(box, mouseX + x, mouseY);\n                    if (actionHovered) {\n                        ctx.globalAlpha = 1;\n                    }\n                    spriteManager.drawSprite(action.icon, \"normal\", ctx, box.x + box.width / 2 - 10, box.y + box.height / 2 - 10, 20, groupTheme);\n                    if (actionHovered) {\n                        ctx.globalAlpha = 0.6;\n                    }\n                }\n                ctx.globalAlpha = 1;\n            }\n        }\n        if (x !== 0 && verticalBorder(span[0])) {\n            ctx.beginPath();\n            ctx.moveTo(x + 0.5, 0);\n            ctx.lineTo(x + 0.5, groupHeaderHeight);\n            ctx.strokeStyle = theme.borderColor;\n            ctx.lineWidth = 1;\n            ctx.stroke();\n        }\n        ctx.restore();\n        finalX = x + w;\n    });\n    ctx.beginPath();\n    ctx.moveTo(finalX + 0.5, 0);\n    ctx.lineTo(finalX + 0.5, groupHeaderHeight);\n    ctx.moveTo(0, groupHeaderHeight + 0.5);\n    ctx.lineTo(width, groupHeaderHeight + 0.5);\n    ctx.strokeStyle = theme.borderColor;\n    ctx.lineWidth = 1;\n    ctx.stroke();\n}\nconst menuButtonSize = 30;\nfunction getHeaderMenuBounds(x, y, width, height, isRtl) {\n    if (isRtl)\n        return { x, y, width: menuButtonSize, height: Math.min(menuButtonSize, height) };\n    return {\n        x: x + width - menuButtonSize,\n        y: Math.max(y, y + height / 2 - menuButtonSize / 2),\n        width: menuButtonSize,\n        height: Math.min(menuButtonSize, height),\n    };\n}\nfunction getActionBoundsForGroup(box, actions) {\n    const result = [];\n    let x = box.x + box.width - 26 * actions.length;\n    const y = box.y + box.height / 2 - 13;\n    const height = 26;\n    const width = 26;\n    for (let i = 0; i < actions.length; i++) {\n        result.push({\n            x,\n            y,\n            width,\n            height,\n        });\n        x += 26;\n    }\n    return result;\n}\nfunction drawHeaderInner(ctx, x, y, width, height, c, selected, theme, isHovered, hoverAmount, spriteManager, touchMode, isRtl, menuBounds) {\n    if (c.rowMarker !== undefined) {\n        const checked = c.rowMarkerChecked;\n        if (checked !== true) {\n            ctx.globalAlpha = hoverAmount;\n        }\n        (0,_draw_checkbox_js__WEBPACK_IMPORTED_MODULE_5__.drawCheckbox)(ctx, theme, checked, x, y, width, height, false, undefined, undefined, 18, \"center\", c.rowMarker);\n        if (checked !== true) {\n            ctx.globalAlpha = 1;\n        }\n        return;\n    }\n    const xPad = theme.cellHorizontalPadding;\n    const fillStyle = selected ? theme.textHeaderSelected : theme.textHeader;\n    const shouldDrawMenu = c.hasMenu === true && (isHovered || (touchMode && selected));\n    const dirScalar = isRtl ? -1 : 1;\n    let drawX = isRtl ? x + width - xPad : x + xPad;\n    if (c.icon !== undefined) {\n        let variant = selected ? \"selected\" : \"normal\";\n        if (c.style === \"highlight\") {\n            variant = selected ? \"selected\" : \"special\";\n        }\n        const headerSize = theme.headerIconSize;\n        spriteManager.drawSprite(c.icon, variant, ctx, isRtl ? drawX - headerSize : drawX, y + (height - headerSize) / 2, headerSize, theme);\n        if (c.overlayIcon !== undefined) {\n            spriteManager.drawSprite(c.overlayIcon, selected ? \"selected\" : \"special\", ctx, isRtl ? drawX - headerSize + 9 : drawX + 9, y + ((height - 18) / 2 + 6), 18, theme);\n        }\n        drawX += Math.ceil(headerSize * 1.3) * dirScalar;\n    }\n    if (shouldDrawMenu && c.hasMenu === true && width > 35) {\n        const fadeWidth = 35;\n        const fadeStart = isRtl ? fadeWidth : width - fadeWidth;\n        const fadeEnd = isRtl ? fadeWidth * 0.7 : width - fadeWidth * 0.7;\n        const fadeStartPercent = fadeStart / width;\n        const fadeEndPercent = fadeEnd / width;\n        const grad = ctx.createLinearGradient(x, 0, x + width, 0);\n        const trans = (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_3__.withAlpha)(fillStyle, 0);\n        grad.addColorStop(isRtl ? 1 : 0, fillStyle);\n        grad.addColorStop(fadeStartPercent, fillStyle);\n        grad.addColorStop(fadeEndPercent, trans);\n        grad.addColorStop(isRtl ? 0 : 1, trans);\n        ctx.fillStyle = grad;\n    }\n    else {\n        ctx.fillStyle = fillStyle;\n    }\n    if (isRtl) {\n        ctx.textAlign = \"right\";\n    }\n    ctx.fillText(c.title, drawX, y + height / 2 + (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.getMiddleCenterBias)(ctx, theme.headerFontFull));\n    if (isRtl) {\n        ctx.textAlign = \"left\";\n    }\n    if (shouldDrawMenu && c.hasMenu === true) {\n        if (c.menuIcon === undefined || c.menuIcon === _data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridColumnMenuIcon.Triangle) {\n            // Draw the default triangle menu icon:\n            ctx.beginPath();\n            const triangleX = menuBounds.x + menuBounds.width / 2 - 5.5;\n            const triangleY = menuBounds.y + menuBounds.height / 2 - 3;\n            (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.roundedPoly)(ctx, [\n                {\n                    x: triangleX,\n                    y: triangleY,\n                },\n                {\n                    x: triangleX + 11,\n                    y: triangleY,\n                },\n                {\n                    x: triangleX + 5.5,\n                    y: triangleY + 6,\n                },\n            ], 1);\n            ctx.fillStyle = fillStyle;\n            ctx.fill();\n        }\n        else if (c.menuIcon === _data_grid_types_js__WEBPACK_IMPORTED_MODULE_6__.GridColumnMenuIcon.Dots) {\n            // Draw the three dots menu icon:\n            ctx.beginPath();\n            const dotsX = menuBounds.x + menuBounds.width / 2;\n            const dotsY = menuBounds.y + menuBounds.height / 2;\n            (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.drawMenuDots)(ctx, dotsX, dotsY);\n            ctx.fillStyle = fillStyle;\n            ctx.fill();\n        }\n        else {\n            // Assume that the user has specified a valid sprite image as header icon:\n            const iconX = menuBounds.x + (menuBounds.width - theme.headerIconSize) / 2;\n            const iconY = menuBounds.y + (menuBounds.height - theme.headerIconSize) / 2;\n            spriteManager.drawSprite(c.menuIcon, \"normal\", ctx, iconX, iconY, theme.headerIconSize, theme);\n        }\n    }\n}\nfunction drawHeader(ctx, x, y, width, height, c, selected, theme, isHovered, hasSelectedCell, hoverAmount, spriteManager, drawHeaderCallback, touchMode) {\n    const isRtl = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_7__.direction)(c.title) === \"rtl\";\n    const menuBounds = getHeaderMenuBounds(x, y, width, height, isRtl);\n    if (drawHeaderCallback !== undefined) {\n        drawHeaderCallback({\n            ctx,\n            theme,\n            rect: { x, y, width, height },\n            column: c,\n            columnIndex: c.sourceIndex,\n            isSelected: selected,\n            hoverAmount,\n            isHovered,\n            hasSelectedCell,\n            spriteManager,\n            menuBounds,\n        }, () => drawHeaderInner(ctx, x, y, width, height, c, selected, theme, isHovered, hoverAmount, spriteManager, touchMode, isRtl, menuBounds));\n    }\n    else {\n        drawHeaderInner(ctx, x, y, width, height, c, selected, theme, isHovered, hoverAmount, spriteManager, touchMode, isRtl, menuBounds);\n    }\n}\n//# sourceMappingURL=data-grid-render.header.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmhlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNEO0FBQ1c7QUFDWjtBQUNOO0FBQ1k7QUFDeUI7QUFDZjtBQUNuQjtBQUMzQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUVBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFFQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSx1RUFBb0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsc0VBQW1CO0FBQzlGO0FBQ0EsOERBQThELDJCQUEyQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJEQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQSwwQ0FBMEMsNERBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsc0VBQW1CO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1FQUFrQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUVBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQkFBa0IsMkRBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RhdGEtZ3JpZC1yZW5kZXIuaGVhZGVyLmpzP2JmYTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9pbnRJblJlY3QgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL21hdGguanNcIjtcbmltcG9ydCB7IG1lcmdlQW5kUmVhbGl6ZVRoZW1lIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9zdHlsZXMuanNcIjtcbmltcG9ydCB7IGRpcmVjdGlvbiB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vdXRpbHMuanNcIjtcbmltcG9ydCB7IHdpdGhBbHBoYSB9IGZyb20gXCIuLi9jb2xvci1wYXJzZXIuanNcIjtcbmltcG9ydCB7IEdyaWRDb2x1bW5NZW51SWNvbiB9IGZyb20gXCIuLi9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmltcG9ydCB7IGRyYXdNZW51RG90cywgZ2V0TWlkZGxlQ2VudGVyQmlhcywgcm91bmRlZFBvbHkgfSBmcm9tIFwiLi9kYXRhLWdyaWQtbGliLmpzXCI7XG5pbXBvcnQgeyB3YWxrQ29sdW1ucywgd2Fsa0dyb3VwcyB9IGZyb20gXCIuL2RhdGEtZ3JpZC1yZW5kZXIud2Fsay5qc1wiO1xuaW1wb3J0IHsgZHJhd0NoZWNrYm94IH0gZnJvbSBcIi4vZHJhdy1jaGVja2JveC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdHcmlkSGVhZGVycyhjdHgsIGVmZmVjdGl2ZUNvbHMsIGVuYWJsZUdyb3VwcywgaG92ZXJlZCwgd2lkdGgsIHRyYW5zbGF0ZVgsIGhlYWRlckhlaWdodCwgZ3JvdXBIZWFkZXJIZWlnaHQsIGRyYWdBbmREcm9wU3RhdGUsIGlzUmVzaXppbmcsIHNlbGVjdGlvbiwgb3V0ZXJUaGVtZSwgc3ByaXRlTWFuYWdlciwgaG92ZXJWYWx1ZXMsIHZlcnRpY2FsQm9yZGVyLCBnZXRHcm91cERldGFpbHMsIGRhbWFnZSwgZHJhd0hlYWRlckNhbGxiYWNrLCB0b3VjaE1vZGUpIHtcbiAgICBjb25zdCB0b3RhbEhlYWRlckhlaWdodCA9IGhlYWRlckhlaWdodCArIGdyb3VwSGVhZGVySGVpZ2h0O1xuICAgIGlmICh0b3RhbEhlYWRlckhlaWdodCA8PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY3R4LmZpbGxTdHlsZSA9IG91dGVyVGhlbWUuYmdIZWFkZXI7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCB0b3RhbEhlYWRlckhlaWdodCk7XG4gICAgY29uc3QgW2hDb2wsIGhSb3ddID0gaG92ZXJlZD8uWzBdID8/IFtdO1xuICAgIGNvbnN0IGZvbnQgPSBvdXRlclRoZW1lLmhlYWRlckZvbnRGdWxsO1xuICAgIC8vIEFzc2luZ2luZyB0aGUgY29udGV4dCBmb250IHRvbyBtdWNoIGNhbiBiZSBleHBlbnNpdmUsIGl0IGNhbiBiZSB3b3J0aCBpdCB0byBtaW5pbXplIHRoaXNcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgd2Fsa0NvbHVtbnMoZWZmZWN0aXZlQ29scywgMCwgdHJhbnNsYXRlWCwgMCwgdG90YWxIZWFkZXJIZWlnaHQsIChjLCB4LCBfeSwgY2xpcFgpID0+IHtcbiAgICAgICAgaWYgKGRhbWFnZSAhPT0gdW5kZWZpbmVkICYmICFkYW1hZ2UuaGFzKFtjLnNvdXJjZUluZGV4LCAtMV0pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5tYXgoMCwgY2xpcFggLSB4KTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCh4ICsgZGlmZiwgZ3JvdXBIZWFkZXJIZWlnaHQsIGMud2lkdGggLSBkaWZmLCBoZWFkZXJIZWlnaHQpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICBjb25zdCBncm91cFRoZW1lID0gZ2V0R3JvdXBEZXRhaWxzKGMuZ3JvdXAgPz8gXCJcIikub3ZlcnJpZGVUaGVtZTtcbiAgICAgICAgY29uc3QgdGhlbWUgPSBjLnRoZW1lT3ZlcnJpZGUgPT09IHVuZGVmaW5lZCAmJiBncm91cFRoZW1lID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gb3V0ZXJUaGVtZVxuICAgICAgICAgICAgOiBtZXJnZUFuZFJlYWxpemVUaGVtZShvdXRlclRoZW1lLCBncm91cFRoZW1lLCBjLnRoZW1lT3ZlcnJpZGUpO1xuICAgICAgICBpZiAodGhlbWUuYmdIZWFkZXIgIT09IG91dGVyVGhlbWUuYmdIZWFkZXIpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS5iZ0hlYWRlcjtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoZW1lICE9PSBvdXRlclRoZW1lKSB7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRoZW1lLmJhc2VGb250RnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdGlvbi5jb2x1bW5zLmhhc0luZGV4KGMuc291cmNlSW5kZXgpO1xuICAgICAgICBjb25zdCBub0hvdmVyID0gZHJhZ0FuZERyb3BTdGF0ZSAhPT0gdW5kZWZpbmVkIHx8IGlzUmVzaXppbmc7XG4gICAgICAgIGNvbnN0IGhvdmVyZWRCb29sZWFuID0gIW5vSG92ZXIgJiYgaFJvdyA9PT0gLTEgJiYgaENvbCA9PT0gYy5zb3VyY2VJbmRleDtcbiAgICAgICAgY29uc3QgaG92ZXIgPSBub0hvdmVyXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogaG92ZXJWYWx1ZXMuZmluZChzID0+IHMuaXRlbVswXSA9PT0gYy5zb3VyY2VJbmRleCAmJiBzLml0ZW1bMV0gPT09IC0xKT8uaG92ZXJBbW91bnQgPz8gMDtcbiAgICAgICAgY29uc3QgaGFzU2VsZWN0ZWRDZWxsID0gc2VsZWN0aW9uPy5jdXJyZW50ICE9PSB1bmRlZmluZWQgJiYgc2VsZWN0aW9uLmN1cnJlbnQuY2VsbFswXSA9PT0gYy5zb3VyY2VJbmRleDtcbiAgICAgICAgY29uc3QgYmdGaWxsU3R5bGUgPSBzZWxlY3RlZCA/IHRoZW1lLmFjY2VudENvbG9yIDogaGFzU2VsZWN0ZWRDZWxsID8gdGhlbWUuYmdIZWFkZXJIYXNGb2N1cyA6IHRoZW1lLmJnSGVhZGVyO1xuICAgICAgICBjb25zdCB5ID0gZW5hYmxlR3JvdXBzID8gZ3JvdXBIZWFkZXJIZWlnaHQgOiAwO1xuICAgICAgICBjb25zdCB4T2Zmc2V0ID0gYy5zb3VyY2VJbmRleCA9PT0gMCA/IDAgOiAxO1xuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiZ0ZpbGxTdHlsZTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4ICsgeE9mZnNldCwgeSwgYy53aWR0aCAtIHhPZmZzZXQsIGhlYWRlckhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzU2VsZWN0ZWRDZWxsIHx8IGhvdmVyID4gMCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QoeCArIHhPZmZzZXQsIHksIGMud2lkdGggLSB4T2Zmc2V0LCBoZWFkZXJIZWlnaHQpO1xuICAgICAgICAgICAgaWYgKGhhc1NlbGVjdGVkQ2VsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGVtZS5iZ0hlYWRlckhhc0ZvY3VzO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaG92ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gaG92ZXI7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoZW1lLmJnSGVhZGVySG92ZXJlZDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0hlYWRlcihjdHgsIHgsIHksIGMud2lkdGgsIGhlYWRlckhlaWdodCwgYywgc2VsZWN0ZWQsIHRoZW1lLCBob3ZlcmVkQm9vbGVhbiwgaGFzU2VsZWN0ZWRDZWxsLCBob3Zlciwgc3ByaXRlTWFuYWdlciwgZHJhd0hlYWRlckNhbGxiYWNrLCB0b3VjaE1vZGUpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0pO1xuICAgIGlmIChlbmFibGVHcm91cHMpIHtcbiAgICAgICAgZHJhd0dyb3VwcyhjdHgsIGVmZmVjdGl2ZUNvbHMsIHdpZHRoLCB0cmFuc2xhdGVYLCBncm91cEhlYWRlckhlaWdodCwgaG92ZXJlZCwgb3V0ZXJUaGVtZSwgc3ByaXRlTWFuYWdlciwgaG92ZXJWYWx1ZXMsIHZlcnRpY2FsQm9yZGVyLCBnZXRHcm91cERldGFpbHMsIGRhbWFnZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdHcm91cHMoY3R4LCBlZmZlY3RpdmVDb2xzLCB3aWR0aCwgdHJhbnNsYXRlWCwgZ3JvdXBIZWFkZXJIZWlnaHQsIGhvdmVyZWQsIHRoZW1lLCBzcHJpdGVNYW5hZ2VyLCBfaG92ZXJWYWx1ZXMsIHZlcnRpY2FsQm9yZGVyLCBnZXRHcm91cERldGFpbHMsIGRhbWFnZSkge1xuICAgIGNvbnN0IHhQYWQgPSA4O1xuICAgIGNvbnN0IFtoQ29sLCBoUm93XSA9IGhvdmVyZWQ/LlswXSA/PyBbXTtcbiAgICBsZXQgZmluYWxYID0gMDtcbiAgICB3YWxrR3JvdXBzKGVmZmVjdGl2ZUNvbHMsIHdpZHRoLCB0cmFuc2xhdGVYLCBncm91cEhlYWRlckhlaWdodCwgKHNwYW4sIGdyb3VwTmFtZSwgeCwgeSwgdywgaCkgPT4ge1xuICAgICAgICBpZiAoZGFtYWdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFkYW1hZ2UuaGFzSXRlbUluUmVjdGFuZ2xlKHtcbiAgICAgICAgICAgICAgICB4OiBzcGFuWzBdLFxuICAgICAgICAgICAgICAgIHk6IC0yLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzcGFuWzFdIC0gc3BhblswXSArIDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gZ2V0R3JvdXBEZXRhaWxzKGdyb3VwTmFtZSk7XG4gICAgICAgIGNvbnN0IGdyb3VwVGhlbWUgPSBncm91cD8ub3ZlcnJpZGVUaGVtZSA9PT0gdW5kZWZpbmVkID8gdGhlbWUgOiBtZXJnZUFuZFJlYWxpemVUaGVtZSh0aGVtZSwgZ3JvdXAub3ZlcnJpZGVUaGVtZSk7XG4gICAgICAgIGNvbnN0IGlzSG92ZXJlZCA9IGhSb3cgPT09IC0yICYmIGhDb2wgIT09IHVuZGVmaW5lZCAmJiBoQ29sID49IHNwYW5bMF0gJiYgaENvbCA8PSBzcGFuWzFdO1xuICAgICAgICBjb25zdCBmaWxsQ29sb3IgPSBpc0hvdmVyZWQgPyBncm91cFRoZW1lLmJnSGVhZGVySG92ZXJlZCA6IGdyb3VwVGhlbWUuYmdIZWFkZXI7XG4gICAgICAgIGlmIChmaWxsQ29sb3IgIT09IHRoZW1lLmJnSGVhZGVyKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JvdXBUaGVtZS50ZXh0R3JvdXBIZWFkZXIgPz8gZ3JvdXBUaGVtZS50ZXh0SGVhZGVyO1xuICAgICAgICBpZiAoZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGRyYXdYID0geDtcbiAgICAgICAgICAgIGlmIChncm91cC5pY29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzcHJpdGVNYW5hZ2VyLmRyYXdTcHJpdGUoZ3JvdXAuaWNvbiwgXCJub3JtYWxcIiwgY3R4LCBkcmF3WCArIHhQYWQsIChncm91cEhlYWRlckhlaWdodCAtIDIwKSAvIDIsIDIwLCBncm91cFRoZW1lKTtcbiAgICAgICAgICAgICAgICBkcmF3WCArPSAyNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChncm91cC5uYW1lLCBkcmF3WCArIHhQYWQsIGdyb3VwSGVhZGVySGVpZ2h0IC8gMiArIGdldE1pZGRsZUNlbnRlckJpYXMoY3R4LCB0aGVtZS5oZWFkZXJGb250RnVsbCkpO1xuICAgICAgICAgICAgaWYgKGdyb3VwLmFjdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBpc0hvdmVyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25Cb3hlcyA9IGdldEFjdGlvbkJvdW5kc0Zvckdyb3VwKHsgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCB9LCBncm91cC5hY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFkZVN0YXJ0WCA9IGFjdGlvbkJveGVzWzBdLnggLSAxMDtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWRlV2lkdGggPSB4ICsgdyAtIGZhZGVTdGFydFg7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoZmFkZVN0YXJ0WCwgMCwgZmFkZVdpZHRoLCBncm91cEhlYWRlckhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChmYWRlU3RhcnRYLCAwLCBmYWRlU3RhcnRYICsgZmFkZVdpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFucyA9IHdpdGhBbHBoYShmaWxsQ29sb3IsIDApO1xuICAgICAgICAgICAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKDAsIHRyYW5zKTtcbiAgICAgICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgxMCAvIGZhZGVXaWR0aCwgZmlsbENvbG9yKTtcbiAgICAgICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcCgxLCBmaWxsQ29sb3IpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC42O1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgICAgICAgICBjb25zdCBbbW91c2VYLCBtb3VzZVldID0gaG92ZXJlZD8uWzFdID8/IFstMSwgLTFdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAuYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBncm91cC5hY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBhY3Rpb25Cb3hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aW9uSG92ZXJlZCA9IHBvaW50SW5SZWN0KGJveCwgbW91c2VYICsgeCwgbW91c2VZKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbkhvdmVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlTWFuYWdlci5kcmF3U3ByaXRlKGFjdGlvbi5pY29uLCBcIm5vcm1hbFwiLCBjdHgsIGJveC54ICsgYm94LndpZHRoIC8gMiAtIDEwLCBib3gueSArIGJveC5oZWlnaHQgLyAyIC0gMTAsIDIwLCBncm91cFRoZW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbkhvdmVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9PSAwICYmIHZlcnRpY2FsQm9yZGVyKHNwYW5bMF0pKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyAwLjUsIDApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgMC41LCBncm91cEhlYWRlckhlaWdodCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZS5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGZpbmFsWCA9IHggKyB3O1xuICAgIH0pO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKGZpbmFsWCArIDAuNSwgMCk7XG4gICAgY3R4LmxpbmVUbyhmaW5hbFggKyAwLjUsIGdyb3VwSGVhZGVySGVpZ2h0KTtcbiAgICBjdHgubW92ZVRvKDAsIGdyb3VwSGVhZGVySGVpZ2h0ICsgMC41KTtcbiAgICBjdHgubGluZVRvKHdpZHRoLCBncm91cEhlYWRlckhlaWdodCArIDAuNSk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LnN0cm9rZSgpO1xufVxuY29uc3QgbWVudUJ1dHRvblNpemUgPSAzMDtcbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWFkZXJNZW51Qm91bmRzKHgsIHksIHdpZHRoLCBoZWlnaHQsIGlzUnRsKSB7XG4gICAgaWYgKGlzUnRsKVxuICAgICAgICByZXR1cm4geyB4LCB5LCB3aWR0aDogbWVudUJ1dHRvblNpemUsIGhlaWdodDogTWF0aC5taW4obWVudUJ1dHRvblNpemUsIGhlaWdodCkgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgd2lkdGggLSBtZW51QnV0dG9uU2l6ZSxcbiAgICAgICAgeTogTWF0aC5tYXgoeSwgeSArIGhlaWdodCAvIDIgLSBtZW51QnV0dG9uU2l6ZSAvIDIpLFxuICAgICAgICB3aWR0aDogbWVudUJ1dHRvblNpemUsXG4gICAgICAgIGhlaWdodDogTWF0aC5taW4obWVudUJ1dHRvblNpemUsIGhlaWdodCksXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3Rpb25Cb3VuZHNGb3JHcm91cChib3gsIGFjdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgeCA9IGJveC54ICsgYm94LndpZHRoIC0gMjYgKiBhY3Rpb25zLmxlbmd0aDtcbiAgICBjb25zdCB5ID0gYm94LnkgKyBib3guaGVpZ2h0IC8gMiAtIDEzO1xuICAgIGNvbnN0IGhlaWdodCA9IDI2O1xuICAgIGNvbnN0IHdpZHRoID0gMjY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgICB4ICs9IDI2O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZHJhd0hlYWRlcklubmVyKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYywgc2VsZWN0ZWQsIHRoZW1lLCBpc0hvdmVyZWQsIGhvdmVyQW1vdW50LCBzcHJpdGVNYW5hZ2VyLCB0b3VjaE1vZGUsIGlzUnRsLCBtZW51Qm91bmRzKSB7XG4gICAgaWYgKGMucm93TWFya2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IGMucm93TWFya2VyQ2hlY2tlZDtcbiAgICAgICAgaWYgKGNoZWNrZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGhvdmVyQW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIGRyYXdDaGVja2JveChjdHgsIHRoZW1lLCBjaGVja2VkLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmYWxzZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDE4LCBcImNlbnRlclwiLCBjLnJvd01hcmtlcik7XG4gICAgICAgIGlmIChjaGVja2VkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeFBhZCA9IHRoZW1lLmNlbGxIb3Jpem9udGFsUGFkZGluZztcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzZWxlY3RlZCA/IHRoZW1lLnRleHRIZWFkZXJTZWxlY3RlZCA6IHRoZW1lLnRleHRIZWFkZXI7XG4gICAgY29uc3Qgc2hvdWxkRHJhd01lbnUgPSBjLmhhc01lbnUgPT09IHRydWUgJiYgKGlzSG92ZXJlZCB8fCAodG91Y2hNb2RlICYmIHNlbGVjdGVkKSk7XG4gICAgY29uc3QgZGlyU2NhbGFyID0gaXNSdGwgPyAtMSA6IDE7XG4gICAgbGV0IGRyYXdYID0gaXNSdGwgPyB4ICsgd2lkdGggLSB4UGFkIDogeCArIHhQYWQ7XG4gICAgaWYgKGMuaWNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB2YXJpYW50ID0gc2VsZWN0ZWQgPyBcInNlbGVjdGVkXCIgOiBcIm5vcm1hbFwiO1xuICAgICAgICBpZiAoYy5zdHlsZSA9PT0gXCJoaWdobGlnaHRcIikge1xuICAgICAgICAgICAgdmFyaWFudCA9IHNlbGVjdGVkID8gXCJzZWxlY3RlZFwiIDogXCJzcGVjaWFsXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVyU2l6ZSA9IHRoZW1lLmhlYWRlckljb25TaXplO1xuICAgICAgICBzcHJpdGVNYW5hZ2VyLmRyYXdTcHJpdGUoYy5pY29uLCB2YXJpYW50LCBjdHgsIGlzUnRsID8gZHJhd1ggLSBoZWFkZXJTaXplIDogZHJhd1gsIHkgKyAoaGVpZ2h0IC0gaGVhZGVyU2l6ZSkgLyAyLCBoZWFkZXJTaXplLCB0aGVtZSk7XG4gICAgICAgIGlmIChjLm92ZXJsYXlJY29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwcml0ZU1hbmFnZXIuZHJhd1Nwcml0ZShjLm92ZXJsYXlJY29uLCBzZWxlY3RlZCA/IFwic2VsZWN0ZWRcIiA6IFwic3BlY2lhbFwiLCBjdHgsIGlzUnRsID8gZHJhd1ggLSBoZWFkZXJTaXplICsgOSA6IGRyYXdYICsgOSwgeSArICgoaGVpZ2h0IC0gMTgpIC8gMiArIDYpLCAxOCwgdGhlbWUpO1xuICAgICAgICB9XG4gICAgICAgIGRyYXdYICs9IE1hdGguY2VpbChoZWFkZXJTaXplICogMS4zKSAqIGRpclNjYWxhcjtcbiAgICB9XG4gICAgaWYgKHNob3VsZERyYXdNZW51ICYmIGMuaGFzTWVudSA9PT0gdHJ1ZSAmJiB3aWR0aCA+IDM1KSB7XG4gICAgICAgIGNvbnN0IGZhZGVXaWR0aCA9IDM1O1xuICAgICAgICBjb25zdCBmYWRlU3RhcnQgPSBpc1J0bCA/IGZhZGVXaWR0aCA6IHdpZHRoIC0gZmFkZVdpZHRoO1xuICAgICAgICBjb25zdCBmYWRlRW5kID0gaXNSdGwgPyBmYWRlV2lkdGggKiAwLjcgOiB3aWR0aCAtIGZhZGVXaWR0aCAqIDAuNztcbiAgICAgICAgY29uc3QgZmFkZVN0YXJ0UGVyY2VudCA9IGZhZGVTdGFydCAvIHdpZHRoO1xuICAgICAgICBjb25zdCBmYWRlRW5kUGVyY2VudCA9IGZhZGVFbmQgLyB3aWR0aDtcbiAgICAgICAgY29uc3QgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCAwLCB4ICsgd2lkdGgsIDApO1xuICAgICAgICBjb25zdCB0cmFucyA9IHdpdGhBbHBoYShmaWxsU3R5bGUsIDApO1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChpc1J0bCA/IDEgOiAwLCBmaWxsU3R5bGUpO1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChmYWRlU3RhcnRQZXJjZW50LCBmaWxsU3R5bGUpO1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChmYWRlRW5kUGVyY2VudCwgdHJhbnMpO1xuICAgICAgICBncmFkLmFkZENvbG9yU3RvcChpc1J0bCA/IDAgOiAxLCB0cmFucyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICB9XG4gICAgaWYgKGlzUnRsKSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgfVxuICAgIGN0eC5maWxsVGV4dChjLnRpdGxlLCBkcmF3WCwgeSArIGhlaWdodCAvIDIgKyBnZXRNaWRkbGVDZW50ZXJCaWFzKGN0eCwgdGhlbWUuaGVhZGVyRm9udEZ1bGwpKTtcbiAgICBpZiAoaXNSdGwpIHtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkRHJhd01lbnUgJiYgYy5oYXNNZW51ID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChjLm1lbnVJY29uID09PSB1bmRlZmluZWQgfHwgYy5tZW51SWNvbiA9PT0gR3JpZENvbHVtbk1lbnVJY29uLlRyaWFuZ2xlKSB7XG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBkZWZhdWx0IHRyaWFuZ2xlIG1lbnUgaWNvbjpcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlWCA9IG1lbnVCb3VuZHMueCArIG1lbnVCb3VuZHMud2lkdGggLyAyIC0gNS41O1xuICAgICAgICAgICAgY29uc3QgdHJpYW5nbGVZID0gbWVudUJvdW5kcy55ICsgbWVudUJvdW5kcy5oZWlnaHQgLyAyIC0gMztcbiAgICAgICAgICAgIHJvdW5kZWRQb2x5KGN0eCwgW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeDogdHJpYW5nbGVYLFxuICAgICAgICAgICAgICAgICAgICB5OiB0cmlhbmdsZVksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRyaWFuZ2xlWCArIDExLFxuICAgICAgICAgICAgICAgICAgICB5OiB0cmlhbmdsZVksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHRyaWFuZ2xlWCArIDUuNSxcbiAgICAgICAgICAgICAgICAgICAgeTogdHJpYW5nbGVZICsgNixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSwgMSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjLm1lbnVJY29uID09PSBHcmlkQ29sdW1uTWVudUljb24uRG90cykge1xuICAgICAgICAgICAgLy8gRHJhdyB0aGUgdGhyZWUgZG90cyBtZW51IGljb246XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb25zdCBkb3RzWCA9IG1lbnVCb3VuZHMueCArIG1lbnVCb3VuZHMud2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgZG90c1kgPSBtZW51Qm91bmRzLnkgKyBtZW51Qm91bmRzLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBkcmF3TWVudURvdHMoY3R4LCBkb3RzWCwgZG90c1kpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdGhhdCB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIGEgdmFsaWQgc3ByaXRlIGltYWdlIGFzIGhlYWRlciBpY29uOlxuICAgICAgICAgICAgY29uc3QgaWNvblggPSBtZW51Qm91bmRzLnggKyAobWVudUJvdW5kcy53aWR0aCAtIHRoZW1lLmhlYWRlckljb25TaXplKSAvIDI7XG4gICAgICAgICAgICBjb25zdCBpY29uWSA9IG1lbnVCb3VuZHMueSArIChtZW51Qm91bmRzLmhlaWdodCAtIHRoZW1lLmhlYWRlckljb25TaXplKSAvIDI7XG4gICAgICAgICAgICBzcHJpdGVNYW5hZ2VyLmRyYXdTcHJpdGUoYy5tZW51SWNvbiwgXCJub3JtYWxcIiwgY3R4LCBpY29uWCwgaWNvblksIHRoZW1lLmhlYWRlckljb25TaXplLCB0aGVtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZHJhd0hlYWRlcihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGMsIHNlbGVjdGVkLCB0aGVtZSwgaXNIb3ZlcmVkLCBoYXNTZWxlY3RlZENlbGwsIGhvdmVyQW1vdW50LCBzcHJpdGVNYW5hZ2VyLCBkcmF3SGVhZGVyQ2FsbGJhY2ssIHRvdWNoTW9kZSkge1xuICAgIGNvbnN0IGlzUnRsID0gZGlyZWN0aW9uKGMudGl0bGUpID09PSBcInJ0bFwiO1xuICAgIGNvbnN0IG1lbnVCb3VuZHMgPSBnZXRIZWFkZXJNZW51Qm91bmRzKHgsIHksIHdpZHRoLCBoZWlnaHQsIGlzUnRsKTtcbiAgICBpZiAoZHJhd0hlYWRlckNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZHJhd0hlYWRlckNhbGxiYWNrKHtcbiAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgIHRoZW1lLFxuICAgICAgICAgICAgcmVjdDogeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgICAgICAgICBjb2x1bW46IGMsXG4gICAgICAgICAgICBjb2x1bW5JbmRleDogYy5zb3VyY2VJbmRleCxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgICAgICAgaG92ZXJBbW91bnQsXG4gICAgICAgICAgICBpc0hvdmVyZWQsXG4gICAgICAgICAgICBoYXNTZWxlY3RlZENlbGwsXG4gICAgICAgICAgICBzcHJpdGVNYW5hZ2VyLFxuICAgICAgICAgICAgbWVudUJvdW5kcyxcbiAgICAgICAgfSwgKCkgPT4gZHJhd0hlYWRlcklubmVyKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYywgc2VsZWN0ZWQsIHRoZW1lLCBpc0hvdmVyZWQsIGhvdmVyQW1vdW50LCBzcHJpdGVNYW5hZ2VyLCB0b3VjaE1vZGUsIGlzUnRsLCBtZW51Qm91bmRzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkcmF3SGVhZGVySW5uZXIoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjLCBzZWxlY3RlZCwgdGhlbWUsIGlzSG92ZXJlZCwgaG92ZXJBbW91bnQsIHNwcml0ZU1hbmFnZXIsIHRvdWNoTW9kZSwgaXNSdGwsIG1lbnVCb3VuZHMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtZ3JpZC1yZW5kZXIuaGVhZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.header.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawGrid: () => (/* binding */ drawGrid)\n/* harmony export */ });\n/* harmony import */ var _data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _color_parser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../color-parser.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\");\n/* harmony import */ var _common_support_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../common/support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n/* harmony import */ var _data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-grid-render.walk.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.walk.js\");\n/* harmony import */ var _data_grid_render_cells_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./data-grid-render.cells.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.cells.js\");\n/* harmony import */ var _data_grid_render_header_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data-grid-render.header.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.header.js\");\n/* harmony import */ var _data_grid_render_lines_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data-grid-render.lines.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.lines.js\");\n/* harmony import */ var _data_grid_render_blit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-grid-render.blit.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.blit.js\");\n/* harmony import */ var _data_grid_render_rings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./data-grid.render.rings.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid.render.rings.js\");\n/* eslint-disable sonarjs/no-duplicate-string */\n/* eslint-disable unicorn/no-for-loop */\n\n\n\n\n\n\n\n\n\n\n\n// Future optimization opportunities\n// - Create a cache of a buffer used to render the full view of a partially displayed column so that when\n//   scrolling horizontally you can simply blit the pre-drawn column instead of continually paying the draw\n//   cost as it slides into view.\n// - The same as above but for partially displayed rows\n// - Blit headers on horizontal scroll\n// - Use webworker to load images, helpful with lots of large images\n// - Retain mode for drawing cells. Instead of drawing cells as we come across them, first build a data\n//   structure which contains all operations to perform, then sort them all by \"prep\" requirement, then do\n//   all like operations at once.\nfunction clipHeaderDamage(ctx, effectiveColumns, width, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, damage) {\n    if (damage === undefined || damage.size === 0)\n        return;\n    ctx.beginPath();\n    (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_0__.walkGroups)(effectiveColumns, width, translateX, groupHeaderHeight, (span, _group, x, y, w, h) => {\n        const hasItemInSpan = damage.hasItemInRectangle({\n            x: span[0],\n            y: -2,\n            width: span[1] - span[0] + 1,\n            height: 1,\n        });\n        if (hasItemInSpan) {\n            ctx.rect(x, y, w, h);\n        }\n    });\n    (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_0__.walkColumns)(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, _colDrawY, clipX) => {\n        const diff = Math.max(0, clipX - drawX);\n        const finalX = drawX + diff + 1;\n        const finalWidth = c.width - diff - 1;\n        if (damage.has([c.sourceIndex, -1])) {\n            ctx.rect(finalX, groupHeaderHeight, finalWidth, totalHeaderHeight - groupHeaderHeight);\n        }\n    });\n    ctx.clip();\n}\nfunction getLastRow(effectiveColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, freezeTrailingRows, hasAppendRow) {\n    let result = 0;\n    (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_0__.walkColumns)(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (_c, __drawX, colDrawY, _clipX, startRow) => {\n        (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_0__.walkRowsInCol)(startRow, colDrawY, height, rows, getRowHeight, freezeTrailingRows, hasAppendRow, undefined, (_drawY, row, _rh, isSticky) => {\n            if (!isSticky) {\n                result = Math.max(row, result);\n            }\n        });\n        return true;\n    });\n    return result;\n}\nfunction drawGrid(arg, lastArg) {\n    const { canvasCtx, headerCanvasCtx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, enableGroups, freezeColumns, dragAndDropState, theme, drawFocus, headerHeight, groupHeaderHeight, disabledRows, rowHeight, verticalBorder, overrideCursor, isResizing, selection, fillHandle, freezeTrailingRows, rows, getCellContent, getGroupDetails, getRowThemeOverride, isFocused, drawHeaderCallback, prelightCells, drawCellCallback, highlightRegions, resizeCol, imageLoader, lastBlitData, hoverValues, hyperWrapping, hoverInfo, spriteManager, maxScaleFactor, hasAppendRow, touchMode, enqueue, renderStateProvider, getCellRenderer, renderStrategy, bufferACtx, bufferBCtx, damage, minimumCellWidth, } = arg;\n    if (width === 0 || height === 0)\n        return;\n    const doubleBuffer = renderStrategy === \"double-buffer\";\n    const dpr = Math.min(maxScaleFactor, Math.ceil(window.devicePixelRatio ?? 1));\n    // if we are double buffering we need to make sure we can blit. If we can't we need to redraw the whole thing\n    const canBlit = renderStrategy !== \"direct\" && (0,_data_grid_render_blit_js__WEBPACK_IMPORTED_MODULE_1__.computeCanBlit)(arg, lastArg);\n    const canvas = canvasCtx.canvas;\n    if (canvas.width !== width * dpr || canvas.height !== height * dpr) {\n        canvas.width = width * dpr;\n        canvas.height = height * dpr;\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n    }\n    const overlayCanvas = headerCanvasCtx.canvas;\n    const totalHeaderHeight = enableGroups ? groupHeaderHeight + headerHeight : headerHeight;\n    const overlayHeight = totalHeaderHeight + 1; // border\n    if (overlayCanvas.width !== width * dpr || overlayCanvas.height !== overlayHeight * dpr) {\n        overlayCanvas.width = width * dpr;\n        overlayCanvas.height = overlayHeight * dpr;\n        overlayCanvas.style.width = width + \"px\";\n        overlayCanvas.style.height = overlayHeight + \"px\";\n    }\n    const bufferA = bufferACtx.canvas;\n    const bufferB = bufferBCtx.canvas;\n    if (doubleBuffer && (bufferA.width !== width * dpr || bufferA.height !== height * dpr)) {\n        bufferA.width = width * dpr;\n        bufferA.height = height * dpr;\n        if (lastBlitData.current !== undefined)\n            lastBlitData.current.aBufferScroll = undefined;\n    }\n    if (doubleBuffer && (bufferB.width !== width * dpr || bufferB.height !== height * dpr)) {\n        bufferB.width = width * dpr;\n        bufferB.height = height * dpr;\n        if (lastBlitData.current !== undefined)\n            lastBlitData.current.bBufferScroll = undefined;\n    }\n    const last = lastBlitData.current;\n    if (canBlit === true &&\n        cellXOffset === last?.cellXOffset &&\n        cellYOffset === last?.cellYOffset &&\n        translateX === last?.translateX &&\n        translateY === last?.translateY)\n        return;\n    let mainCtx = null;\n    if (doubleBuffer) {\n        mainCtx = canvasCtx;\n    }\n    const overlayCtx = headerCanvasCtx;\n    let targetCtx;\n    if (!doubleBuffer) {\n        targetCtx = canvasCtx;\n    }\n    else if (damage !== undefined) {\n        targetCtx = last?.lastBuffer === \"b\" ? bufferBCtx : bufferACtx;\n    }\n    else {\n        targetCtx = last?.lastBuffer === \"b\" ? bufferACtx : bufferBCtx;\n    }\n    const targetBuffer = targetCtx.canvas;\n    const blitSource = doubleBuffer ? (targetBuffer === bufferA ? bufferB : bufferA) : canvas;\n    const getRowHeight = typeof rowHeight === \"number\" ? () => rowHeight : rowHeight;\n    overlayCtx.save();\n    targetCtx.save();\n    overlayCtx.beginPath();\n    targetCtx.beginPath();\n    overlayCtx.textBaseline = \"middle\";\n    targetCtx.textBaseline = \"middle\";\n    if (dpr !== 1) {\n        overlayCtx.scale(dpr, dpr);\n        targetCtx.scale(dpr, dpr);\n    }\n    const effectiveCols = (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.getEffectiveColumns)(mappedColumns, cellXOffset, width, dragAndDropState, translateX);\n    let drawRegions = [];\n    const mustDrawFocusOnHeader = drawFocus && selection.current?.cell[1] === cellYOffset && translateY === 0;\n    let mustDrawHighlightRingsOnHeader = false;\n    if (highlightRegions !== undefined) {\n        for (const r of highlightRegions) {\n            if (r.style !== \"no-outline\" && r.range.y === cellYOffset && translateY === 0) {\n                mustDrawHighlightRingsOnHeader = true;\n                break;\n            }\n        }\n    }\n    const drawHeaderTexture = () => {\n        (0,_data_grid_render_header_js__WEBPACK_IMPORTED_MODULE_3__.drawGridHeaders)(overlayCtx, effectiveCols, enableGroups, hoverInfo, width, translateX, headerHeight, groupHeaderHeight, dragAndDropState, isResizing, selection, theme, spriteManager, hoverValues, verticalBorder, getGroupDetails, damage, drawHeaderCallback, touchMode);\n        (0,_data_grid_render_lines_js__WEBPACK_IMPORTED_MODULE_4__.drawGridLines)(overlayCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, undefined, undefined, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, freezeTrailingRows, rows, theme, true);\n        overlayCtx.beginPath();\n        overlayCtx.moveTo(0, overlayHeight - 0.5);\n        overlayCtx.lineTo(width, overlayHeight - 0.5);\n        overlayCtx.strokeStyle = (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blend)(theme.headerBottomBorderColor ?? theme.horizontalBorderColor ?? theme.borderColor, theme.bgHeader);\n        overlayCtx.stroke();\n        if (mustDrawHighlightRingsOnHeader) {\n            (0,_data_grid_render_rings_js__WEBPACK_IMPORTED_MODULE_6__.drawHighlightRings)(overlayCtx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, freezeTrailingRows, rows, highlightRegions, theme);\n        }\n        if (mustDrawFocusOnHeader) {\n            (0,_data_grid_render_rings_js__WEBPACK_IMPORTED_MODULE_6__.drawFillHandle)(overlayCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, freezeTrailingRows, hasAppendRow, fillHandle, rows);\n        }\n    };\n    // handle damage updates by directly drawing to the target to avoid large blits\n    if (damage !== undefined) {\n        const viewRegionWidth = effectiveCols[effectiveCols.length - 1].sourceIndex + 1;\n        const damageInView = damage.hasItemInRegion([\n            {\n                x: cellXOffset,\n                y: -2,\n                width: viewRegionWidth,\n                height: 2,\n            },\n            {\n                x: cellXOffset,\n                y: cellYOffset,\n                width: viewRegionWidth,\n                height: 300,\n            },\n            {\n                x: 0,\n                y: cellYOffset,\n                width: freezeColumns,\n                height: 300,\n            },\n            {\n                x: 0,\n                y: -2,\n                width: freezeColumns,\n                height: 2,\n            },\n            {\n                x: cellXOffset,\n                y: rows - freezeTrailingRows,\n                width: viewRegionWidth,\n                height: freezeTrailingRows,\n                when: freezeTrailingRows > 0,\n            },\n        ]);\n        const doDamage = (ctx) => {\n            (0,_data_grid_render_cells_js__WEBPACK_IMPORTED_MODULE_7__.drawCells)(ctx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, freezeTrailingRows, hasAppendRow, drawRegions, damage, selection, prelightCells, highlightRegions, imageLoader, spriteManager, hoverValues, hoverInfo, drawCellCallback, hyperWrapping, theme, enqueue, renderStateProvider, getCellRenderer, overrideCursor, minimumCellWidth);\n            const selectionCurrent = selection.current;\n            if (fillHandle &&\n                drawFocus &&\n                selectionCurrent !== undefined &&\n                damage.has((0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_2__.rectBottomRight)(selectionCurrent.range))) {\n                (0,_data_grid_render_rings_js__WEBPACK_IMPORTED_MODULE_6__.drawFillHandle)(ctx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, freezeTrailingRows, hasAppendRow, fillHandle, rows);\n            }\n        };\n        if (damageInView) {\n            doDamage(targetCtx);\n            if (mainCtx !== null) {\n                mainCtx.save();\n                mainCtx.scale(dpr, dpr);\n                mainCtx.textBaseline = \"middle\";\n                doDamage(mainCtx);\n                mainCtx.restore();\n            }\n            const doHeaders = damage.hasHeader();\n            if (doHeaders) {\n                clipHeaderDamage(overlayCtx, effectiveCols, width, groupHeaderHeight, totalHeaderHeight, translateX, translateY, cellYOffset, damage);\n                drawHeaderTexture();\n            }\n        }\n        targetCtx.restore();\n        overlayCtx.restore();\n        return;\n    }\n    if (canBlit !== true ||\n        cellXOffset !== last?.cellXOffset ||\n        translateX !== last?.translateX ||\n        mustDrawFocusOnHeader !== last?.mustDrawFocusOnHeader ||\n        mustDrawHighlightRingsOnHeader !== last?.mustDrawHighlightRingsOnHeader) {\n        drawHeaderTexture();\n    }\n    if (canBlit === true) {\n        (0,_common_support_js__WEBPACK_IMPORTED_MODULE_8__.assert)(blitSource !== undefined && last !== undefined);\n        const { regions } = (0,_data_grid_render_blit_js__WEBPACK_IMPORTED_MODULE_1__.blitLastFrame)(targetCtx, blitSource, blitSource === bufferA ? last.aBufferScroll : last.bBufferScroll, blitSource === bufferA ? last.bBufferScroll : last.aBufferScroll, last, cellXOffset, cellYOffset, translateX, translateY, freezeTrailingRows, width, height, rows, totalHeaderHeight, dpr, mappedColumns, effectiveCols, rowHeight, doubleBuffer);\n        drawRegions = regions;\n    }\n    else if (canBlit !== false) {\n        (0,_common_support_js__WEBPACK_IMPORTED_MODULE_8__.assert)(last !== undefined);\n        const resizedCol = canBlit;\n        drawRegions = (0,_data_grid_render_blit_js__WEBPACK_IMPORTED_MODULE_1__.blitResizedCol)(last, cellXOffset, cellYOffset, translateX, translateY, width, height, totalHeaderHeight, effectiveCols, resizedCol);\n    }\n    (0,_data_grid_render_lines_js__WEBPACK_IMPORTED_MODULE_4__.overdrawStickyBoundaries)(targetCtx, effectiveCols, width, height, freezeTrailingRows, rows, verticalBorder, getRowHeight, theme);\n    const highlightRedraw = (0,_data_grid_render_rings_js__WEBPACK_IMPORTED_MODULE_6__.drawHighlightRings)(targetCtx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, freezeTrailingRows, rows, highlightRegions, theme);\n    // the overdraw may have nuked out our focus ring right edge.\n    const focusRedraw = drawFocus\n        ? (0,_data_grid_render_rings_js__WEBPACK_IMPORTED_MODULE_6__.drawFillHandle)(targetCtx, width, height, cellYOffset, translateX, translateY, effectiveCols, mappedColumns, theme, totalHeaderHeight, selection, getRowHeight, getCellContent, freezeTrailingRows, hasAppendRow, fillHandle, rows)\n        : undefined;\n    targetCtx.fillStyle = theme.bgCell;\n    if (drawRegions.length > 0) {\n        targetCtx.beginPath();\n        for (const r of drawRegions) {\n            targetCtx.rect(r.x, r.y, r.width, r.height);\n        }\n        targetCtx.clip();\n        targetCtx.fill();\n        targetCtx.beginPath();\n    }\n    else {\n        targetCtx.fillRect(0, 0, width, height);\n    }\n    const spans = (0,_data_grid_render_cells_js__WEBPACK_IMPORTED_MODULE_7__.drawCells)(targetCtx, effectiveCols, mappedColumns, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getCellContent, getGroupDetails, getRowThemeOverride, disabledRows, isFocused, drawFocus, freezeTrailingRows, hasAppendRow, drawRegions, damage, selection, prelightCells, highlightRegions, imageLoader, spriteManager, hoverValues, hoverInfo, drawCellCallback, hyperWrapping, theme, enqueue, renderStateProvider, getCellRenderer, overrideCursor, minimumCellWidth);\n    (0,_data_grid_render_lines_js__WEBPACK_IMPORTED_MODULE_4__.drawBlanks)(targetCtx, effectiveCols, mappedColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowThemeOverride, selection.rows, disabledRows, freezeTrailingRows, hasAppendRow, drawRegions, damage, theme);\n    (0,_data_grid_render_lines_js__WEBPACK_IMPORTED_MODULE_4__.drawExtraRowThemes)(targetCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, freezeTrailingRows, rows, theme);\n    (0,_data_grid_render_lines_js__WEBPACK_IMPORTED_MODULE_4__.drawGridLines)(targetCtx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, freezeTrailingRows, rows, theme);\n    highlightRedraw?.();\n    focusRedraw?.();\n    if (isResizing) {\n        (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_0__.walkColumns)(effectiveCols, 0, translateX, 0, totalHeaderHeight, (c, x) => {\n            if (c.sourceIndex === resizeCol) {\n                (0,_data_grid_render_rings_js__WEBPACK_IMPORTED_MODULE_6__.drawColumnResizeOutline)(overlayCtx, x + c.width, 0, totalHeaderHeight + 1, (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blend)(theme.resizeIndicatorColor ?? theme.accentLight, theme.bgHeader));\n                (0,_data_grid_render_rings_js__WEBPACK_IMPORTED_MODULE_6__.drawColumnResizeOutline)(targetCtx, x + c.width, totalHeaderHeight, height, (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blend)(theme.resizeIndicatorColor ?? theme.accentLight, theme.bgCell));\n                return true;\n            }\n            return false;\n        });\n    }\n    if (mainCtx !== null) {\n        mainCtx.fillStyle = theme.bgCell;\n        mainCtx.fillRect(0, 0, width, height);\n        mainCtx.drawImage(targetCtx.canvas, 0, 0);\n    }\n    const lastRowDrawn = getLastRow(effectiveCols, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, freezeTrailingRows, hasAppendRow);\n    imageLoader?.setWindow({\n        x: cellXOffset,\n        y: cellYOffset,\n        width: effectiveCols.length,\n        height: lastRowDrawn - cellYOffset,\n    }, freezeColumns, Array.from({ length: freezeTrailingRows }, (_, i) => rows - 1 - i));\n    const scrollX = last !== undefined && (cellXOffset !== last.cellXOffset || translateX !== last.translateX);\n    const scrollY = last !== undefined && (cellYOffset !== last.cellYOffset || translateY !== last.translateY);\n    lastBlitData.current = {\n        cellXOffset,\n        cellYOffset,\n        translateX,\n        translateY,\n        mustDrawFocusOnHeader,\n        mustDrawHighlightRingsOnHeader,\n        lastBuffer: doubleBuffer ? (targetBuffer === bufferA ? \"a\" : \"b\") : undefined,\n        aBufferScroll: targetBuffer === bufferA ? [scrollX, scrollY] : last?.aBufferScroll,\n        bBufferScroll: targetBuffer === bufferB ? [scrollX, scrollY] : last?.bBufferScroll,\n    };\n    targetCtx.restore();\n    overlayCtx.restore();\n}\n//# sourceMappingURL=data-grid-render.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VDO0FBQ0U7QUFDaUM7QUFDL0I7QUFDUztBQUNnQztBQUM1QjtBQUNPO0FBQ3VEO0FBQzNCO0FBQ2U7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUVBQVU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLHNFQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBVztBQUNmLFFBQVEsd0VBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLFlBQVksb3NCQUFvc0I7QUFDaHRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQseUVBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNFQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRFQUFlO0FBQ3ZCLFFBQVEseUVBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVEQUFLO0FBQ3RDO0FBQ0E7QUFDQSxZQUFZLDhFQUFrQjtBQUM5QjtBQUNBO0FBQ0EsWUFBWSwwRUFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxxRUFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrRUFBZTtBQUMxQyxnQkFBZ0IsMEVBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQU07QUFDZCxnQkFBZ0IsVUFBVSxFQUFFLHdFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQU07QUFDZDtBQUNBLHNCQUFzQix5RUFBYztBQUNwQztBQUNBLElBQUksb0ZBQXdCO0FBQzVCLDRCQUE0Qiw4RUFBa0I7QUFDOUM7QUFDQTtBQUNBLFVBQVUsMEVBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxRUFBUztBQUMzQixJQUFJLHNFQUFVO0FBQ2QsSUFBSSw4RUFBa0I7QUFDdEIsSUFBSSx5RUFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNFQUFXO0FBQ25CO0FBQ0EsZ0JBQWdCLG1GQUF1QixvREFBb0QsdURBQUs7QUFDaEcsZ0JBQWdCLG1GQUF1QixvREFBb0QsdURBQUs7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssOEJBQThCLDRCQUE0QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmpzP2M0OTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSB1bmljb3JuL25vLWZvci1sb29wICovXG5pbXBvcnQge30gZnJvbSBcIi4uL2RhdGEtZ3JpZC10eXBlcy5qc1wiO1xuaW1wb3J0IHsgQ2VsbFNldCB9IGZyb20gXCIuLi9jZWxsLXNldC5qc1wiO1xuaW1wb3J0IHsgZ2V0RWZmZWN0aXZlQ29sdW1ucywgcmVjdEJvdHRvbVJpZ2h0IH0gZnJvbSBcIi4vZGF0YS1ncmlkLWxpYi5qc1wiO1xuaW1wb3J0IHsgYmxlbmQgfSBmcm9tIFwiLi4vY29sb3ItcGFyc2VyLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL3N1cHBvcnQuanNcIjtcbmltcG9ydCB7IHdhbGtDb2x1bW5zLCB3YWxrR3JvdXBzLCB3YWxrUm93c0luQ29sIH0gZnJvbSBcIi4vZGF0YS1ncmlkLXJlbmRlci53YWxrLmpzXCI7XG5pbXBvcnQgeyBkcmF3Q2VsbHMgfSBmcm9tIFwiLi9kYXRhLWdyaWQtcmVuZGVyLmNlbGxzLmpzXCI7XG5pbXBvcnQgeyBkcmF3R3JpZEhlYWRlcnMgfSBmcm9tIFwiLi9kYXRhLWdyaWQtcmVuZGVyLmhlYWRlci5qc1wiO1xuaW1wb3J0IHsgZHJhd0dyaWRMaW5lcywgb3ZlcmRyYXdTdGlja3lCb3VuZGFyaWVzLCBkcmF3QmxhbmtzLCBkcmF3RXh0cmFSb3dUaGVtZXMgfSBmcm9tIFwiLi9kYXRhLWdyaWQtcmVuZGVyLmxpbmVzLmpzXCI7XG5pbXBvcnQgeyBibGl0TGFzdEZyYW1lLCBibGl0UmVzaXplZENvbCwgY29tcHV0ZUNhbkJsaXQgfSBmcm9tIFwiLi9kYXRhLWdyaWQtcmVuZGVyLmJsaXQuanNcIjtcbmltcG9ydCB7IGRyYXdIaWdobGlnaHRSaW5ncywgZHJhd0ZpbGxIYW5kbGUsIGRyYXdDb2x1bW5SZXNpemVPdXRsaW5lIH0gZnJvbSBcIi4vZGF0YS1ncmlkLnJlbmRlci5yaW5ncy5qc1wiO1xuLy8gRnV0dXJlIG9wdGltaXphdGlvbiBvcHBvcnR1bml0aWVzXG4vLyAtIENyZWF0ZSBhIGNhY2hlIG9mIGEgYnVmZmVyIHVzZWQgdG8gcmVuZGVyIHRoZSBmdWxsIHZpZXcgb2YgYSBwYXJ0aWFsbHkgZGlzcGxheWVkIGNvbHVtbiBzbyB0aGF0IHdoZW5cbi8vICAgc2Nyb2xsaW5nIGhvcml6b250YWxseSB5b3UgY2FuIHNpbXBseSBibGl0IHRoZSBwcmUtZHJhd24gY29sdW1uIGluc3RlYWQgb2YgY29udGludWFsbHkgcGF5aW5nIHRoZSBkcmF3XG4vLyAgIGNvc3QgYXMgaXQgc2xpZGVzIGludG8gdmlldy5cbi8vIC0gVGhlIHNhbWUgYXMgYWJvdmUgYnV0IGZvciBwYXJ0aWFsbHkgZGlzcGxheWVkIHJvd3Ncbi8vIC0gQmxpdCBoZWFkZXJzIG9uIGhvcml6b250YWwgc2Nyb2xsXG4vLyAtIFVzZSB3ZWJ3b3JrZXIgdG8gbG9hZCBpbWFnZXMsIGhlbHBmdWwgd2l0aCBsb3RzIG9mIGxhcmdlIGltYWdlc1xuLy8gLSBSZXRhaW4gbW9kZSBmb3IgZHJhd2luZyBjZWxscy4gSW5zdGVhZCBvZiBkcmF3aW5nIGNlbGxzIGFzIHdlIGNvbWUgYWNyb3NzIHRoZW0sIGZpcnN0IGJ1aWxkIGEgZGF0YVxuLy8gICBzdHJ1Y3R1cmUgd2hpY2ggY29udGFpbnMgYWxsIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSwgdGhlbiBzb3J0IHRoZW0gYWxsIGJ5IFwicHJlcFwiIHJlcXVpcmVtZW50LCB0aGVuIGRvXG4vLyAgIGFsbCBsaWtlIG9wZXJhdGlvbnMgYXQgb25jZS5cbmZ1bmN0aW9uIGNsaXBIZWFkZXJEYW1hZ2UoY3R4LCBlZmZlY3RpdmVDb2x1bW5zLCB3aWR0aCwgZ3JvdXBIZWFkZXJIZWlnaHQsIHRvdGFsSGVhZGVySGVpZ2h0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBjZWxsWU9mZnNldCwgZGFtYWdlKSB7XG4gICAgaWYgKGRhbWFnZSA9PT0gdW5kZWZpbmVkIHx8IGRhbWFnZS5zaXplID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIHdhbGtHcm91cHMoZWZmZWN0aXZlQ29sdW1ucywgd2lkdGgsIHRyYW5zbGF0ZVgsIGdyb3VwSGVhZGVySGVpZ2h0LCAoc3BhbiwgX2dyb3VwLCB4LCB5LCB3LCBoKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc0l0ZW1JblNwYW4gPSBkYW1hZ2UuaGFzSXRlbUluUmVjdGFuZ2xlKHtcbiAgICAgICAgICAgIHg6IHNwYW5bMF0sXG4gICAgICAgICAgICB5OiAtMixcbiAgICAgICAgICAgIHdpZHRoOiBzcGFuWzFdIC0gc3BhblswXSArIDEsXG4gICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzSXRlbUluU3Bhbikge1xuICAgICAgICAgICAgY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3YWxrQ29sdW1ucyhlZmZlY3RpdmVDb2x1bW5zLCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgdG90YWxIZWFkZXJIZWlnaHQsIChjLCBkcmF3WCwgX2NvbERyYXdZLCBjbGlwWCkgPT4ge1xuICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5tYXgoMCwgY2xpcFggLSBkcmF3WCk7XG4gICAgICAgIGNvbnN0IGZpbmFsWCA9IGRyYXdYICsgZGlmZiArIDE7XG4gICAgICAgIGNvbnN0IGZpbmFsV2lkdGggPSBjLndpZHRoIC0gZGlmZiAtIDE7XG4gICAgICAgIGlmIChkYW1hZ2UuaGFzKFtjLnNvdXJjZUluZGV4LCAtMV0pKSB7XG4gICAgICAgICAgICBjdHgucmVjdChmaW5hbFgsIGdyb3VwSGVhZGVySGVpZ2h0LCBmaW5hbFdpZHRoLCB0b3RhbEhlYWRlckhlaWdodCAtIGdyb3VwSGVhZGVySGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiBnZXRMYXN0Um93KGVmZmVjdGl2ZUNvbHVtbnMsIGhlaWdodCwgdG90YWxIZWFkZXJIZWlnaHQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIGNlbGxZT2Zmc2V0LCByb3dzLCBnZXRSb3dIZWlnaHQsIGZyZWV6ZVRyYWlsaW5nUm93cywgaGFzQXBwZW5kUm93KSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgd2Fsa0NvbHVtbnMoZWZmZWN0aXZlQ29sdW1ucywgY2VsbFlPZmZzZXQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHRvdGFsSGVhZGVySGVpZ2h0LCAoX2MsIF9fZHJhd1gsIGNvbERyYXdZLCBfY2xpcFgsIHN0YXJ0Um93KSA9PiB7XG4gICAgICAgIHdhbGtSb3dzSW5Db2woc3RhcnRSb3csIGNvbERyYXdZLCBoZWlnaHQsIHJvd3MsIGdldFJvd0hlaWdodCwgZnJlZXplVHJhaWxpbmdSb3dzLCBoYXNBcHBlbmRSb3csIHVuZGVmaW5lZCwgKF9kcmF3WSwgcm93LCBfcmgsIGlzU3RpY2t5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzU3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTWF0aC5tYXgocm93LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkcmF3R3JpZChhcmcsIGxhc3RBcmcpIHtcbiAgICBjb25zdCB7IGNhbnZhc0N0eCwgaGVhZGVyQ2FudmFzQ3R4LCB3aWR0aCwgaGVpZ2h0LCBjZWxsWE9mZnNldCwgY2VsbFlPZmZzZXQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIG1hcHBlZENvbHVtbnMsIGVuYWJsZUdyb3VwcywgZnJlZXplQ29sdW1ucywgZHJhZ0FuZERyb3BTdGF0ZSwgdGhlbWUsIGRyYXdGb2N1cywgaGVhZGVySGVpZ2h0LCBncm91cEhlYWRlckhlaWdodCwgZGlzYWJsZWRSb3dzLCByb3dIZWlnaHQsIHZlcnRpY2FsQm9yZGVyLCBvdmVycmlkZUN1cnNvciwgaXNSZXNpemluZywgc2VsZWN0aW9uLCBmaWxsSGFuZGxlLCBmcmVlemVUcmFpbGluZ1Jvd3MsIHJvd3MsIGdldENlbGxDb250ZW50LCBnZXRHcm91cERldGFpbHMsIGdldFJvd1RoZW1lT3ZlcnJpZGUsIGlzRm9jdXNlZCwgZHJhd0hlYWRlckNhbGxiYWNrLCBwcmVsaWdodENlbGxzLCBkcmF3Q2VsbENhbGxiYWNrLCBoaWdobGlnaHRSZWdpb25zLCByZXNpemVDb2wsIGltYWdlTG9hZGVyLCBsYXN0QmxpdERhdGEsIGhvdmVyVmFsdWVzLCBoeXBlcldyYXBwaW5nLCBob3ZlckluZm8sIHNwcml0ZU1hbmFnZXIsIG1heFNjYWxlRmFjdG9yLCBoYXNBcHBlbmRSb3csIHRvdWNoTW9kZSwgZW5xdWV1ZSwgcmVuZGVyU3RhdGVQcm92aWRlciwgZ2V0Q2VsbFJlbmRlcmVyLCByZW5kZXJTdHJhdGVneSwgYnVmZmVyQUN0eCwgYnVmZmVyQkN0eCwgZGFtYWdlLCBtaW5pbXVtQ2VsbFdpZHRoLCB9ID0gYXJnO1xuICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBkb3VibGVCdWZmZXIgPSByZW5kZXJTdHJhdGVneSA9PT0gXCJkb3VibGUtYnVmZmVyXCI7XG4gICAgY29uc3QgZHByID0gTWF0aC5taW4obWF4U2NhbGVGYWN0b3IsIE1hdGguY2VpbCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA/PyAxKSk7XG4gICAgLy8gaWYgd2UgYXJlIGRvdWJsZSBidWZmZXJpbmcgd2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgY2FuIGJsaXQuIElmIHdlIGNhbid0IHdlIG5lZWQgdG8gcmVkcmF3IHRoZSB3aG9sZSB0aGluZ1xuICAgIGNvbnN0IGNhbkJsaXQgPSByZW5kZXJTdHJhdGVneSAhPT0gXCJkaXJlY3RcIiAmJiBjb21wdXRlQ2FuQmxpdChhcmcsIGxhc3RBcmcpO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc0N0eC5jYW52YXM7XG4gICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gd2lkdGggKiBkcHIgfHwgY2FudmFzLmhlaWdodCAhPT0gaGVpZ2h0ICogZHByKSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB9XG4gICAgY29uc3Qgb3ZlcmxheUNhbnZhcyA9IGhlYWRlckNhbnZhc0N0eC5jYW52YXM7XG4gICAgY29uc3QgdG90YWxIZWFkZXJIZWlnaHQgPSBlbmFibGVHcm91cHMgPyBncm91cEhlYWRlckhlaWdodCArIGhlYWRlckhlaWdodCA6IGhlYWRlckhlaWdodDtcbiAgICBjb25zdCBvdmVybGF5SGVpZ2h0ID0gdG90YWxIZWFkZXJIZWlnaHQgKyAxOyAvLyBib3JkZXJcbiAgICBpZiAob3ZlcmxheUNhbnZhcy53aWR0aCAhPT0gd2lkdGggKiBkcHIgfHwgb3ZlcmxheUNhbnZhcy5oZWlnaHQgIT09IG92ZXJsYXlIZWlnaHQgKiBkcHIpIHtcbiAgICAgICAgb3ZlcmxheUNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBvdmVybGF5Q2FudmFzLmhlaWdodCA9IG92ZXJsYXlIZWlnaHQgKiBkcHI7XG4gICAgICAgIG92ZXJsYXlDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICAgICAgb3ZlcmxheUNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvdmVybGF5SGVpZ2h0ICsgXCJweFwiO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJBID0gYnVmZmVyQUN0eC5jYW52YXM7XG4gICAgY29uc3QgYnVmZmVyQiA9IGJ1ZmZlckJDdHguY2FudmFzO1xuICAgIGlmIChkb3VibGVCdWZmZXIgJiYgKGJ1ZmZlckEud2lkdGggIT09IHdpZHRoICogZHByIHx8IGJ1ZmZlckEuaGVpZ2h0ICE9PSBoZWlnaHQgKiBkcHIpKSB7XG4gICAgICAgIGJ1ZmZlckEud2lkdGggPSB3aWR0aCAqIGRwcjtcbiAgICAgICAgYnVmZmVyQS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG4gICAgICAgIGlmIChsYXN0QmxpdERhdGEuY3VycmVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbGFzdEJsaXREYXRhLmN1cnJlbnQuYUJ1ZmZlclNjcm9sbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGRvdWJsZUJ1ZmZlciAmJiAoYnVmZmVyQi53aWR0aCAhPT0gd2lkdGggKiBkcHIgfHwgYnVmZmVyQi5oZWlnaHQgIT09IGhlaWdodCAqIGRwcikpIHtcbiAgICAgICAgYnVmZmVyQi53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBidWZmZXJCLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcbiAgICAgICAgaWYgKGxhc3RCbGl0RGF0YS5jdXJyZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBsYXN0QmxpdERhdGEuY3VycmVudC5iQnVmZmVyU2Nyb2xsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gbGFzdEJsaXREYXRhLmN1cnJlbnQ7XG4gICAgaWYgKGNhbkJsaXQgPT09IHRydWUgJiZcbiAgICAgICAgY2VsbFhPZmZzZXQgPT09IGxhc3Q/LmNlbGxYT2Zmc2V0ICYmXG4gICAgICAgIGNlbGxZT2Zmc2V0ID09PSBsYXN0Py5jZWxsWU9mZnNldCAmJlxuICAgICAgICB0cmFuc2xhdGVYID09PSBsYXN0Py50cmFuc2xhdGVYICYmXG4gICAgICAgIHRyYW5zbGF0ZVkgPT09IGxhc3Q/LnRyYW5zbGF0ZVkpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbWFpbkN0eCA9IG51bGw7XG4gICAgaWYgKGRvdWJsZUJ1ZmZlcikge1xuICAgICAgICBtYWluQ3R4ID0gY2FudmFzQ3R4O1xuICAgIH1cbiAgICBjb25zdCBvdmVybGF5Q3R4ID0gaGVhZGVyQ2FudmFzQ3R4O1xuICAgIGxldCB0YXJnZXRDdHg7XG4gICAgaWYgKCFkb3VibGVCdWZmZXIpIHtcbiAgICAgICAgdGFyZ2V0Q3R4ID0gY2FudmFzQ3R4O1xuICAgIH1cbiAgICBlbHNlIGlmIChkYW1hZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YXJnZXRDdHggPSBsYXN0Py5sYXN0QnVmZmVyID09PSBcImJcIiA/IGJ1ZmZlckJDdHggOiBidWZmZXJBQ3R4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Q3R4ID0gbGFzdD8ubGFzdEJ1ZmZlciA9PT0gXCJiXCIgPyBidWZmZXJBQ3R4IDogYnVmZmVyQkN0eDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0QnVmZmVyID0gdGFyZ2V0Q3R4LmNhbnZhcztcbiAgICBjb25zdCBibGl0U291cmNlID0gZG91YmxlQnVmZmVyID8gKHRhcmdldEJ1ZmZlciA9PT0gYnVmZmVyQSA/IGJ1ZmZlckIgOiBidWZmZXJBKSA6IGNhbnZhcztcbiAgICBjb25zdCBnZXRSb3dIZWlnaHQgPSB0eXBlb2Ygcm93SGVpZ2h0ID09PSBcIm51bWJlclwiID8gKCkgPT4gcm93SGVpZ2h0IDogcm93SGVpZ2h0O1xuICAgIG92ZXJsYXlDdHguc2F2ZSgpO1xuICAgIHRhcmdldEN0eC5zYXZlKCk7XG4gICAgb3ZlcmxheUN0eC5iZWdpblBhdGgoKTtcbiAgICB0YXJnZXRDdHguYmVnaW5QYXRoKCk7XG4gICAgb3ZlcmxheUN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIHRhcmdldEN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIGlmIChkcHIgIT09IDEpIHtcbiAgICAgICAgb3ZlcmxheUN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgIHRhcmdldEN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgfVxuICAgIGNvbnN0IGVmZmVjdGl2ZUNvbHMgPSBnZXRFZmZlY3RpdmVDb2x1bW5zKG1hcHBlZENvbHVtbnMsIGNlbGxYT2Zmc2V0LCB3aWR0aCwgZHJhZ0FuZERyb3BTdGF0ZSwgdHJhbnNsYXRlWCk7XG4gICAgbGV0IGRyYXdSZWdpb25zID0gW107XG4gICAgY29uc3QgbXVzdERyYXdGb2N1c09uSGVhZGVyID0gZHJhd0ZvY3VzICYmIHNlbGVjdGlvbi5jdXJyZW50Py5jZWxsWzFdID09PSBjZWxsWU9mZnNldCAmJiB0cmFuc2xhdGVZID09PSAwO1xuICAgIGxldCBtdXN0RHJhd0hpZ2hsaWdodFJpbmdzT25IZWFkZXIgPSBmYWxzZTtcbiAgICBpZiAoaGlnaGxpZ2h0UmVnaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAoY29uc3QgciBvZiBoaWdobGlnaHRSZWdpb25zKSB7XG4gICAgICAgICAgICBpZiAoci5zdHlsZSAhPT0gXCJuby1vdXRsaW5lXCIgJiYgci5yYW5nZS55ID09PSBjZWxsWU9mZnNldCAmJiB0cmFuc2xhdGVZID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbXVzdERyYXdIaWdobGlnaHRSaW5nc09uSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkcmF3SGVhZGVyVGV4dHVyZSA9ICgpID0+IHtcbiAgICAgICAgZHJhd0dyaWRIZWFkZXJzKG92ZXJsYXlDdHgsIGVmZmVjdGl2ZUNvbHMsIGVuYWJsZUdyb3VwcywgaG92ZXJJbmZvLCB3aWR0aCwgdHJhbnNsYXRlWCwgaGVhZGVySGVpZ2h0LCBncm91cEhlYWRlckhlaWdodCwgZHJhZ0FuZERyb3BTdGF0ZSwgaXNSZXNpemluZywgc2VsZWN0aW9uLCB0aGVtZSwgc3ByaXRlTWFuYWdlciwgaG92ZXJWYWx1ZXMsIHZlcnRpY2FsQm9yZGVyLCBnZXRHcm91cERldGFpbHMsIGRhbWFnZSwgZHJhd0hlYWRlckNhbGxiYWNrLCB0b3VjaE1vZGUpO1xuICAgICAgICBkcmF3R3JpZExpbmVzKG92ZXJsYXlDdHgsIGVmZmVjdGl2ZUNvbHMsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCB3aWR0aCwgaGVpZ2h0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZ3JvdXBIZWFkZXJIZWlnaHQsIHRvdGFsSGVhZGVySGVpZ2h0LCBnZXRSb3dIZWlnaHQsIGdldFJvd1RoZW1lT3ZlcnJpZGUsIHZlcnRpY2FsQm9yZGVyLCBmcmVlemVUcmFpbGluZ1Jvd3MsIHJvd3MsIHRoZW1lLCB0cnVlKTtcbiAgICAgICAgb3ZlcmxheUN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgb3ZlcmxheUN0eC5tb3ZlVG8oMCwgb3ZlcmxheUhlaWdodCAtIDAuNSk7XG4gICAgICAgIG92ZXJsYXlDdHgubGluZVRvKHdpZHRoLCBvdmVybGF5SGVpZ2h0IC0gMC41KTtcbiAgICAgICAgb3ZlcmxheUN0eC5zdHJva2VTdHlsZSA9IGJsZW5kKHRoZW1lLmhlYWRlckJvdHRvbUJvcmRlckNvbG9yID8/IHRoZW1lLmhvcml6b250YWxCb3JkZXJDb2xvciA/PyB0aGVtZS5ib3JkZXJDb2xvciwgdGhlbWUuYmdIZWFkZXIpO1xuICAgICAgICBvdmVybGF5Q3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAobXVzdERyYXdIaWdobGlnaHRSaW5nc09uSGVhZGVyKSB7XG4gICAgICAgICAgICBkcmF3SGlnaGxpZ2h0UmluZ3Mob3ZlcmxheUN0eCwgd2lkdGgsIGhlaWdodCwgY2VsbFhPZmZzZXQsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBtYXBwZWRDb2x1bW5zLCBmcmVlemVDb2x1bW5zLCBoZWFkZXJIZWlnaHQsIGdyb3VwSGVhZGVySGVpZ2h0LCByb3dIZWlnaHQsIGZyZWV6ZVRyYWlsaW5nUm93cywgcm93cywgaGlnaGxpZ2h0UmVnaW9ucywgdGhlbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdXN0RHJhd0ZvY3VzT25IZWFkZXIpIHtcbiAgICAgICAgICAgIGRyYXdGaWxsSGFuZGxlKG92ZXJsYXlDdHgsIHdpZHRoLCBoZWlnaHQsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBlZmZlY3RpdmVDb2xzLCBtYXBwZWRDb2x1bW5zLCB0aGVtZSwgdG90YWxIZWFkZXJIZWlnaHQsIHNlbGVjdGlvbiwgZ2V0Um93SGVpZ2h0LCBnZXRDZWxsQ29udGVudCwgZnJlZXplVHJhaWxpbmdSb3dzLCBoYXNBcHBlbmRSb3csIGZpbGxIYW5kbGUsIHJvd3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBoYW5kbGUgZGFtYWdlIHVwZGF0ZXMgYnkgZGlyZWN0bHkgZHJhd2luZyB0byB0aGUgdGFyZ2V0IHRvIGF2b2lkIGxhcmdlIGJsaXRzXG4gICAgaWYgKGRhbWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZpZXdSZWdpb25XaWR0aCA9IGVmZmVjdGl2ZUNvbHNbZWZmZWN0aXZlQ29scy5sZW5ndGggLSAxXS5zb3VyY2VJbmRleCArIDE7XG4gICAgICAgIGNvbnN0IGRhbWFnZUluVmlldyA9IGRhbWFnZS5oYXNJdGVtSW5SZWdpb24oW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHg6IGNlbGxYT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHk6IC0yLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB2aWV3UmVnaW9uV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiBjZWxsWE9mZnNldCxcbiAgICAgICAgICAgICAgICB5OiBjZWxsWU9mZnNldCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdmlld1JlZ2lvbldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMzAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IGNlbGxZT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBmcmVlemVDb2x1bW5zLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMzAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IC0yLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBmcmVlemVDb2x1bW5zLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeDogY2VsbFhPZmZzZXQsXG4gICAgICAgICAgICAgICAgeTogcm93cyAtIGZyZWV6ZVRyYWlsaW5nUm93cyxcbiAgICAgICAgICAgICAgICB3aWR0aDogdmlld1JlZ2lvbldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZnJlZXplVHJhaWxpbmdSb3dzLFxuICAgICAgICAgICAgICAgIHdoZW46IGZyZWV6ZVRyYWlsaW5nUm93cyA+IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZG9EYW1hZ2UgPSAoY3R4KSA9PiB7XG4gICAgICAgICAgICBkcmF3Q2VsbHMoY3R4LCBlZmZlY3RpdmVDb2xzLCBtYXBwZWRDb2x1bW5zLCBoZWlnaHQsIHRvdGFsSGVhZGVySGVpZ2h0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBjZWxsWU9mZnNldCwgcm93cywgZ2V0Um93SGVpZ2h0LCBnZXRDZWxsQ29udGVudCwgZ2V0R3JvdXBEZXRhaWxzLCBnZXRSb3dUaGVtZU92ZXJyaWRlLCBkaXNhYmxlZFJvd3MsIGlzRm9jdXNlZCwgZHJhd0ZvY3VzLCBmcmVlemVUcmFpbGluZ1Jvd3MsIGhhc0FwcGVuZFJvdywgZHJhd1JlZ2lvbnMsIGRhbWFnZSwgc2VsZWN0aW9uLCBwcmVsaWdodENlbGxzLCBoaWdobGlnaHRSZWdpb25zLCBpbWFnZUxvYWRlciwgc3ByaXRlTWFuYWdlciwgaG92ZXJWYWx1ZXMsIGhvdmVySW5mbywgZHJhd0NlbGxDYWxsYmFjaywgaHlwZXJXcmFwcGluZywgdGhlbWUsIGVucXVldWUsIHJlbmRlclN0YXRlUHJvdmlkZXIsIGdldENlbGxSZW5kZXJlciwgb3ZlcnJpZGVDdXJzb3IsIG1pbmltdW1DZWxsV2lkdGgpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ3VycmVudCA9IHNlbGVjdGlvbi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKGZpbGxIYW5kbGUgJiZcbiAgICAgICAgICAgICAgICBkcmF3Rm9jdXMgJiZcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25DdXJyZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBkYW1hZ2UuaGFzKHJlY3RCb3R0b21SaWdodChzZWxlY3Rpb25DdXJyZW50LnJhbmdlKSkpIHtcbiAgICAgICAgICAgICAgICBkcmF3RmlsbEhhbmRsZShjdHgsIHdpZHRoLCBoZWlnaHQsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBlZmZlY3RpdmVDb2xzLCBtYXBwZWRDb2x1bW5zLCB0aGVtZSwgdG90YWxIZWFkZXJIZWlnaHQsIHNlbGVjdGlvbiwgZ2V0Um93SGVpZ2h0LCBnZXRDZWxsQ29udGVudCwgZnJlZXplVHJhaWxpbmdSb3dzLCBoYXNBcHBlbmRSb3csIGZpbGxIYW5kbGUsIHJvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGFtYWdlSW5WaWV3KSB7XG4gICAgICAgICAgICBkb0RhbWFnZSh0YXJnZXRDdHgpO1xuICAgICAgICAgICAgaWYgKG1haW5DdHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtYWluQ3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBtYWluQ3R4LnNjYWxlKGRwciwgZHByKTtcbiAgICAgICAgICAgICAgICBtYWluQ3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgICAgICAgICAgZG9EYW1hZ2UobWFpbkN0eCk7XG4gICAgICAgICAgICAgICAgbWFpbkN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkb0hlYWRlcnMgPSBkYW1hZ2UuaGFzSGVhZGVyKCk7XG4gICAgICAgICAgICBpZiAoZG9IZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgY2xpcEhlYWRlckRhbWFnZShvdmVybGF5Q3R4LCBlZmZlY3RpdmVDb2xzLCB3aWR0aCwgZ3JvdXBIZWFkZXJIZWlnaHQsIHRvdGFsSGVhZGVySGVpZ2h0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBjZWxsWU9mZnNldCwgZGFtYWdlKTtcbiAgICAgICAgICAgICAgICBkcmF3SGVhZGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldEN0eC5yZXN0b3JlKCk7XG4gICAgICAgIG92ZXJsYXlDdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYW5CbGl0ICE9PSB0cnVlIHx8XG4gICAgICAgIGNlbGxYT2Zmc2V0ICE9PSBsYXN0Py5jZWxsWE9mZnNldCB8fFxuICAgICAgICB0cmFuc2xhdGVYICE9PSBsYXN0Py50cmFuc2xhdGVYIHx8XG4gICAgICAgIG11c3REcmF3Rm9jdXNPbkhlYWRlciAhPT0gbGFzdD8ubXVzdERyYXdGb2N1c09uSGVhZGVyIHx8XG4gICAgICAgIG11c3REcmF3SGlnaGxpZ2h0UmluZ3NPbkhlYWRlciAhPT0gbGFzdD8ubXVzdERyYXdIaWdobGlnaHRSaW5nc09uSGVhZGVyKSB7XG4gICAgICAgIGRyYXdIZWFkZXJUZXh0dXJlKCk7XG4gICAgfVxuICAgIGlmIChjYW5CbGl0ID09PSB0cnVlKSB7XG4gICAgICAgIGFzc2VydChibGl0U291cmNlICE9PSB1bmRlZmluZWQgJiYgbGFzdCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgeyByZWdpb25zIH0gPSBibGl0TGFzdEZyYW1lKHRhcmdldEN0eCwgYmxpdFNvdXJjZSwgYmxpdFNvdXJjZSA9PT0gYnVmZmVyQSA/IGxhc3QuYUJ1ZmZlclNjcm9sbCA6IGxhc3QuYkJ1ZmZlclNjcm9sbCwgYmxpdFNvdXJjZSA9PT0gYnVmZmVyQSA/IGxhc3QuYkJ1ZmZlclNjcm9sbCA6IGxhc3QuYUJ1ZmZlclNjcm9sbCwgbGFzdCwgY2VsbFhPZmZzZXQsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBmcmVlemVUcmFpbGluZ1Jvd3MsIHdpZHRoLCBoZWlnaHQsIHJvd3MsIHRvdGFsSGVhZGVySGVpZ2h0LCBkcHIsIG1hcHBlZENvbHVtbnMsIGVmZmVjdGl2ZUNvbHMsIHJvd0hlaWdodCwgZG91YmxlQnVmZmVyKTtcbiAgICAgICAgZHJhd1JlZ2lvbnMgPSByZWdpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmIChjYW5CbGl0ICE9PSBmYWxzZSkge1xuICAgICAgICBhc3NlcnQobGFzdCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcmVzaXplZENvbCA9IGNhbkJsaXQ7XG4gICAgICAgIGRyYXdSZWdpb25zID0gYmxpdFJlc2l6ZWRDb2wobGFzdCwgY2VsbFhPZmZzZXQsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCB3aWR0aCwgaGVpZ2h0LCB0b3RhbEhlYWRlckhlaWdodCwgZWZmZWN0aXZlQ29scywgcmVzaXplZENvbCk7XG4gICAgfVxuICAgIG92ZXJkcmF3U3RpY2t5Qm91bmRhcmllcyh0YXJnZXRDdHgsIGVmZmVjdGl2ZUNvbHMsIHdpZHRoLCBoZWlnaHQsIGZyZWV6ZVRyYWlsaW5nUm93cywgcm93cywgdmVydGljYWxCb3JkZXIsIGdldFJvd0hlaWdodCwgdGhlbWUpO1xuICAgIGNvbnN0IGhpZ2hsaWdodFJlZHJhdyA9IGRyYXdIaWdobGlnaHRSaW5ncyh0YXJnZXRDdHgsIHdpZHRoLCBoZWlnaHQsIGNlbGxYT2Zmc2V0LCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgbWFwcGVkQ29sdW1ucywgZnJlZXplQ29sdW1ucywgaGVhZGVySGVpZ2h0LCBncm91cEhlYWRlckhlaWdodCwgcm93SGVpZ2h0LCBmcmVlemVUcmFpbGluZ1Jvd3MsIHJvd3MsIGhpZ2hsaWdodFJlZ2lvbnMsIHRoZW1lKTtcbiAgICAvLyB0aGUgb3ZlcmRyYXcgbWF5IGhhdmUgbnVrZWQgb3V0IG91ciBmb2N1cyByaW5nIHJpZ2h0IGVkZ2UuXG4gICAgY29uc3QgZm9jdXNSZWRyYXcgPSBkcmF3Rm9jdXNcbiAgICAgICAgPyBkcmF3RmlsbEhhbmRsZSh0YXJnZXRDdHgsIHdpZHRoLCBoZWlnaHQsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBlZmZlY3RpdmVDb2xzLCBtYXBwZWRDb2x1bW5zLCB0aGVtZSwgdG90YWxIZWFkZXJIZWlnaHQsIHNlbGVjdGlvbiwgZ2V0Um93SGVpZ2h0LCBnZXRDZWxsQ29udGVudCwgZnJlZXplVHJhaWxpbmdSb3dzLCBoYXNBcHBlbmRSb3csIGZpbGxIYW5kbGUsIHJvd3MpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHRhcmdldEN0eC5maWxsU3R5bGUgPSB0aGVtZS5iZ0NlbGw7XG4gICAgaWYgKGRyYXdSZWdpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGFyZ2V0Q3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHIgb2YgZHJhd1JlZ2lvbnMpIHtcbiAgICAgICAgICAgIHRhcmdldEN0eC5yZWN0KHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0Q3R4LmNsaXAoKTtcbiAgICAgICAgdGFyZ2V0Q3R4LmZpbGwoKTtcbiAgICAgICAgdGFyZ2V0Q3R4LmJlZ2luUGF0aCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Q3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBzcGFucyA9IGRyYXdDZWxscyh0YXJnZXRDdHgsIGVmZmVjdGl2ZUNvbHMsIG1hcHBlZENvbHVtbnMsIGhlaWdodCwgdG90YWxIZWFkZXJIZWlnaHQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIGNlbGxZT2Zmc2V0LCByb3dzLCBnZXRSb3dIZWlnaHQsIGdldENlbGxDb250ZW50LCBnZXRHcm91cERldGFpbHMsIGdldFJvd1RoZW1lT3ZlcnJpZGUsIGRpc2FibGVkUm93cywgaXNGb2N1c2VkLCBkcmF3Rm9jdXMsIGZyZWV6ZVRyYWlsaW5nUm93cywgaGFzQXBwZW5kUm93LCBkcmF3UmVnaW9ucywgZGFtYWdlLCBzZWxlY3Rpb24sIHByZWxpZ2h0Q2VsbHMsIGhpZ2hsaWdodFJlZ2lvbnMsIGltYWdlTG9hZGVyLCBzcHJpdGVNYW5hZ2VyLCBob3ZlclZhbHVlcywgaG92ZXJJbmZvLCBkcmF3Q2VsbENhbGxiYWNrLCBoeXBlcldyYXBwaW5nLCB0aGVtZSwgZW5xdWV1ZSwgcmVuZGVyU3RhdGVQcm92aWRlciwgZ2V0Q2VsbFJlbmRlcmVyLCBvdmVycmlkZUN1cnNvciwgbWluaW11bUNlbGxXaWR0aCk7XG4gICAgZHJhd0JsYW5rcyh0YXJnZXRDdHgsIGVmZmVjdGl2ZUNvbHMsIG1hcHBlZENvbHVtbnMsIHdpZHRoLCBoZWlnaHQsIHRvdGFsSGVhZGVySGVpZ2h0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBjZWxsWU9mZnNldCwgcm93cywgZ2V0Um93SGVpZ2h0LCBnZXRSb3dUaGVtZU92ZXJyaWRlLCBzZWxlY3Rpb24ucm93cywgZGlzYWJsZWRSb3dzLCBmcmVlemVUcmFpbGluZ1Jvd3MsIGhhc0FwcGVuZFJvdywgZHJhd1JlZ2lvbnMsIGRhbWFnZSwgdGhlbWUpO1xuICAgIGRyYXdFeHRyYVJvd1RoZW1lcyh0YXJnZXRDdHgsIGVmZmVjdGl2ZUNvbHMsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCB3aWR0aCwgaGVpZ2h0LCBkcmF3UmVnaW9ucywgdG90YWxIZWFkZXJIZWlnaHQsIGdldFJvd0hlaWdodCwgZ2V0Um93VGhlbWVPdmVycmlkZSwgdmVydGljYWxCb3JkZXIsIGZyZWV6ZVRyYWlsaW5nUm93cywgcm93cywgdGhlbWUpO1xuICAgIGRyYXdHcmlkTGluZXModGFyZ2V0Q3R4LCBlZmZlY3RpdmVDb2xzLCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgd2lkdGgsIGhlaWdodCwgZHJhd1JlZ2lvbnMsIHNwYW5zLCBncm91cEhlYWRlckhlaWdodCwgdG90YWxIZWFkZXJIZWlnaHQsIGdldFJvd0hlaWdodCwgZ2V0Um93VGhlbWVPdmVycmlkZSwgdmVydGljYWxCb3JkZXIsIGZyZWV6ZVRyYWlsaW5nUm93cywgcm93cywgdGhlbWUpO1xuICAgIGhpZ2hsaWdodFJlZHJhdz8uKCk7XG4gICAgZm9jdXNSZWRyYXc/LigpO1xuICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgIHdhbGtDb2x1bW5zKGVmZmVjdGl2ZUNvbHMsIDAsIHRyYW5zbGF0ZVgsIDAsIHRvdGFsSGVhZGVySGVpZ2h0LCAoYywgeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGMuc291cmNlSW5kZXggPT09IHJlc2l6ZUNvbCkge1xuICAgICAgICAgICAgICAgIGRyYXdDb2x1bW5SZXNpemVPdXRsaW5lKG92ZXJsYXlDdHgsIHggKyBjLndpZHRoLCAwLCB0b3RhbEhlYWRlckhlaWdodCArIDEsIGJsZW5kKHRoZW1lLnJlc2l6ZUluZGljYXRvckNvbG9yID8/IHRoZW1lLmFjY2VudExpZ2h0LCB0aGVtZS5iZ0hlYWRlcikpO1xuICAgICAgICAgICAgICAgIGRyYXdDb2x1bW5SZXNpemVPdXRsaW5lKHRhcmdldEN0eCwgeCArIGMud2lkdGgsIHRvdGFsSGVhZGVySGVpZ2h0LCBoZWlnaHQsIGJsZW5kKHRoZW1lLnJlc2l6ZUluZGljYXRvckNvbG9yID8/IHRoZW1lLmFjY2VudExpZ2h0LCB0aGVtZS5iZ0NlbGwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYWluQ3R4ICE9PSBudWxsKSB7XG4gICAgICAgIG1haW5DdHguZmlsbFN0eWxlID0gdGhlbWUuYmdDZWxsO1xuICAgICAgICBtYWluQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtYWluQ3R4LmRyYXdJbWFnZSh0YXJnZXRDdHguY2FudmFzLCAwLCAwKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdFJvd0RyYXduID0gZ2V0TGFzdFJvdyhlZmZlY3RpdmVDb2xzLCBoZWlnaHQsIHRvdGFsSGVhZGVySGVpZ2h0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCBjZWxsWU9mZnNldCwgcm93cywgZ2V0Um93SGVpZ2h0LCBmcmVlemVUcmFpbGluZ1Jvd3MsIGhhc0FwcGVuZFJvdyk7XG4gICAgaW1hZ2VMb2FkZXI/LnNldFdpbmRvdyh7XG4gICAgICAgIHg6IGNlbGxYT2Zmc2V0LFxuICAgICAgICB5OiBjZWxsWU9mZnNldCxcbiAgICAgICAgd2lkdGg6IGVmZmVjdGl2ZUNvbHMubGVuZ3RoLFxuICAgICAgICBoZWlnaHQ6IGxhc3RSb3dEcmF3biAtIGNlbGxZT2Zmc2V0LFxuICAgIH0sIGZyZWV6ZUNvbHVtbnMsIEFycmF5LmZyb20oeyBsZW5ndGg6IGZyZWV6ZVRyYWlsaW5nUm93cyB9LCAoXywgaSkgPT4gcm93cyAtIDEgLSBpKSk7XG4gICAgY29uc3Qgc2Nyb2xsWCA9IGxhc3QgIT09IHVuZGVmaW5lZCAmJiAoY2VsbFhPZmZzZXQgIT09IGxhc3QuY2VsbFhPZmZzZXQgfHwgdHJhbnNsYXRlWCAhPT0gbGFzdC50cmFuc2xhdGVYKTtcbiAgICBjb25zdCBzY3JvbGxZID0gbGFzdCAhPT0gdW5kZWZpbmVkICYmIChjZWxsWU9mZnNldCAhPT0gbGFzdC5jZWxsWU9mZnNldCB8fCB0cmFuc2xhdGVZICE9PSBsYXN0LnRyYW5zbGF0ZVkpO1xuICAgIGxhc3RCbGl0RGF0YS5jdXJyZW50ID0ge1xuICAgICAgICBjZWxsWE9mZnNldCxcbiAgICAgICAgY2VsbFlPZmZzZXQsXG4gICAgICAgIHRyYW5zbGF0ZVgsXG4gICAgICAgIHRyYW5zbGF0ZVksXG4gICAgICAgIG11c3REcmF3Rm9jdXNPbkhlYWRlcixcbiAgICAgICAgbXVzdERyYXdIaWdobGlnaHRSaW5nc09uSGVhZGVyLFxuICAgICAgICBsYXN0QnVmZmVyOiBkb3VibGVCdWZmZXIgPyAodGFyZ2V0QnVmZmVyID09PSBidWZmZXJBID8gXCJhXCIgOiBcImJcIikgOiB1bmRlZmluZWQsXG4gICAgICAgIGFCdWZmZXJTY3JvbGw6IHRhcmdldEJ1ZmZlciA9PT0gYnVmZmVyQSA/IFtzY3JvbGxYLCBzY3JvbGxZXSA6IGxhc3Q/LmFCdWZmZXJTY3JvbGwsXG4gICAgICAgIGJCdWZmZXJTY3JvbGw6IHRhcmdldEJ1ZmZlciA9PT0gYnVmZmVyQiA/IFtzY3JvbGxYLCBzY3JvbGxZXSA6IGxhc3Q/LmJCdWZmZXJTY3JvbGwsXG4gICAgfTtcbiAgICB0YXJnZXRDdHgucmVzdG9yZSgpO1xuICAgIG92ZXJsYXlDdHgucmVzdG9yZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS1ncmlkLXJlbmRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.lines.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.lines.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawBlanks: () => (/* binding */ drawBlanks),\n/* harmony export */   drawExtraRowThemes: () => (/* binding */ drawExtraRowThemes),\n/* harmony export */   drawGridLines: () => (/* binding */ drawGridLines),\n/* harmony export */   overdrawStickyBoundaries: () => (/* binding */ overdrawStickyBoundaries)\n/* harmony export */ });\n/* harmony import */ var lodash_groupBy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/groupBy.js */ \"(ssr)/./node_modules/lodash/groupBy.js\");\n/* harmony import */ var _data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _common_styles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/styles.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/styles.js\");\n/* harmony import */ var _color_parser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../color-parser.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\");\n/* harmony import */ var _common_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../common/math.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js\");\n/* harmony import */ var _data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-grid-render.walk.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.walk.js\");\n/* eslint-disable sonarjs/no-duplicate-string */\n/* eslint-disable unicorn/no-for-loop */\n\n\n\n\n\n\n\n\n\nfunction drawBlanks(ctx, effectiveColumns, allColumns, width, height, totalHeaderHeight, translateX, translateY, cellYOffset, rows, getRowHeight, getRowTheme, selectedRows, disabledRows, freezeTrailingRows, hasAppendRow, drawRegions, damage, theme) {\n    if (damage !== undefined ||\n        effectiveColumns[effectiveColumns.length - 1] !== allColumns[effectiveColumns.length - 1])\n        return;\n    const skipPoint = (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_1__.getSkipPoint)(drawRegions);\n    (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_1__.walkColumns)(effectiveColumns, cellYOffset, translateX, translateY, totalHeaderHeight, (c, drawX, colDrawY, clipX, startRow) => {\n        if (c !== effectiveColumns[effectiveColumns.length - 1])\n            return;\n        drawX += c.width;\n        const x = Math.max(drawX, clipX);\n        if (x > width)\n            return;\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x, totalHeaderHeight + 1, 10000, height - totalHeaderHeight - 1);\n        ctx.clip();\n        (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_1__.walkRowsInCol)(startRow, colDrawY, height, rows, getRowHeight, freezeTrailingRows, hasAppendRow, skipPoint, (drawY, row, rh, isSticky) => {\n            if (!isSticky &&\n                drawRegions.length > 0 &&\n                !drawRegions.some(dr => (0,_common_math_js__WEBPACK_IMPORTED_MODULE_2__.intersectRect)(drawX, drawY, 10000, rh, dr.x, dr.y, dr.width, dr.height))) {\n                return;\n            }\n            const rowSelected = selectedRows.hasIndex(row);\n            const rowDisabled = disabledRows.hasIndex(row);\n            ctx.beginPath();\n            const rowTheme = getRowTheme?.(row);\n            const blankTheme = rowTheme === undefined ? theme : (0,_common_styles_js__WEBPACK_IMPORTED_MODULE_3__.mergeAndRealizeTheme)(theme, rowTheme);\n            if (blankTheme.bgCell !== theme.bgCell) {\n                ctx.fillStyle = blankTheme.bgCell;\n                ctx.fillRect(drawX, drawY, 10000, rh);\n            }\n            if (rowDisabled) {\n                ctx.fillStyle = blankTheme.bgHeader;\n                ctx.fillRect(drawX, drawY, 10000, rh);\n            }\n            if (rowSelected) {\n                ctx.fillStyle = blankTheme.accentLight;\n                ctx.fillRect(drawX, drawY, 10000, rh);\n            }\n        });\n        ctx.restore();\n    });\n}\nfunction overdrawStickyBoundaries(ctx, effectiveCols, width, height, freezeTrailingRows, rows, verticalBorder, getRowHeight, theme) {\n    let drawFreezeBorder = false;\n    for (const c of effectiveCols) {\n        if (c.sticky)\n            continue;\n        drawFreezeBorder = verticalBorder(c.sourceIndex);\n        break;\n    }\n    const hColor = theme.horizontalBorderColor ?? theme.borderColor;\n    const vColor = theme.borderColor;\n    const drawX = drawFreezeBorder ? (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.getStickyWidth)(effectiveCols) : 0;\n    let vStroke;\n    if (drawX !== 0) {\n        vStroke = (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blendCache)(vColor, theme.bgCell);\n        ctx.beginPath();\n        ctx.moveTo(drawX + 0.5, 0);\n        ctx.lineTo(drawX + 0.5, height);\n        ctx.strokeStyle = vStroke;\n        ctx.stroke();\n    }\n    if (freezeTrailingRows > 0) {\n        const hStroke = vColor === hColor && vStroke !== undefined ? vStroke : (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_5__.blendCache)(hColor, theme.bgCell);\n        const h = (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.getFreezeTrailingHeight)(rows, freezeTrailingRows, getRowHeight);\n        ctx.beginPath();\n        ctx.moveTo(0, height - h + 0.5);\n        ctx.lineTo(width, height - h + 0.5);\n        ctx.strokeStyle = hStroke;\n        ctx.stroke();\n    }\n}\nconst getMinMaxXY = (drawRegions, width, height) => {\n    let minX = 0;\n    let maxX = width;\n    let minY = 0;\n    let maxY = height;\n    if (drawRegions !== undefined && drawRegions.length > 0) {\n        minX = Number.MAX_SAFE_INTEGER;\n        minY = Number.MAX_SAFE_INTEGER;\n        maxX = Number.MIN_SAFE_INTEGER;\n        maxY = Number.MIN_SAFE_INTEGER;\n        for (const r of drawRegions) {\n            minX = Math.min(minX, r.x - 1);\n            maxX = Math.max(maxX, r.x + r.width + 1);\n            minY = Math.min(minY, r.y - 1);\n            maxY = Math.max(maxY, r.y + r.height + 1);\n        }\n    }\n    return { minX, maxX, minY, maxY };\n};\nfunction drawExtraRowThemes(ctx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, freezeTrailingRows, rows, theme) {\n    const bgCell = theme.bgCell;\n    const { minX, maxX, minY, maxY } = getMinMaxXY(drawRegions, width, height);\n    const toDraw = [];\n    const freezeY = height - (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_4__.getFreezeTrailingHeight)(rows, freezeTrailingRows, getRowHeight);\n    // row overflow\n    let y = totalHeaderHeight;\n    let row = cellYOffset;\n    let extraRowsStartY = 0;\n    while (y + translateY < freezeY) {\n        const ty = y + translateY;\n        const rh = getRowHeight(row);\n        if (ty >= minY && ty <= maxY - 1) {\n            const rowTheme = getRowThemeOverride?.(row);\n            const rowThemeBgCell = rowTheme?.bgCell;\n            const needDraw = rowThemeBgCell !== undefined && rowThemeBgCell !== bgCell && row >= rows - freezeTrailingRows;\n            if (needDraw) {\n                toDraw.push({\n                    x: minX,\n                    y: ty,\n                    w: maxX - minX,\n                    h: rh,\n                    color: rowThemeBgCell,\n                });\n            }\n        }\n        y += rh;\n        if (row < rows - freezeTrailingRows)\n            extraRowsStartY = y;\n        row++;\n    }\n    // column overflow\n    let x = 0;\n    const h = Math.min(freezeY, maxY) - extraRowsStartY;\n    if (h > 0) {\n        for (let index = 0; index < effectiveCols.length; index++) {\n            const c = effectiveCols[index];\n            if (c.width === 0)\n                continue;\n            const tx = c.sticky ? x : x + translateX;\n            const colThemeBgCell = c.themeOverride?.bgCell;\n            if (colThemeBgCell !== undefined &&\n                colThemeBgCell !== bgCell &&\n                tx >= minX &&\n                tx <= maxX &&\n                verticalBorder(index + 1)) {\n                toDraw.push({\n                    x: tx,\n                    y: extraRowsStartY,\n                    w: c.width,\n                    h,\n                    color: colThemeBgCell,\n                });\n            }\n            x += c.width;\n        }\n    }\n    if (toDraw.length === 0)\n        return;\n    let color;\n    ctx.beginPath();\n    // render in reverse order because we computed and added the columns last, but they should actually be lower\n    // priority than the rows.\n    for (let i = toDraw.length - 1; i >= 0; i--) {\n        const r = toDraw[i];\n        if (color === undefined) {\n            color = r.color;\n        }\n        else if (r.color !== color) {\n            ctx.fillStyle = color;\n            ctx.fill();\n            ctx.beginPath();\n            color = r.color;\n        }\n        ctx.rect(r.x, r.y, r.w, r.h);\n    }\n    if (color !== undefined) {\n        ctx.fillStyle = color;\n        ctx.fill();\n    }\n    ctx.beginPath();\n}\n// lines are effectively drawn on the top left edge of a cell.\nfunction drawGridLines(ctx, effectiveCols, cellYOffset, translateX, translateY, width, height, drawRegions, spans, groupHeaderHeight, totalHeaderHeight, getRowHeight, getRowThemeOverride, verticalBorder, freezeTrailingRows, rows, theme, verticalOnly = false) {\n    if (spans !== undefined) {\n        ctx.beginPath();\n        ctx.save();\n        ctx.rect(0, 0, width, height);\n        for (const span of spans) {\n            ctx.rect(span.x + 1, span.y + 1, span.width - 1, span.height - 1);\n        }\n        ctx.clip(\"evenodd\");\n    }\n    const hColor = theme.horizontalBorderColor ?? theme.borderColor;\n    const vColor = theme.borderColor;\n    const { minX, maxX, minY, maxY } = getMinMaxXY(drawRegions, width, height);\n    const toDraw = [];\n    ctx.beginPath();\n    // vertical lines\n    let x = 0.5;\n    for (let index = 0; index < effectiveCols.length; index++) {\n        const c = effectiveCols[index];\n        if (c.width === 0)\n            continue;\n        x += c.width;\n        const tx = c.sticky ? x : x + translateX;\n        if (tx >= minX && tx <= maxX && verticalBorder(index + 1)) {\n            toDraw.push({\n                x1: tx,\n                y1: Math.max(groupHeaderHeight, minY),\n                x2: tx,\n                y2: Math.min(height, maxY),\n                color: vColor,\n            });\n        }\n    }\n    let freezeY = height + 0.5;\n    for (let i = rows - freezeTrailingRows; i < rows; i++) {\n        const rh = getRowHeight(i);\n        freezeY -= rh;\n        toDraw.push({ x1: minX, y1: freezeY, x2: maxX, y2: freezeY, color: hColor });\n    }\n    if (verticalOnly !== true) {\n        // horizontal lines\n        let y = totalHeaderHeight + 0.5;\n        let row = cellYOffset;\n        const target = freezeY;\n        while (y + translateY < target) {\n            const ty = y + translateY;\n            if (ty >= minY && ty <= maxY - 1) {\n                const rowTheme = getRowThemeOverride?.(row);\n                toDraw.push({\n                    x1: minX,\n                    y1: ty,\n                    x2: maxX,\n                    y2: ty,\n                    color: rowTheme?.horizontalBorderColor ?? rowTheme?.borderColor ?? hColor,\n                });\n            }\n            y += getRowHeight(row);\n            row++;\n        }\n    }\n    const groups = lodash_groupBy_js__WEBPACK_IMPORTED_MODULE_0__(toDraw, line => line.color);\n    for (const g of Object.keys(groups)) {\n        ctx.strokeStyle = g;\n        for (const line of groups[g]) {\n            ctx.moveTo(line.x1, line.y1);\n            ctx.lineTo(line.x2, line.y2);\n        }\n        ctx.stroke();\n        ctx.beginPath();\n    }\n    if (spans !== undefined) {\n        ctx.restore();\n    }\n}\n//# sourceMappingURL=data-grid-render.lines.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLmxpbmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3lEO0FBQ2hCO0FBQ0Q7QUFDcUM7QUFDWjtBQUNqQjtBQUNRO0FBQzhCO0FBQ3pDO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVFQUFZO0FBQ2xDLElBQUksc0VBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0VBQWE7QUFDckI7QUFDQTtBQUNBLHdDQUF3Qyw4REFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsdUVBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlFQUFjO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0IsNERBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsNERBQVU7QUFDekYsa0JBQWtCLDBFQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQSw2QkFBNkIsMEVBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0Esc0JBQXNCLDZEQUE2RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RhdGEtZ3JpZC1yZW5kZXIubGluZXMuanM/YjFjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBzb25hcmpzL25vLWR1cGxpY2F0ZS1zdHJpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIHVuaWNvcm4vbm8tZm9yLWxvb3AgKi9cbmltcG9ydCB7IENvbXBhY3RTZWxlY3Rpb24gfSBmcm9tIFwiLi4vZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5pbXBvcnQgeyBDZWxsU2V0IH0gZnJvbSBcIi4uL2NlbGwtc2V0LmpzXCI7XG5pbXBvcnQgZ3JvdXBCeSBmcm9tIFwibG9kYXNoL2dyb3VwQnkuanNcIjtcbmltcG9ydCB7IGdldFN0aWNreVdpZHRoLCBnZXRGcmVlemVUcmFpbGluZ0hlaWdodCB9IGZyb20gXCIuL2RhdGEtZ3JpZC1saWIuanNcIjtcbmltcG9ydCB7IG1lcmdlQW5kUmVhbGl6ZVRoZW1lIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9zdHlsZXMuanNcIjtcbmltcG9ydCB7IGJsZW5kQ2FjaGUgfSBmcm9tIFwiLi4vY29sb3ItcGFyc2VyLmpzXCI7XG5pbXBvcnQgeyBpbnRlcnNlY3RSZWN0IH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9tYXRoLmpzXCI7XG5pbXBvcnQgeyBnZXRTa2lwUG9pbnQsIHdhbGtDb2x1bW5zLCB3YWxrUm93c0luQ29sIH0gZnJvbSBcIi4vZGF0YS1ncmlkLXJlbmRlci53YWxrLmpzXCI7XG5pbXBvcnQge30gZnJvbSBcIi4vZGF0YS1ncmlkLXJlbmRlci5jZWxscy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdCbGFua3MoY3R4LCBlZmZlY3RpdmVDb2x1bW5zLCBhbGxDb2x1bW5zLCB3aWR0aCwgaGVpZ2h0LCB0b3RhbEhlYWRlckhlaWdodCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgY2VsbFlPZmZzZXQsIHJvd3MsIGdldFJvd0hlaWdodCwgZ2V0Um93VGhlbWUsIHNlbGVjdGVkUm93cywgZGlzYWJsZWRSb3dzLCBmcmVlemVUcmFpbGluZ1Jvd3MsIGhhc0FwcGVuZFJvdywgZHJhd1JlZ2lvbnMsIGRhbWFnZSwgdGhlbWUpIHtcbiAgICBpZiAoZGFtYWdlICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgZWZmZWN0aXZlQ29sdW1uc1tlZmZlY3RpdmVDb2x1bW5zLmxlbmd0aCAtIDFdICE9PSBhbGxDb2x1bW5zW2VmZmVjdGl2ZUNvbHVtbnMubGVuZ3RoIC0gMV0pXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBza2lwUG9pbnQgPSBnZXRTa2lwUG9pbnQoZHJhd1JlZ2lvbnMpO1xuICAgIHdhbGtDb2x1bW5zKGVmZmVjdGl2ZUNvbHVtbnMsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCB0b3RhbEhlYWRlckhlaWdodCwgKGMsIGRyYXdYLCBjb2xEcmF3WSwgY2xpcFgsIHN0YXJ0Um93KSA9PiB7XG4gICAgICAgIGlmIChjICE9PSBlZmZlY3RpdmVDb2x1bW5zW2VmZmVjdGl2ZUNvbHVtbnMubGVuZ3RoIC0gMV0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRyYXdYICs9IGMud2lkdGg7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChkcmF3WCwgY2xpcFgpO1xuICAgICAgICBpZiAoeCA+IHdpZHRoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHgsIHRvdGFsSGVhZGVySGVpZ2h0ICsgMSwgMTAwMDAsIGhlaWdodCAtIHRvdGFsSGVhZGVySGVpZ2h0IC0gMSk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIHdhbGtSb3dzSW5Db2woc3RhcnRSb3csIGNvbERyYXdZLCBoZWlnaHQsIHJvd3MsIGdldFJvd0hlaWdodCwgZnJlZXplVHJhaWxpbmdSb3dzLCBoYXNBcHBlbmRSb3csIHNraXBQb2ludCwgKGRyYXdZLCByb3csIHJoLCBpc1N0aWNreSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1N0aWNreSAmJlxuICAgICAgICAgICAgICAgIGRyYXdSZWdpb25zLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAhZHJhd1JlZ2lvbnMuc29tZShkciA9PiBpbnRlcnNlY3RSZWN0KGRyYXdYLCBkcmF3WSwgMTAwMDAsIHJoLCBkci54LCBkci55LCBkci53aWR0aCwgZHIuaGVpZ2h0KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3dTZWxlY3RlZCA9IHNlbGVjdGVkUm93cy5oYXNJbmRleChyb3cpO1xuICAgICAgICAgICAgY29uc3Qgcm93RGlzYWJsZWQgPSBkaXNhYmxlZFJvd3MuaGFzSW5kZXgocm93KTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd1RoZW1lID0gZ2V0Um93VGhlbWU/Lihyb3cpO1xuICAgICAgICAgICAgY29uc3QgYmxhbmtUaGVtZSA9IHJvd1RoZW1lID09PSB1bmRlZmluZWQgPyB0aGVtZSA6IG1lcmdlQW5kUmVhbGl6ZVRoZW1lKHRoZW1lLCByb3dUaGVtZSk7XG4gICAgICAgICAgICBpZiAoYmxhbmtUaGVtZS5iZ0NlbGwgIT09IHRoZW1lLmJnQ2VsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBibGFua1RoZW1lLmJnQ2VsbDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZHJhd1gsIGRyYXdZLCAxMDAwMCwgcmgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvd0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJsYW5rVGhlbWUuYmdIZWFkZXI7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGRyYXdYLCBkcmF3WSwgMTAwMDAsIHJoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3dTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBibGFua1RoZW1lLmFjY2VudExpZ2h0O1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChkcmF3WCwgZHJhd1ksIDEwMDAwLCByaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJkcmF3U3RpY2t5Qm91bmRhcmllcyhjdHgsIGVmZmVjdGl2ZUNvbHMsIHdpZHRoLCBoZWlnaHQsIGZyZWV6ZVRyYWlsaW5nUm93cywgcm93cywgdmVydGljYWxCb3JkZXIsIGdldFJvd0hlaWdodCwgdGhlbWUpIHtcbiAgICBsZXQgZHJhd0ZyZWV6ZUJvcmRlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgYyBvZiBlZmZlY3RpdmVDb2xzKSB7XG4gICAgICAgIGlmIChjLnN0aWNreSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBkcmF3RnJlZXplQm9yZGVyID0gdmVydGljYWxCb3JkZXIoYy5zb3VyY2VJbmRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBoQ29sb3IgPSB0aGVtZS5ob3Jpem9udGFsQm9yZGVyQ29sb3IgPz8gdGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgY29uc3QgdkNvbG9yID0gdGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgY29uc3QgZHJhd1ggPSBkcmF3RnJlZXplQm9yZGVyID8gZ2V0U3RpY2t5V2lkdGgoZWZmZWN0aXZlQ29scykgOiAwO1xuICAgIGxldCB2U3Ryb2tlO1xuICAgIGlmIChkcmF3WCAhPT0gMCkge1xuICAgICAgICB2U3Ryb2tlID0gYmxlbmRDYWNoZSh2Q29sb3IsIHRoZW1lLmJnQ2VsbCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhkcmF3WCArIDAuNSwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oZHJhd1ggKyAwLjUsIGhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZTdHJva2U7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgaWYgKGZyZWV6ZVRyYWlsaW5nUm93cyA+IDApIHtcbiAgICAgICAgY29uc3QgaFN0cm9rZSA9IHZDb2xvciA9PT0gaENvbG9yICYmIHZTdHJva2UgIT09IHVuZGVmaW5lZCA/IHZTdHJva2UgOiBibGVuZENhY2hlKGhDb2xvciwgdGhlbWUuYmdDZWxsKTtcbiAgICAgICAgY29uc3QgaCA9IGdldEZyZWV6ZVRyYWlsaW5nSGVpZ2h0KHJvd3MsIGZyZWV6ZVRyYWlsaW5nUm93cywgZ2V0Um93SGVpZ2h0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIGhlaWdodCAtIGggKyAwLjUpO1xuICAgICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQgLSBoICsgMC41KTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gaFN0cm9rZTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn1cbmNvbnN0IGdldE1pbk1heFhZID0gKGRyYXdSZWdpb25zLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgbGV0IG1pblggPSAwO1xuICAgIGxldCBtYXhYID0gd2lkdGg7XG4gICAgbGV0IG1pblkgPSAwO1xuICAgIGxldCBtYXhZID0gaGVpZ2h0O1xuICAgIGlmIChkcmF3UmVnaW9ucyAhPT0gdW5kZWZpbmVkICYmIGRyYXdSZWdpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbWluWCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBtaW5ZID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIG1heFggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgbWF4WSA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICBmb3IgKGNvbnN0IHIgb2YgZHJhd1JlZ2lvbnMpIHtcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCByLnggLSAxKTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCByLnggKyByLndpZHRoICsgMSk7XG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgci55IC0gMSk7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgci55ICsgci5oZWlnaHQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZIH07XG59O1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdFeHRyYVJvd1RoZW1lcyhjdHgsIGVmZmVjdGl2ZUNvbHMsIGNlbGxZT2Zmc2V0LCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZLCB3aWR0aCwgaGVpZ2h0LCBkcmF3UmVnaW9ucywgdG90YWxIZWFkZXJIZWlnaHQsIGdldFJvd0hlaWdodCwgZ2V0Um93VGhlbWVPdmVycmlkZSwgdmVydGljYWxCb3JkZXIsIGZyZWV6ZVRyYWlsaW5nUm93cywgcm93cywgdGhlbWUpIHtcbiAgICBjb25zdCBiZ0NlbGwgPSB0aGVtZS5iZ0NlbGw7XG4gICAgY29uc3QgeyBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZIH0gPSBnZXRNaW5NYXhYWShkcmF3UmVnaW9ucywgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdG9EcmF3ID0gW107XG4gICAgY29uc3QgZnJlZXplWSA9IGhlaWdodCAtIGdldEZyZWV6ZVRyYWlsaW5nSGVpZ2h0KHJvd3MsIGZyZWV6ZVRyYWlsaW5nUm93cywgZ2V0Um93SGVpZ2h0KTtcbiAgICAvLyByb3cgb3ZlcmZsb3dcbiAgICBsZXQgeSA9IHRvdGFsSGVhZGVySGVpZ2h0O1xuICAgIGxldCByb3cgPSBjZWxsWU9mZnNldDtcbiAgICBsZXQgZXh0cmFSb3dzU3RhcnRZID0gMDtcbiAgICB3aGlsZSAoeSArIHRyYW5zbGF0ZVkgPCBmcmVlemVZKSB7XG4gICAgICAgIGNvbnN0IHR5ID0geSArIHRyYW5zbGF0ZVk7XG4gICAgICAgIGNvbnN0IHJoID0gZ2V0Um93SGVpZ2h0KHJvdyk7XG4gICAgICAgIGlmICh0eSA+PSBtaW5ZICYmIHR5IDw9IG1heFkgLSAxKSB7XG4gICAgICAgICAgICBjb25zdCByb3dUaGVtZSA9IGdldFJvd1RoZW1lT3ZlcnJpZGU/Lihyb3cpO1xuICAgICAgICAgICAgY29uc3Qgcm93VGhlbWVCZ0NlbGwgPSByb3dUaGVtZT8uYmdDZWxsO1xuICAgICAgICAgICAgY29uc3QgbmVlZERyYXcgPSByb3dUaGVtZUJnQ2VsbCAhPT0gdW5kZWZpbmVkICYmIHJvd1RoZW1lQmdDZWxsICE9PSBiZ0NlbGwgJiYgcm93ID49IHJvd3MgLSBmcmVlemVUcmFpbGluZ1Jvd3M7XG4gICAgICAgICAgICBpZiAobmVlZERyYXcpIHtcbiAgICAgICAgICAgICAgICB0b0RyYXcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IG1pblgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHR5LFxuICAgICAgICAgICAgICAgICAgICB3OiBtYXhYIC0gbWluWCxcbiAgICAgICAgICAgICAgICAgICAgaDogcmgsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiByb3dUaGVtZUJnQ2VsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5ICs9IHJoO1xuICAgICAgICBpZiAocm93IDwgcm93cyAtIGZyZWV6ZVRyYWlsaW5nUm93cylcbiAgICAgICAgICAgIGV4dHJhUm93c1N0YXJ0WSA9IHk7XG4gICAgICAgIHJvdysrO1xuICAgIH1cbiAgICAvLyBjb2x1bW4gb3ZlcmZsb3dcbiAgICBsZXQgeCA9IDA7XG4gICAgY29uc3QgaCA9IE1hdGgubWluKGZyZWV6ZVksIG1heFkpIC0gZXh0cmFSb3dzU3RhcnRZO1xuICAgIGlmIChoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZWZmZWN0aXZlQ29scy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBlZmZlY3RpdmVDb2xzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChjLndpZHRoID09PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdHggPSBjLnN0aWNreSA/IHggOiB4ICsgdHJhbnNsYXRlWDtcbiAgICAgICAgICAgIGNvbnN0IGNvbFRoZW1lQmdDZWxsID0gYy50aGVtZU92ZXJyaWRlPy5iZ0NlbGw7XG4gICAgICAgICAgICBpZiAoY29sVGhlbWVCZ0NlbGwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIGNvbFRoZW1lQmdDZWxsICE9PSBiZ0NlbGwgJiZcbiAgICAgICAgICAgICAgICB0eCA+PSBtaW5YICYmXG4gICAgICAgICAgICAgICAgdHggPD0gbWF4WCAmJlxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyKGluZGV4ICsgMSkpIHtcbiAgICAgICAgICAgICAgICB0b0RyYXcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHR4LFxuICAgICAgICAgICAgICAgICAgICB5OiBleHRyYVJvd3NTdGFydFksXG4gICAgICAgICAgICAgICAgICAgIHc6IGMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xUaGVtZUJnQ2VsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodG9EcmF3Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBjb2xvcjtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgLy8gcmVuZGVyIGluIHJldmVyc2Ugb3JkZXIgYmVjYXVzZSB3ZSBjb21wdXRlZCBhbmQgYWRkZWQgdGhlIGNvbHVtbnMgbGFzdCwgYnV0IHRoZXkgc2hvdWxkIGFjdHVhbGx5IGJlIGxvd2VyXG4gICAgLy8gcHJpb3JpdHkgdGhhbiB0aGUgcm93cy5cbiAgICBmb3IgKGxldCBpID0gdG9EcmF3Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0b0RyYXdbaV07XG4gICAgICAgIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2xvciA9IHIuY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoci5jb2xvciAhPT0gY29sb3IpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb2xvciA9IHIuY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlY3Qoci54LCByLnksIHIudywgci5oKTtcbiAgICB9XG4gICAgaWYgKGNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG59XG4vLyBsaW5lcyBhcmUgZWZmZWN0aXZlbHkgZHJhd24gb24gdGhlIHRvcCBsZWZ0IGVkZ2Ugb2YgYSBjZWxsLlxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdHcmlkTGluZXMoY3R4LCBlZmZlY3RpdmVDb2xzLCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgd2lkdGgsIGhlaWdodCwgZHJhd1JlZ2lvbnMsIHNwYW5zLCBncm91cEhlYWRlckhlaWdodCwgdG90YWxIZWFkZXJIZWlnaHQsIGdldFJvd0hlaWdodCwgZ2V0Um93VGhlbWVPdmVycmlkZSwgdmVydGljYWxCb3JkZXIsIGZyZWV6ZVRyYWlsaW5nUm93cywgcm93cywgdGhlbWUsIHZlcnRpY2FsT25seSA9IGZhbHNlKSB7XG4gICAgaWYgKHNwYW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKSB7XG4gICAgICAgICAgICBjdHgucmVjdChzcGFuLnggKyAxLCBzcGFuLnkgKyAxLCBzcGFuLndpZHRoIC0gMSwgc3Bhbi5oZWlnaHQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xpcChcImV2ZW5vZGRcIik7XG4gICAgfVxuICAgIGNvbnN0IGhDb2xvciA9IHRoZW1lLmhvcml6b250YWxCb3JkZXJDb2xvciA/PyB0aGVtZS5ib3JkZXJDb2xvcjtcbiAgICBjb25zdCB2Q29sb3IgPSB0aGVtZS5ib3JkZXJDb2xvcjtcbiAgICBjb25zdCB7IG1pblgsIG1heFgsIG1pblksIG1heFkgfSA9IGdldE1pbk1heFhZKGRyYXdSZWdpb25zLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB0b0RyYXcgPSBbXTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgLy8gdmVydGljYWwgbGluZXNcbiAgICBsZXQgeCA9IDAuNTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZWZmZWN0aXZlQ29scy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgYyA9IGVmZmVjdGl2ZUNvbHNbaW5kZXhdO1xuICAgICAgICBpZiAoYy53aWR0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB4ICs9IGMud2lkdGg7XG4gICAgICAgIGNvbnN0IHR4ID0gYy5zdGlja3kgPyB4IDogeCArIHRyYW5zbGF0ZVg7XG4gICAgICAgIGlmICh0eCA+PSBtaW5YICYmIHR4IDw9IG1heFggJiYgdmVydGljYWxCb3JkZXIoaW5kZXggKyAxKSkge1xuICAgICAgICAgICAgdG9EcmF3LnB1c2goe1xuICAgICAgICAgICAgICAgIHgxOiB0eCxcbiAgICAgICAgICAgICAgICB5MTogTWF0aC5tYXgoZ3JvdXBIZWFkZXJIZWlnaHQsIG1pblkpLFxuICAgICAgICAgICAgICAgIHgyOiB0eCxcbiAgICAgICAgICAgICAgICB5MjogTWF0aC5taW4oaGVpZ2h0LCBtYXhZKSxcbiAgICAgICAgICAgICAgICBjb2xvcjogdkNvbG9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZyZWV6ZVkgPSBoZWlnaHQgKyAwLjU7XG4gICAgZm9yIChsZXQgaSA9IHJvd3MgLSBmcmVlemVUcmFpbGluZ1Jvd3M7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmggPSBnZXRSb3dIZWlnaHQoaSk7XG4gICAgICAgIGZyZWV6ZVkgLT0gcmg7XG4gICAgICAgIHRvRHJhdy5wdXNoKHsgeDE6IG1pblgsIHkxOiBmcmVlemVZLCB4MjogbWF4WCwgeTI6IGZyZWV6ZVksIGNvbG9yOiBoQ29sb3IgfSk7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbE9ubHkgIT09IHRydWUpIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBsaW5lc1xuICAgICAgICBsZXQgeSA9IHRvdGFsSGVhZGVySGVpZ2h0ICsgMC41O1xuICAgICAgICBsZXQgcm93ID0gY2VsbFlPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGZyZWV6ZVk7XG4gICAgICAgIHdoaWxlICh5ICsgdHJhbnNsYXRlWSA8IHRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgdHkgPSB5ICsgdHJhbnNsYXRlWTtcbiAgICAgICAgICAgIGlmICh0eSA+PSBtaW5ZICYmIHR5IDw9IG1heFkgLSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93VGhlbWUgPSBnZXRSb3dUaGVtZU92ZXJyaWRlPy4ocm93KTtcbiAgICAgICAgICAgICAgICB0b0RyYXcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHgxOiBtaW5YLFxuICAgICAgICAgICAgICAgICAgICB5MTogdHksXG4gICAgICAgICAgICAgICAgICAgIHgyOiBtYXhYLFxuICAgICAgICAgICAgICAgICAgICB5MjogdHksXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiByb3dUaGVtZT8uaG9yaXpvbnRhbEJvcmRlckNvbG9yID8/IHJvd1RoZW1lPy5ib3JkZXJDb2xvciA/PyBoQ29sb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ICs9IGdldFJvd0hlaWdodChyb3cpO1xuICAgICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZ3JvdXBzID0gZ3JvdXBCeSh0b0RyYXcsIGxpbmUgPT4gbGluZS5jb2xvcik7XG4gICAgZm9yIChjb25zdCBnIG9mIE9iamVjdC5rZXlzKGdyb3VwcykpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZztcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGdyb3Vwc1tnXSkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhsaW5lLngxLCBsaW5lLnkxKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8obGluZS54MiwgbGluZS55Mik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfVxuICAgIGlmIChzcGFucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS1ncmlkLXJlbmRlci5saW5lcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.lines.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.walk.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.walk.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSkipPoint: () => (/* binding */ getSkipPoint),\n/* harmony export */   getSpanBounds: () => (/* binding */ getSpanBounds),\n/* harmony export */   walkColumns: () => (/* binding */ walkColumns),\n/* harmony export */   walkGroups: () => (/* binding */ walkGroups),\n/* harmony export */   walkRowsInCol: () => (/* binding */ walkRowsInCol)\n/* harmony export */ });\n/* harmony import */ var _data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n\n\nfunction getSkipPoint(drawRegions) {\n    if (drawRegions.length === 0)\n        return undefined;\n    let drawRegionsLowestY;\n    for (const dr of drawRegions) {\n        drawRegionsLowestY = Math.min(drawRegionsLowestY ?? dr.y, dr.y);\n    }\n}\nfunction walkRowsInCol(startRow, drawY, height, rows, getRowHeight, freezeTrailingRows, hasAppendRow, skipToY, cb) {\n    skipToY = skipToY ?? drawY;\n    let y = drawY;\n    let row = startRow;\n    const rowEnd = rows - freezeTrailingRows;\n    let didBreak = false;\n    while (y < height && row < rowEnd) {\n        const rh = getRowHeight(row);\n        if (y + rh > skipToY && cb(y, row, rh, false, hasAppendRow && row === rows - 1) === true) {\n            didBreak = true;\n            break;\n        }\n        y += rh;\n        row++;\n    }\n    if (didBreak)\n        return;\n    y = height;\n    for (let fr = 0; fr < freezeTrailingRows; fr++) {\n        row = rows - 1 - fr;\n        const rh = getRowHeight(row);\n        y -= rh;\n        cb(y, row, rh, true, hasAppendRow && row === rows - 1);\n    }\n}\nfunction walkColumns(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, cb) {\n    let x = 0;\n    let clipX = 0; // this tracks the total width of sticky cols\n    const drawY = totalHeaderHeight + translateY;\n    for (const c of effectiveCols) {\n        const drawX = c.sticky ? clipX : x + translateX;\n        if (cb(c, drawX, drawY, c.sticky ? 0 : clipX, cellYOffset) === true) {\n            break;\n        }\n        x += c.width;\n        clipX += c.sticky ? c.width : 0;\n    }\n}\nfunction walkGroups(effectiveCols, width, translateX, groupHeaderHeight, cb) {\n    let x = 0;\n    let clipX = 0;\n    for (let index = 0; index < effectiveCols.length; index++) {\n        const startCol = effectiveCols[index];\n        let end = index + 1;\n        let boxWidth = startCol.width;\n        if (startCol.sticky) {\n            clipX += boxWidth;\n        }\n        while (end < effectiveCols.length &&\n            (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__.isGroupEqual)(effectiveCols[end].group, startCol.group) &&\n            effectiveCols[end].sticky === effectiveCols[index].sticky) {\n            const endCol = effectiveCols[end];\n            boxWidth += endCol.width;\n            end++;\n            index++;\n            if (endCol.sticky) {\n                clipX += endCol.width;\n            }\n        }\n        const t = startCol.sticky ? 0 : translateX;\n        const localX = x + t;\n        const delta = startCol.sticky ? 0 : Math.max(0, clipX - localX);\n        const w = Math.min(boxWidth - delta, width - (localX + delta));\n        cb([startCol.sourceIndex, effectiveCols[end - 1].sourceIndex], startCol.group ?? \"\", localX + delta, 0, w, groupHeaderHeight);\n        x += boxWidth;\n    }\n}\nfunction getSpanBounds(span, cellX, cellY, cellW, cellH, column, allColumns) {\n    const [startCol, endCol] = span;\n    let frozenRect;\n    let contentRect;\n    const firstNonSticky = allColumns.find(x => !x.sticky)?.sourceIndex ?? 0;\n    if (endCol > firstNonSticky) {\n        const renderFromCol = Math.max(startCol, firstNonSticky);\n        let tempX = cellX;\n        let tempW = cellW;\n        for (let x = column.sourceIndex - 1; x >= renderFromCol; x--) {\n            tempX -= allColumns[x].width;\n            tempW += allColumns[x].width;\n        }\n        for (let x = column.sourceIndex + 1; x <= endCol; x++) {\n            tempW += allColumns[x].width;\n        }\n        contentRect = {\n            x: tempX,\n            y: cellY,\n            width: tempW,\n            height: cellH,\n        };\n    }\n    if (firstNonSticky > startCol) {\n        const renderToCol = Math.min(endCol, firstNonSticky - 1);\n        let tempX = cellX;\n        let tempW = cellW;\n        for (let x = column.sourceIndex - 1; x >= startCol; x--) {\n            tempX -= allColumns[x].width;\n            tempW += allColumns[x].width;\n        }\n        for (let x = column.sourceIndex + 1; x <= renderToCol; x++) {\n            tempW += allColumns[x].width;\n        }\n        frozenRect = {\n            x: tempX,\n            y: cellY,\n            width: tempW,\n            height: cellH,\n        };\n    }\n    return [frozenRect, contentRect];\n}\n//# sourceMappingURL=data-grid-render.walk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQtcmVuZGVyLndhbGsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXVDO0FBQ1c7QUFDM0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RhdGEtZ3JpZC1yZW5kZXIud2Fsay5qcz9kZTljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7fSBmcm9tIFwiLi4vZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5pbXBvcnQgeyBpc0dyb3VwRXF1YWwgfSBmcm9tIFwiLi9kYXRhLWdyaWQtbGliLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0U2tpcFBvaW50KGRyYXdSZWdpb25zKSB7XG4gICAgaWYgKGRyYXdSZWdpb25zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgZHJhd1JlZ2lvbnNMb3dlc3RZO1xuICAgIGZvciAoY29uc3QgZHIgb2YgZHJhd1JlZ2lvbnMpIHtcbiAgICAgICAgZHJhd1JlZ2lvbnNMb3dlc3RZID0gTWF0aC5taW4oZHJhd1JlZ2lvbnNMb3dlc3RZID8/IGRyLnksIGRyLnkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3YWxrUm93c0luQ29sKHN0YXJ0Um93LCBkcmF3WSwgaGVpZ2h0LCByb3dzLCBnZXRSb3dIZWlnaHQsIGZyZWV6ZVRyYWlsaW5nUm93cywgaGFzQXBwZW5kUm93LCBza2lwVG9ZLCBjYikge1xuICAgIHNraXBUb1kgPSBza2lwVG9ZID8/IGRyYXdZO1xuICAgIGxldCB5ID0gZHJhd1k7XG4gICAgbGV0IHJvdyA9IHN0YXJ0Um93O1xuICAgIGNvbnN0IHJvd0VuZCA9IHJvd3MgLSBmcmVlemVUcmFpbGluZ1Jvd3M7XG4gICAgbGV0IGRpZEJyZWFrID0gZmFsc2U7XG4gICAgd2hpbGUgKHkgPCBoZWlnaHQgJiYgcm93IDwgcm93RW5kKSB7XG4gICAgICAgIGNvbnN0IHJoID0gZ2V0Um93SGVpZ2h0KHJvdyk7XG4gICAgICAgIGlmICh5ICsgcmggPiBza2lwVG9ZICYmIGNiKHksIHJvdywgcmgsIGZhbHNlLCBoYXNBcHBlbmRSb3cgJiYgcm93ID09PSByb3dzIC0gMSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGRpZEJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHkgKz0gcmg7XG4gICAgICAgIHJvdysrO1xuICAgIH1cbiAgICBpZiAoZGlkQnJlYWspXG4gICAgICAgIHJldHVybjtcbiAgICB5ID0gaGVpZ2h0O1xuICAgIGZvciAobGV0IGZyID0gMDsgZnIgPCBmcmVlemVUcmFpbGluZ1Jvd3M7IGZyKyspIHtcbiAgICAgICAgcm93ID0gcm93cyAtIDEgLSBmcjtcbiAgICAgICAgY29uc3QgcmggPSBnZXRSb3dIZWlnaHQocm93KTtcbiAgICAgICAgeSAtPSByaDtcbiAgICAgICAgY2IoeSwgcm93LCByaCwgdHJ1ZSwgaGFzQXBwZW5kUm93ICYmIHJvdyA9PT0gcm93cyAtIDEpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3YWxrQ29sdW1ucyhlZmZlY3RpdmVDb2xzLCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgdG90YWxIZWFkZXJIZWlnaHQsIGNiKSB7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCBjbGlwWCA9IDA7IC8vIHRoaXMgdHJhY2tzIHRoZSB0b3RhbCB3aWR0aCBvZiBzdGlja3kgY29sc1xuICAgIGNvbnN0IGRyYXdZID0gdG90YWxIZWFkZXJIZWlnaHQgKyB0cmFuc2xhdGVZO1xuICAgIGZvciAoY29uc3QgYyBvZiBlZmZlY3RpdmVDb2xzKSB7XG4gICAgICAgIGNvbnN0IGRyYXdYID0gYy5zdGlja3kgPyBjbGlwWCA6IHggKyB0cmFuc2xhdGVYO1xuICAgICAgICBpZiAoY2IoYywgZHJhd1gsIGRyYXdZLCBjLnN0aWNreSA/IDAgOiBjbGlwWCwgY2VsbFlPZmZzZXQpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB4ICs9IGMud2lkdGg7XG4gICAgICAgIGNsaXBYICs9IGMuc3RpY2t5ID8gYy53aWR0aCA6IDA7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHdhbGtHcm91cHMoZWZmZWN0aXZlQ29scywgd2lkdGgsIHRyYW5zbGF0ZVgsIGdyb3VwSGVhZGVySGVpZ2h0LCBjYikge1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgY2xpcFggPSAwO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBlZmZlY3RpdmVDb2xzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBzdGFydENvbCA9IGVmZmVjdGl2ZUNvbHNbaW5kZXhdO1xuICAgICAgICBsZXQgZW5kID0gaW5kZXggKyAxO1xuICAgICAgICBsZXQgYm94V2lkdGggPSBzdGFydENvbC53aWR0aDtcbiAgICAgICAgaWYgKHN0YXJ0Q29sLnN0aWNreSkge1xuICAgICAgICAgICAgY2xpcFggKz0gYm94V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVuZCA8IGVmZmVjdGl2ZUNvbHMubGVuZ3RoICYmXG4gICAgICAgICAgICBpc0dyb3VwRXF1YWwoZWZmZWN0aXZlQ29sc1tlbmRdLmdyb3VwLCBzdGFydENvbC5ncm91cCkgJiZcbiAgICAgICAgICAgIGVmZmVjdGl2ZUNvbHNbZW5kXS5zdGlja3kgPT09IGVmZmVjdGl2ZUNvbHNbaW5kZXhdLnN0aWNreSkge1xuICAgICAgICAgICAgY29uc3QgZW5kQ29sID0gZWZmZWN0aXZlQ29sc1tlbmRdO1xuICAgICAgICAgICAgYm94V2lkdGggKz0gZW5kQ29sLndpZHRoO1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKGVuZENvbC5zdGlja3kpIHtcbiAgICAgICAgICAgICAgICBjbGlwWCArPSBlbmRDb2wud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdCA9IHN0YXJ0Q29sLnN0aWNreSA/IDAgOiB0cmFuc2xhdGVYO1xuICAgICAgICBjb25zdCBsb2NhbFggPSB4ICsgdDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBzdGFydENvbC5zdGlja3kgPyAwIDogTWF0aC5tYXgoMCwgY2xpcFggLSBsb2NhbFgpO1xuICAgICAgICBjb25zdCB3ID0gTWF0aC5taW4oYm94V2lkdGggLSBkZWx0YSwgd2lkdGggLSAobG9jYWxYICsgZGVsdGEpKTtcbiAgICAgICAgY2IoW3N0YXJ0Q29sLnNvdXJjZUluZGV4LCBlZmZlY3RpdmVDb2xzW2VuZCAtIDFdLnNvdXJjZUluZGV4XSwgc3RhcnRDb2wuZ3JvdXAgPz8gXCJcIiwgbG9jYWxYICsgZGVsdGEsIDAsIHcsIGdyb3VwSGVhZGVySGVpZ2h0KTtcbiAgICAgICAgeCArPSBib3hXaWR0aDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3BhbkJvdW5kcyhzcGFuLCBjZWxsWCwgY2VsbFksIGNlbGxXLCBjZWxsSCwgY29sdW1uLCBhbGxDb2x1bW5zKSB7XG4gICAgY29uc3QgW3N0YXJ0Q29sLCBlbmRDb2xdID0gc3BhbjtcbiAgICBsZXQgZnJvemVuUmVjdDtcbiAgICBsZXQgY29udGVudFJlY3Q7XG4gICAgY29uc3QgZmlyc3ROb25TdGlja3kgPSBhbGxDb2x1bW5zLmZpbmQoeCA9PiAheC5zdGlja3kpPy5zb3VyY2VJbmRleCA/PyAwO1xuICAgIGlmIChlbmRDb2wgPiBmaXJzdE5vblN0aWNreSkge1xuICAgICAgICBjb25zdCByZW5kZXJGcm9tQ29sID0gTWF0aC5tYXgoc3RhcnRDb2wsIGZpcnN0Tm9uU3RpY2t5KTtcbiAgICAgICAgbGV0IHRlbXBYID0gY2VsbFg7XG4gICAgICAgIGxldCB0ZW1wVyA9IGNlbGxXO1xuICAgICAgICBmb3IgKGxldCB4ID0gY29sdW1uLnNvdXJjZUluZGV4IC0gMTsgeCA+PSByZW5kZXJGcm9tQ29sOyB4LS0pIHtcbiAgICAgICAgICAgIHRlbXBYIC09IGFsbENvbHVtbnNbeF0ud2lkdGg7XG4gICAgICAgICAgICB0ZW1wVyArPSBhbGxDb2x1bW5zW3hdLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHggPSBjb2x1bW4uc291cmNlSW5kZXggKyAxOyB4IDw9IGVuZENvbDsgeCsrKSB7XG4gICAgICAgICAgICB0ZW1wVyArPSBhbGxDb2x1bW5zW3hdLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnRSZWN0ID0ge1xuICAgICAgICAgICAgeDogdGVtcFgsXG4gICAgICAgICAgICB5OiBjZWxsWSxcbiAgICAgICAgICAgIHdpZHRoOiB0ZW1wVyxcbiAgICAgICAgICAgIGhlaWdodDogY2VsbEgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChmaXJzdE5vblN0aWNreSA+IHN0YXJ0Q29sKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlclRvQ29sID0gTWF0aC5taW4oZW5kQ29sLCBmaXJzdE5vblN0aWNreSAtIDEpO1xuICAgICAgICBsZXQgdGVtcFggPSBjZWxsWDtcbiAgICAgICAgbGV0IHRlbXBXID0gY2VsbFc7XG4gICAgICAgIGZvciAobGV0IHggPSBjb2x1bW4uc291cmNlSW5kZXggLSAxOyB4ID49IHN0YXJ0Q29sOyB4LS0pIHtcbiAgICAgICAgICAgIHRlbXBYIC09IGFsbENvbHVtbnNbeF0ud2lkdGg7XG4gICAgICAgICAgICB0ZW1wVyArPSBhbGxDb2x1bW5zW3hdLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHggPSBjb2x1bW4uc291cmNlSW5kZXggKyAxOyB4IDw9IHJlbmRlclRvQ29sOyB4KyspIHtcbiAgICAgICAgICAgIHRlbXBXICs9IGFsbENvbHVtbnNbeF0ud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZnJvemVuUmVjdCA9IHtcbiAgICAgICAgICAgIHg6IHRlbXBYLFxuICAgICAgICAgICAgeTogY2VsbFksXG4gICAgICAgICAgICB3aWR0aDogdGVtcFcsXG4gICAgICAgICAgICBoZWlnaHQ6IGNlbGxILFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gW2Zyb3plblJlY3QsIGNvbnRlbnRSZWN0XTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtZ3JpZC1yZW5kZXIud2Fsay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.walk.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid.render.rings.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid.render.rings.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawColumnResizeOutline: () => (/* binding */ drawColumnResizeOutline),\n/* harmony export */   drawFillHandle: () => (/* binding */ drawFillHandle),\n/* harmony export */   drawHighlightRings: () => (/* binding */ drawHighlightRings)\n/* harmony export */ });\n/* harmony import */ var _data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _color_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../color-parser.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/color-parser.js\");\n/* harmony import */ var _common_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/math.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/math.js\");\n/* harmony import */ var _data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data-grid-render.walk.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-render.walk.js\");\n/* eslint-disable sonarjs/no-duplicate-string */\n/* eslint-disable unicorn/no-for-loop */\n\n\n\n\n\n\n\nfunction drawHighlightRings(ctx, width, height, cellXOffset, cellYOffset, translateX, translateY, mappedColumns, freezeColumns, headerHeight, groupHeaderHeight, rowHeight, freezeTrailingRows, rows, allHighlightRegions, theme) {\n    const highlightRegions = allHighlightRegions?.filter(x => x.style !== \"no-outline\");\n    if (highlightRegions === undefined || highlightRegions.length === 0)\n        return undefined;\n    const freezeLeft = (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__.getStickyWidth)(mappedColumns);\n    const freezeBottom = (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__.getFreezeTrailingHeight)(rows, freezeTrailingRows, rowHeight);\n    const splitIndicies = [freezeColumns, 0, mappedColumns.length, rows - freezeTrailingRows];\n    const splitLocations = [freezeLeft, 0, width, height - freezeBottom];\n    const drawRects = highlightRegions.map(h => {\n        const r = h.range;\n        const style = h.style ?? \"dashed\";\n        return (0,_common_math_js__WEBPACK_IMPORTED_MODULE_1__.splitRectIntoRegions)(r, splitIndicies, width, height, splitLocations).map(arg => {\n            const rect = arg.rect;\n            const topLeftBounds = (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__.computeBounds)(rect.x, rect.y, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, freezeTrailingRows, mappedColumns, rowHeight);\n            const bottomRightBounds = rect.width === 1 && rect.height === 1\n                ? topLeftBounds\n                : (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__.computeBounds)(rect.x + rect.width - 1, rect.y + rect.height - 1, width, height, groupHeaderHeight, headerHeight + groupHeaderHeight, cellXOffset, cellYOffset, translateX, translateY, rows, freezeColumns, freezeTrailingRows, mappedColumns, rowHeight);\n            if (rect.x + rect.width >= mappedColumns.length) {\n                bottomRightBounds.width -= 1;\n            }\n            if (rect.y + rect.height >= rows) {\n                bottomRightBounds.height -= 1;\n            }\n            return {\n                color: h.color,\n                style,\n                clip: arg.clip,\n                rect: (0,_common_math_js__WEBPACK_IMPORTED_MODULE_1__.hugRectToTarget)({\n                    x: topLeftBounds.x,\n                    y: topLeftBounds.y,\n                    width: bottomRightBounds.x + bottomRightBounds.width - topLeftBounds.x,\n                    height: bottomRightBounds.y + bottomRightBounds.height - topLeftBounds.y,\n                }, width, height, 8),\n            };\n        });\n    });\n    const drawCb = () => {\n        ctx.lineWidth = 1;\n        let dashed = false;\n        for (const dr of drawRects) {\n            for (const s of dr) {\n                if (s?.rect !== undefined &&\n                    (0,_common_math_js__WEBPACK_IMPORTED_MODULE_1__.intersectRect)(0, 0, width, height, s.rect.x, s.rect.y, s.rect.width, s.rect.height)) {\n                    const wasDashed = dashed;\n                    const needsClip = !(0,_common_math_js__WEBPACK_IMPORTED_MODULE_1__.rectContains)(s.clip, s.rect);\n                    if (needsClip) {\n                        ctx.save();\n                        ctx.rect(s.clip.x, s.clip.y, s.clip.width, s.clip.height);\n                        ctx.clip();\n                    }\n                    if (s.style === \"dashed\" && !dashed) {\n                        ctx.setLineDash([5, 3]);\n                        dashed = true;\n                    }\n                    else if ((s.style === \"solid\" || s.style === \"solid-outline\") && dashed) {\n                        ctx.setLineDash([]);\n                        dashed = false;\n                    }\n                    ctx.strokeStyle =\n                        s.style === \"solid-outline\"\n                            ? (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_2__.blend)((0,_color_parser_js__WEBPACK_IMPORTED_MODULE_2__.blend)(s.color, theme.borderColor), theme.bgCell)\n                            : (0,_color_parser_js__WEBPACK_IMPORTED_MODULE_2__.withAlpha)(s.color, 1);\n                    ctx.strokeRect(s.rect.x + 0.5, s.rect.y + 0.5, s.rect.width - 1, s.rect.height - 1);\n                    if (needsClip) {\n                        ctx.restore();\n                        dashed = wasDashed;\n                    }\n                }\n            }\n        }\n        if (dashed) {\n            ctx.setLineDash([]);\n        }\n    };\n    drawCb();\n    return drawCb;\n}\nfunction drawColumnResizeOutline(ctx, yOffset, xOffset, height, style) {\n    ctx.beginPath();\n    ctx.moveTo(yOffset, xOffset);\n    ctx.lineTo(yOffset, height);\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = style;\n    ctx.stroke();\n    ctx.globalAlpha = 1;\n}\nfunction drawFillHandle(ctx, width, height, cellYOffset, translateX, translateY, effectiveCols, allColumns, theme, totalHeaderHeight, selectedCell, getRowHeight, getCellContent, freezeTrailingRows, hasAppendRow, fillHandle, rows) {\n    if (selectedCell.current === undefined)\n        return undefined;\n    const range = selectedCell.current.range;\n    const currentItem = selectedCell.current.cell;\n    const fillHandleTarget = [range.x + range.width - 1, range.y + range.height - 1];\n    // if the currentItem row greater than rows and the fill handle row is greater than rows, we dont need to draw\n    if (currentItem[1] >= rows && fillHandleTarget[1] >= rows)\n        return undefined;\n    const mustDraw = effectiveCols.some(c => c.sourceIndex === currentItem[0] || c.sourceIndex === fillHandleTarget[0]);\n    if (!mustDraw)\n        return undefined;\n    const [targetCol, targetRow] = selectedCell.current.cell;\n    const cell = getCellContent(selectedCell.current.cell);\n    const targetColSpan = cell.span ?? [targetCol, targetCol];\n    const isStickyRow = targetRow >= rows - freezeTrailingRows;\n    const stickRowHeight = freezeTrailingRows > 0 && !isStickyRow\n        ? (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_0__.getFreezeTrailingHeight)(rows, freezeTrailingRows, getRowHeight) - 1\n        : 0;\n    const fillHandleRow = fillHandleTarget[1];\n    let drawHandleCb = undefined;\n    (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_3__.walkColumns)(effectiveCols, cellYOffset, translateX, translateY, totalHeaderHeight, (col, drawX, colDrawY, clipX, startRow) => {\n        clipX;\n        if (col.sticky && targetCol > col.sourceIndex)\n            return;\n        const isBeforeTarget = col.sourceIndex < targetColSpan[0];\n        const isAfterTarget = col.sourceIndex > targetColSpan[1];\n        const isFillHandleCol = col.sourceIndex === fillHandleTarget[0];\n        if (!isFillHandleCol && (isBeforeTarget || isAfterTarget)) {\n            // we dont need to do any drawing on this column but may yet need to draw\n            return;\n        }\n        (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_3__.walkRowsInCol)(startRow, colDrawY, height, rows, getRowHeight, freezeTrailingRows, hasAppendRow, undefined, (drawY, row, rh) => {\n            if (row !== targetRow && row !== fillHandleRow)\n                return;\n            let cellX = drawX;\n            let cellWidth = col.width;\n            if (cell.span !== undefined) {\n                const areas = (0,_data_grid_render_walk_js__WEBPACK_IMPORTED_MODULE_3__.getSpanBounds)(cell.span, drawX, drawY, col.width, rh, col, allColumns);\n                const area = col.sticky ? areas[0] : areas[1];\n                if (area !== undefined) {\n                    cellX = area.x;\n                    cellWidth = area.width;\n                }\n            }\n            const doHandle = row === fillHandleRow && isFillHandleCol && fillHandle;\n            if (doHandle) {\n                drawHandleCb = () => {\n                    if (clipX > cellX && !col.sticky) {\n                        ctx.beginPath();\n                        ctx.rect(clipX, 0, width - clipX, height);\n                        ctx.clip();\n                    }\n                    ctx.beginPath();\n                    ctx.rect(cellX + cellWidth - 4, drawY + rh - 4, 4, 4);\n                    ctx.fillStyle = col.themeOverride?.accentColor ?? theme.accentColor;\n                    ctx.fill();\n                };\n            }\n            return drawHandleCb !== undefined;\n        });\n        return drawHandleCb !== undefined;\n    });\n    if (drawHandleCb === undefined)\n        return undefined;\n    const result = () => {\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(0, totalHeaderHeight, width, height - totalHeaderHeight - stickRowHeight);\n        ctx.clip();\n        drawHandleCb?.();\n        ctx.restore();\n    };\n    result();\n    return result;\n}\n//# sourceMappingURL=data-grid.render.rings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQucmVuZGVyLnJpbmdzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VDO0FBQ3FEO0FBQ2pEO0FBQ1c7QUFDdUQ7QUFDdEI7QUFDMUM7QUFDdEM7QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQWM7QUFDckMseUJBQXlCLDBFQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxRUFBb0I7QUFDbkM7QUFDQSxrQ0FBa0MsZ0VBQWE7QUFDL0M7QUFDQTtBQUNBLGtCQUFrQixnRUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnRUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhEQUFhO0FBQ2pDO0FBQ0EsdUNBQXVDLDZEQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBSyxDQUFDLHVEQUFLO0FBQ3pDLDhCQUE4QiwyREFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwRUFBdUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3RUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdFQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kYXRhLWdyaWQucmVuZGVyLnJpbmdzLmpzPzQyMmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgc29uYXJqcy9uby1kdXBsaWNhdGUtc3RyaW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSB1bmljb3JuL25vLWZvci1sb29wICovXG5pbXBvcnQge30gZnJvbSBcIi4uL2RhdGEtZ3JpZC10eXBlcy5qc1wiO1xuaW1wb3J0IHsgZ2V0U3RpY2t5V2lkdGgsIGNvbXB1dGVCb3VuZHMsIGdldEZyZWV6ZVRyYWlsaW5nSGVpZ2h0IH0gZnJvbSBcIi4vZGF0YS1ncmlkLWxpYi5qc1wiO1xuaW1wb3J0IHt9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vc3R5bGVzLmpzXCI7XG5pbXBvcnQgeyBibGVuZCwgd2l0aEFscGhhIH0gZnJvbSBcIi4uL2NvbG9yLXBhcnNlci5qc1wiO1xuaW1wb3J0IHsgaHVnUmVjdFRvVGFyZ2V0LCBpbnRlcnNlY3RSZWN0LCByZWN0Q29udGFpbnMsIHNwbGl0UmVjdEludG9SZWdpb25zIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9tYXRoLmpzXCI7XG5pbXBvcnQgeyBnZXRTcGFuQm91bmRzLCB3YWxrQ29sdW1ucywgd2Fsa1Jvd3NJbkNvbCB9IGZyb20gXCIuL2RhdGEtZ3JpZC1yZW5kZXIud2Fsay5qc1wiO1xuaW1wb3J0IHt9IGZyb20gXCIuL2RhdGEtZ3JpZC1yZW5kZXIuY2VsbHMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkcmF3SGlnaGxpZ2h0UmluZ3MoY3R4LCB3aWR0aCwgaGVpZ2h0LCBjZWxsWE9mZnNldCwgY2VsbFlPZmZzZXQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIG1hcHBlZENvbHVtbnMsIGZyZWV6ZUNvbHVtbnMsIGhlYWRlckhlaWdodCwgZ3JvdXBIZWFkZXJIZWlnaHQsIHJvd0hlaWdodCwgZnJlZXplVHJhaWxpbmdSb3dzLCByb3dzLCBhbGxIaWdobGlnaHRSZWdpb25zLCB0aGVtZSkge1xuICAgIGNvbnN0IGhpZ2hsaWdodFJlZ2lvbnMgPSBhbGxIaWdobGlnaHRSZWdpb25zPy5maWx0ZXIoeCA9PiB4LnN0eWxlICE9PSBcIm5vLW91dGxpbmVcIik7XG4gICAgaWYgKGhpZ2hsaWdodFJlZ2lvbnMgPT09IHVuZGVmaW5lZCB8fCBoaWdobGlnaHRSZWdpb25zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBmcmVlemVMZWZ0ID0gZ2V0U3RpY2t5V2lkdGgobWFwcGVkQ29sdW1ucyk7XG4gICAgY29uc3QgZnJlZXplQm90dG9tID0gZ2V0RnJlZXplVHJhaWxpbmdIZWlnaHQocm93cywgZnJlZXplVHJhaWxpbmdSb3dzLCByb3dIZWlnaHQpO1xuICAgIGNvbnN0IHNwbGl0SW5kaWNpZXMgPSBbZnJlZXplQ29sdW1ucywgMCwgbWFwcGVkQ29sdW1ucy5sZW5ndGgsIHJvd3MgLSBmcmVlemVUcmFpbGluZ1Jvd3NdO1xuICAgIGNvbnN0IHNwbGl0TG9jYXRpb25zID0gW2ZyZWV6ZUxlZnQsIDAsIHdpZHRoLCBoZWlnaHQgLSBmcmVlemVCb3R0b21dO1xuICAgIGNvbnN0IGRyYXdSZWN0cyA9IGhpZ2hsaWdodFJlZ2lvbnMubWFwKGggPT4ge1xuICAgICAgICBjb25zdCByID0gaC5yYW5nZTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBoLnN0eWxlID8/IFwiZGFzaGVkXCI7XG4gICAgICAgIHJldHVybiBzcGxpdFJlY3RJbnRvUmVnaW9ucyhyLCBzcGxpdEluZGljaWVzLCB3aWR0aCwgaGVpZ2h0LCBzcGxpdExvY2F0aW9ucykubWFwKGFyZyA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gYXJnLnJlY3Q7XG4gICAgICAgICAgICBjb25zdCB0b3BMZWZ0Qm91bmRzID0gY29tcHV0ZUJvdW5kcyhyZWN0LngsIHJlY3QueSwgd2lkdGgsIGhlaWdodCwgZ3JvdXBIZWFkZXJIZWlnaHQsIGhlYWRlckhlaWdodCArIGdyb3VwSGVhZGVySGVpZ2h0LCBjZWxsWE9mZnNldCwgY2VsbFlPZmZzZXQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHJvd3MsIGZyZWV6ZUNvbHVtbnMsIGZyZWV6ZVRyYWlsaW5nUm93cywgbWFwcGVkQ29sdW1ucywgcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0Qm91bmRzID0gcmVjdC53aWR0aCA9PT0gMSAmJiByZWN0LmhlaWdodCA9PT0gMVxuICAgICAgICAgICAgICAgID8gdG9wTGVmdEJvdW5kc1xuICAgICAgICAgICAgICAgIDogY29tcHV0ZUJvdW5kcyhyZWN0LnggKyByZWN0LndpZHRoIC0gMSwgcmVjdC55ICsgcmVjdC5oZWlnaHQgLSAxLCB3aWR0aCwgaGVpZ2h0LCBncm91cEhlYWRlckhlaWdodCwgaGVhZGVySGVpZ2h0ICsgZ3JvdXBIZWFkZXJIZWlnaHQsIGNlbGxYT2Zmc2V0LCBjZWxsWU9mZnNldCwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgcm93cywgZnJlZXplQ29sdW1ucywgZnJlZXplVHJhaWxpbmdSb3dzLCBtYXBwZWRDb2x1bW5zLCByb3dIZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHJlY3QueCArIHJlY3Qud2lkdGggPj0gbWFwcGVkQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodEJvdW5kcy53aWR0aCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY3QueSArIHJlY3QuaGVpZ2h0ID49IHJvd3MpIHtcbiAgICAgICAgICAgICAgICBib3R0b21SaWdodEJvdW5kcy5oZWlnaHQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGguY29sb3IsXG4gICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgY2xpcDogYXJnLmNsaXAsXG4gICAgICAgICAgICAgICAgcmVjdDogaHVnUmVjdFRvVGFyZ2V0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogdG9wTGVmdEJvdW5kcy54LFxuICAgICAgICAgICAgICAgICAgICB5OiB0b3BMZWZ0Qm91bmRzLnksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBib3R0b21SaWdodEJvdW5kcy54ICsgYm90dG9tUmlnaHRCb3VuZHMud2lkdGggLSB0b3BMZWZ0Qm91bmRzLngsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogYm90dG9tUmlnaHRCb3VuZHMueSArIGJvdHRvbVJpZ2h0Qm91bmRzLmhlaWdodCAtIHRvcExlZnRCb3VuZHMueSxcbiAgICAgICAgICAgICAgICB9LCB3aWR0aCwgaGVpZ2h0LCA4KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGRyYXdDYiA9ICgpID0+IHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGxldCBkYXNoZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBkciBvZiBkcmF3UmVjdHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBkcikge1xuICAgICAgICAgICAgICAgIGlmIChzPy5yZWN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0UmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0LCBzLnJlY3QueCwgcy5yZWN0LnksIHMucmVjdC53aWR0aCwgcy5yZWN0LmhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FzRGFzaGVkID0gZGFzaGVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkc0NsaXAgPSAhcmVjdENvbnRhaW5zKHMuY2xpcCwgcy5yZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzQ2xpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHMuY2xpcC54LCBzLmNsaXAueSwgcy5jbGlwLndpZHRoLCBzLmNsaXAuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc3R5bGUgPT09IFwiZGFzaGVkXCIgJiYgIWRhc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFs1LCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChzLnN0eWxlID09PSBcInNvbGlkXCIgfHwgcy5zdHlsZSA9PT0gXCJzb2xpZC1vdXRsaW5lXCIpICYmIGRhc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnN0eWxlID09PSBcInNvbGlkLW91dGxpbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYmxlbmQoYmxlbmQocy5jb2xvciwgdGhlbWUuYm9yZGVyQ29sb3IpLCB0aGVtZS5iZ0NlbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB3aXRoQWxwaGEocy5jb2xvciwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHMucmVjdC54ICsgMC41LCBzLnJlY3QueSArIDAuNSwgcy5yZWN0LndpZHRoIC0gMSwgcy5yZWN0LmhlaWdodCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNDbGlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFzaGVkID0gd2FzRGFzaGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXNoZWQpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRyYXdDYigpO1xuICAgIHJldHVybiBkcmF3Q2I7XG59XG5leHBvcnQgZnVuY3Rpb24gZHJhd0NvbHVtblJlc2l6ZU91dGxpbmUoY3R4LCB5T2Zmc2V0LCB4T2Zmc2V0LCBoZWlnaHQsIHN0eWxlKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeU9mZnNldCwgeE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh5T2Zmc2V0LCBoZWlnaHQpO1xuICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdGaWxsSGFuZGxlKGN0eCwgd2lkdGgsIGhlaWdodCwgY2VsbFlPZmZzZXQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIGVmZmVjdGl2ZUNvbHMsIGFsbENvbHVtbnMsIHRoZW1lLCB0b3RhbEhlYWRlckhlaWdodCwgc2VsZWN0ZWRDZWxsLCBnZXRSb3dIZWlnaHQsIGdldENlbGxDb250ZW50LCBmcmVlemVUcmFpbGluZ1Jvd3MsIGhhc0FwcGVuZFJvdywgZmlsbEhhbmRsZSwgcm93cykge1xuICAgIGlmIChzZWxlY3RlZENlbGwuY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0ZWRDZWxsLmN1cnJlbnQucmFuZ2U7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSBzZWxlY3RlZENlbGwuY3VycmVudC5jZWxsO1xuICAgIGNvbnN0IGZpbGxIYW5kbGVUYXJnZXQgPSBbcmFuZ2UueCArIHJhbmdlLndpZHRoIC0gMSwgcmFuZ2UueSArIHJhbmdlLmhlaWdodCAtIDFdO1xuICAgIC8vIGlmIHRoZSBjdXJyZW50SXRlbSByb3cgZ3JlYXRlciB0aGFuIHJvd3MgYW5kIHRoZSBmaWxsIGhhbmRsZSByb3cgaXMgZ3JlYXRlciB0aGFuIHJvd3MsIHdlIGRvbnQgbmVlZCB0byBkcmF3XG4gICAgaWYgKGN1cnJlbnRJdGVtWzFdID49IHJvd3MgJiYgZmlsbEhhbmRsZVRhcmdldFsxXSA+PSByb3dzKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG11c3REcmF3ID0gZWZmZWN0aXZlQ29scy5zb21lKGMgPT4gYy5zb3VyY2VJbmRleCA9PT0gY3VycmVudEl0ZW1bMF0gfHwgYy5zb3VyY2VJbmRleCA9PT0gZmlsbEhhbmRsZVRhcmdldFswXSk7XG4gICAgaWYgKCFtdXN0RHJhdylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBbdGFyZ2V0Q29sLCB0YXJnZXRSb3ddID0gc2VsZWN0ZWRDZWxsLmN1cnJlbnQuY2VsbDtcbiAgICBjb25zdCBjZWxsID0gZ2V0Q2VsbENvbnRlbnQoc2VsZWN0ZWRDZWxsLmN1cnJlbnQuY2VsbCk7XG4gICAgY29uc3QgdGFyZ2V0Q29sU3BhbiA9IGNlbGwuc3BhbiA/PyBbdGFyZ2V0Q29sLCB0YXJnZXRDb2xdO1xuICAgIGNvbnN0IGlzU3RpY2t5Um93ID0gdGFyZ2V0Um93ID49IHJvd3MgLSBmcmVlemVUcmFpbGluZ1Jvd3M7XG4gICAgY29uc3Qgc3RpY2tSb3dIZWlnaHQgPSBmcmVlemVUcmFpbGluZ1Jvd3MgPiAwICYmICFpc1N0aWNreVJvd1xuICAgICAgICA/IGdldEZyZWV6ZVRyYWlsaW5nSGVpZ2h0KHJvd3MsIGZyZWV6ZVRyYWlsaW5nUm93cywgZ2V0Um93SGVpZ2h0KSAtIDFcbiAgICAgICAgOiAwO1xuICAgIGNvbnN0IGZpbGxIYW5kbGVSb3cgPSBmaWxsSGFuZGxlVGFyZ2V0WzFdO1xuICAgIGxldCBkcmF3SGFuZGxlQ2IgPSB1bmRlZmluZWQ7XG4gICAgd2Fsa0NvbHVtbnMoZWZmZWN0aXZlQ29scywgY2VsbFlPZmZzZXQsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIHRvdGFsSGVhZGVySGVpZ2h0LCAoY29sLCBkcmF3WCwgY29sRHJhd1ksIGNsaXBYLCBzdGFydFJvdykgPT4ge1xuICAgICAgICBjbGlwWDtcbiAgICAgICAgaWYgKGNvbC5zdGlja3kgJiYgdGFyZ2V0Q29sID4gY29sLnNvdXJjZUluZGV4KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpc0JlZm9yZVRhcmdldCA9IGNvbC5zb3VyY2VJbmRleCA8IHRhcmdldENvbFNwYW5bMF07XG4gICAgICAgIGNvbnN0IGlzQWZ0ZXJUYXJnZXQgPSBjb2wuc291cmNlSW5kZXggPiB0YXJnZXRDb2xTcGFuWzFdO1xuICAgICAgICBjb25zdCBpc0ZpbGxIYW5kbGVDb2wgPSBjb2wuc291cmNlSW5kZXggPT09IGZpbGxIYW5kbGVUYXJnZXRbMF07XG4gICAgICAgIGlmICghaXNGaWxsSGFuZGxlQ29sICYmIChpc0JlZm9yZVRhcmdldCB8fCBpc0FmdGVyVGFyZ2V0KSkge1xuICAgICAgICAgICAgLy8gd2UgZG9udCBuZWVkIHRvIGRvIGFueSBkcmF3aW5nIG9uIHRoaXMgY29sdW1uIGJ1dCBtYXkgeWV0IG5lZWQgdG8gZHJhd1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhbGtSb3dzSW5Db2woc3RhcnRSb3csIGNvbERyYXdZLCBoZWlnaHQsIHJvd3MsIGdldFJvd0hlaWdodCwgZnJlZXplVHJhaWxpbmdSb3dzLCBoYXNBcHBlbmRSb3csIHVuZGVmaW5lZCwgKGRyYXdZLCByb3csIHJoKSA9PiB7XG4gICAgICAgICAgICBpZiAocm93ICE9PSB0YXJnZXRSb3cgJiYgcm93ICE9PSBmaWxsSGFuZGxlUm93KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBjZWxsWCA9IGRyYXdYO1xuICAgICAgICAgICAgbGV0IGNlbGxXaWR0aCA9IGNvbC53aWR0aDtcbiAgICAgICAgICAgIGlmIChjZWxsLnNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZWFzID0gZ2V0U3BhbkJvdW5kcyhjZWxsLnNwYW4sIGRyYXdYLCBkcmF3WSwgY29sLndpZHRoLCByaCwgY29sLCBhbGxDb2x1bW5zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmVhID0gY29sLnN0aWNreSA/IGFyZWFzWzBdIDogYXJlYXNbMV07XG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsWCA9IGFyZWEueDtcbiAgICAgICAgICAgICAgICAgICAgY2VsbFdpZHRoID0gYXJlYS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkb0hhbmRsZSA9IHJvdyA9PT0gZmlsbEhhbmRsZVJvdyAmJiBpc0ZpbGxIYW5kbGVDb2wgJiYgZmlsbEhhbmRsZTtcbiAgICAgICAgICAgIGlmIChkb0hhbmRsZSkge1xuICAgICAgICAgICAgICAgIGRyYXdIYW5kbGVDYiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXBYID4gY2VsbFggJiYgIWNvbC5zdGlja3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGNsaXBYLCAwLCB3aWR0aCAtIGNsaXBYLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGNlbGxYICsgY2VsbFdpZHRoIC0gNCwgZHJhd1kgKyByaCAtIDQsIDQsIDQpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sLnRoZW1lT3ZlcnJpZGU/LmFjY2VudENvbG9yID8/IHRoZW1lLmFjY2VudENvbG9yO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZHJhd0hhbmRsZUNiICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZHJhd0hhbmRsZUNiICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaWYgKGRyYXdIYW5kbGVDYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3VsdCA9ICgpID0+IHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCgwLCB0b3RhbEhlYWRlckhlaWdodCwgd2lkdGgsIGhlaWdodCAtIHRvdGFsSGVhZGVySGVpZ2h0IC0gc3RpY2tSb3dIZWlnaHQpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICBkcmF3SGFuZGxlQ2I/LigpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgcmVzdWx0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtZ3JpZC5yZW5kZXIucmluZ3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid.render.rings.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/draw-checkbox.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/draw-checkbox.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawCheckbox: () => (/* binding */ drawCheckbox)\n/* harmony export */ });\n/* harmony import */ var _common_support_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* harmony import */ var _data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-grid-lib.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/data-grid-lib.js\");\n/* harmony import */ var _data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n\n\n\n\nfunction drawCheckbox(ctx, theme, checked, x, y, width, height, highlighted, hoverX = -20, hoverY = -20, maxSize = 32, alignment = \"center\", style = \"square\") {\n    const centerY = Math.floor(y + height / 2);\n    const rectBordRadius = style === \"circle\" ? 10000 : theme.roundingRadius ?? 4;\n    let checkBoxWidth = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSquareWidth)(maxSize, height, theme.cellVerticalPadding);\n    let checkBoxHalfWidth = checkBoxWidth / 2;\n    const posX = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSquareXPosFromAlign)(alignment, x, width, theme.cellHorizontalPadding, checkBoxWidth);\n    const bb = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSquareBB)(posX, centerY, checkBoxWidth);\n    const hovered = (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_0__.pointIsWithinBB)(x + hoverX, y + hoverY, bb);\n    switch (checked) {\n        case true: {\n            ctx.beginPath();\n            (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.roundedRect)(ctx, posX - checkBoxWidth / 2, centerY - checkBoxWidth / 2, checkBoxWidth, checkBoxWidth, rectBordRadius);\n            if (style === \"circle\") {\n                checkBoxHalfWidth *= 0.8;\n                checkBoxWidth *= 0.8;\n            }\n            ctx.fillStyle = highlighted ? theme.accentColor : theme.textMedium;\n            ctx.fill();\n            ctx.beginPath();\n            ctx.moveTo(posX - checkBoxHalfWidth + checkBoxWidth / 4.23, centerY - checkBoxHalfWidth + checkBoxWidth / 1.97);\n            ctx.lineTo(posX - checkBoxHalfWidth + checkBoxWidth / 2.42, centerY - checkBoxHalfWidth + checkBoxWidth / 1.44);\n            ctx.lineTo(posX - checkBoxHalfWidth + checkBoxWidth / 1.29, centerY - checkBoxHalfWidth + checkBoxWidth / 3.25);\n            ctx.strokeStyle = theme.bgCell;\n            ctx.lineJoin = \"round\";\n            ctx.lineCap = \"round\";\n            ctx.lineWidth = 1.9;\n            ctx.stroke();\n            break;\n        }\n        case _data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.BooleanEmpty:\n        case false: {\n            ctx.beginPath();\n            (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.roundedRect)(ctx, posX - checkBoxWidth / 2 + 0.5, centerY - checkBoxWidth / 2 + 0.5, checkBoxWidth - 1, checkBoxWidth - 1, rectBordRadius);\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = hovered ? theme.textDark : theme.textMedium;\n            ctx.stroke();\n            break;\n        }\n        case _data_grid_types_js__WEBPACK_IMPORTED_MODULE_2__.BooleanIndeterminate: {\n            ctx.beginPath();\n            (0,_data_grid_lib_js__WEBPACK_IMPORTED_MODULE_1__.roundedRect)(ctx, posX - checkBoxWidth / 2, centerY - checkBoxWidth / 2, checkBoxWidth, checkBoxWidth, rectBordRadius);\n            ctx.fillStyle = hovered ? theme.textMedium : theme.textLight;\n            ctx.fill();\n            if (style === \"circle\") {\n                checkBoxHalfWidth *= 0.8;\n                checkBoxWidth *= 0.8;\n            }\n            ctx.beginPath();\n            ctx.moveTo(posX - checkBoxWidth / 3, centerY);\n            ctx.lineTo(posX + checkBoxWidth / 3, centerY);\n            ctx.strokeStyle = theme.bgCell;\n            ctx.lineCap = \"round\";\n            ctx.lineWidth = 1.9;\n            ctx.stroke();\n            break;\n        }\n        default:\n            (0,_common_support_js__WEBPACK_IMPORTED_MODULE_3__.assertNever)(checked);\n    }\n}\n//# sourceMappingURL=draw-checkbox.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3JlbmRlci9kcmF3LWNoZWNrYm94LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlEO0FBQ3VEO0FBQy9EO0FBQzBCO0FBQ3BFO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixnRUFBYztBQUN0QztBQUNBLGlCQUFpQix3RUFBc0I7QUFDdkMsZUFBZSw2REFBVztBQUMxQixvQkFBb0IsaUVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2REFBWTtBQUN6QjtBQUNBO0FBQ0EsWUFBWSw4REFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxRUFBb0I7QUFDakM7QUFDQSxZQUFZLDhEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBVztBQUN2QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQvcmVuZGVyL2RyYXctY2hlY2tib3guanM/ZmJmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnROZXZlciB9IGZyb20gXCIuLi8uLi8uLi9jb21tb24vc3VwcG9ydC5qc1wiO1xuaW1wb3J0IHsgZ2V0U3F1YXJlV2lkdGgsIGdldFNxdWFyZVhQb3NGcm9tQWxpZ24sIGdldFNxdWFyZUJCLCBwb2ludElzV2l0aGluQkIgfSBmcm9tIFwiLi4vLi4vLi4vY29tbW9uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyByb3VuZGVkUmVjdCB9IGZyb20gXCIuL2RhdGEtZ3JpZC1saWIuanNcIjtcbmltcG9ydCB7IEJvb2xlYW5FbXB0eSwgQm9vbGVhbkluZGV0ZXJtaW5hdGUgfSBmcm9tIFwiLi4vZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZHJhd0NoZWNrYm94KGN0eCwgdGhlbWUsIGNoZWNrZWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGhpZ2hsaWdodGVkLCBob3ZlclggPSAtMjAsIGhvdmVyWSA9IC0yMCwgbWF4U2l6ZSA9IDMyLCBhbGlnbm1lbnQgPSBcImNlbnRlclwiLCBzdHlsZSA9IFwic3F1YXJlXCIpIHtcbiAgICBjb25zdCBjZW50ZXJZID0gTWF0aC5mbG9vcih5ICsgaGVpZ2h0IC8gMik7XG4gICAgY29uc3QgcmVjdEJvcmRSYWRpdXMgPSBzdHlsZSA9PT0gXCJjaXJjbGVcIiA/IDEwMDAwIDogdGhlbWUucm91bmRpbmdSYWRpdXMgPz8gNDtcbiAgICBsZXQgY2hlY2tCb3hXaWR0aCA9IGdldFNxdWFyZVdpZHRoKG1heFNpemUsIGhlaWdodCwgdGhlbWUuY2VsbFZlcnRpY2FsUGFkZGluZyk7XG4gICAgbGV0IGNoZWNrQm94SGFsZldpZHRoID0gY2hlY2tCb3hXaWR0aCAvIDI7XG4gICAgY29uc3QgcG9zWCA9IGdldFNxdWFyZVhQb3NGcm9tQWxpZ24oYWxpZ25tZW50LCB4LCB3aWR0aCwgdGhlbWUuY2VsbEhvcml6b250YWxQYWRkaW5nLCBjaGVja0JveFdpZHRoKTtcbiAgICBjb25zdCBiYiA9IGdldFNxdWFyZUJCKHBvc1gsIGNlbnRlclksIGNoZWNrQm94V2lkdGgpO1xuICAgIGNvbnN0IGhvdmVyZWQgPSBwb2ludElzV2l0aGluQkIoeCArIGhvdmVyWCwgeSArIGhvdmVyWSwgYmIpO1xuICAgIHN3aXRjaCAoY2hlY2tlZCkge1xuICAgICAgICBjYXNlIHRydWU6IHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHJvdW5kZWRSZWN0KGN0eCwgcG9zWCAtIGNoZWNrQm94V2lkdGggLyAyLCBjZW50ZXJZIC0gY2hlY2tCb3hXaWR0aCAvIDIsIGNoZWNrQm94V2lkdGgsIGNoZWNrQm94V2lkdGgsIHJlY3RCb3JkUmFkaXVzKTtcbiAgICAgICAgICAgIGlmIChzdHlsZSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrQm94SGFsZldpZHRoICo9IDAuODtcbiAgICAgICAgICAgICAgICBjaGVja0JveFdpZHRoICo9IDAuODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBoaWdobGlnaHRlZCA/IHRoZW1lLmFjY2VudENvbG9yIDogdGhlbWUudGV4dE1lZGl1bTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHBvc1ggLSBjaGVja0JveEhhbGZXaWR0aCArIGNoZWNrQm94V2lkdGggLyA0LjIzLCBjZW50ZXJZIC0gY2hlY2tCb3hIYWxmV2lkdGggKyBjaGVja0JveFdpZHRoIC8gMS45Nyk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvc1ggLSBjaGVja0JveEhhbGZXaWR0aCArIGNoZWNrQm94V2lkdGggLyAyLjQyLCBjZW50ZXJZIC0gY2hlY2tCb3hIYWxmV2lkdGggKyBjaGVja0JveFdpZHRoIC8gMS40NCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvc1ggLSBjaGVja0JveEhhbGZXaWR0aCArIGNoZWNrQm94V2lkdGggLyAxLjI5LCBjZW50ZXJZIC0gY2hlY2tCb3hIYWxmV2lkdGggKyBjaGVja0JveFdpZHRoIC8gMy4yNSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGVtZS5iZ0NlbGw7XG4gICAgICAgICAgICBjdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgICAgICAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxLjk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEJvb2xlYW5FbXB0eTpcbiAgICAgICAgY2FzZSBmYWxzZToge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgcm91bmRlZFJlY3QoY3R4LCBwb3NYIC0gY2hlY2tCb3hXaWR0aCAvIDIgKyAwLjUsIGNlbnRlclkgLSBjaGVja0JveFdpZHRoIC8gMiArIDAuNSwgY2hlY2tCb3hXaWR0aCAtIDEsIGNoZWNrQm94V2lkdGggLSAxLCByZWN0Qm9yZFJhZGl1cyk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGhvdmVyZWQgPyB0aGVtZS50ZXh0RGFyayA6IHRoZW1lLnRleHRNZWRpdW07XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEJvb2xlYW5JbmRldGVybWluYXRlOiB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICByb3VuZGVkUmVjdChjdHgsIHBvc1ggLSBjaGVja0JveFdpZHRoIC8gMiwgY2VudGVyWSAtIGNoZWNrQm94V2lkdGggLyAyLCBjaGVja0JveFdpZHRoLCBjaGVja0JveFdpZHRoLCByZWN0Qm9yZFJhZGl1cyk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gaG92ZXJlZCA/IHRoZW1lLnRleHRNZWRpdW0gOiB0aGVtZS50ZXh0TGlnaHQ7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgaWYgKHN0eWxlID09PSBcImNpcmNsZVwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tCb3hIYWxmV2lkdGggKj0gMC44O1xuICAgICAgICAgICAgICAgIGNoZWNrQm94V2lkdGggKj0gMC44O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb3NYIC0gY2hlY2tCb3hXaWR0aCAvIDMsIGNlbnRlclkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb3NYICsgY2hlY2tCb3hXaWR0aCAvIDMsIGNlbnRlclkpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhlbWUuYmdDZWxsO1xuICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMS45O1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGFzc2VydE5ldmVyKGNoZWNrZWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYXctY2hlY2tib3guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/render/draw-checkbox.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/sprites.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/sprites.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sprites: () => (/* binding */ sprites)\n/* harmony export */ });\nconst iconHead = `<svg width=\"20\" height=\"20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">`;\nconst headerRowID = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}<rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/><path d=\"M15.75 4h-1.5a.25.25 0 0 0-.177.074L9.308 8.838a3.75 3.75 0 1 0 1.854 1.854l1.155-1.157.967.322a.5.5 0 0 0 .65-.55l-.18-1.208.363-.363.727.331a.5.5 0 0 0 .69-.59l-.254-.904.647-.647A.25.25 0 0 0 16 5.75v-1.5a.25.25 0 0 0-.25-.25zM7.5 13.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0z\" fill=\"${fg}\"/></svg>`;\n};\nconst headerCode = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}<rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"4\" fill=\"${bg}\"/><path d=\"m12.223 13.314 3.052-2.826a.65.65 0 0 0 0-.984l-3.052-2.822c-.27-.25-.634-.242-.865.022-.232.263-.206.636.056.882l2.601 2.41-2.601 2.41c-.262.245-.288.619-.056.882.231.263.595.277.865.026Zm-4.444.005c.266.25.634.241.866-.027.231-.263.206-.636-.06-.882L5.983 10l2.602-2.405c.266-.25.291-.62.06-.887-.232-.263-.596-.272-.866-.022L4.723 9.51a.653.653 0 0 0 0 .983l3.056 2.827Z\" fill=\"${fg}\"/></svg>`;\n};\nconst headerNumber = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M6.52 12.78H5.51V8.74l-1.33.47v-.87l2.29-.83h.05v5.27zm5.2 0H8.15v-.69l1.7-1.83a6.38 6.38 0 0 0 .34-.4c.09-.11.16-.22.22-.32s.1-.19.12-.27a.9.9 0 0 0 0-.56.63.63 0 0 0-.15-.23.58.58 0 0 0-.22-.15.75.75 0 0 0-.29-.05c-.27 0-.48.08-.62.23a.95.95 0 0 0-.2.65H8.03c0-.24.04-.46.13-.67a1.67 1.67 0 0 1 .97-.91c.23-.1.49-.14.77-.14.26 0 .5.04.7.11.21.08.38.18.52.32.14.13.25.3.32.48a1.74 1.74 0 0 1 .03 1.13 2.05 2.05 0 0 1-.24.47 4.16 4.16 0 0 1-.35.47l-.47.5-1 1.05h2.32v.8zm1.8-3.08h.55c.28 0 .48-.06.61-.2a.76.76 0 0 0 .2-.55.8.8 0 0 0-.05-.28.56.56 0 0 0-.13-.22.6.6 0 0 0-.23-.15.93.93 0 0 0-.32-.05.92.92 0 0 0-.29.05.72.72 0 0 0-.23.12.57.57 0 0 0-.21.46H12.4a1.3 1.3 0 0 1 .5-1.04c.15-.13.33-.23.54-.3a2.48 2.48 0 0 1 1.4 0c.2.06.4.15.55.28.15.13.27.28.36.47.08.19.13.4.13.65a1.15 1.15 0 0 1-.2.65 1.36 1.36 0 0 1-.58.49c.15.05.28.12.38.2a1.14 1.14 0 0 1 .43.62c.03.13.05.26.05.4 0 .25-.05.47-.14.66a1.42 1.42 0 0 1-.4.49c-.16.13-.35.23-.58.3a2.51 2.51 0 0 1-.73.1c-.22 0-.44-.03-.65-.09a1.8 1.8 0 0 1-.57-.28 1.43 1.43 0 0 1-.4-.47 1.41 1.41 0 0 1-.15-.66h1a.66.66 0 0 0 .22.5.87.87 0 0 0 .58.2c.25 0 .45-.07.6-.2a.71.71 0 0 0 .21-.56.97.97 0 0 0-.06-.36.61.61 0 0 0-.18-.25.74.74 0 0 0-.28-.15 1.33 1.33 0 0 0-.37-.04h-.55V9.7z\" fill=\"${fg}\"/>\n  </svg>`;\n};\nconst headerString = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path d=\"M8.182 12.4h3.636l.655 1.6H14l-3.454-8H9.455L6 14h1.527l.655-1.6zM10 7.44l1.36 3.651H8.64L10 7.441z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst headerBoolean = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n    <path\n        d=\"M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z\"\n        fill=\"${bg}\"\n    />\n    <path\n        fill-rule=\"evenodd\"\n        clip-rule=\"evenodd\"\n        d=\"M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z\"\n        fill=\"${fg}\"\n    />\n</svg>`;\n};\nconst headerUri = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n<path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10.29 4.947a3.368 3.368 0 014.723.04 3.375 3.375 0 01.041 4.729l-.009.009-1.596 1.597a3.367 3.367 0 01-5.081-.364.71.71 0 011.136-.85 1.95 1.95 0 002.942.21l1.591-1.593a1.954 1.954 0 00-.027-2.733 1.95 1.95 0 00-2.732-.027l-.91.907a.709.709 0 11-1.001-1.007l.915-.911.007-.007z\" fill=\"${fg}\"/>\n<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M6.55 8.678a3.368 3.368 0 015.082.364.71.71 0 01-1.136.85 1.95 1.95 0 00-2.942-.21l-1.591 1.593a1.954 1.954 0 00.027 2.733 1.95 1.95 0 002.73.028l.906-.906a.709.709 0 111.003 1.004l-.91.91-.008.01a3.368 3.368 0 01-4.724-.042 3.375 3.375 0 01-.041-4.728l.009-.009L6.55 8.678z\" fill=\"${fg}\"/>\n</svg>\n  `;\n};\nconst renameIcon = (props) => {\n    const bg = props.bgColor;\n    return `${iconHead}\n    <path stroke=\"${bg}\" stroke-width=\"2\" d=\"M12 3v14\"/>\n    <path stroke=\"${bg}\" stroke-width=\"2\" stroke-linecap=\"round\" d=\"M10 4h4m-4 12h4\"/>\n    <path d=\"M11 14h4a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3h-4v2h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-4v2ZM9.5 8H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h4.5v2H5a3 3 0 0 1-3-3V9a3 3 0 0 1 3-3h4.5v2Z\" fill=\"${bg}\"/>\n  </svg>\n`;\n};\nconst headerAudioUri = headerUri;\nconst headerVideoUri = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7 13.138a.5.5 0 00.748.434l5.492-3.138a.5.5 0 000-.868L7.748 6.427A.5.5 0 007 6.862v6.276z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst headerEmoji = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M10 5a5 5 0 1 0 0 10 5 5 0 0 0 0-10zm0 9.17A4.17 4.17 0 0 1 5.83 10 4.17 4.17 0 0 1 10 5.83 4.17 4.17 0 0 1 14.17 10 4.17 4.17 0 0 1 10 14.17z\" fill=\"${fg}\"/>\n    <path d=\"M8.33 8.21a.83.83 0 1 0-.03 1.67.83.83 0 0 0 .03-1.67zm3.34 0a.83.83 0 1 0-.04 1.67.83.83 0 0 0 .04-1.67z\" fill=\"${fg}\"/>\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.53 13.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z\" fill=\"${fg}\"/>\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M10 4a6 6 0 1 0 0 12 6 6 0 0 0 0-12zm0 11a5 5 0 1 1 .01-10.01A5 5 0 0 1 10 15z\" fill=\"${fg}\"/>\n    <path d=\"M8 7.86a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2zm4 0a1 1 0 1 0-.04 2 1 1 0 0 0 .04-2z\" fill=\"${fg}\"/>\n    <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.53 11.9a2.82 2.82 0 0 1-5.06 0l.77-.38a1.97 1.97 0 0 0 3.52 0l.77.39z\" fill=\"${fg}\"/>\n  </svg>`;\n};\nconst headerImage = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path opacity=\".5\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.499 10.801a.5.5 0 01.835 0l2.698 4.098a.5.5 0 01-.418.775H10.22a.5.5 0 01-.417-.775l2.697-4.098z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.07 8.934a.5.5 0 01.824 0l4.08 5.958a.5.5 0 01-.412.782h-8.16a.5.5 0 01-.413-.782l4.08-5.958zM13.75 8.333a2.083 2.083 0 100-4.166 2.083 2.083 0 000 4.166z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst headerPhone = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path fill=\"${fg}\" d=\"M3 3h14v14H3z\"/>\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2zm-7.24 9.78h1.23c.15 0 .27.06.36.18l.98 1.28a.43.43 0 0 1-.05.58l-1.2 1.21a.45.45 0 0 1-.6.04A6.72 6.72 0 0 1 7.33 10c0-.61.1-1.2.25-1.78a6.68 6.68 0 0 1 2.12-3.3.44.44 0 0 1 .6.04l1.2 1.2c.16.17.18.42.05.59l-.98 1.29a.43.43 0 0 1-.36.17H8.98A5.38 5.38 0 0 0 8.67 10c0 .62.11 1.23.3 1.79z\" fill=\"${bg}\"/>\n  </svg>`;\n};\nconst headerMarkdown = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"m13.49 13.15-2.32-3.27h1.4V7h1.86v2.88h1.4l-2.34 3.27zM11 13H9v-3l-1.5 1.92L6 10v3H4V7h2l1.5 2L9 7h2v6z\" fill=\"${fg}\"/>\n  </svg>`;\n};\nconst headerDate = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path d=\"M14.8 4.182h-.6V3H13v1.182H7V3H5.8v1.182h-.6c-.66 0-1.2.532-1.2 1.182v9.454C4 15.468 4.54 16 5.2 16h9.6c.66 0 1.2-.532 1.2-1.182V5.364c0-.65-.54-1.182-1.2-1.182zm0 10.636H5.2V7.136h9.6v7.682z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst headerTime = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M10 4a6 6 0 0 0-6 6 6 6 0 0 0 6 6 6 6 0 0 0 6-6 6 6 0 0 0-6-6zm0 10.8A4.8 4.8 0 0 1 5.2 10a4.8 4.8 0 1 1 4.8 4.8z\" fill=\"${fg}\"/>\n    <path d=\"M10 7H9v3.93L12.5 13l.5-.8-3-1.76V7z\" fill=\"${fg}\"/>\n  </svg>`;\n};\nconst headerEmail = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10 8.643a1.357 1.357 0 100 2.714 1.357 1.357 0 000-2.714zM7.357 10a2.643 2.643 0 115.286 0 2.643 2.643 0 01-5.286 0z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.589 4.898A5.643 5.643 0 0115.643 10v.5a2.143 2.143 0 01-4.286 0V8a.643.643 0 011.286 0v2.5a.857.857 0 001.714 0V10a4.357 4.357 0 10-1.708 3.46.643.643 0 01.782 1.02 5.643 5.643 0 11-5.842-9.582z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst headerReference = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"8\" width=\"10\" height=\"8\" rx=\"2\" fill=\"${bg}\"/>\n    <rect x=\"8\" y=\"4\" width=\"10\" height=\"8\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M10.68 7.73V6l2.97 3.02-2.97 3.02v-1.77c-2.13 0-3.62.7-4.68 2.2.43-2.15 1.7-4.31 4.68-4.74z\" fill=\"${fg}\"/>\n  </svg>`;\n};\nconst headerIfThenElse = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path fill=\"${fg}\" d=\"M4 3h12v14H4z\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M3.6 2A1.6 1.6 0 002 3.6v12.8A1.6 1.6 0 003.6 18h12.8a1.6 1.6 0 001.6-1.6V3.6A1.6 1.6 0 0016.4 2H3.6zm11.3 10.8a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7h-1.4a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.6-.693.117.117 0 00.1-.115V10.35a.117.117 0 00-.117-.116h-2.8a.117.117 0 00-.117.116v2.333c0 .064.053.117.117.117h.117a.7.7 0 01.7.7v1.4a.7.7 0 01-.7.7H9.3a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.117a.117.117 0 00.117-.117V10.35a.117.117 0 00-.117-.117h-2.8a.117.117 0 00-.117.117v2.342c0 .058.042.106.1.115a.7.7 0 01.6.693v1.4a.7.7 0 01-.7.7H5.1a.7.7 0 01-.7-.7v-1.4a.7.7 0 01.7-.7h.35a.116.116 0 00.116-.117v-2.45c0-.515.418-.933.934-.933h2.917a.117.117 0 00.117-.117V6.85a.117.117 0 00-.117-.116h-2.45a.7.7 0 01-.7-.7V5.1a.7.7 0 01.7-.7h6.067a.7.7 0 01.7.7v.934a.7.7 0 01-.7.7h-2.45a.117.117 0 00-.118.116v2.333c0 .064.053.117.117.117H13.5c.516 0 .934.418.934.934v2.45c0 .063.052.116.116.116h.35z\" fill=\"${bg}\"/>\n</svg>`;\n};\nconst headerSingleValue = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M9.98 13.33c.45 0 .74-.3.73-.75l-.01-.1-.16-1.67 1.45 1.05a.81.81 0 0 0 .5.18c.37 0 .72-.32.72-.76 0-.3-.17-.54-.49-.68l-1.63-.77 1.63-.77c.32-.14.49-.37.49-.67 0-.45-.34-.76-.71-.76a.81.81 0 0 0-.5.18l-1.47 1.03.16-1.74.01-.08c.01-.46-.27-.76-.72-.76-.46 0-.76.32-.75.76l.01.08.16 1.74-1.47-1.03a.77.77 0 0 0-.5-.18.74.74 0 0 0-.72.76c0 .3.17.53.49.67l1.63.77-1.62.77c-.32.14-.5.37-.5.68 0 .44.35.75.72.75a.78.78 0 0 0 .5-.17L9.4 10.8l-.16 1.68v.09c-.02.44.28.75.74.75z\" fill=\"${fg}\"/>\n  </svg>`;\n};\nconst headerLookup = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M8 5.83H5.83a.83.83 0 0 0 0 1.67h1.69A4.55 4.55 0 0 1 8 5.83zm-.33 3.34H5.83a.83.83 0 0 0 0 1.66h2.72a4.57 4.57 0 0 1-.88-1.66zM5.83 12.5a.83.83 0 0 0 0 1.67h7.5a.83.83 0 1 0 0-1.67h-7.5zm8.8-2.9a3.02 3.02 0 0 0 .46-1.6c0-1.66-1.32-3-2.94-3C10.52 5 9.2 6.34 9.2 8s1.31 3 2.93 3c.58 0 1.11-.17 1.56-.47l2.04 2.08.93-.94-2.04-2.08zm-2.48.07c-.9 0-1.63-.75-1.63-1.67s.73-1.67 1.63-1.67c.9 0 1.63.75 1.63 1.67s-.73 1.67-1.63 1.67z\" fill=\"${fg}\"/>\n  </svg>`;\n};\nconst headerTextTemplate = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path d=\"M7.676 4.726V3l2.976 3.021-2.976 3.022v-1.77c-2.125 0-3.613.69-4.676 2.201.425-2.158 1.7-4.316 4.676-4.748zM10.182 14.4h3.636l.655 1.6H16l-3.454-8h-1.091L8 16h1.527l.655-1.6zM12 9.44l1.36 3.65h-2.72L12 9.44z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst headerMath = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.167 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666H4.167z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.083 4.167a.833.833 0 10-1.666 0v4.166a.833.833 0 101.666 0V4.167zM11.667 5.417a.833.833 0 100 1.666h4.166a.833.833 0 100-1.666h-4.166zM5.367 11.688a.833.833 0 00-1.179 1.179l2.947 2.946a.833.833 0 001.178-1.178l-2.946-2.947z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M8.313 12.867a.833.833 0 10-1.178-1.179l-2.947 2.947a.833.833 0 101.179 1.178l2.946-2.946z\" fill=\"${fg}\"/>\n  <path d=\"M10.833 12.5c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833zM10.833 15c0-.46.373-.833.834-.833h4.166a.833.833 0 110 1.666h-4.166a.833.833 0 01-.834-.833z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst headerRollup = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <path d=\"M16.22 2H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.77-.8 1.77-1.78L18 3.78C18 2.8 17.2 2 16.22 2z\" fill=\"${bg}\"/>\n    <path d=\"M10 8.84a1.16 1.16 0 1 0 0 2.32 1.16 1.16 0 0 0 0-2.32zm3.02 3.61a3.92 3.92 0 0 0 .78-3.28.49.49 0 1 0-.95.2c.19.87-.02 1.78-.58 2.47a2.92 2.92 0 1 1-4.13-4.08 2.94 2.94 0 0 1 2.43-.62.49.49 0 1 0 .17-.96 3.89 3.89 0 1 0 2.28 6.27zM10 4.17a5.84 5.84 0 0 0-5.44 7.93.49.49 0 1 0 .9-.35 4.86 4.86 0 1 1 2.5 2.67.49.49 0 1 0-.4.88c.76.35 1.6.54 2.44.53a5.83 5.83 0 0 0 0-11.66zm3.02 3.5a.7.7 0 1 0-1.4 0 .7.7 0 0 0 1.4 0zm-6.97 5.35a.7.7 0 1 1 0 1.4.7.7 0 0 1 0-1.4z\" fill=\"${fg}\"/>\n  </svg>`;\n};\nconst headerJoinStrings = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path d=\"M12.4 13.565c1.865-.545 3.645-2.083 3.645-4.396 0-1.514-.787-2.604-2.071-2.604C12.69 6.565 12 7.63 12 8.939c1.114.072 1.865.726 1.865 1.683 0 .933-.8 1.647-1.84 2.023l.375.92zM4 5h6v2H4zM4 9h5v2H4zM4 13h4v2H4z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst headerSplitString = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    ${iconHead}\n    <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n    <path d=\"M12.4 13.56c1.86-.54 3.65-2.08 3.65-4.4 0-1.5-.8-2.6-2.08-2.6S12 7.64 12 8.95c1.11.07 1.86.73 1.86 1.68 0 .94-.8 1.65-1.83 2.03l.37.91zM4 5h6v2H4zm0 4h5v2H4zm0 4h4v2H4z\" fill=\"${fg}\"/>\n  </svg>`;\n};\nconst headerGeoDistance = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <path d=\"M16.222 2H3.778C2.8 2 2 2.8 2 3.778v12.444C2 17.2 2.8 18 3.778 18h12.444c.978 0 1.77-.8 1.77-1.778L18 3.778C18 2.8 17.2 2 16.222 2z\" fill=\"${bg}\"/>\n  <path d=\"M10 7a1 1 0 100-2v2zm0 6a1 1 0 100 2v-2zm0-8H7v2h3V5zm-3 6h5V9H7v2zm5 2h-2v2h2v-2zm1-1a1 1 0 01-1 1v2a3 3 0 003-3h-2zm-1-1a1 1 0 011 1h2a3 3 0 00-3-3v2zM4 8a3 3 0 003 3V9a1 1 0 01-1-1H4zm3-3a3 3 0 00-3 3h2a1 1 0 011-1V5z\" fill=\"${fg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.856 12.014a.5.5 0 00-.712.702L5.409 14l-1.265 1.284a.5.5 0 00.712.702l1.255-1.274 1.255 1.274a.5.5 0 00.712-.702L6.813 14l1.265-1.284a.5.5 0 00-.712-.702L6.11 13.288l-1.255-1.274zM12.856 4.014a.5.5 0 00-.712.702L13.409 6l-1.265 1.284a.5.5 0 10.712.702l1.255-1.274 1.255 1.274a.5.5 0 10.712-.702L14.813 6l1.265-1.284a.5.5 0 00-.712-.702L14.11 5.288l-1.255-1.274z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst headerArray = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `${iconHead}\n  <rect x=\"2\" y=\"2\" width=\"16\" height=\"16\" rx=\"2\" fill=\"${bg}\"/>\n  <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.25 7.25a.75.75 0 000-1.5h-6.5a.75.75 0 100 1.5h6.5zM15 10a.75.75 0 01-.75.75h-6.5a.75.75 0 010-1.5h6.5A.75.75 0 0115 10zm-.75 4.25a.75.75 0 000-1.5h-6.5a.75.75 0 000 1.5h6.5zm-8.987-7a.75.75 0 100-1.5.75.75 0 000 1.5zm.75 2.75a.75.75 0 11-1.5 0 .75.75 0 011.5 0zm-.75 4.25a.75.75 0 100-1.5.75.75 0 000 1.5z\" fill=\"${fg}\"/>\n</svg>`;\n};\nconst rowOwnerOverlay = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    <svg width=\"18\" height=\"18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 15v1h14v-2.5c0-.87-.44-1.55-.98-2.04a6.19 6.19 0 0 0-1.9-1.14 12.1 12.1 0 0 0-2.48-.67A4 4 0 1 0 5 6a4 4 0 0 0 2.36 3.65c-.82.13-1.7.36-2.48.67-.69.28-1.37.65-1.9 1.13A2.8 2.8 0 0 0 2 13.5V15z\" fill=\"${bg}\" stroke=\"${fg}\" stroke-width=\"2\"/>\n  </svg>`;\n};\nconst protectedColumnOverlay = (props) => {\n    const fg = props.fgColor;\n    const bg = props.bgColor;\n    return `\n    <svg width=\"18\" height=\"18\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M12.43 6.04v-.18a3.86 3.86 0 0 0-7.72 0v.18A2.15 2.15 0 0 0 3 8.14v5.72C3 15.04 3.96 16 5.14 16H12c1.18 0 2.14-.96 2.14-2.14V8.14c0-1.03-.73-1.9-1.71-2.1zM7.86 6v-.14a.71.71 0 1 1 1.43 0V6H7.86z\" fill=\"${bg}\" stroke=\"${fg}\" stroke-width=\"2\"/>\n  </svg>\n`;\n};\nconst sprites = {\n    headerRowID,\n    headerNumber,\n    headerCode,\n    headerString,\n    headerBoolean,\n    headerAudioUri,\n    headerVideoUri,\n    headerEmoji,\n    headerImage,\n    headerUri,\n    headerPhone,\n    headerMarkdown,\n    headerDate,\n    headerTime,\n    headerEmail,\n    headerReference,\n    headerIfThenElse,\n    headerSingleValue,\n    headerLookup,\n    headerTextTemplate,\n    headerMath,\n    headerRollup,\n    headerJoinStrings,\n    headerSplitString,\n    headerGeoDistance,\n    headerArray,\n    rowOwnerOverlay,\n    protectedColumnOverlay,\n    renameIcon,\n};\n//# sourceMappingURL=sprites.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3Nwcml0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsd0RBQXdELEdBQUcsNFNBQTRTLEdBQUc7QUFDelg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyx3REFBd0QsR0FBRywyWUFBMlksR0FBRztBQUN4ZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnSkFBZ0osR0FBRztBQUNuSix1dUNBQXV1QyxHQUFHO0FBQzF1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHdKQUF3SixHQUFHO0FBQzNKLHdIQUF3SCxHQUFHO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsR0FBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsc0pBQXNKLEdBQUc7QUFDekosaVZBQWlWLEdBQUc7QUFDcFYsNlVBQTZVLEdBQUc7QUFDaFY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxvQkFBb0IsR0FBRztBQUN2QixvQkFBb0IsR0FBRztBQUN2QiwyTEFBMkwsR0FBRztBQUM5TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCx3SkFBd0osR0FBRztBQUMzSix3SkFBd0osR0FBRztBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scUtBQXFLLEdBQUc7QUFDeEssZ0lBQWdJLEdBQUc7QUFDbkksd0lBQXdJLEdBQUc7QUFDM0ksZ0pBQWdKLEdBQUc7QUFDbkoscUdBQXFHLEdBQUc7QUFDeEcsb0dBQW9HLEdBQUc7QUFDdkcsd0lBQXdJLEdBQUc7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCx3SkFBd0osR0FBRztBQUMzSiw4S0FBOEssR0FBRztBQUNqTCx5TkFBeU4sR0FBRztBQUM1TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLEdBQUc7QUFDckIsZ2JBQWdiLEdBQUc7QUFDbmI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdKQUFnSixHQUFHO0FBQ25KLDhIQUE4SCxHQUFHO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsd0pBQXdKLEdBQUc7QUFDM0osb05BQW9OLEdBQUc7QUFDdk47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdKQUFnSixHQUFHO0FBQ25KLHdJQUF3SSxHQUFHO0FBQzNJLDJEQUEyRCxHQUFHO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMERBQTBELEdBQUc7QUFDN0Qsa0xBQWtMLEdBQUc7QUFDckwsa1FBQWtRLEdBQUc7QUFDclE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJEQUEyRCxHQUFHO0FBQzlELDJEQUEyRCxHQUFHO0FBQzlELGtIQUFrSCxHQUFHO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0JBQWdCLEdBQUc7QUFDbkIsMDZCQUEwNkIsR0FBRztBQUM3NkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxHQUFHO0FBQy9ELDZlQUE2ZSxHQUFHO0FBQ2hmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0REFBNEQsR0FBRztBQUMvRCxpY0FBaWMsR0FBRztBQUNwYztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDBEQUEwRCxHQUFHO0FBQzdELG9PQUFvTyxHQUFHO0FBQ3ZPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMERBQTBELEdBQUc7QUFDN0QsZ0lBQWdJLEdBQUc7QUFDbkksZ1NBQWdTLEdBQUc7QUFDblMsdUpBQXVKLEdBQUc7QUFDMUosaU5BQWlOLEdBQUc7QUFDcE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdKQUFnSixHQUFHO0FBQ25KLHNlQUFzZSxHQUFHO0FBQ3plO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMERBQTBELEdBQUc7QUFDN0Qsc09BQXNPLEdBQUc7QUFDek87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxHQUFHO0FBQy9ELCtMQUErTCxHQUFHO0FBQ2xNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsd0pBQXdKLEdBQUc7QUFDM0osaVBBQWlQLEdBQUc7QUFDcFAseWFBQXlhLEdBQUc7QUFDNWE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCwwREFBMEQsR0FBRztBQUM3RCxtWEFBbVgsR0FBRztBQUN0WDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBOQUEwTixHQUFHLFlBQVksR0FBRztBQUM1TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlOQUF5TixHQUFHLFlBQVksR0FBRztBQUMzTztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3Nwcml0ZXMuanM/YjA3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpY29uSGVhZCA9IGA8c3ZnIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIyMFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPmA7XG5jb25zdCBoZWFkZXJSb3dJRCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGBcbiAgICAke2ljb25IZWFkfTxyZWN0IHg9XCIyXCIgeT1cIjJcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjJcIiBmaWxsPVwiJHtiZ31cIi8+PHBhdGggZD1cIk0xNS43NSA0aC0xLjVhLjI1LjI1IDAgMCAwLS4xNzcuMDc0TDkuMzA4IDguODM4YTMuNzUgMy43NSAwIDEgMCAxLjg1NCAxLjg1NGwxLjE1NS0xLjE1Ny45NjcuMzIyYS41LjUgMCAwIDAgLjY1LS41NWwtLjE4LTEuMjA4LjM2My0uMzYzLjcyNy4zMzFhLjUuNSAwIDAgMCAuNjktLjU5bC0uMjU0LS45MDQuNjQ3LS42NDdBLjI1LjI1IDAgMCAwIDE2IDUuNzV2LTEuNWEuMjUuMjUgMCAwIDAtLjI1LS4yNXpNNy41IDEzLjI1YS43NS43NSAwIDEgMS0xLjUgMCAuNzUuNzUgMCAwIDEgMS41IDB6XCIgZmlsbD1cIiR7Zmd9XCIvPjwvc3ZnPmA7XG59O1xuY29uc3QgaGVhZGVyQ29kZSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGBcbiAgICAke2ljb25IZWFkfTxyZWN0IHg9XCIyXCIgeT1cIjJcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjRcIiBmaWxsPVwiJHtiZ31cIi8+PHBhdGggZD1cIm0xMi4yMjMgMTMuMzE0IDMuMDUyLTIuODI2YS42NS42NSAwIDAgMCAwLS45ODRsLTMuMDUyLTIuODIyYy0uMjctLjI1LS42MzQtLjI0Mi0uODY1LjAyMi0uMjMyLjI2My0uMjA2LjYzNi4wNTYuODgybDIuNjAxIDIuNDEtMi42MDEgMi40MWMtLjI2Mi4yNDUtLjI4OC42MTktLjA1Ni44ODIuMjMxLjI2My41OTUuMjc3Ljg2NS4wMjZabS00LjQ0NC4wMDVjLjI2Ni4yNS42MzQuMjQxLjg2Ni0uMDI3LjIzMS0uMjYzLjIwNi0uNjM2LS4wNi0uODgyTDUuOTgzIDEwbDIuNjAyLTIuNDA1Yy4yNjYtLjI1LjI5MS0uNjIuMDYtLjg4Ny0uMjMyLS4yNjMtLjU5Ni0uMjcyLS44NjYtLjAyMkw0LjcyMyA5LjUxYS42NTMuNjUzIDAgMCAwIDAgLjk4M2wzLjA1NiAyLjgyN1pcIiBmaWxsPVwiJHtmZ31cIi8+PC9zdmc+YDtcbn07XG5jb25zdCBoZWFkZXJOdW1iZXIgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBmZyA9IHByb3BzLmZnQ29sb3I7XG4gICAgY29uc3QgYmcgPSBwcm9wcy5iZ0NvbG9yO1xuICAgIHJldHVybiBgJHtpY29uSGVhZH1cbiAgICA8cGF0aCBkPVwiTTE2LjIyIDJIMy43OEMyLjggMiAyIDIuOCAyIDMuNzh2MTIuNDRDMiAxNy4yIDIuOCAxOCAzLjc4IDE4aDEyLjQ0Yy45OCAwIDEuNzctLjggMS43Ny0xLjc4TDE4IDMuNzhDMTggMi44IDE3LjIgMiAxNi4yMiAyelwiIGZpbGw9XCIke2JnfVwiLz5cbiAgICA8cGF0aCBkPVwiTTYuNTIgMTIuNzhINS41MVY4Ljc0bC0xLjMzLjQ3di0uODdsMi4yOS0uODNoLjA1djUuMjd6bTUuMiAwSDguMTV2LS42OWwxLjctMS44M2E2LjM4IDYuMzggMCAwIDAgLjM0LS40Yy4wOS0uMTEuMTYtLjIyLjIyLS4zMnMuMS0uMTkuMTItLjI3YS45LjkgMCAwIDAgMC0uNTYuNjMuNjMgMCAwIDAtLjE1LS4yMy41OC41OCAwIDAgMC0uMjItLjE1Ljc1Ljc1IDAgMCAwLS4yOS0uMDVjLS4yNyAwLS40OC4wOC0uNjIuMjNhLjk1Ljk1IDAgMCAwLS4yLjY1SDguMDNjMC0uMjQuMDQtLjQ2LjEzLS42N2ExLjY3IDEuNjcgMCAwIDEgLjk3LS45MWMuMjMtLjEuNDktLjE0Ljc3LS4xNC4yNiAwIC41LjA0LjcuMTEuMjEuMDguMzguMTguNTIuMzIuMTQuMTMuMjUuMy4zMi40OGExLjc0IDEuNzQgMCAwIDEgLjAzIDEuMTMgMi4wNSAyLjA1IDAgMCAxLS4yNC40NyA0LjE2IDQuMTYgMCAwIDEtLjM1LjQ3bC0uNDcuNS0xIDEuMDVoMi4zMnYuOHptMS44LTMuMDhoLjU1Yy4yOCAwIC40OC0uMDYuNjEtLjJhLjc2Ljc2IDAgMCAwIC4yLS41NS44LjggMCAwIDAtLjA1LS4yOC41Ni41NiAwIDAgMC0uMTMtLjIyLjYuNiAwIDAgMC0uMjMtLjE1LjkzLjkzIDAgMCAwLS4zMi0uMDUuOTIuOTIgMCAwIDAtLjI5LjA1LjcyLjcyIDAgMCAwLS4yMy4xMi41Ny41NyAwIDAgMC0uMjEuNDZIMTIuNGExLjMgMS4zIDAgMCAxIC41LTEuMDRjLjE1LS4xMy4zMy0uMjMuNTQtLjNhMi40OCAyLjQ4IDAgMCAxIDEuNCAwYy4yLjA2LjQuMTUuNTUuMjguMTUuMTMuMjcuMjguMzYuNDcuMDguMTkuMTMuNC4xMy42NWExLjE1IDEuMTUgMCAwIDEtLjIuNjUgMS4zNiAxLjM2IDAgMCAxLS41OC40OWMuMTUuMDUuMjguMTIuMzguMmExLjE0IDEuMTQgMCAwIDEgLjQzLjYyYy4wMy4xMy4wNS4yNi4wNS40IDAgLjI1LS4wNS40Ny0uMTQuNjZhMS40MiAxLjQyIDAgMCAxLS40LjQ5Yy0uMTYuMTMtLjM1LjIzLS41OC4zYTIuNTEgMi41MSAwIDAgMS0uNzMuMWMtLjIyIDAtLjQ0LS4wMy0uNjUtLjA5YTEuOCAxLjggMCAwIDEtLjU3LS4yOCAxLjQzIDEuNDMgMCAwIDEtLjQtLjQ3IDEuNDEgMS40MSAwIDAgMS0uMTUtLjY2aDFhLjY2LjY2IDAgMCAwIC4yMi41Ljg3Ljg3IDAgMCAwIC41OC4yYy4yNSAwIC40NS0uMDcuNi0uMmEuNzEuNzEgMCAwIDAgLjIxLS41Ni45Ny45NyAwIDAgMC0uMDYtLjM2LjYxLjYxIDAgMCAwLS4xOC0uMjUuNzQuNzQgMCAwIDAtLjI4LS4xNSAxLjMzIDEuMzMgMCAwIDAtLjM3LS4wNGgtLjU1VjkuN3pcIiBmaWxsPVwiJHtmZ31cIi8+XG4gIDwvc3ZnPmA7XG59O1xuY29uc3QgaGVhZGVyU3RyaW5nID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmcgPSBwcm9wcy5mZ0NvbG9yO1xuICAgIGNvbnN0IGJnID0gcHJvcHMuYmdDb2xvcjtcbiAgICByZXR1cm4gYCR7aWNvbkhlYWR9XG4gIDxwYXRoIGQ9XCJNMTYuMjIyIDJIMy43NzhDMi44IDIgMiAyLjggMiAzLjc3OHYxMi40NDRDMiAxNy4yIDIuOCAxOCAzLjc3OCAxOGgxMi40NDRjLjk3OCAwIDEuNzctLjggMS43Ny0xLjc3OEwxOCAzLjc3OEMxOCAyLjggMTcuMiAyIDE2LjIyMiAyelwiIGZpbGw9XCIke2JnfVwiLz5cbiAgPHBhdGggZD1cIk04LjE4MiAxMi40aDMuNjM2bC42NTUgMS42SDE0bC0zLjQ1NC04SDkuNDU1TDYgMTRoMS41MjdsLjY1NS0xLjZ6TTEwIDcuNDRsMS4zNiAzLjY1MUg4LjY0TDEwIDcuNDQxelwiIGZpbGw9XCIke2ZnfVwiLz5cbjwvc3ZnPmA7XG59O1xuY29uc3QgaGVhZGVyQm9vbGVhbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGAke2ljb25IZWFkfVxuICAgIDxwYXRoXG4gICAgICAgIGQ9XCJNMTYuMjIyMiAySDMuNzc3NzhDMi44IDIgMiAyLjggMiAzLjc3Nzc4VjE2LjIyMjJDMiAxNy4yIDIuOCAxOCAzLjc3Nzc4IDE4SDE2LjIyMjJDMTcuMiAxOCAxNy45OTExIDE3LjIgMTcuOTkxMSAxNi4yMjIyTDE4IDMuNzc3NzhDMTggMi44IDE3LjIgMiAxNi4yMjIyIDJaXCJcbiAgICAgICAgZmlsbD1cIiR7Ymd9XCJcbiAgICAvPlxuICAgIDxwYXRoXG4gICAgICAgIGZpbGwtcnVsZT1cImV2ZW5vZGRcIlxuICAgICAgICBjbGlwLXJ1bGU9XCJldmVub2RkXCJcbiAgICAgICAgZD1cIk03LjY2NjY3IDYuNjY2NjlDNS43MzM2OCA2LjY2NjY5IDQuMTY2NjcgOC4xNTkwNyA0LjE2NjY3IDEwQzQuMTY2NjcgMTEuODQxIDUuNzMzNjggMTMuMzMzNCA3LjY2NjY3IDEzLjMzMzRIMTIuMzMzM0MxNC4yNjYzIDEzLjMzMzQgMTUuODMzMyAxMS44NDEgMTUuODMzMyAxMEMxNS44MzMzIDguMTU5MDcgMTQuMjY2MyA2LjY2NjY5IDEyLjMzMzMgNi42NjY2OUg3LjY2NjY3Wk0xMi41IDEyLjVDMTMuODgwNyAxMi41IDE1IDExLjM4MDcgMTUgMTBDMTUgOC42MTkzMSAxMy44ODA3IDcuNTAwMDIgMTIuNSA3LjUwMDAyQzExLjExOTMgNy41MDAwMiAxMCA4LjYxOTMxIDEwIDEwQzEwIDExLjM4MDcgMTEuMTE5MyAxMi41IDEyLjUgMTIuNVpcIlxuICAgICAgICBmaWxsPVwiJHtmZ31cIlxuICAgIC8+XG48L3N2Zz5gO1xufTtcbmNvbnN0IGhlYWRlclVyaSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGAke2ljb25IZWFkfVxuPHBhdGggZD1cIk0xNi4yMjIgMkgzLjc3OEMyLjggMiAyIDIuOCAyIDMuNzc4djEyLjQ0NEMyIDE3LjIgMi44IDE4IDMuNzc4IDE4aDEyLjQ0NGMuOTc4IDAgMS43Ny0uOCAxLjc3LTEuNzc4TDE4IDMuNzc4QzE4IDIuOCAxNy4yIDIgMTYuMjIyIDJ6XCIgZmlsbD1cIiR7Ymd9XCIvPlxuPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTEwLjI5IDQuOTQ3YTMuMzY4IDMuMzY4IDAgMDE0LjcyMy4wNCAzLjM3NSAzLjM3NSAwIDAxLjA0MSA0LjcyOWwtLjAwOS4wMDktMS41OTYgMS41OTdhMy4zNjcgMy4zNjcgMCAwMS01LjA4MS0uMzY0LjcxLjcxIDAgMDExLjEzNi0uODUgMS45NSAxLjk1IDAgMDAyLjk0Mi4yMWwxLjU5MS0xLjU5M2ExLjk1NCAxLjk1NCAwIDAwLS4wMjctMi43MzMgMS45NSAxLjk1IDAgMDAtMi43MzItLjAyN2wtLjkxLjkwN2EuNzA5LjcwOSAwIDExLTEuMDAxLTEuMDA3bC45MTUtLjkxMS4wMDctLjAwN3pcIiBmaWxsPVwiJHtmZ31cIi8+XG48cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNi41NSA4LjY3OGEzLjM2OCAzLjM2OCAwIDAxNS4wODIuMzY0LjcxLjcxIDAgMDEtMS4xMzYuODUgMS45NSAxLjk1IDAgMDAtMi45NDItLjIxbC0xLjU5MSAxLjU5M2ExLjk1NCAxLjk1NCAwIDAwLjAyNyAyLjczMyAxLjk1IDEuOTUgMCAwMDIuNzMuMDI4bC45MDYtLjkwNmEuNzA5LjcwOSAwIDExMS4wMDMgMS4wMDRsLS45MS45MS0uMDA4LjAxYTMuMzY4IDMuMzY4IDAgMDEtNC43MjQtLjA0MiAzLjM3NSAzLjM3NSAwIDAxLS4wNDEtNC43MjhsLjAwOS0uMDA5TDYuNTUgOC42Nzh6XCIgZmlsbD1cIiR7Zmd9XCIvPlxuPC9zdmc+XG4gIGA7XG59O1xuY29uc3QgcmVuYW1lSWNvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGJnID0gcHJvcHMuYmdDb2xvcjtcbiAgICByZXR1cm4gYCR7aWNvbkhlYWR9XG4gICAgPHBhdGggc3Ryb2tlPVwiJHtiZ31cIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMiAzdjE0XCIvPlxuICAgIDxwYXRoIHN0cm9rZT1cIiR7Ymd9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBkPVwiTTEwIDRoNG0tNCAxMmg0XCIvPlxuICAgIDxwYXRoIGQ9XCJNMTEgMTRoNGEzIDMgMCAwIDAgMy0zVjlhMyAzIDAgMCAwLTMtM2gtNHYyaDRhMSAxIDAgMCAxIDEgMXYyYTEgMSAwIDAgMS0xIDFoLTR2MlpNOS41IDhINWExIDEgMCAwIDAtMSAxdjJhMSAxIDAgMCAwIDEgMWg0LjV2Mkg1YTMgMyAwIDAgMS0zLTNWOWEzIDMgMCAwIDEgMy0zaDQuNXYyWlwiIGZpbGw9XCIke2JnfVwiLz5cbiAgPC9zdmc+XG5gO1xufTtcbmNvbnN0IGhlYWRlckF1ZGlvVXJpID0gaGVhZGVyVXJpO1xuY29uc3QgaGVhZGVyVmlkZW9VcmkgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBmZyA9IHByb3BzLmZnQ29sb3I7XG4gICAgY29uc3QgYmcgPSBwcm9wcy5iZ0NvbG9yO1xuICAgIHJldHVybiBgJHtpY29uSGVhZH1cbiAgPHBhdGggZD1cIk0xNi4yMjIgMkgzLjc3OEMyLjggMiAyIDIuOCAyIDMuNzc4djEyLjQ0NEMyIDE3LjIgMi44IDE4IDMuNzc4IDE4aDEyLjQ0NGMuOTc4IDAgMS43Ny0uOCAxLjc3LTEuNzc4TDE4IDMuNzc4QzE4IDIuOCAxNy4yIDIgMTYuMjIyIDJ6XCIgZmlsbD1cIiR7Ymd9XCIvPlxuICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNyAxMy4xMzhhLjUuNSAwIDAwLjc0OC40MzRsNS40OTItMy4xMzhhLjUuNSAwIDAwMC0uODY4TDcuNzQ4IDYuNDI3QS41LjUgMCAwMDcgNi44NjJ2Ni4yNzZ6XCIgZmlsbD1cIiR7Zmd9XCIvPlxuPC9zdmc+YDtcbn07XG5jb25zdCBoZWFkZXJFbW9qaSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGBcbiAgICAke2ljb25IZWFkfVxuICAgIDxwYXRoIGQ9XCJNMTAgNWE1IDUgMCAxIDAgMCAxMCA1IDUgMCAwIDAgMC0xMHptMCA5LjE3QTQuMTcgNC4xNyAwIDAgMSA1LjgzIDEwIDQuMTcgNC4xNyAwIDAgMSAxMCA1LjgzIDQuMTcgNC4xNyAwIDAgMSAxNC4xNyAxMCA0LjE3IDQuMTcgMCAwIDEgMTAgMTQuMTd6XCIgZmlsbD1cIiR7Zmd9XCIvPlxuICAgIDxwYXRoIGQ9XCJNOC4zMyA4LjIxYS44My44MyAwIDEgMC0uMDMgMS42Ny44My44MyAwIDAgMCAuMDMtMS42N3ptMy4zNCAwYS44My44MyAwIDEgMC0uMDQgMS42Ny44My44MyAwIDAgMCAuMDQtMS42N3pcIiBmaWxsPVwiJHtmZ31cIi8+XG4gICAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTE0LjUzIDEzLjlhMi44MiAyLjgyIDAgMCAxLTUuMDYgMGwuNzctLjM4YTEuOTcgMS45NyAwIDAgMCAzLjUyIDBsLjc3LjM5elwiIGZpbGw9XCIke2ZnfVwiLz5cbiAgICA8cGF0aCBkPVwiTTE2LjIyIDJIMy43OEMyLjggMiAyIDIuOCAyIDMuNzh2MTIuNDRDMiAxNy4yIDIuOCAxOCAzLjc4IDE4aDEyLjQ0Yy45OCAwIDEuNzctLjggMS43Ny0xLjc4TDE4IDMuNzhDMTggMi44IDE3LjIgMiAxNi4yMiAyelwiIGZpbGw9XCIke2JnfVwiLz5cbiAgICA8cGF0aCBkPVwiTTEwIDRhNiA2IDAgMSAwIDAgMTIgNiA2IDAgMCAwIDAtMTJ6bTAgMTFhNSA1IDAgMSAxIC4wMS0xMC4wMUE1IDUgMCAwIDEgMTAgMTV6XCIgZmlsbD1cIiR7Zmd9XCIvPlxuICAgIDxwYXRoIGQ9XCJNOCA3Ljg2YTEgMSAwIDEgMC0uMDQgMiAxIDEgMCAwIDAgLjA0LTJ6bTQgMGExIDEgMCAxIDAtLjA0IDIgMSAxIDAgMCAwIC4wNC0yelwiIGZpbGw9XCIke2ZnfVwiLz5cbiAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNMTIuNTMgMTEuOWEyLjgyIDIuODIgMCAwIDEtNS4wNiAwbC43Ny0uMzhhMS45NyAxLjk3IDAgMCAwIDMuNTIgMGwuNzcuMzl6XCIgZmlsbD1cIiR7Zmd9XCIvPlxuICA8L3N2Zz5gO1xufTtcbmNvbnN0IGhlYWRlckltYWdlID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmcgPSBwcm9wcy5mZ0NvbG9yO1xuICAgIGNvbnN0IGJnID0gcHJvcHMuYmdDb2xvcjtcbiAgICByZXR1cm4gYCR7aWNvbkhlYWR9XG4gIDxwYXRoIGQ9XCJNMTYuMjIyIDJIMy43NzhDMi44IDIgMiAyLjggMiAzLjc3OHYxMi40NDRDMiAxNy4yIDIuOCAxOCAzLjc3OCAxOGgxMi40NDRjLjk3OCAwIDEuNzctLjggMS43Ny0xLjc3OEwxOCAzLjc3OEMxOCAyLjggMTcuMiAyIDE2LjIyMiAyelwiIGZpbGw9XCIke2JnfVwiLz5cbiAgPHBhdGggb3BhY2l0eT1cIi41XCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTEyLjQ5OSAxMC44MDFhLjUuNSAwIDAxLjgzNSAwbDIuNjk4IDQuMDk4YS41LjUgMCAwMS0uNDE4Ljc3NUgxMC4yMmEuNS41IDAgMDEtLjQxNy0uNzc1bDIuNjk3LTQuMDk4elwiIGZpbGw9XCIke2ZnfVwiLz5cbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTguMDcgOC45MzRhLjUuNSAwIDAxLjgyNCAwbDQuMDggNS45NThhLjUuNSAwIDAxLS40MTIuNzgyaC04LjE2YS41LjUgMCAwMS0uNDEzLS43ODJsNC4wOC01Ljk1OHpNMTMuNzUgOC4zMzNhMi4wODMgMi4wODMgMCAxMDAtNC4xNjYgMi4wODMgMi4wODMgMCAwMDAgNC4xNjZ6XCIgZmlsbD1cIiR7Zmd9XCIvPlxuPC9zdmc+YDtcbn07XG5jb25zdCBoZWFkZXJQaG9uZSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGBcbiAgICAke2ljb25IZWFkfVxuICAgIDxwYXRoIGZpbGw9XCIke2ZnfVwiIGQ9XCJNMyAzaDE0djE0SDN6XCIvPlxuICAgIDxwYXRoIGQ9XCJNMTYuMjIgMkgzLjc4QzIuOCAyIDIgMi44IDIgMy43OHYxMi40NEMyIDE3LjIgMi44IDE4IDMuNzggMThoMTIuNDRjLjk4IDAgMS43Ny0uOCAxLjc3LTEuNzhMMTggMy43OEMxOCAyLjggMTcuMiAyIDE2LjIyIDJ6bS03LjI0IDkuNzhoMS4yM2MuMTUgMCAuMjcuMDYuMzYuMThsLjk4IDEuMjhhLjQzLjQzIDAgMCAxLS4wNS41OGwtMS4yIDEuMjFhLjQ1LjQ1IDAgMCAxLS42LjA0QTYuNzIgNi43MiAwIDAgMSA3LjMzIDEwYzAtLjYxLjEtMS4yLjI1LTEuNzhhNi42OCA2LjY4IDAgMCAxIDIuMTItMy4zLjQ0LjQ0IDAgMCAxIC42LjA0bDEuMiAxLjJjLjE2LjE3LjE4LjQyLjA1LjU5bC0uOTggMS4yOWEuNDMuNDMgMCAwIDEtLjM2LjE3SDguOThBNS4zOCA1LjM4IDAgMCAwIDguNjcgMTBjMCAuNjIuMTEgMS4yMy4zIDEuNzl6XCIgZmlsbD1cIiR7Ymd9XCIvPlxuICA8L3N2Zz5gO1xufTtcbmNvbnN0IGhlYWRlck1hcmtkb3duID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmcgPSBwcm9wcy5mZ0NvbG9yO1xuICAgIGNvbnN0IGJnID0gcHJvcHMuYmdDb2xvcjtcbiAgICByZXR1cm4gYFxuICAgICR7aWNvbkhlYWR9XG4gICAgPHBhdGggZD1cIk0xNi4yMiAySDMuNzhDMi44IDIgMiAyLjggMiAzLjc4djEyLjQ0QzIgMTcuMiAyLjggMTggMy43OCAxOGgxMi40NGMuOTggMCAxLjc3LS44IDEuNzctMS43OEwxOCAzLjc4QzE4IDIuOCAxNy4yIDIgMTYuMjIgMnpcIiBmaWxsPVwiJHtiZ31cIi8+XG4gICAgPHBhdGggZD1cIm0xMy40OSAxMy4xNS0yLjMyLTMuMjdoMS40VjdoMS44NnYyLjg4aDEuNGwtMi4zNCAzLjI3ek0xMSAxM0g5di0zbC0xLjUgMS45Mkw2IDEwdjNINFY3aDJsMS41IDJMOSA3aDJ2NnpcIiBmaWxsPVwiJHtmZ31cIi8+XG4gIDwvc3ZnPmA7XG59O1xuY29uc3QgaGVhZGVyRGF0ZSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGAke2ljb25IZWFkfVxuICA8cGF0aCBkPVwiTTE2LjIyMiAySDMuNzc4QzIuOCAyIDIgMi44IDIgMy43Nzh2MTIuNDQ0QzIgMTcuMiAyLjggMTggMy43NzggMThoMTIuNDQ0Yy45NzggMCAxLjc3LS44IDEuNzctMS43NzhMMTggMy43NzhDMTggMi44IDE3LjIgMiAxNi4yMjIgMnpcIiBmaWxsPVwiJHtiZ31cIi8+XG4gIDxwYXRoIGQ9XCJNMTQuOCA0LjE4MmgtLjZWM0gxM3YxLjE4Mkg3VjNINS44djEuMTgyaC0uNmMtLjY2IDAtMS4yLjUzMi0xLjIgMS4xODJ2OS40NTRDNCAxNS40NjggNC41NCAxNiA1LjIgMTZoOS42Yy42NiAwIDEuMi0uNTMyIDEuMi0xLjE4MlY1LjM2NGMwLS42NS0uNTQtMS4xODItMS4yLTEuMTgyem0wIDEwLjYzNkg1LjJWNy4xMzZoOS42djcuNjgyelwiIGZpbGw9XCIke2ZnfVwiLz5cbjwvc3ZnPmA7XG59O1xuY29uc3QgaGVhZGVyVGltZSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGBcbiAgICAke2ljb25IZWFkfVxuICAgIDxwYXRoIGQ9XCJNMTYuMjIgMkgzLjc4QzIuOCAyIDIgMi44IDIgMy43OHYxMi40NEMyIDE3LjIgMi44IDE4IDMuNzggMThoMTIuNDRjLjk4IDAgMS43Ny0uOCAxLjc3LTEuNzhMMTggMy43OEMxOCAyLjggMTcuMiAyIDE2LjIyIDJ6XCIgZmlsbD1cIiR7Ymd9XCIvPlxuICAgIDxwYXRoIGQ9XCJNMTAgNGE2IDYgMCAwIDAtNiA2IDYgNiAwIDAgMCA2IDYgNiA2IDAgMCAwIDYtNiA2IDYgMCAwIDAtNi02em0wIDEwLjhBNC44IDQuOCAwIDAgMSA1LjIgMTBhNC44IDQuOCAwIDEgMSA0LjggNC44elwiIGZpbGw9XCIke2ZnfVwiLz5cbiAgICA8cGF0aCBkPVwiTTEwIDdIOXYzLjkzTDEyLjUgMTNsLjUtLjgtMy0xLjc2Vjd6XCIgZmlsbD1cIiR7Zmd9XCIvPlxuICA8L3N2Zz5gO1xufTtcbmNvbnN0IGhlYWRlckVtYWlsID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmcgPSBwcm9wcy5mZ0NvbG9yO1xuICAgIGNvbnN0IGJnID0gcHJvcHMuYmdDb2xvcjtcbiAgICByZXR1cm4gYCR7aWNvbkhlYWR9XG4gIDxyZWN0IHg9XCIyXCIgeT1cIjJcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjJcIiBmaWxsPVwiJHtiZ31cIi8+XG4gIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0xMCA4LjY0M2ExLjM1NyAxLjM1NyAwIDEwMCAyLjcxNCAxLjM1NyAxLjM1NyAwIDAwMC0yLjcxNHpNNy4zNTcgMTBhMi42NDMgMi42NDMgMCAxMTUuMjg2IDAgMi42NDMgMi42NDMgMCAwMS01LjI4NiAwelwiIGZpbGw9XCIke2ZnfVwiLz5cbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTcuNTg5IDQuODk4QTUuNjQzIDUuNjQzIDAgMDExNS42NDMgMTB2LjVhMi4xNDMgMi4xNDMgMCAwMS00LjI4NiAwVjhhLjY0My42NDMgMCAwMTEuMjg2IDB2Mi41YS44NTcuODU3IDAgMDAxLjcxNCAwVjEwYTQuMzU3IDQuMzU3IDAgMTAtMS43MDggMy40Ni42NDMuNjQzIDAgMDEuNzgyIDEuMDIgNS42NDMgNS42NDMgMCAxMS01Ljg0Mi05LjU4MnpcIiBmaWxsPVwiJHtmZ31cIi8+XG48L3N2Zz5gO1xufTtcbmNvbnN0IGhlYWRlclJlZmVyZW5jZSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGBcbiAgICAke2ljb25IZWFkfVxuICAgIDxyZWN0IHg9XCIyXCIgeT1cIjhcIiB3aWR0aD1cIjEwXCIgaGVpZ2h0PVwiOFwiIHJ4PVwiMlwiIGZpbGw9XCIke2JnfVwiLz5cbiAgICA8cmVjdCB4PVwiOFwiIHk9XCI0XCIgd2lkdGg9XCIxMFwiIGhlaWdodD1cIjhcIiByeD1cIjJcIiBmaWxsPVwiJHtiZ31cIi8+XG4gICAgPHBhdGggZD1cIk0xMC42OCA3LjczVjZsMi45NyAzLjAyLTIuOTcgMy4wMnYtMS43N2MtMi4xMyAwLTMuNjIuNy00LjY4IDIuMi40My0yLjE1IDEuNy00LjMxIDQuNjgtNC43NHpcIiBmaWxsPVwiJHtmZ31cIi8+XG4gIDwvc3ZnPmA7XG59O1xuY29uc3QgaGVhZGVySWZUaGVuRWxzZSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGAke2ljb25IZWFkfVxuICA8cGF0aCBmaWxsPVwiJHtmZ31cIiBkPVwiTTQgM2gxMnYxNEg0elwiLz5cbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTMuNiAyQTEuNiAxLjYgMCAwMDIgMy42djEyLjhBMS42IDEuNiAwIDAwMy42IDE4aDEyLjhhMS42IDEuNiAwIDAwMS42LTEuNlYzLjZBMS42IDEuNiAwIDAwMTYuNCAySDMuNnptMTEuMyAxMC44YS43LjcgMCAwMS43Ljd2MS40YS43LjcgMCAwMS0uNy43aC0xLjRhLjcuNyAwIDAxLS43LS43di0xLjRhLjcuNyAwIDAxLjYtLjY5My4xMTcuMTE3IDAgMDAuMS0uMTE1VjEwLjM1YS4xMTcuMTE3IDAgMDAtLjExNy0uMTE2aC0yLjhhLjExNy4xMTcgMCAwMC0uMTE3LjExNnYyLjMzM2MwIC4wNjQuMDUzLjExNy4xMTcuMTE3aC4xMTdhLjcuNyAwIDAxLjcuN3YxLjRhLjcuNyAwIDAxLS43LjdIOS4zYS43LjcgMCAwMS0uNy0uN3YtMS40YS43LjcgMCAwMS43LS43aC4xMTdhLjExNy4xMTcgMCAwMC4xMTctLjExN1YxMC4zNWEuMTE3LjExNyAwIDAwLS4xMTctLjExN2gtMi44YS4xMTcuMTE3IDAgMDAtLjExNy4xMTd2Mi4zNDJjMCAuMDU4LjA0Mi4xMDYuMS4xMTVhLjcuNyAwIDAxLjYuNjkzdjEuNGEuNy43IDAgMDEtLjcuN0g1LjFhLjcuNyAwIDAxLS43LS43di0xLjRhLjcuNyAwIDAxLjctLjdoLjM1YS4xMTYuMTE2IDAgMDAuMTE2LS4xMTd2LTIuNDVjMC0uNTE1LjQxOC0uOTMzLjkzNC0uOTMzaDIuOTE3YS4xMTcuMTE3IDAgMDAuMTE3LS4xMTdWNi44NWEuMTE3LjExNyAwIDAwLS4xMTctLjExNmgtMi40NWEuNy43IDAgMDEtLjctLjdWNS4xYS43LjcgMCAwMS43LS43aDYuMDY3YS43LjcgMCAwMS43Ljd2LjkzNGEuNy43IDAgMDEtLjcuN2gtMi40NWEuMTE3LjExNyAwIDAwLS4xMTguMTE2djIuMzMzYzAgLjA2NC4wNTMuMTE3LjExNy4xMTdIMTMuNWMuNTE2IDAgLjkzNC40MTguOTM0LjkzNHYyLjQ1YzAgLjA2My4wNTIuMTE2LjExNi4xMTZoLjM1elwiIGZpbGw9XCIke2JnfVwiLz5cbjwvc3ZnPmA7XG59O1xuY29uc3QgaGVhZGVyU2luZ2xlVmFsdWUgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBmZyA9IHByb3BzLmZnQ29sb3I7XG4gICAgY29uc3QgYmcgPSBwcm9wcy5iZ0NvbG9yO1xuICAgIHJldHVybiBgXG4gICAgJHtpY29uSGVhZH1cbiAgICA8cmVjdCB4PVwiMlwiIHk9XCIyXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgcng9XCIyXCIgZmlsbD1cIiR7Ymd9XCIvPlxuICAgIDxwYXRoIGQ9XCJNOS45OCAxMy4zM2MuNDUgMCAuNzQtLjMuNzMtLjc1bC0uMDEtLjEtLjE2LTEuNjcgMS40NSAxLjA1YS44MS44MSAwIDAgMCAuNS4xOGMuMzcgMCAuNzItLjMyLjcyLS43NiAwLS4zLS4xNy0uNTQtLjQ5LS42OGwtMS42My0uNzcgMS42My0uNzdjLjMyLS4xNC40OS0uMzcuNDktLjY3IDAtLjQ1LS4zNC0uNzYtLjcxLS43NmEuODEuODEgMCAwIDAtLjUuMThsLTEuNDcgMS4wMy4xNi0xLjc0LjAxLS4wOGMuMDEtLjQ2LS4yNy0uNzYtLjcyLS43Ni0uNDYgMC0uNzYuMzItLjc1Ljc2bC4wMS4wOC4xNiAxLjc0LTEuNDctMS4wM2EuNzcuNzcgMCAwIDAtLjUtLjE4Ljc0Ljc0IDAgMCAwLS43Mi43NmMwIC4zLjE3LjUzLjQ5LjY3bDEuNjMuNzctMS42Mi43N2MtLjMyLjE0LS41LjM3LS41LjY4IDAgLjQ0LjM1Ljc1LjcyLjc1YS43OC43OCAwIDAgMCAuNS0uMTdMOS40IDEwLjhsLS4xNiAxLjY4di4wOWMtLjAyLjQ0LjI4Ljc1Ljc0Ljc1elwiIGZpbGw9XCIke2ZnfVwiLz5cbiAgPC9zdmc+YDtcbn07XG5jb25zdCBoZWFkZXJMb29rdXAgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBmZyA9IHByb3BzLmZnQ29sb3I7XG4gICAgY29uc3QgYmcgPSBwcm9wcy5iZ0NvbG9yO1xuICAgIHJldHVybiBgXG4gICAgJHtpY29uSGVhZH1cbiAgICA8cmVjdCB4PVwiMlwiIHk9XCIyXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgcng9XCIyXCIgZmlsbD1cIiR7Ymd9XCIvPlxuICAgIDxwYXRoIGQ9XCJNOCA1LjgzSDUuODNhLjgzLjgzIDAgMCAwIDAgMS42N2gxLjY5QTQuNTUgNC41NSAwIDAgMSA4IDUuODN6bS0uMzMgMy4zNEg1LjgzYS44My44MyAwIDAgMCAwIDEuNjZoMi43MmE0LjU3IDQuNTcgMCAwIDEtLjg4LTEuNjZ6TTUuODMgMTIuNWEuODMuODMgMCAwIDAgMCAxLjY3aDcuNWEuODMuODMgMCAxIDAgMC0xLjY3aC03LjV6bTguOC0yLjlhMy4wMiAzLjAyIDAgMCAwIC40Ni0xLjZjMC0xLjY2LTEuMzItMy0yLjk0LTNDMTAuNTIgNSA5LjIgNi4zNCA5LjIgOHMxLjMxIDMgMi45MyAzYy41OCAwIDEuMTEtLjE3IDEuNTYtLjQ3bDIuMDQgMi4wOC45My0uOTQtMi4wNC0yLjA4em0tMi40OC4wN2MtLjkgMC0xLjYzLS43NS0xLjYzLTEuNjdzLjczLTEuNjcgMS42My0xLjY3Yy45IDAgMS42My43NSAxLjYzIDEuNjdzLS43MyAxLjY3LTEuNjMgMS42N3pcIiBmaWxsPVwiJHtmZ31cIi8+XG4gIDwvc3ZnPmA7XG59O1xuY29uc3QgaGVhZGVyVGV4dFRlbXBsYXRlID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmcgPSBwcm9wcy5mZ0NvbG9yO1xuICAgIGNvbnN0IGJnID0gcHJvcHMuYmdDb2xvcjtcbiAgICByZXR1cm4gYCR7aWNvbkhlYWR9XG4gIDxyZWN0IHg9XCIyXCIgeT1cIjJcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjJcIiBmaWxsPVwiJHtiZ31cIi8+XG4gIDxwYXRoIGQ9XCJNNy42NzYgNC43MjZWM2wyLjk3NiAzLjAyMS0yLjk3NiAzLjAyMnYtMS43N2MtMi4xMjUgMC0zLjYxMy42OS00LjY3NiAyLjIwMS40MjUtMi4xNTggMS43LTQuMzE2IDQuNjc2LTQuNzQ4ek0xMC4xODIgMTQuNGgzLjYzNmwuNjU1IDEuNkgxNmwtMy40NTQtOGgtMS4wOTFMOCAxNmgxLjUyN2wuNjU1LTEuNnpNMTIgOS40NGwxLjM2IDMuNjVoLTIuNzJMMTIgOS40NHpcIiBmaWxsPVwiJHtmZ31cIi8+XG48L3N2Zz5gO1xufTtcbmNvbnN0IGhlYWRlck1hdGggPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBmZyA9IHByb3BzLmZnQ29sb3I7XG4gICAgY29uc3QgYmcgPSBwcm9wcy5iZ0NvbG9yO1xuICAgIHJldHVybiBgJHtpY29uSGVhZH1cbiAgPHJlY3QgeD1cIjJcIiB5PVwiMlwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiMlwiIGZpbGw9XCIke2JnfVwiLz5cbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTQuMTY3IDUuNDE3YS44MzMuODMzIDAgMTAwIDEuNjY2aDQuMTY2YS44MzMuODMzIDAgMTAwLTEuNjY2SDQuMTY3elwiIGZpbGw9XCIke2ZnfVwiLz5cbiAgPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTcuMDgzIDQuMTY3YS44MzMuODMzIDAgMTAtMS42NjYgMHY0LjE2NmEuODMzLjgzMyAwIDEwMS42NjYgMFY0LjE2N3pNMTEuNjY3IDUuNDE3YS44MzMuODMzIDAgMTAwIDEuNjY2aDQuMTY2YS44MzMuODMzIDAgMTAwLTEuNjY2aC00LjE2NnpNNS4zNjcgMTEuNjg4YS44MzMuODMzIDAgMDAtMS4xNzkgMS4xNzlsMi45NDcgMi45NDZhLjgzMy44MzMgMCAwMDEuMTc4LTEuMTc4bC0yLjk0Ni0yLjk0N3pcIiBmaWxsPVwiJHtmZ31cIi8+XG4gIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgZD1cIk04LjMxMyAxMi44NjdhLjgzMy44MzMgMCAxMC0xLjE3OC0xLjE3OWwtMi45NDcgMi45NDdhLjgzMy44MzMgMCAxMDEuMTc5IDEuMTc4bDIuOTQ2LTIuOTQ2elwiIGZpbGw9XCIke2ZnfVwiLz5cbiAgPHBhdGggZD1cIk0xMC44MzMgMTIuNWMwLS40Ni4zNzMtLjgzMy44MzQtLjgzM2g0LjE2NmEuODMzLjgzMyAwIDExMCAxLjY2NmgtNC4xNjZhLjgzMy44MzMgMCAwMS0uODM0LS44MzN6TTEwLjgzMyAxNWMwLS40Ni4zNzMtLjgzMy44MzQtLjgzM2g0LjE2NmEuODMzLjgzMyAwIDExMCAxLjY2NmgtNC4xNjZhLjgzMy44MzMgMCAwMS0uODM0LS44MzN6XCIgZmlsbD1cIiR7Zmd9XCIvPlxuPC9zdmc+YDtcbn07XG5jb25zdCBoZWFkZXJSb2xsdXAgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCBmZyA9IHByb3BzLmZnQ29sb3I7XG4gICAgY29uc3QgYmcgPSBwcm9wcy5iZ0NvbG9yO1xuICAgIHJldHVybiBgXG4gICAgJHtpY29uSGVhZH1cbiAgICA8cGF0aCBkPVwiTTE2LjIyIDJIMy43OEMyLjggMiAyIDIuOCAyIDMuNzh2MTIuNDRDMiAxNy4yIDIuOCAxOCAzLjc4IDE4aDEyLjQ0Yy45OCAwIDEuNzctLjggMS43Ny0xLjc4TDE4IDMuNzhDMTggMi44IDE3LjIgMiAxNi4yMiAyelwiIGZpbGw9XCIke2JnfVwiLz5cbiAgICA8cGF0aCBkPVwiTTEwIDguODRhMS4xNiAxLjE2IDAgMSAwIDAgMi4zMiAxLjE2IDEuMTYgMCAwIDAgMC0yLjMyem0zLjAyIDMuNjFhMy45MiAzLjkyIDAgMCAwIC43OC0zLjI4LjQ5LjQ5IDAgMSAwLS45NS4yYy4xOS44Ny0uMDIgMS43OC0uNTggMi40N2EyLjkyIDIuOTIgMCAxIDEtNC4xMy00LjA4IDIuOTQgMi45NCAwIDAgMSAyLjQzLS42Mi40OS40OSAwIDEgMCAuMTctLjk2IDMuODkgMy44OSAwIDEgMCAyLjI4IDYuMjd6TTEwIDQuMTdhNS44NCA1Ljg0IDAgMCAwLTUuNDQgNy45My40OS40OSAwIDEgMCAuOS0uMzUgNC44NiA0Ljg2IDAgMSAxIDIuNSAyLjY3LjQ5LjQ5IDAgMSAwLS40Ljg4Yy43Ni4zNSAxLjYuNTQgMi40NC41M2E1LjgzIDUuODMgMCAwIDAgMC0xMS42NnptMy4wMiAzLjVhLjcuNyAwIDEgMC0xLjQgMCAuNy43IDAgMCAwIDEuNCAwem0tNi45NyA1LjM1YS43LjcgMCAxIDEgMCAxLjQuNy43IDAgMCAxIDAtMS40elwiIGZpbGw9XCIke2ZnfVwiLz5cbiAgPC9zdmc+YDtcbn07XG5jb25zdCBoZWFkZXJKb2luU3RyaW5ncyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGAke2ljb25IZWFkfVxuICA8cmVjdCB4PVwiMlwiIHk9XCIyXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgcng9XCIyXCIgZmlsbD1cIiR7Ymd9XCIvPlxuICA8cGF0aCBkPVwiTTEyLjQgMTMuNTY1YzEuODY1LS41NDUgMy42NDUtMi4wODMgMy42NDUtNC4zOTYgMC0xLjUxNC0uNzg3LTIuNjA0LTIuMDcxLTIuNjA0QzEyLjY5IDYuNTY1IDEyIDcuNjMgMTIgOC45MzljMS4xMTQuMDcyIDEuODY1LjcyNiAxLjg2NSAxLjY4MyAwIC45MzMtLjggMS42NDctMS44NCAyLjAyM2wuMzc1Ljkyek00IDVoNnYySDR6TTQgOWg1djJINHpNNCAxM2g0djJINHpcIiBmaWxsPVwiJHtmZ31cIi8+XG48L3N2Zz5gO1xufTtcbmNvbnN0IGhlYWRlclNwbGl0U3RyaW5nID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmcgPSBwcm9wcy5mZ0NvbG9yO1xuICAgIGNvbnN0IGJnID0gcHJvcHMuYmdDb2xvcjtcbiAgICByZXR1cm4gYFxuICAgICR7aWNvbkhlYWR9XG4gICAgPHJlY3QgeD1cIjJcIiB5PVwiMlwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHJ4PVwiMlwiIGZpbGw9XCIke2JnfVwiLz5cbiAgICA8cGF0aCBkPVwiTTEyLjQgMTMuNTZjMS44Ni0uNTQgMy42NS0yLjA4IDMuNjUtNC40IDAtMS41LS44LTIuNi0yLjA4LTIuNlMxMiA3LjY0IDEyIDguOTVjMS4xMS4wNyAxLjg2LjczIDEuODYgMS42OCAwIC45NC0uOCAxLjY1LTEuODMgMi4wM2wuMzcuOTF6TTQgNWg2djJINHptMCA0aDV2Mkg0em0wIDRoNHYySDR6XCIgZmlsbD1cIiR7Zmd9XCIvPlxuICA8L3N2Zz5gO1xufTtcbmNvbnN0IGhlYWRlckdlb0Rpc3RhbmNlID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmcgPSBwcm9wcy5mZ0NvbG9yO1xuICAgIGNvbnN0IGJnID0gcHJvcHMuYmdDb2xvcjtcbiAgICByZXR1cm4gYCR7aWNvbkhlYWR9XG4gIDxwYXRoIGQ9XCJNMTYuMjIyIDJIMy43NzhDMi44IDIgMiAyLjggMiAzLjc3OHYxMi40NDRDMiAxNy4yIDIuOCAxOCAzLjc3OCAxOGgxMi40NDRjLjk3OCAwIDEuNzctLjggMS43Ny0xLjc3OEwxOCAzLjc3OEMxOCAyLjggMTcuMiAyIDE2LjIyMiAyelwiIGZpbGw9XCIke2JnfVwiLz5cbiAgPHBhdGggZD1cIk0xMCA3YTEgMSAwIDEwMC0ydjJ6bTAgNmExIDEgMCAxMDAgMnYtMnptMC04SDd2MmgzVjV6bS0zIDZoNVY5SDd2MnptNSAyaC0ydjJoMnYtMnptMS0xYTEgMSAwIDAxLTEgMXYyYTMgMyAwIDAwMy0zaC0yem0tMS0xYTEgMSAwIDAxMSAxaDJhMyAzIDAgMDAtMy0zdjJ6TTQgOGEzIDMgMCAwMDMgM1Y5YTEgMSAwIDAxLTEtMUg0em0zLTNhMyAzIDAgMDAtMyAzaDJhMSAxIDAgMDExLTFWNXpcIiBmaWxsPVwiJHtmZ31cIi8+XG4gIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgZD1cIk00Ljg1NiAxMi4wMTRhLjUuNSAwIDAwLS43MTIuNzAyTDUuNDA5IDE0bC0xLjI2NSAxLjI4NGEuNS41IDAgMDAuNzEyLjcwMmwxLjI1NS0xLjI3NCAxLjI1NSAxLjI3NGEuNS41IDAgMDAuNzEyLS43MDJMNi44MTMgMTRsMS4yNjUtMS4yODRhLjUuNSAwIDAwLS43MTItLjcwMkw2LjExIDEzLjI4OGwtMS4yNTUtMS4yNzR6TTEyLjg1NiA0LjAxNGEuNS41IDAgMDAtLjcxMi43MDJMMTMuNDA5IDZsLTEuMjY1IDEuMjg0YS41LjUgMCAxMC43MTIuNzAybDEuMjU1LTEuMjc0IDEuMjU1IDEuMjc0YS41LjUgMCAxMC43MTItLjcwMkwxNC44MTMgNmwxLjI2NS0xLjI4NGEuNS41IDAgMDAtLjcxMi0uNzAyTDE0LjExIDUuMjg4bC0xLjI1NS0xLjI3NHpcIiBmaWxsPVwiJHtmZ31cIi8+XG48L3N2Zz5gO1xufTtcbmNvbnN0IGhlYWRlckFycmF5ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgZmcgPSBwcm9wcy5mZ0NvbG9yO1xuICAgIGNvbnN0IGJnID0gcHJvcHMuYmdDb2xvcjtcbiAgICByZXR1cm4gYCR7aWNvbkhlYWR9XG4gIDxyZWN0IHg9XCIyXCIgeT1cIjJcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiByeD1cIjJcIiBmaWxsPVwiJHtiZ31cIi8+XG4gIDxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBjbGlwLXJ1bGU9XCJldmVub2RkXCIgZD1cIk0xNC4yNSA3LjI1YS43NS43NSAwIDAwMC0xLjVoLTYuNWEuNzUuNzUgMCAxMDAgMS41aDYuNXpNMTUgMTBhLjc1Ljc1IDAgMDEtLjc1Ljc1aC02LjVhLjc1Ljc1IDAgMDEwLTEuNWg2LjVBLjc1Ljc1IDAgMDExNSAxMHptLS43NSA0LjI1YS43NS43NSAwIDAwMC0xLjVoLTYuNWEuNzUuNzUgMCAwMDAgMS41aDYuNXptLTguOTg3LTdhLjc1Ljc1IDAgMTAwLTEuNS43NS43NSAwIDAwMCAxLjV6bS43NSAyLjc1YS43NS43NSAwIDExLTEuNSAwIC43NS43NSAwIDAxMS41IDB6bS0uNzUgNC4yNWEuNzUuNzUgMCAxMDAtMS41Ljc1Ljc1IDAgMDAwIDEuNXpcIiBmaWxsPVwiJHtmZ31cIi8+XG48L3N2Zz5gO1xufTtcbmNvbnN0IHJvd093bmVyT3ZlcmxheSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGBcbiAgICA8c3ZnIHdpZHRoPVwiMThcIiBoZWlnaHQ9XCIxOFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgIDxwYXRoIGQ9XCJNMiAxNXYxaDE0di0yLjVjMC0uODctLjQ0LTEuNTUtLjk4LTIuMDRhNi4xOSA2LjE5IDAgMCAwLTEuOS0xLjE0IDEyLjEgMTIuMSAwIDAgMC0yLjQ4LS42N0E0IDQgMCAxIDAgNSA2YTQgNCAwIDAgMCAyLjM2IDMuNjVjLS44Mi4xMy0xLjcuMzYtMi40OC42Ny0uNjkuMjgtMS4zNy42NS0xLjkgMS4xM0EyLjggMi44IDAgMCAwIDIgMTMuNVYxNXpcIiBmaWxsPVwiJHtiZ31cIiBzdHJva2U9XCIke2ZnfVwiIHN0cm9rZS13aWR0aD1cIjJcIi8+XG4gIDwvc3ZnPmA7XG59O1xuY29uc3QgcHJvdGVjdGVkQ29sdW1uT3ZlcmxheSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGZnID0gcHJvcHMuZmdDb2xvcjtcbiAgICBjb25zdCBiZyA9IHByb3BzLmJnQ29sb3I7XG4gICAgcmV0dXJuIGBcbiAgICA8c3ZnIHdpZHRoPVwiMThcIiBoZWlnaHQ9XCIxOFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuICAgIDxwYXRoIGQ9XCJNMTIuNDMgNi4wNHYtLjE4YTMuODYgMy44NiAwIDAgMC03LjcyIDB2LjE4QTIuMTUgMi4xNSAwIDAgMCAzIDguMTR2NS43MkMzIDE1LjA0IDMuOTYgMTYgNS4xNCAxNkgxMmMxLjE4IDAgMi4xNC0uOTYgMi4xNC0yLjE0VjguMTRjMC0xLjAzLS43My0xLjktMS43MS0yLjF6TTcuODYgNnYtLjE0YS43MS43MSAwIDEgMSAxLjQzIDBWNkg3Ljg2elwiIGZpbGw9XCIke2JnfVwiIHN0cm9rZT1cIiR7Zmd9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz5cbiAgPC9zdmc+XG5gO1xufTtcbmV4cG9ydCBjb25zdCBzcHJpdGVzID0ge1xuICAgIGhlYWRlclJvd0lELFxuICAgIGhlYWRlck51bWJlcixcbiAgICBoZWFkZXJDb2RlLFxuICAgIGhlYWRlclN0cmluZyxcbiAgICBoZWFkZXJCb29sZWFuLFxuICAgIGhlYWRlckF1ZGlvVXJpLFxuICAgIGhlYWRlclZpZGVvVXJpLFxuICAgIGhlYWRlckVtb2ppLFxuICAgIGhlYWRlckltYWdlLFxuICAgIGhlYWRlclVyaSxcbiAgICBoZWFkZXJQaG9uZSxcbiAgICBoZWFkZXJNYXJrZG93bixcbiAgICBoZWFkZXJEYXRlLFxuICAgIGhlYWRlclRpbWUsXG4gICAgaGVhZGVyRW1haWwsXG4gICAgaGVhZGVyUmVmZXJlbmNlLFxuICAgIGhlYWRlcklmVGhlbkVsc2UsXG4gICAgaGVhZGVyU2luZ2xlVmFsdWUsXG4gICAgaGVhZGVyTG9va3VwLFxuICAgIGhlYWRlclRleHRUZW1wbGF0ZSxcbiAgICBoZWFkZXJNYXRoLFxuICAgIGhlYWRlclJvbGx1cCxcbiAgICBoZWFkZXJKb2luU3RyaW5ncyxcbiAgICBoZWFkZXJTcGxpdFN0cmluZyxcbiAgICBoZWFkZXJHZW9EaXN0YW5jZSxcbiAgICBoZWFkZXJBcnJheSxcbiAgICByb3dPd25lck92ZXJsYXksXG4gICAgcHJvdGVjdGVkQ29sdW1uT3ZlcmxheSxcbiAgICByZW5hbWVJY29uLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcml0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/sprites.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/use-animation-queue.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/use-animation-queue.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAnimationQueue: () => (/* binding */ useAnimationQueue)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _cell_set_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cell-set.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/cell-set.js\");\n/* harmony import */ var _common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/render-state-provider.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/render-state-provider.js\");\n\n\n\n\nfunction useAnimationQueue(draw) {\n    const queue = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const seq = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const drawRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(draw);\n    drawRef.current = draw;\n    const loop = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        const requeue = () => window.requestAnimationFrame(fn);\n        const fn = () => {\n            const toDraw = queue.current.map(_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_1__.unpackNumberToColRow);\n            queue.current = [];\n            drawRef.current(new _cell_set_js__WEBPACK_IMPORTED_MODULE_2__.CellSet(toDraw));\n            if (queue.current.length > 0) {\n                seq.current++;\n            }\n            else {\n                seq.current = 0;\n            }\n        };\n        window.requestAnimationFrame(seq.current > 600 ? requeue : fn);\n    }, []);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((item) => {\n        if (queue.current.length === 0)\n            loop();\n        const packed = (0,_common_render_state_provider_js__WEBPACK_IMPORTED_MODULE_1__.packColRowToNumber)(item[0], item[1]);\n        if (queue.current.includes(packed))\n            return;\n        queue.current.push(packed);\n    }, [loop]);\n}\n//# sourceMappingURL=use-animation-queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3VzZS1hbmltYXRpb24tcXVldWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQjtBQUNPO0FBQ0U7QUFDeUQ7QUFDMUY7QUFDUCxrQkFBa0IseUNBQVk7QUFDOUIsZ0JBQWdCLHlDQUFZO0FBQzVCLG9CQUFvQix5Q0FBWTtBQUNoQztBQUNBLGlCQUFpQiw4Q0FBaUI7QUFDbEM7QUFDQTtBQUNBLDZDQUE2QyxrRkFBb0I7QUFDakU7QUFDQSxnQ0FBZ0MsaURBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLDhDQUFpQjtBQUM1QjtBQUNBO0FBQ0EsdUJBQXVCLG9GQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL2RhdGEtZ3JpZC91c2UtYW5pbWF0aW9uLXF1ZXVlLmpzPzBjYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge30gZnJvbSBcIi4vZGF0YS1ncmlkLXR5cGVzLmpzXCI7XG5pbXBvcnQgeyBDZWxsU2V0IH0gZnJvbSBcIi4vY2VsbC1zZXQuanNcIjtcbmltcG9ydCB7IHBhY2tDb2xSb3dUb051bWJlciwgdW5wYWNrTnVtYmVyVG9Db2xSb3cgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3JlbmRlci1zdGF0ZS1wcm92aWRlci5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvblF1ZXVlKGRyYXcpIHtcbiAgICBjb25zdCBxdWV1ZSA9IFJlYWN0LnVzZVJlZihbXSk7XG4gICAgY29uc3Qgc2VxID0gUmVhY3QudXNlUmVmKDApO1xuICAgIGNvbnN0IGRyYXdSZWYgPSBSZWFjdC51c2VSZWYoZHJhdyk7XG4gICAgZHJhd1JlZi5jdXJyZW50ID0gZHJhdztcbiAgICBjb25zdCBsb29wID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXVlID0gKCkgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICAgIGNvbnN0IGZuID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9EcmF3ID0gcXVldWUuY3VycmVudC5tYXAodW5wYWNrTnVtYmVyVG9Db2xSb3cpO1xuICAgICAgICAgICAgcXVldWUuY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgZHJhd1JlZi5jdXJyZW50KG5ldyBDZWxsU2V0KHRvRHJhdykpO1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNlcS5jdXJyZW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXEuY3VycmVudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2VxLmN1cnJlbnQgPiA2MDAgPyByZXF1ZXVlIDogZm4pO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKHF1ZXVlLmN1cnJlbnQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICBjb25zdCBwYWNrZWQgPSBwYWNrQ29sUm93VG9OdW1iZXIoaXRlbVswXSwgaXRlbVsxXSk7XG4gICAgICAgIGlmIChxdWV1ZS5jdXJyZW50LmluY2x1ZGVzKHBhY2tlZCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHF1ZXVlLmN1cnJlbnQucHVzaChwYWNrZWQpO1xuICAgIH0sIFtsb29wXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtYW5pbWF0aW9uLXF1ZXVlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/use-animation-queue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/use-selection-behavior.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/use-selection-behavior.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSelectionBehavior: () => (/* binding */ useSelectionBehavior)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-grid-types.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/data-grid-types.js\");\n\n\nfunction useSelectionBehavior(gridSelection, setGridSelection, rangeBehavior, columnBehavior, rowBehavior, rangeSelect) {\n    // if append is true, the current range will be added to the rangeStack\n    const setCurrent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((value, expand, append, trigger) => {\n        if ((rangeSelect === \"cell\" || rangeSelect === \"multi-cell\") && value !== undefined) {\n            value = {\n                ...value,\n                range: {\n                    x: value.cell[0],\n                    y: value.cell[1],\n                    width: 1,\n                    height: 1,\n                },\n            };\n        }\n        const rangeMixable = rangeBehavior === \"mixed\" && (append || trigger === \"drag\");\n        const allowColumnCoSelect = columnBehavior === \"mixed\" && rangeMixable;\n        const allowRowCoSelect = rowBehavior === \"mixed\" && rangeMixable;\n        let newVal = {\n            current: value === undefined\n                ? undefined\n                : {\n                    ...value,\n                    rangeStack: trigger === \"drag\" ? gridSelection.current?.rangeStack ?? [] : [],\n                },\n            columns: allowColumnCoSelect ? gridSelection.columns : _data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.CompactSelection.empty(),\n            rows: allowRowCoSelect ? gridSelection.rows : _data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.CompactSelection.empty(),\n        };\n        const addLastRange = append && (rangeSelect === \"multi-rect\" || rangeSelect === \"multi-cell\");\n        if (addLastRange && newVal.current !== undefined && gridSelection.current !== undefined) {\n            newVal = {\n                ...newVal,\n                current: {\n                    ...newVal.current,\n                    rangeStack: [...gridSelection.current.rangeStack, gridSelection.current.range],\n                },\n            };\n        }\n        setGridSelection(newVal, expand);\n    }, [columnBehavior, gridSelection, rangeBehavior, rangeSelect, rowBehavior, setGridSelection]);\n    const setSelectedRows = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newRows, append, allowMixed) => {\n        newRows = newRows ?? gridSelection.rows;\n        if (append !== undefined) {\n            newRows = newRows.add(append);\n        }\n        let newVal;\n        if (rowBehavior === \"exclusive\" && newRows.length > 0) {\n            newVal = {\n                current: undefined,\n                columns: _data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.CompactSelection.empty(),\n                rows: newRows,\n            };\n        }\n        else {\n            const rangeMixed = allowMixed && rangeBehavior === \"mixed\";\n            const columnMixed = allowMixed && columnBehavior === \"mixed\";\n            const current = !rangeMixed ? undefined : gridSelection.current;\n            newVal = {\n                current,\n                columns: columnMixed ? gridSelection.columns : _data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.CompactSelection.empty(),\n                rows: newRows,\n            };\n        }\n        setGridSelection(newVal, false);\n    }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);\n    const setSelectedColumns = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newCols, append, allowMixed) => {\n        newCols = newCols ?? gridSelection.columns;\n        if (append !== undefined) {\n            newCols = newCols.add(append);\n        }\n        let newVal;\n        if (columnBehavior === \"exclusive\" && newCols.length > 0) {\n            newVal = {\n                current: undefined,\n                rows: _data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.CompactSelection.empty(),\n                columns: newCols,\n            };\n        }\n        else {\n            const rangeMixed = allowMixed && rangeBehavior === \"mixed\";\n            const rowMixed = allowMixed && rowBehavior === \"mixed\";\n            const current = !rangeMixed ? undefined : gridSelection.current;\n            newVal = {\n                current,\n                rows: rowMixed ? gridSelection.rows : _data_grid_types_js__WEBPACK_IMPORTED_MODULE_1__.CompactSelection.empty(),\n                columns: newCols,\n            };\n        }\n        setGridSelection(newVal, false);\n    }, [columnBehavior, gridSelection, rangeBehavior, rowBehavior, setGridSelection]);\n    return [setCurrent, setSelectedRows, setSelectedColumns];\n}\n//# sourceMappingURL=use-selection-behavior.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZGF0YS1ncmlkL3VzZS1zZWxlY3Rpb24tYmVoYXZpb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBCO0FBQzhCO0FBQ2pEO0FBQ1A7QUFDQSx1QkFBdUIsOENBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixtRUFBbUUsaUVBQWdCO0FBQ25GLDBEQUEwRCxpRUFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCLDhDQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlFQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsaUVBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQiw4Q0FBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpRUFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlFQUFnQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9kYXRhLWdyaWQvdXNlLXNlbGVjdGlvbi1iZWhhdmlvci5qcz8wNjQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IENvbXBhY3RTZWxlY3Rpb24gfSBmcm9tIFwiLi9kYXRhLWdyaWQtdHlwZXMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWxlY3Rpb25CZWhhdmlvcihncmlkU2VsZWN0aW9uLCBzZXRHcmlkU2VsZWN0aW9uLCByYW5nZUJlaGF2aW9yLCBjb2x1bW5CZWhhdmlvciwgcm93QmVoYXZpb3IsIHJhbmdlU2VsZWN0KSB7XG4gICAgLy8gaWYgYXBwZW5kIGlzIHRydWUsIHRoZSBjdXJyZW50IHJhbmdlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJhbmdlU3RhY2tcbiAgICBjb25zdCBzZXRDdXJyZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soKHZhbHVlLCBleHBhbmQsIGFwcGVuZCwgdHJpZ2dlcikgPT4ge1xuICAgICAgICBpZiAoKHJhbmdlU2VsZWN0ID09PSBcImNlbGxcIiB8fCByYW5nZVNlbGVjdCA9PT0gXCJtdWx0aS1jZWxsXCIpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHZhbHVlLmNlbGxbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IHZhbHVlLmNlbGxbMV0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2VNaXhhYmxlID0gcmFuZ2VCZWhhdmlvciA9PT0gXCJtaXhlZFwiICYmIChhcHBlbmQgfHwgdHJpZ2dlciA9PT0gXCJkcmFnXCIpO1xuICAgICAgICBjb25zdCBhbGxvd0NvbHVtbkNvU2VsZWN0ID0gY29sdW1uQmVoYXZpb3IgPT09IFwibWl4ZWRcIiAmJiByYW5nZU1peGFibGU7XG4gICAgICAgIGNvbnN0IGFsbG93Um93Q29TZWxlY3QgPSByb3dCZWhhdmlvciA9PT0gXCJtaXhlZFwiICYmIHJhbmdlTWl4YWJsZTtcbiAgICAgICAgbGV0IG5ld1ZhbCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnQ6IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VTdGFjazogdHJpZ2dlciA9PT0gXCJkcmFnXCIgPyBncmlkU2VsZWN0aW9uLmN1cnJlbnQ/LnJhbmdlU3RhY2sgPz8gW10gOiBbXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sdW1uczogYWxsb3dDb2x1bW5Db1NlbGVjdCA/IGdyaWRTZWxlY3Rpb24uY29sdW1ucyA6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICAgICAgICAgIHJvd3M6IGFsbG93Um93Q29TZWxlY3QgPyBncmlkU2VsZWN0aW9uLnJvd3MgOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZExhc3RSYW5nZSA9IGFwcGVuZCAmJiAocmFuZ2VTZWxlY3QgPT09IFwibXVsdGktcmVjdFwiIHx8IHJhbmdlU2VsZWN0ID09PSBcIm11bHRpLWNlbGxcIik7XG4gICAgICAgIGlmIChhZGRMYXN0UmFuZ2UgJiYgbmV3VmFsLmN1cnJlbnQgIT09IHVuZGVmaW5lZCAmJiBncmlkU2VsZWN0aW9uLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsID0ge1xuICAgICAgICAgICAgICAgIC4uLm5ld1ZhbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5ld1ZhbC5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICByYW5nZVN0YWNrOiBbLi4uZ3JpZFNlbGVjdGlvbi5jdXJyZW50LnJhbmdlU3RhY2ssIGdyaWRTZWxlY3Rpb24uY3VycmVudC5yYW5nZV0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2V0R3JpZFNlbGVjdGlvbihuZXdWYWwsIGV4cGFuZCk7XG4gICAgfSwgW2NvbHVtbkJlaGF2aW9yLCBncmlkU2VsZWN0aW9uLCByYW5nZUJlaGF2aW9yLCByYW5nZVNlbGVjdCwgcm93QmVoYXZpb3IsIHNldEdyaWRTZWxlY3Rpb25dKTtcbiAgICBjb25zdCBzZXRTZWxlY3RlZFJvd3MgPSBSZWFjdC51c2VDYWxsYmFjaygobmV3Um93cywgYXBwZW5kLCBhbGxvd01peGVkKSA9PiB7XG4gICAgICAgIG5ld1Jvd3MgPSBuZXdSb3dzID8/IGdyaWRTZWxlY3Rpb24ucm93cztcbiAgICAgICAgaWYgKGFwcGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdSb3dzID0gbmV3Um93cy5hZGQoYXBwZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3VmFsO1xuICAgICAgICBpZiAocm93QmVoYXZpb3IgPT09IFwiZXhjbHVzaXZlXCIgJiYgbmV3Um93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZXdWYWwgPSB7XG4gICAgICAgICAgICAgICAgY3VycmVudDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IENvbXBhY3RTZWxlY3Rpb24uZW1wdHkoKSxcbiAgICAgICAgICAgICAgICByb3dzOiBuZXdSb3dzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlTWl4ZWQgPSBhbGxvd01peGVkICYmIHJhbmdlQmVoYXZpb3IgPT09IFwibWl4ZWRcIjtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbk1peGVkID0gYWxsb3dNaXhlZCAmJiBjb2x1bW5CZWhhdmlvciA9PT0gXCJtaXhlZFwiO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9ICFyYW5nZU1peGVkID8gdW5kZWZpbmVkIDogZ3JpZFNlbGVjdGlvbi5jdXJyZW50O1xuICAgICAgICAgICAgbmV3VmFsID0ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgY29sdW1uczogY29sdW1uTWl4ZWQgPyBncmlkU2VsZWN0aW9uLmNvbHVtbnMgOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgICAgICAgICAgcm93czogbmV3Um93cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2V0R3JpZFNlbGVjdGlvbihuZXdWYWwsIGZhbHNlKTtcbiAgICB9LCBbY29sdW1uQmVoYXZpb3IsIGdyaWRTZWxlY3Rpb24sIHJhbmdlQmVoYXZpb3IsIHJvd0JlaGF2aW9yLCBzZXRHcmlkU2VsZWN0aW9uXSk7XG4gICAgY29uc3Qgc2V0U2VsZWN0ZWRDb2x1bW5zID0gUmVhY3QudXNlQ2FsbGJhY2soKG5ld0NvbHMsIGFwcGVuZCwgYWxsb3dNaXhlZCkgPT4ge1xuICAgICAgICBuZXdDb2xzID0gbmV3Q29scyA/PyBncmlkU2VsZWN0aW9uLmNvbHVtbnM7XG4gICAgICAgIGlmIChhcHBlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3Q29scyA9IG5ld0NvbHMuYWRkKGFwcGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1ZhbDtcbiAgICAgICAgaWYgKGNvbHVtbkJlaGF2aW9yID09PSBcImV4Y2x1c2l2ZVwiICYmIG5ld0NvbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV3VmFsID0ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByb3dzOiBDb21wYWN0U2VsZWN0aW9uLmVtcHR5KCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogbmV3Q29scyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZU1peGVkID0gYWxsb3dNaXhlZCAmJiByYW5nZUJlaGF2aW9yID09PSBcIm1peGVkXCI7XG4gICAgICAgICAgICBjb25zdCByb3dNaXhlZCA9IGFsbG93TWl4ZWQgJiYgcm93QmVoYXZpb3IgPT09IFwibWl4ZWRcIjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSAhcmFuZ2VNaXhlZCA/IHVuZGVmaW5lZCA6IGdyaWRTZWxlY3Rpb24uY3VycmVudDtcbiAgICAgICAgICAgIG5ld1ZhbCA9IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJvd3M6IHJvd01peGVkID8gZ3JpZFNlbGVjdGlvbi5yb3dzIDogQ29tcGFjdFNlbGVjdGlvbi5lbXB0eSgpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IG5ld0NvbHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNldEdyaWRTZWxlY3Rpb24obmV3VmFsLCBmYWxzZSk7XG4gICAgfSwgW2NvbHVtbkJlaGF2aW9yLCBncmlkU2VsZWN0aW9uLCByYW5nZUJlaGF2aW9yLCByb3dCZWhhdmlvciwgc2V0R3JpZFNlbGVjdGlvbl0pO1xuICAgIHJldHVybiBbc2V0Q3VycmVudCwgc2V0U2VsZWN0ZWRSb3dzLCBzZXRTZWxlY3RlZENvbHVtbnNdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLXNlbGVjdGlvbi1iZWhhdmlvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid/use-selection-behavior.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry-style.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry-style.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GrowingEntryStyle: () => (/* binding */ GrowingEntryStyle),\n/* harmony export */   InputBox: () => (/* binding */ InputBox),\n/* harmony export */   ShadowBox: () => (/* binding */ ShadowBox)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\nconst InputBox = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('textarea')({\n  name: \"InputBox\",\n  class: \"gdg-izpuzkl\",\n  propsAsIs: false\n});\nconst ShadowBox = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"ShadowBox\",\n  class: \"gdg-s69h75o\",\n  propsAsIs: false\n});\nconst GrowingEntryStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"GrowingEntryStyle\",\n  class: \"gdg-g1y0xocz\",\n  propsAsIs: false\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZ3Jvd2luZy1lbnRyeS9ncm93aW5nLWVudHJ5LXN0eWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0M7QUFDakMsOEJBQThCLHNEQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSwrQkFBK0Isc0RBQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNLHVDQUF1QyxzREFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZ3Jvd2luZy1lbnRyeS9ncm93aW5nLWVudHJ5LXN0eWxlLmpzPzI5MTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgSW5wdXRCb3ggPSAvKiNfX1BVUkVfXyovc3R5bGVkKCd0ZXh0YXJlYScpKHtcbiAgbmFtZTogXCJJbnB1dEJveFwiLFxuICBjbGFzczogXCJnZGctaXpwdXprbFwiLFxuICBwcm9wc0FzSXM6IGZhbHNlXG59KTtcbmV4cG9ydCBjb25zdCBTaGFkb3dCb3ggPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnKSh7XG4gIG5hbWU6IFwiU2hhZG93Qm94XCIsXG4gIGNsYXNzOiBcImdkZy1zNjloNzVvXCIsXG4gIHByb3BzQXNJczogZmFsc2Vcbn0pO1xuZXhwb3J0IGNvbnN0IEdyb3dpbmdFbnRyeVN0eWxlID0gLyojX19QVVJFX18qL3N0eWxlZCgnZGl2Jykoe1xuICBuYW1lOiBcIkdyb3dpbmdFbnRyeVN0eWxlXCIsXG4gIGNsYXNzOiBcImdkZy1nMXkweG9jelwiLFxuICBwcm9wc0FzSXM6IGZhbHNlXG59KTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry-style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GrowingEntry: () => (/* binding */ GrowingEntry)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _growing_entry_style_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./growing-entry-style.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry-style.js\");\n/* harmony import */ var _common_support_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/support.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/support.js\");\n\n\n\nlet globalInputID = 0;\n/** @category Renderers */\nconst GrowingEntry = (props) => {\n    const { placeholder, value, onKeyDown, highlight, altNewline, validatedSelection, ...rest } = props;\n    const { onChange, className } = rest;\n    const inputRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const useText = value ?? \"\";\n    (0,_common_support_js__WEBPACK_IMPORTED_MODULE_1__.assert)(onChange !== undefined, \"GrowingEntry must be a controlled input area\");\n    // 10 million id's aught to be enough for anybody\n    const [inputID] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => \"input-box-\" + (globalInputID = (globalInputID + 1) % 10000000));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        const ta = inputRef.current;\n        if (ta === null)\n            return;\n        if (ta.disabled)\n            return;\n        const length = useText.toString().length;\n        ta.focus();\n        ta.setSelectionRange(highlight ? 0 : length, length);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (validatedSelection !== undefined) {\n            const range = typeof validatedSelection === \"number\" ? [validatedSelection, null] : validatedSelection;\n            inputRef.current?.setSelectionRange(range[0], range[1]);\n        }\n    }, [validatedSelection]);\n    const onKeyDownInner = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(e => {\n        if (e.key === \"Enter\" && e.shiftKey && altNewline === true) {\n            return;\n        }\n        onKeyDown?.(e);\n    }, [altNewline, onKeyDown]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_growing_entry_style_js__WEBPACK_IMPORTED_MODULE_2__.GrowingEntryStyle, { className: \"gdg-growing-entry\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_growing_entry_style_js__WEBPACK_IMPORTED_MODULE_2__.ShadowBox, { className: className }, useText + \"\\n\"),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_growing_entry_style_js__WEBPACK_IMPORTED_MODULE_2__.InputBox, { ...rest, className: (className ?? \"\") + \" gdg-input\", id: inputID, ref: inputRef, onKeyDown: onKeyDownInner, value: useText, placeholder: placeholder, dir: \"auto\" })));\n};\n//# sourceMappingURL=growing-entry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvZ3Jvd2luZy1lbnRyeS9ncm93aW5nLWVudHJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDbUQ7QUFDakM7QUFDakQ7QUFDQTtBQUNPO0FBQ1AsWUFBWSxvRkFBb0Y7QUFDaEcsWUFBWSxzQkFBc0I7QUFDbEMscUJBQXFCLHlDQUFZO0FBQ2pDO0FBQ0EsSUFBSSwwREFBTTtBQUNWO0FBQ0Esc0JBQXNCLDJDQUFjO0FBQ3BDLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksa0RBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQiw4Q0FBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnREFBbUIsQ0FBQyxzRUFBaUIsSUFBSSxnQ0FBZ0M7QUFDckYsUUFBUSxnREFBbUIsQ0FBQyw4REFBUyxJQUFJLHNCQUFzQjtBQUMvRCxRQUFRLGdEQUFtQixDQUFDLDZEQUFRLElBQUksb0tBQW9LO0FBQzVNO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9ncm93aW5nLWVudHJ5L2dyb3dpbmctZW50cnkuanM/NWUzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEdyb3dpbmdFbnRyeVN0eWxlLCBTaGFkb3dCb3gsIElucHV0Qm94IH0gZnJvbSBcIi4vZ3Jvd2luZy1lbnRyeS1zdHlsZS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9zdXBwb3J0LmpzXCI7XG5sZXQgZ2xvYmFsSW5wdXRJRCA9IDA7XG4vKiogQGNhdGVnb3J5IFJlbmRlcmVycyAqL1xuZXhwb3J0IGNvbnN0IEdyb3dpbmdFbnRyeSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgcGxhY2Vob2xkZXIsIHZhbHVlLCBvbktleURvd24sIGhpZ2hsaWdodCwgYWx0TmV3bGluZSwgdmFsaWRhdGVkU2VsZWN0aW9uLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBjbGFzc05hbWUgfSA9IHJlc3Q7XG4gICAgY29uc3QgaW5wdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdXNlVGV4dCA9IHZhbHVlID8/IFwiXCI7XG4gICAgYXNzZXJ0KG9uQ2hhbmdlICE9PSB1bmRlZmluZWQsIFwiR3Jvd2luZ0VudHJ5IG11c3QgYmUgYSBjb250cm9sbGVkIGlucHV0IGFyZWFcIik7XG4gICAgLy8gMTAgbWlsbGlvbiBpZCdzIGF1Z2h0IHRvIGJlIGVub3VnaCBmb3IgYW55Ym9keVxuICAgIGNvbnN0IFtpbnB1dElEXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IFwiaW5wdXQtYm94LVwiICsgKGdsb2JhbElucHV0SUQgPSAoZ2xvYmFsSW5wdXRJRCArIDEpICUgMTAwMDAwMDApKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB0YSA9IGlucHV0UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICh0YSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRhLmRpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB1c2VUZXh0LnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICB0YS5mb2N1cygpO1xuICAgICAgICB0YS5zZXRTZWxlY3Rpb25SYW5nZShoaWdobGlnaHQgPyAwIDogbGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh2YWxpZGF0ZWRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgdmFsaWRhdGVkU2VsZWN0aW9uID09PSBcIm51bWJlclwiID8gW3ZhbGlkYXRlZFNlbGVjdGlvbiwgbnVsbF0gOiB2YWxpZGF0ZWRTZWxlY3Rpb247XG4gICAgICAgICAgICBpbnB1dFJlZi5jdXJyZW50Py5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgICAgICB9XG4gICAgfSwgW3ZhbGlkYXRlZFNlbGVjdGlvbl0pO1xuICAgIGNvbnN0IG9uS2V5RG93bklubmVyID0gUmVhY3QudXNlQ2FsbGJhY2soZSA9PiB7XG4gICAgICAgIGlmIChlLmtleSA9PT0gXCJFbnRlclwiICYmIGUuc2hpZnRLZXkgJiYgYWx0TmV3bGluZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uS2V5RG93bj8uKGUpO1xuICAgIH0sIFthbHROZXdsaW5lLCBvbktleURvd25dKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3Jvd2luZ0VudHJ5U3R5bGUsIHsgY2xhc3NOYW1lOiBcImdkZy1ncm93aW5nLWVudHJ5XCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaGFkb3dCb3gsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgdXNlVGV4dCArIFwiXFxuXCIpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KElucHV0Qm94LCB7IC4uLnJlc3QsIGNsYXNzTmFtZTogKGNsYXNzTmFtZSA/PyBcIlwiKSArIFwiIGdkZy1pbnB1dFwiLCBpZDogaW5wdXRJRCwgcmVmOiBpbnB1dFJlZiwgb25LZXlEb3duOiBvbktleURvd25Jbm5lciwgdmFsdWU6IHVzZVRleHQsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgZGlyOiBcImF1dG9cIiB9KSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3dpbmctZW50cnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/growing-entry/growing-entry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/markdown-div/markdown-div.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/markdown-div/markdown-div.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MarkdownDiv)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! marked */ \"(ssr)/./node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var _private_markdown_container_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./private/markdown-container.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/markdown-div/private/markdown-container.js\");\n\n\n\n/** @category Renderers */\nclass MarkdownDiv extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n    targetElement = null;\n    renderMarkdownIntoDiv() {\n        const { targetElement, props } = this;\n        if (targetElement === null)\n            return;\n        const { contents, createNode } = props;\n        const innerHTML = (0,marked__WEBPACK_IMPORTED_MODULE_1__.marked)(contents);\n        const childRange = document.createRange();\n        childRange.selectNodeContents(targetElement);\n        childRange.deleteContents();\n        let newChild = createNode?.(innerHTML);\n        if (newChild === undefined) {\n            const childDoc = document.createElement(\"template\");\n            childDoc.innerHTML = innerHTML;\n            newChild = childDoc.content;\n        }\n        targetElement.append(newChild);\n        const tags = targetElement.getElementsByTagName(\"a\");\n        for (const tag of tags) {\n            tag.target = \"_blank\";\n            tag.rel = \"noreferrer noopener\";\n        }\n    }\n    containerRefHook = (element) => {\n        this.targetElement = element;\n        this.renderMarkdownIntoDiv();\n    };\n    render() {\n        // Doing this in the ref hook works great when we first render, but never again.\n        // This only works great after the first render, but not in the first render.\n        // Putting the two together makes the full solution.\n        this.renderMarkdownIntoDiv();\n        return react__WEBPACK_IMPORTED_MODULE_0__.createElement(_private_markdown_container_js__WEBPACK_IMPORTED_MODULE_2__.MarkdownContainer, { ref: this.containerRefHook });\n    }\n}\n//# sourceMappingURL=markdown-div.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvbWFya2Rvd24tZGl2L21hcmtkb3duLWRpdi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBCO0FBQ007QUFDb0M7QUFDcEU7QUFDZSwwQkFBMEIsZ0RBQW1CO0FBQzVEO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLDBCQUEwQiw4Q0FBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQW1CLENBQUMsNkVBQWlCLElBQUksNEJBQTRCO0FBQ3BGO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL21hcmtkb3duLWRpdi9tYXJrZG93bi1kaXYuanM/ODAzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBtYXJrZWQgfSBmcm9tIFwibWFya2VkXCI7XG5pbXBvcnQgeyBNYXJrZG93bkNvbnRhaW5lciB9IGZyb20gXCIuL3ByaXZhdGUvbWFya2Rvd24tY29udGFpbmVyLmpzXCI7XG4vKiogQGNhdGVnb3J5IFJlbmRlcmVycyAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFya2Rvd25EaXYgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50IHtcbiAgICB0YXJnZXRFbGVtZW50ID0gbnVsbDtcbiAgICByZW5kZXJNYXJrZG93bkludG9EaXYoKSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0RWxlbWVudCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0YXJnZXRFbGVtZW50ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRzLCBjcmVhdGVOb2RlIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgaW5uZXJIVE1MID0gbWFya2VkKGNvbnRlbnRzKTtcbiAgICAgICAgY29uc3QgY2hpbGRSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGNoaWxkUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICBjaGlsZFJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgIGxldCBuZXdDaGlsZCA9IGNyZWF0ZU5vZGU/Lihpbm5lckhUTUwpO1xuICAgICAgICBpZiAobmV3Q2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGREb2MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICAgICAgICBjaGlsZERvYy5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG4gICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkRG9jLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0RWxlbWVudC5hcHBlbmQobmV3Q2hpbGQpO1xuICAgICAgICBjb25zdCB0YWdzID0gdGFyZ2V0RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIik7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIHRhZy50YXJnZXQgPSBcIl9ibGFua1wiO1xuICAgICAgICAgICAgdGFnLnJlbCA9IFwibm9yZWZlcnJlciBub29wZW5lclwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRhaW5lclJlZkhvb2sgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICB0aGlzLnRhcmdldEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJlbmRlck1hcmtkb3duSW50b0RpdigpO1xuICAgIH07XG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyBEb2luZyB0aGlzIGluIHRoZSByZWYgaG9vayB3b3JrcyBncmVhdCB3aGVuIHdlIGZpcnN0IHJlbmRlciwgYnV0IG5ldmVyIGFnYWluLlxuICAgICAgICAvLyBUaGlzIG9ubHkgd29ya3MgZ3JlYXQgYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlciwgYnV0IG5vdCBpbiB0aGUgZmlyc3QgcmVuZGVyLlxuICAgICAgICAvLyBQdXR0aW5nIHRoZSB0d28gdG9nZXRoZXIgbWFrZXMgdGhlIGZ1bGwgc29sdXRpb24uXG4gICAgICAgIHRoaXMucmVuZGVyTWFya2Rvd25JbnRvRGl2KCk7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duQ29udGFpbmVyLCB7IHJlZjogdGhpcy5jb250YWluZXJSZWZIb29rIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcmtkb3duLWRpdi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/markdown-div/markdown-div.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/markdown-div/private/markdown-container.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/markdown-div/private/markdown-container.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MarkdownContainer: () => (/* binding */ MarkdownContainer)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n\nconst MarkdownContainer = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_0__.styled)('div')({\n  name: \"MarkdownContainer\",\n  class: \"gdg-mnuv029\",\n  propsAsIs: false\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvbWFya2Rvd24tZGl2L3ByaXZhdGUvbWFya2Rvd24tY29udGFpbmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ2pDLHVDQUF1QyxzREFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9yaXpvbi10YWlsd2luZC1yZWFjdC1uZXh0anMvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvbWFya2Rvd24tZGl2L3ByaXZhdGUvbWFya2Rvd24tY29udGFpbmVyLmpzPzM1M2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSBcIkBsaW5hcmlhL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgTWFya2Rvd25Db250YWluZXIgPSAvKiNfX1BVUkVfXyovc3R5bGVkKCdkaXYnKSh7XG4gIG5hbWU6IFwiTWFya2Rvd25Db250YWluZXJcIixcbiAgY2xhc3M6IFwiZ2RnLW1udXYwMjlcIixcbiAgcHJvcHNBc0lzOiBmYWxzZVxufSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/markdown-div/private/markdown-container.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/infinite-scroller.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/infinite-scroller.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfiniteScroller: () => (/* binding */ InfiniteScroller)\n/* harmony export */ });\n/* harmony import */ var _linaria_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @linaria/react */ \"(ssr)/./node_modules/@linaria/react/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _common_resize_detector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/resize-detector.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/resize-detector.js\");\n/* harmony import */ var _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/browser-detect.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/browser-detect.js\");\n/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/utils.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/common/utils.js\");\n/* harmony import */ var _use_kinetic_scroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-kinetic-scroll.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/use-kinetic-scroll.js\");\n\n\n\n\n\n\nconst _exp = /*#__PURE__*/() => p => p.isSafari ? \"scroll\" : \"auto\";\nconst ScrollRegionStyle = /*#__PURE__*/(0,_linaria_react__WEBPACK_IMPORTED_MODULE_1__.styled)('div')({\n  name: \"ScrollRegionStyle\",\n  class: \"gdg-s1dgczr6\",\n  propsAsIs: false,\n  vars: {\n    \"s1dgczr6-0\": [_exp()]\n  }\n});\nfunction useTouchUpDelayed(delay) {\n  const [hasTouches, setHasTouches] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  const safeWindow = typeof window === \"undefined\" ? null : window;\n  const cbTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n  (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_2__.useEventListener)(\"touchstart\", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    window.clearTimeout(cbTimer.current);\n    setHasTouches(true);\n  }, []), safeWindow, true, false);\n  (0,_common_utils_js__WEBPACK_IMPORTED_MODULE_2__.useEventListener)(\"touchend\", react__WEBPACK_IMPORTED_MODULE_0__.useCallback(e => {\n    if (e.touches.length === 0) {\n      cbTimer.current = window.setTimeout(() => setHasTouches(false), delay);\n    }\n  }, [delay]), safeWindow, true, false);\n  return hasTouches;\n}\nconst InfiniteScroller = p => {\n  const {\n    children,\n    clientHeight,\n    scrollHeight,\n    scrollWidth,\n    update,\n    draggable,\n    className,\n    preventDiagonalScrolling = false,\n    paddingBottom = 0,\n    paddingRight = 0,\n    rightElement,\n    rightElementProps,\n    kineticScrollPerfHack = false,\n    scrollRef,\n    initialSize\n  } = p;\n  const padders = [];\n  const rightElementSticky = rightElementProps?.sticky ?? false;\n  const rightElementFill = rightElementProps?.fill ?? false;\n  const offsetY = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n  const lastScrollY = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n  const scroller = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const dpr = typeof window === \"undefined\" ? 1 : window.devicePixelRatio;\n  const lastScrollPosition = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n    scrollLeft: 0,\n    scrollTop: 0,\n    lockDirection: undefined\n  });\n  const rightWrapRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const hasTouches = useTouchUpDelayed(200);\n  const [isIdle, setIsIdle] = react__WEBPACK_IMPORTED_MODULE_0__.useState(true);\n  const idleTimer = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n    if (!isIdle || hasTouches || lastScrollPosition.current.lockDirection === undefined) return;\n    const el = scroller.current;\n    if (el === null) return;\n    const [lx, ly] = lastScrollPosition.current.lockDirection;\n    if (lx !== undefined) {\n      el.scrollLeft = lx;\n    } else if (ly !== undefined) {\n      el.scrollTop = ly;\n    }\n    lastScrollPosition.current.lockDirection = undefined;\n  }, [hasTouches, isIdle]);\n  const onScroll = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((scrollLeft, scrollTop) => {\n    const el = scroller.current;\n    if (el === null) return;\n    scrollTop = scrollTop ?? el.scrollTop;\n    scrollLeft = scrollLeft ?? el.scrollLeft;\n    const lastScrollTop = lastScrollPosition.current.scrollTop;\n    const lastScrollLeft = lastScrollPosition.current.scrollLeft;\n    const dx = scrollLeft - lastScrollLeft;\n    const dy = scrollTop - lastScrollTop;\n    if (hasTouches && dx !== 0 && dy !== 0 && (Math.abs(dx) > 3 || Math.abs(dy) > 3) && preventDiagonalScrolling && lastScrollPosition.current.lockDirection === undefined) {\n      lastScrollPosition.current.lockDirection = Math.abs(dx) < Math.abs(dy) ? [lastScrollLeft, undefined] : [undefined, lastScrollTop];\n    }\n    const lock = lastScrollPosition.current.lockDirection;\n    scrollLeft = lock?.[0] ?? scrollLeft;\n    scrollTop = lock?.[1] ?? scrollTop;\n    lastScrollPosition.current.scrollLeft = scrollLeft;\n    lastScrollPosition.current.scrollTop = scrollTop;\n    const cWidth = el.clientWidth;\n    const cHeight = el.clientHeight;\n    const newY = scrollTop;\n    const delta = lastScrollY.current - newY;\n    const scrollableHeight = el.scrollHeight - cHeight;\n    lastScrollY.current = newY;\n    if (scrollableHeight > 0 && (Math.abs(delta) > 2000 || newY === 0 || newY === scrollableHeight) && scrollHeight > el.scrollHeight + 5) {\n      const prog = newY / scrollableHeight;\n      const recomputed = (scrollHeight - cHeight) * prog;\n      offsetY.current = recomputed - newY;\n    }\n    if (lock !== undefined) {\n      window.clearTimeout(idleTimer.current);\n      setIsIdle(false);\n      idleTimer.current = window.setTimeout(() => setIsIdle(true), 200);\n    }\n    update({\n      x: scrollLeft,\n      y: newY + offsetY.current,\n      width: cWidth - paddingRight,\n      height: cHeight - paddingBottom,\n      paddingRight: rightWrapRef.current?.clientWidth ?? 0\n    });\n  }, [paddingBottom, paddingRight, scrollHeight, update, preventDiagonalScrolling, hasTouches]);\n  (0,_use_kinetic_scroll_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(kineticScrollPerfHack && _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_4__.browserIsSafari.value, onScroll, scroller);\n  const onScrollRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onScroll);\n  onScrollRef.current = onScroll;\n  const lastProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const didFirstScroll = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  // if this is not a layout effect there will be a flicker when changing the number of freezeColumns\n  // we need to document what this is needed at all.\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n    if (didFirstScroll.current) onScroll();else didFirstScroll.current = true;\n  }, [onScroll, paddingBottom, paddingRight]);\n  const setRefs = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(instance => {\n    scroller.current = instance;\n    if (scrollRef !== undefined) {\n      scrollRef.current = instance;\n    }\n  }, [scrollRef]);\n  let key = 0;\n  let h = 0;\n  padders.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    key: key++,\n    style: {\n      width: scrollWidth,\n      height: 0\n    }\n  }));\n  while (h < scrollHeight) {\n    const toAdd = Math.min(5000000, scrollHeight - h);\n    padders.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      key: key++,\n      style: {\n        width: 0,\n        height: toAdd\n      }\n    }));\n    h += toAdd;\n  }\n  const {\n    ref,\n    width,\n    height\n  } = (0,_common_resize_detector_js__WEBPACK_IMPORTED_MODULE_5__.useResizeDetector)(initialSize);\n  if (typeof window !== \"undefined\" && (lastProps.current?.height !== height || lastProps.current?.width !== width)) {\n    window.setTimeout(() => onScrollRef.current(), 0);\n    lastProps.current = {\n      width,\n      height\n    };\n  }\n  if ((width ?? 0) === 0 || (height ?? 0) === 0) return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    ref: ref\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    ref: ref\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(ScrollRegionStyle, {\n    isSafari: _common_browser_detect_js__WEBPACK_IMPORTED_MODULE_4__.browserIsSafari.value\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"dvn-underlay\"\n  }, children), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    ref: setRefs,\n    style: lastProps.current,\n    draggable: draggable,\n    onDragStart: e => {\n      if (!draggable) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    },\n    className: \"dvn-scroller \" + (className ?? \"\"),\n    onScroll: () => onScroll()\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"dvn-scroll-inner\" + (rightElement === undefined ? \" dvn-hidden\" : \"\")\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"dvn-stack\"\n  }, padders), rightElement !== undefined && react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, !rightElementFill && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: \"dvn-spacer\"\n  }), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    ref: rightWrapRef,\n    style: {\n      height,\n      maxHeight: clientHeight - Math.ceil(dpr % 1),\n      position: \"sticky\",\n      top: 0,\n      paddingLeft: 1,\n      marginBottom: -40,\n      marginRight: paddingRight,\n      flexGrow: rightElementFill ? 1 : undefined,\n      right: rightElementSticky ? paddingRight ?? 0 : undefined,\n      pointerEvents: \"auto\"\n    }\n  }, rightElement))))));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9pbmZpbml0ZS1zY3JvbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdDO0FBQ1Q7QUFDcUM7QUFDSDtBQUNSO0FBQ0Y7QUFDdkQ7QUFDQSx1Q0FBdUMsc0RBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0NBQXNDLDJDQUFjO0FBQ3BEO0FBQ0Esa0JBQWtCLHlDQUFZO0FBQzlCLEVBQUUsa0VBQWdCLGVBQWUsOENBQWlCO0FBQ2xEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxrRUFBZ0IsYUFBYSw4Q0FBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBWTtBQUM5QixzQkFBc0IseUNBQVk7QUFDbEMsbUJBQW1CLHlDQUFZO0FBQy9CO0FBQ0EsNkJBQTZCLHlDQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIseUNBQVk7QUFDbkM7QUFDQSw4QkFBOEIsMkNBQWM7QUFDNUMsb0JBQW9CLHlDQUFZO0FBQ2hDLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsbUJBQW1CLDhDQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFLGtFQUFnQiwwQkFBMEIsc0VBQWU7QUFDM0Qsc0JBQXNCLHlDQUFZO0FBQ2xDO0FBQ0Esb0JBQW9CLHlDQUFZO0FBQ2hDLHlCQUF5Qix5Q0FBWTtBQUNyQztBQUNBO0FBQ0EsRUFBRSxrREFBcUI7QUFDdkIsMkNBQTJDO0FBQzNDLEdBQUc7QUFDSCxrQkFBa0IsOENBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLGdEQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsZ0RBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLDZFQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnREFBbUI7QUFDM0U7QUFDQSxHQUFHO0FBQ0gsU0FBUyxnREFBbUI7QUFDNUI7QUFDQSxHQUFHLEVBQUUsZ0RBQW1CO0FBQ3hCLGNBQWMsc0VBQWU7QUFDN0IsR0FBRyxFQUFFLGdEQUFtQjtBQUN4QjtBQUNBLEdBQUcsYUFBYSxnREFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRyxFQUFFLGdEQUFtQjtBQUN4QjtBQUNBLEdBQUcsRUFBRSxnREFBbUI7QUFDeEI7QUFDQSxHQUFHLDBDQUEwQyxnREFBbUIsQ0FBQywyQ0FBYyw2QkFBNkIsZ0RBQW1CO0FBQy9IO0FBQ0EsR0FBRyxHQUFHLGdEQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL3Njcm9sbGluZy1kYXRhLWdyaWQvaW5maW5pdGUtc2Nyb2xsZXIuanM/ZDAzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwiQGxpbmFyaWEvcmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUmVzaXplRGV0ZWN0b3IgfSBmcm9tIFwiLi4vLi4vY29tbW9uL3Jlc2l6ZS1kZXRlY3Rvci5qc1wiO1xuaW1wb3J0IHsgYnJvd3NlcklzU2FmYXJpIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9icm93c2VyLWRldGVjdC5qc1wiO1xuaW1wb3J0IHsgdXNlRXZlbnRMaXN0ZW5lciB9IGZyb20gXCIuLi8uLi9jb21tb24vdXRpbHMuanNcIjtcbmltcG9ydCB1c2VLaW5ldGljU2Nyb2xsIGZyb20gXCIuL3VzZS1raW5ldGljLXNjcm9sbC5qc1wiO1xuY29uc3QgX2V4cCA9IC8qI19fUFVSRV9fKi8oKSA9PiBwID0+IHAuaXNTYWZhcmkgPyBcInNjcm9sbFwiIDogXCJhdXRvXCI7XG5jb25zdCBTY3JvbGxSZWdpb25TdHlsZSA9IC8qI19fUFVSRV9fKi9zdHlsZWQoJ2RpdicpKHtcbiAgbmFtZTogXCJTY3JvbGxSZWdpb25TdHlsZVwiLFxuICBjbGFzczogXCJnZGctczFkZ2N6cjZcIixcbiAgcHJvcHNBc0lzOiBmYWxzZSxcbiAgdmFyczoge1xuICAgIFwiczFkZ2N6cjYtMFwiOiBbX2V4cCgpXVxuICB9XG59KTtcbmZ1bmN0aW9uIHVzZVRvdWNoVXBEZWxheWVkKGRlbGF5KSB7XG4gIGNvbnN0IFtoYXNUb3VjaGVzLCBzZXRIYXNUb3VjaGVzXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3Qgc2FmZVdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogd2luZG93O1xuICBjb25zdCBjYlRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuICB1c2VFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dChjYlRpbWVyLmN1cnJlbnQpO1xuICAgIHNldEhhc1RvdWNoZXModHJ1ZSk7XG4gIH0sIFtdKSwgc2FmZVdpbmRvdywgdHJ1ZSwgZmFsc2UpO1xuICB1c2VFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgUmVhY3QudXNlQ2FsbGJhY2soZSA9PiB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNiVGltZXIuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHNldEhhc1RvdWNoZXMoZmFsc2UpLCBkZWxheSk7XG4gICAgfVxuICB9LCBbZGVsYXldKSwgc2FmZVdpbmRvdywgdHJ1ZSwgZmFsc2UpO1xuICByZXR1cm4gaGFzVG91Y2hlcztcbn1cbmV4cG9ydCBjb25zdCBJbmZpbml0ZVNjcm9sbGVyID0gcCA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBjbGllbnRIZWlnaHQsXG4gICAgc2Nyb2xsSGVpZ2h0LFxuICAgIHNjcm9sbFdpZHRoLFxuICAgIHVwZGF0ZSxcbiAgICBkcmFnZ2FibGUsXG4gICAgY2xhc3NOYW1lLFxuICAgIHByZXZlbnREaWFnb25hbFNjcm9sbGluZyA9IGZhbHNlLFxuICAgIHBhZGRpbmdCb3R0b20gPSAwLFxuICAgIHBhZGRpbmdSaWdodCA9IDAsXG4gICAgcmlnaHRFbGVtZW50LFxuICAgIHJpZ2h0RWxlbWVudFByb3BzLFxuICAgIGtpbmV0aWNTY3JvbGxQZXJmSGFjayA9IGZhbHNlLFxuICAgIHNjcm9sbFJlZixcbiAgICBpbml0aWFsU2l6ZVxuICB9ID0gcDtcbiAgY29uc3QgcGFkZGVycyA9IFtdO1xuICBjb25zdCByaWdodEVsZW1lbnRTdGlja3kgPSByaWdodEVsZW1lbnRQcm9wcz8uc3RpY2t5ID8/IGZhbHNlO1xuICBjb25zdCByaWdodEVsZW1lbnRGaWxsID0gcmlnaHRFbGVtZW50UHJvcHM/LmZpbGwgPz8gZmFsc2U7XG4gIGNvbnN0IG9mZnNldFkgPSBSZWFjdC51c2VSZWYoMCk7XG4gIGNvbnN0IGxhc3RTY3JvbGxZID0gUmVhY3QudXNlUmVmKDApO1xuICBjb25zdCBzY3JvbGxlciA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZHByID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IDEgOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgbGFzdFNjcm9sbFBvc2l0aW9uID0gUmVhY3QudXNlUmVmKHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMCxcbiAgICBsb2NrRGlyZWN0aW9uOiB1bmRlZmluZWRcbiAgfSk7XG4gIGNvbnN0IHJpZ2h0V3JhcFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaGFzVG91Y2hlcyA9IHVzZVRvdWNoVXBEZWxheWVkKDIwMCk7XG4gIGNvbnN0IFtpc0lkbGUsIHNldElzSWRsZV0gPSBSZWFjdC51c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgaWRsZVRpbWVyID0gUmVhY3QudXNlUmVmKDApO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNJZGxlIHx8IGhhc1RvdWNoZXMgfHwgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQubG9ja0RpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgY29uc3QgZWwgPSBzY3JvbGxlci5jdXJyZW50O1xuICAgIGlmIChlbCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IFtseCwgbHldID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQubG9ja0RpcmVjdGlvbjtcbiAgICBpZiAobHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWwuc2Nyb2xsTGVmdCA9IGx4O1xuICAgIH0gZWxzZSBpZiAobHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWwuc2Nyb2xsVG9wID0gbHk7XG4gICAgfVxuICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gIH0sIFtoYXNUb3VjaGVzLCBpc0lkbGVdKTtcbiAgY29uc3Qgb25TY3JvbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wKSA9PiB7XG4gICAgY29uc3QgZWwgPSBzY3JvbGxlci5jdXJyZW50O1xuICAgIGlmIChlbCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHNjcm9sbFRvcCA9IHNjcm9sbFRvcCA/PyBlbC5zY3JvbGxUb3A7XG4gICAgc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQgPz8gZWwuc2Nyb2xsTGVmdDtcbiAgICBjb25zdCBsYXN0U2Nyb2xsVG9wID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsVG9wO1xuICAgIGNvbnN0IGxhc3RTY3JvbGxMZWZ0ID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQuc2Nyb2xsTGVmdDtcbiAgICBjb25zdCBkeCA9IHNjcm9sbExlZnQgLSBsYXN0U2Nyb2xsTGVmdDtcbiAgICBjb25zdCBkeSA9IHNjcm9sbFRvcCAtIGxhc3RTY3JvbGxUb3A7XG4gICAgaWYgKGhhc1RvdWNoZXMgJiYgZHggIT09IDAgJiYgZHkgIT09IDAgJiYgKE1hdGguYWJzKGR4KSA+IDMgfHwgTWF0aC5hYnMoZHkpID4gMykgJiYgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nICYmIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50LmxvY2tEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQubG9ja0RpcmVjdGlvbiA9IE1hdGguYWJzKGR4KSA8IE1hdGguYWJzKGR5KSA/IFtsYXN0U2Nyb2xsTGVmdCwgdW5kZWZpbmVkXSA6IFt1bmRlZmluZWQsIGxhc3RTY3JvbGxUb3BdO1xuICAgIH1cbiAgICBjb25zdCBsb2NrID0gbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQubG9ja0RpcmVjdGlvbjtcbiAgICBzY3JvbGxMZWZ0ID0gbG9jaz8uWzBdID8/IHNjcm9sbExlZnQ7XG4gICAgc2Nyb2xsVG9wID0gbG9jaz8uWzFdID8/IHNjcm9sbFRvcDtcbiAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgY29uc3QgY1dpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gICAgY29uc3QgY0hlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBuZXdZID0gc2Nyb2xsVG9wO1xuICAgIGNvbnN0IGRlbHRhID0gbGFzdFNjcm9sbFkuY3VycmVudCAtIG5ld1k7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZUhlaWdodCA9IGVsLnNjcm9sbEhlaWdodCAtIGNIZWlnaHQ7XG4gICAgbGFzdFNjcm9sbFkuY3VycmVudCA9IG5ld1k7XG4gICAgaWYgKHNjcm9sbGFibGVIZWlnaHQgPiAwICYmIChNYXRoLmFicyhkZWx0YSkgPiAyMDAwIHx8IG5ld1kgPT09IDAgfHwgbmV3WSA9PT0gc2Nyb2xsYWJsZUhlaWdodCkgJiYgc2Nyb2xsSGVpZ2h0ID4gZWwuc2Nyb2xsSGVpZ2h0ICsgNSkge1xuICAgICAgY29uc3QgcHJvZyA9IG5ld1kgLyBzY3JvbGxhYmxlSGVpZ2h0O1xuICAgICAgY29uc3QgcmVjb21wdXRlZCA9IChzY3JvbGxIZWlnaHQgLSBjSGVpZ2h0KSAqIHByb2c7XG4gICAgICBvZmZzZXRZLmN1cnJlbnQgPSByZWNvbXB1dGVkIC0gbmV3WTtcbiAgICB9XG4gICAgaWYgKGxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChpZGxlVGltZXIuY3VycmVudCk7XG4gICAgICBzZXRJc0lkbGUoZmFsc2UpO1xuICAgICAgaWRsZVRpbWVyLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBzZXRJc0lkbGUodHJ1ZSksIDIwMCk7XG4gICAgfVxuICAgIHVwZGF0ZSh7XG4gICAgICB4OiBzY3JvbGxMZWZ0LFxuICAgICAgeTogbmV3WSArIG9mZnNldFkuY3VycmVudCxcbiAgICAgIHdpZHRoOiBjV2lkdGggLSBwYWRkaW5nUmlnaHQsXG4gICAgICBoZWlnaHQ6IGNIZWlnaHQgLSBwYWRkaW5nQm90dG9tLFxuICAgICAgcGFkZGluZ1JpZ2h0OiByaWdodFdyYXBSZWYuY3VycmVudD8uY2xpZW50V2lkdGggPz8gMFxuICAgIH0pO1xuICB9LCBbcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBzY3JvbGxIZWlnaHQsIHVwZGF0ZSwgcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCBoYXNUb3VjaGVzXSk7XG4gIHVzZUtpbmV0aWNTY3JvbGwoa2luZXRpY1Njcm9sbFBlcmZIYWNrICYmIGJyb3dzZXJJc1NhZmFyaS52YWx1ZSwgb25TY3JvbGwsIHNjcm9sbGVyKTtcbiAgY29uc3Qgb25TY3JvbGxSZWYgPSBSZWFjdC51c2VSZWYob25TY3JvbGwpO1xuICBvblNjcm9sbFJlZi5jdXJyZW50ID0gb25TY3JvbGw7XG4gIGNvbnN0IGxhc3RQcm9wcyA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBkaWRGaXJzdFNjcm9sbCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIC8vIGlmIHRoaXMgaXMgbm90IGEgbGF5b3V0IGVmZmVjdCB0aGVyZSB3aWxsIGJlIGEgZmxpY2tlciB3aGVuIGNoYW5naW5nIHRoZSBudW1iZXIgb2YgZnJlZXplQ29sdW1uc1xuICAvLyB3ZSBuZWVkIHRvIGRvY3VtZW50IHdoYXQgdGhpcyBpcyBuZWVkZWQgYXQgYWxsLlxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaWRGaXJzdFNjcm9sbC5jdXJyZW50KSBvblNjcm9sbCgpO2Vsc2UgZGlkRmlyc3RTY3JvbGwuY3VycmVudCA9IHRydWU7XG4gIH0sIFtvblNjcm9sbCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0XSk7XG4gIGNvbnN0IHNldFJlZnMgPSBSZWFjdC51c2VDYWxsYmFjayhpbnN0YW5jZSA9PiB7XG4gICAgc2Nyb2xsZXIuY3VycmVudCA9IGluc3RhbmNlO1xuICAgIGlmIChzY3JvbGxSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2Nyb2xsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICB9XG4gIH0sIFtzY3JvbGxSZWZdKTtcbiAgbGV0IGtleSA9IDA7XG4gIGxldCBoID0gMDtcbiAgcGFkZGVycy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGtleToga2V5KyssXG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiBzY3JvbGxXaWR0aCxcbiAgICAgIGhlaWdodDogMFxuICAgIH1cbiAgfSkpO1xuICB3aGlsZSAoaCA8IHNjcm9sbEhlaWdodCkge1xuICAgIGNvbnN0IHRvQWRkID0gTWF0aC5taW4oNTAwMDAwMCwgc2Nyb2xsSGVpZ2h0IC0gaCk7XG4gICAgcGFkZGVycy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAga2V5OiBrZXkrKyxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IHRvQWRkXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGggKz0gdG9BZGQ7XG4gIH1cbiAgY29uc3Qge1xuICAgIHJlZixcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHVzZVJlc2l6ZURldGVjdG9yKGluaXRpYWxTaXplKTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgKGxhc3RQcm9wcy5jdXJyZW50Py5oZWlnaHQgIT09IGhlaWdodCB8fCBsYXN0UHJvcHMuY3VycmVudD8ud2lkdGggIT09IHdpZHRoKSkge1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IG9uU2Nyb2xsUmVmLmN1cnJlbnQoKSwgMCk7XG4gICAgbGFzdFByb3BzLmN1cnJlbnQgPSB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH07XG4gIH1cbiAgaWYgKCh3aWR0aCA/PyAwKSA9PT0gMCB8fCAoaGVpZ2h0ID8/IDApID09PSAwKSByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiByZWZcbiAgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IHJlZlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFNjcm9sbFJlZ2lvblN0eWxlLCB7XG4gICAgaXNTYWZhcmk6IGJyb3dzZXJJc1NhZmFyaS52YWx1ZVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwiZHZuLXVuZGVybGF5XCJcbiAgfSwgY2hpbGRyZW4pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IHNldFJlZnMsXG4gICAgc3R5bGU6IGxhc3RQcm9wcy5jdXJyZW50LFxuICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgIG9uRHJhZ1N0YXJ0OiBlID0+IHtcbiAgICAgIGlmICghZHJhZ2dhYmxlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsYXNzTmFtZTogXCJkdm4tc2Nyb2xsZXIgXCIgKyAoY2xhc3NOYW1lID8/IFwiXCIpLFxuICAgIG9uU2Nyb2xsOiAoKSA9PiBvblNjcm9sbCgpXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJkdm4tc2Nyb2xsLWlubmVyXCIgKyAocmlnaHRFbGVtZW50ID09PSB1bmRlZmluZWQgPyBcIiBkdm4taGlkZGVuXCIgOiBcIlwiKVxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwiZHZuLXN0YWNrXCJcbiAgfSwgcGFkZGVycyksIHJpZ2h0RWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsICFyaWdodEVsZW1lbnRGaWxsICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJkdm4tc3BhY2VyXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogcmlnaHRXcmFwUmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBoZWlnaHQsXG4gICAgICBtYXhIZWlnaHQ6IGNsaWVudEhlaWdodCAtIE1hdGguY2VpbChkcHIgJSAxKSxcbiAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgdG9wOiAwLFxuICAgICAgcGFkZGluZ0xlZnQ6IDEsXG4gICAgICBtYXJnaW5Cb3R0b206IC00MCxcbiAgICAgIG1hcmdpblJpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICBmbGV4R3JvdzogcmlnaHRFbGVtZW50RmlsbCA/IDEgOiB1bmRlZmluZWQsXG4gICAgICByaWdodDogcmlnaHRFbGVtZW50U3RpY2t5ID8gcGFkZGluZ1JpZ2h0ID8/IDAgOiB1bmRlZmluZWQsXG4gICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgIH1cbiAgfSwgcmlnaHRFbGVtZW50KSkpKSkpO1xufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/infinite-scroller.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/scrolling-data-grid.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/scrolling-data-grid.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _data_grid_dnd_data_grid_dnd_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data-grid-dnd/data-grid-dnd.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/data-grid-dnd/data-grid-dnd.js\");\n/* harmony import */ var _infinite_scroller_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./infinite-scroller.js */ \"(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/infinite-scroller.js\");\n\n\n\nconst GridScroller = p => {\n    const { columns, rows, rowHeight, headerHeight, groupHeaderHeight, enableGroups, freezeColumns, experimental, nonGrowWidth, clientSize, className, onVisibleRegionChanged, scrollRef, preventDiagonalScrolling, rightElement, rightElementProps, overscrollX, overscrollY, initialSize, smoothScrollX = false, smoothScrollY = false, isDraggable, } = p;\n    const { paddingRight, paddingBottom } = experimental ?? {};\n    const [clientWidth, clientHeight] = clientSize;\n    const last = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const lastX = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const lastY = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const lastSize = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const width = nonGrowWidth + Math.max(0, overscrollX ?? 0);\n    let height = enableGroups ? headerHeight + groupHeaderHeight : headerHeight;\n    if (typeof rowHeight === \"number\") {\n        height += rows * rowHeight;\n    }\n    else {\n        for (let r = 0; r < rows; r++) {\n            height += rowHeight(r);\n        }\n    }\n    if (overscrollY !== undefined) {\n        height += overscrollY;\n    }\n    const lastArgs = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const processArgs = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n        if (lastArgs.current === undefined)\n            return;\n        const args = { ...lastArgs.current };\n        let x = 0;\n        let tx = args.x < 0 ? -args.x : 0;\n        let cellRight = 0;\n        let cellX = 0;\n        args.x = args.x < 0 ? 0 : args.x;\n        let stickyColWidth = 0;\n        for (let i = 0; i < freezeColumns; i++) {\n            stickyColWidth += columns[i].width;\n        }\n        for (const c of columns) {\n            const cx = x - stickyColWidth;\n            if (args.x >= cx + c.width) {\n                x += c.width;\n                cellX++;\n                cellRight++;\n            }\n            else if (args.x > cx) {\n                x += c.width;\n                if (smoothScrollX) {\n                    tx += cx - args.x;\n                }\n                else {\n                    cellX++;\n                }\n                cellRight++;\n            }\n            else if (args.x + args.width > cx) {\n                x += c.width;\n                cellRight++;\n            }\n            else {\n                break;\n            }\n        }\n        let ty = 0;\n        let cellY = 0;\n        let cellBottom = 0;\n        if (typeof rowHeight === \"number\") {\n            if (smoothScrollY) {\n                cellY = Math.floor(args.y / rowHeight);\n                ty = cellY * rowHeight - args.y;\n            }\n            else {\n                cellY = Math.ceil(args.y / rowHeight);\n            }\n            cellBottom = Math.ceil(args.height / rowHeight) + cellY;\n            if (ty < 0)\n                cellBottom++;\n        }\n        else {\n            let y = 0;\n            for (let row = 0; row < rows; row++) {\n                const rh = rowHeight(row);\n                const cy = y + (smoothScrollY ? 0 : rh / 2);\n                if (args.y >= y + rh) {\n                    y += rh;\n                    cellY++;\n                    cellBottom++;\n                }\n                else if (args.y > cy) {\n                    y += rh;\n                    if (smoothScrollY) {\n                        ty += cy - args.y;\n                    }\n                    else {\n                        cellY++;\n                    }\n                    cellBottom++;\n                }\n                else if (args.y + args.height > rh / 2 + y) {\n                    y += rh;\n                    cellBottom++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        const rect = {\n            x: cellX,\n            y: cellY,\n            width: cellRight - cellX,\n            height: cellBottom - cellY,\n        };\n        const oldRect = last.current;\n        if (oldRect === undefined ||\n            oldRect.y !== rect.y ||\n            oldRect.x !== rect.x ||\n            oldRect.height !== rect.height ||\n            oldRect.width !== rect.width ||\n            lastX.current !== tx ||\n            lastY.current !== ty ||\n            args.width !== lastSize.current?.[0] ||\n            args.height !== lastSize.current?.[1]) {\n            onVisibleRegionChanged?.({\n                x: cellX,\n                y: cellY,\n                width: cellRight - cellX,\n                height: cellBottom - cellY,\n            }, args.width, args.height, args.paddingRight ?? 0, tx, ty);\n            last.current = rect;\n            lastX.current = tx;\n            lastY.current = ty;\n            lastSize.current = [args.width, args.height];\n        }\n    }, [columns, rowHeight, rows, onVisibleRegionChanged, freezeColumns, smoothScrollX, smoothScrollY]);\n    const onScrollUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((args) => {\n        lastArgs.current = args;\n        processArgs();\n    }, [processArgs]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        processArgs();\n    }, [processArgs]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_infinite_scroller_js__WEBPACK_IMPORTED_MODULE_1__.InfiniteScroller, { scrollRef: scrollRef, className: className, kineticScrollPerfHack: experimental?.kineticScrollPerfHack, preventDiagonalScrolling: preventDiagonalScrolling, draggable: isDraggable === true || typeof isDraggable === \"string\", scrollWidth: width + (paddingRight ?? 0), scrollHeight: height + (paddingBottom ?? 0), clientHeight: clientHeight, rightElement: rightElement, paddingBottom: paddingBottom, paddingRight: paddingRight, rightElementProps: rightElementProps, update: onScrollUpdate, initialSize: initialSize },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_data_grid_dnd_data_grid_dnd_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], { eventTargetRef: scrollRef, width: clientWidth, height: clientHeight, accessibilityHeight: p.accessibilityHeight, canvasRef: p.canvasRef, cellXOffset: p.cellXOffset, cellYOffset: p.cellYOffset, columns: p.columns, disabledRows: p.disabledRows, enableGroups: p.enableGroups, fillHandle: p.fillHandle, firstColAccessible: p.firstColAccessible, fixedShadowX: p.fixedShadowX, fixedShadowY: p.fixedShadowY, freezeColumns: p.freezeColumns, getCellContent: p.getCellContent, getCellRenderer: p.getCellRenderer, getGroupDetails: p.getGroupDetails, getRowThemeOverride: p.getRowThemeOverride, groupHeaderHeight: p.groupHeaderHeight, headerHeight: p.headerHeight, highlightRegions: p.highlightRegions, imageWindowLoader: p.imageWindowLoader, isFilling: p.isFilling, isFocused: p.isFocused, lockColumns: p.lockColumns, maxColumnWidth: p.maxColumnWidth, minColumnWidth: p.minColumnWidth, onHeaderMenuClick: p.onHeaderMenuClick, onMouseMove: p.onMouseMove, prelightCells: p.prelightCells, rowHeight: p.rowHeight, rows: p.rows, selection: p.selection, theme: p.theme, freezeTrailingRows: p.freezeTrailingRows, hasAppendRow: p.hasAppendRow, translateX: p.translateX, translateY: p.translateY, onColumnProposeMove: p.onColumnProposeMove, verticalBorder: p.verticalBorder, drawFocusRing: p.drawFocusRing, drawHeader: p.drawHeader, drawCell: p.drawCell, experimental: p.experimental, gridRef: p.gridRef, headerIcons: p.headerIcons, isDraggable: p.isDraggable, onCanvasBlur: p.onCanvasBlur, onCanvasFocused: p.onCanvasFocused, onCellFocused: p.onCellFocused, onColumnMoved: p.onColumnMoved, onColumnResize: p.onColumnResize, onColumnResizeEnd: p.onColumnResizeEnd, onColumnResizeStart: p.onColumnResizeStart, onContextMenu: p.onContextMenu, onDragEnd: p.onDragEnd, onDragLeave: p.onDragLeave, onDragOverCell: p.onDragOverCell, onDragStart: p.onDragStart, onDrop: p.onDrop, onItemHovered: p.onItemHovered, onKeyDown: p.onKeyDown, onKeyUp: p.onKeyUp, onMouseDown: p.onMouseDown, onMouseUp: p.onMouseUp, onRowMoved: p.onRowMoved, smoothScrollX: p.smoothScrollX, smoothScrollY: p.smoothScrollY })));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridScroller);\n//# sourceMappingURL=scrolling-data-grid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvc2Nyb2xsaW5nLWRhdGEtZ3JpZC9zY3JvbGxpbmctZGF0YS1ncmlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7QUFDaUM7QUFDTjtBQUMxRDtBQUNBLFlBQVksNlVBQTZVO0FBQ3pWLFlBQVksOEJBQThCO0FBQzFDO0FBQ0EsaUJBQWlCLHlDQUFZO0FBQzdCLGtCQUFrQix5Q0FBWTtBQUM5QixrQkFBa0IseUNBQVk7QUFDOUIscUJBQXFCLHlDQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBWTtBQUNqQyx3QkFBd0IsOENBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQiw4Q0FBaUI7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDRDQUFlO0FBQ25CO0FBQ0EsS0FBSztBQUNMLFlBQVksZ0RBQW1CLENBQUMsbUVBQWdCLElBQUksaWdCQUFpZ0I7QUFDcmpCLFFBQVEsZ0RBQW1CLENBQUMsdUVBQVcsSUFBSSx1aEVBQXVoRTtBQUNsa0U7QUFDQSxpRUFBZSxZQUFZLEVBQUM7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3Jpem9uLXRhaWx3aW5kLXJlYWN0LW5leHRqcy8uL25vZGVfbW9kdWxlcy9AZ2xpZGVhcHBzL2dsaWRlLWRhdGEtZ3JpZC9kaXN0L2VzbS9pbnRlcm5hbC9zY3JvbGxpbmctZGF0YS1ncmlkL3Njcm9sbGluZy1kYXRhLWdyaWQuanM/NGI5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBEYXRhR3JpZERuZCwge30gZnJvbSBcIi4uL2RhdGEtZ3JpZC1kbmQvZGF0YS1ncmlkLWRuZC5qc1wiO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxlciB9IGZyb20gXCIuL2luZmluaXRlLXNjcm9sbGVyLmpzXCI7XG5jb25zdCBHcmlkU2Nyb2xsZXIgPSBwID0+IHtcbiAgICBjb25zdCB7IGNvbHVtbnMsIHJvd3MsIHJvd0hlaWdodCwgaGVhZGVySGVpZ2h0LCBncm91cEhlYWRlckhlaWdodCwgZW5hYmxlR3JvdXBzLCBmcmVlemVDb2x1bW5zLCBleHBlcmltZW50YWwsIG5vbkdyb3dXaWR0aCwgY2xpZW50U2l6ZSwgY2xhc3NOYW1lLCBvblZpc2libGVSZWdpb25DaGFuZ2VkLCBzY3JvbGxSZWYsIHByZXZlbnREaWFnb25hbFNjcm9sbGluZywgcmlnaHRFbGVtZW50LCByaWdodEVsZW1lbnRQcm9wcywgb3ZlcnNjcm9sbFgsIG92ZXJzY3JvbGxZLCBpbml0aWFsU2l6ZSwgc21vb3RoU2Nyb2xsWCA9IGZhbHNlLCBzbW9vdGhTY3JvbGxZID0gZmFsc2UsIGlzRHJhZ2dhYmxlLCB9ID0gcDtcbiAgICBjb25zdCB7IHBhZGRpbmdSaWdodCwgcGFkZGluZ0JvdHRvbSB9ID0gZXhwZXJpbWVudGFsID8/IHt9O1xuICAgIGNvbnN0IFtjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0XSA9IGNsaWVudFNpemU7XG4gICAgY29uc3QgbGFzdCA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGNvbnN0IGxhc3RYID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgbGFzdFkgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBjb25zdCBsYXN0U2l6ZSA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGNvbnN0IHdpZHRoID0gbm9uR3Jvd1dpZHRoICsgTWF0aC5tYXgoMCwgb3ZlcnNjcm9sbFggPz8gMCk7XG4gICAgbGV0IGhlaWdodCA9IGVuYWJsZUdyb3VwcyA/IGhlYWRlckhlaWdodCArIGdyb3VwSGVhZGVySGVpZ2h0IDogaGVhZGVySGVpZ2h0O1xuICAgIGlmICh0eXBlb2Ygcm93SGVpZ2h0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGhlaWdodCArPSByb3dzICogcm93SGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzOyByKyspIHtcbiAgICAgICAgICAgIGhlaWdodCArPSByb3dIZWlnaHQocik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJzY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVpZ2h0ICs9IG92ZXJzY3JvbGxZO1xuICAgIH1cbiAgICBjb25zdCBsYXN0QXJncyA9IFJlYWN0LnVzZVJlZigpO1xuICAgIGNvbnN0IHByb2Nlc3NBcmdzID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAobGFzdEFyZ3MuY3VycmVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBhcmdzID0geyAuLi5sYXN0QXJncy5jdXJyZW50IH07XG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHR4ID0gYXJncy54IDwgMCA/IC1hcmdzLnggOiAwO1xuICAgICAgICBsZXQgY2VsbFJpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGNlbGxYID0gMDtcbiAgICAgICAgYXJncy54ID0gYXJncy54IDwgMCA/IDAgOiBhcmdzLng7XG4gICAgICAgIGxldCBzdGlja3lDb2xXaWR0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJlZXplQ29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICBzdGlja3lDb2xXaWR0aCArPSBjb2x1bW5zW2ldLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb25zdCBjeCA9IHggLSBzdGlja3lDb2xXaWR0aDtcbiAgICAgICAgICAgIGlmIChhcmdzLnggPj0gY3ggKyBjLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGNlbGxYKys7XG4gICAgICAgICAgICAgICAgY2VsbFJpZ2h0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmdzLnggPiBjeCkge1xuICAgICAgICAgICAgICAgIHggKz0gYy53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoc21vb3RoU2Nyb2xsWCkge1xuICAgICAgICAgICAgICAgICAgICB0eCArPSBjeCAtIGFyZ3MueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxYKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJncy54ICsgYXJncy53aWR0aCA+IGN4KSB7XG4gICAgICAgICAgICAgICAgeCArPSBjLndpZHRoO1xuICAgICAgICAgICAgICAgIGNlbGxSaWdodCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5ID0gMDtcbiAgICAgICAgbGV0IGNlbGxZID0gMDtcbiAgICAgICAgbGV0IGNlbGxCb3R0b20gPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHJvd0hlaWdodCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHNtb290aFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICBjZWxsWSA9IE1hdGguZmxvb3IoYXJncy55IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0eSA9IGNlbGxZICogcm93SGVpZ2h0IC0gYXJncy55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbFkgPSBNYXRoLmNlaWwoYXJncy55IC8gcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxCb3R0b20gPSBNYXRoLmNlaWwoYXJncy5oZWlnaHQgLyByb3dIZWlnaHQpICsgY2VsbFk7XG4gICAgICAgICAgICBpZiAodHkgPCAwKVxuICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmggPSByb3dIZWlnaHQocm93KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjeSA9IHkgKyAoc21vb3RoU2Nyb2xsWSA/IDAgOiByaCAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLnkgPj0geSArIHJoKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gcmg7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxZKys7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxCb3R0b20rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJncy55ID4gY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgeSArPSByaDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNtb290aFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5ICs9IGN5IC0gYXJncy55O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3MueSArIGFyZ3MuaGVpZ2h0ID4gcmggLyAyICsgeSkge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHJoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsQm90dG9tKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjdCA9IHtcbiAgICAgICAgICAgIHg6IGNlbGxYLFxuICAgICAgICAgICAgeTogY2VsbFksXG4gICAgICAgICAgICB3aWR0aDogY2VsbFJpZ2h0IC0gY2VsbFgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNlbGxCb3R0b20gLSBjZWxsWSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb2xkUmVjdCA9IGxhc3QuY3VycmVudDtcbiAgICAgICAgaWYgKG9sZFJlY3QgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgb2xkUmVjdC55ICE9PSByZWN0LnkgfHxcbiAgICAgICAgICAgIG9sZFJlY3QueCAhPT0gcmVjdC54IHx8XG4gICAgICAgICAgICBvbGRSZWN0LmhlaWdodCAhPT0gcmVjdC5oZWlnaHQgfHxcbiAgICAgICAgICAgIG9sZFJlY3Qud2lkdGggIT09IHJlY3Qud2lkdGggfHxcbiAgICAgICAgICAgIGxhc3RYLmN1cnJlbnQgIT09IHR4IHx8XG4gICAgICAgICAgICBsYXN0WS5jdXJyZW50ICE9PSB0eSB8fFxuICAgICAgICAgICAgYXJncy53aWR0aCAhPT0gbGFzdFNpemUuY3VycmVudD8uWzBdIHx8XG4gICAgICAgICAgICBhcmdzLmhlaWdodCAhPT0gbGFzdFNpemUuY3VycmVudD8uWzFdKSB7XG4gICAgICAgICAgICBvblZpc2libGVSZWdpb25DaGFuZ2VkPy4oe1xuICAgICAgICAgICAgICAgIHg6IGNlbGxYLFxuICAgICAgICAgICAgICAgIHk6IGNlbGxZLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsUmlnaHQgLSBjZWxsWCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGNlbGxCb3R0b20gLSBjZWxsWSxcbiAgICAgICAgICAgIH0sIGFyZ3Mud2lkdGgsIGFyZ3MuaGVpZ2h0LCBhcmdzLnBhZGRpbmdSaWdodCA/PyAwLCB0eCwgdHkpO1xuICAgICAgICAgICAgbGFzdC5jdXJyZW50ID0gcmVjdDtcbiAgICAgICAgICAgIGxhc3RYLmN1cnJlbnQgPSB0eDtcbiAgICAgICAgICAgIGxhc3RZLmN1cnJlbnQgPSB0eTtcbiAgICAgICAgICAgIGxhc3RTaXplLmN1cnJlbnQgPSBbYXJncy53aWR0aCwgYXJncy5oZWlnaHRdO1xuICAgICAgICB9XG4gICAgfSwgW2NvbHVtbnMsIHJvd0hlaWdodCwgcm93cywgb25WaXNpYmxlUmVnaW9uQ2hhbmdlZCwgZnJlZXplQ29sdW1ucywgc21vb3RoU2Nyb2xsWCwgc21vb3RoU2Nyb2xsWV0pO1xuICAgIGNvbnN0IG9uU2Nyb2xsVXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKGFyZ3MpID0+IHtcbiAgICAgICAgbGFzdEFyZ3MuY3VycmVudCA9IGFyZ3M7XG4gICAgICAgIHByb2Nlc3NBcmdzKCk7XG4gICAgfSwgW3Byb2Nlc3NBcmdzXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcHJvY2Vzc0FyZ3MoKTtcbiAgICB9LCBbcHJvY2Vzc0FyZ3NdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5maW5pdGVTY3JvbGxlciwgeyBzY3JvbGxSZWY6IHNjcm9sbFJlZiwgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGtpbmV0aWNTY3JvbGxQZXJmSGFjazogZXhwZXJpbWVudGFsPy5raW5ldGljU2Nyb2xsUGVyZkhhY2ssIHByZXZlbnREaWFnb25hbFNjcm9sbGluZzogcHJldmVudERpYWdvbmFsU2Nyb2xsaW5nLCBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlID09PSB0cnVlIHx8IHR5cGVvZiBpc0RyYWdnYWJsZSA9PT0gXCJzdHJpbmdcIiwgc2Nyb2xsV2lkdGg6IHdpZHRoICsgKHBhZGRpbmdSaWdodCA/PyAwKSwgc2Nyb2xsSGVpZ2h0OiBoZWlnaHQgKyAocGFkZGluZ0JvdHRvbSA/PyAwKSwgY2xpZW50SGVpZ2h0OiBjbGllbnRIZWlnaHQsIHJpZ2h0RWxlbWVudDogcmlnaHRFbGVtZW50LCBwYWRkaW5nQm90dG9tOiBwYWRkaW5nQm90dG9tLCBwYWRkaW5nUmlnaHQ6IHBhZGRpbmdSaWdodCwgcmlnaHRFbGVtZW50UHJvcHM6IHJpZ2h0RWxlbWVudFByb3BzLCB1cGRhdGU6IG9uU2Nyb2xsVXBkYXRlLCBpbml0aWFsU2l6ZTogaW5pdGlhbFNpemUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhR3JpZERuZCwgeyBldmVudFRhcmdldFJlZjogc2Nyb2xsUmVmLCB3aWR0aDogY2xpZW50V2lkdGgsIGhlaWdodDogY2xpZW50SGVpZ2h0LCBhY2Nlc3NpYmlsaXR5SGVpZ2h0OiBwLmFjY2Vzc2liaWxpdHlIZWlnaHQsIGNhbnZhc1JlZjogcC5jYW52YXNSZWYsIGNlbGxYT2Zmc2V0OiBwLmNlbGxYT2Zmc2V0LCBjZWxsWU9mZnNldDogcC5jZWxsWU9mZnNldCwgY29sdW1uczogcC5jb2x1bW5zLCBkaXNhYmxlZFJvd3M6IHAuZGlzYWJsZWRSb3dzLCBlbmFibGVHcm91cHM6IHAuZW5hYmxlR3JvdXBzLCBmaWxsSGFuZGxlOiBwLmZpbGxIYW5kbGUsIGZpcnN0Q29sQWNjZXNzaWJsZTogcC5maXJzdENvbEFjY2Vzc2libGUsIGZpeGVkU2hhZG93WDogcC5maXhlZFNoYWRvd1gsIGZpeGVkU2hhZG93WTogcC5maXhlZFNoYWRvd1ksIGZyZWV6ZUNvbHVtbnM6IHAuZnJlZXplQ29sdW1ucywgZ2V0Q2VsbENvbnRlbnQ6IHAuZ2V0Q2VsbENvbnRlbnQsIGdldENlbGxSZW5kZXJlcjogcC5nZXRDZWxsUmVuZGVyZXIsIGdldEdyb3VwRGV0YWlsczogcC5nZXRHcm91cERldGFpbHMsIGdldFJvd1RoZW1lT3ZlcnJpZGU6IHAuZ2V0Um93VGhlbWVPdmVycmlkZSwgZ3JvdXBIZWFkZXJIZWlnaHQ6IHAuZ3JvdXBIZWFkZXJIZWlnaHQsIGhlYWRlckhlaWdodDogcC5oZWFkZXJIZWlnaHQsIGhpZ2hsaWdodFJlZ2lvbnM6IHAuaGlnaGxpZ2h0UmVnaW9ucywgaW1hZ2VXaW5kb3dMb2FkZXI6IHAuaW1hZ2VXaW5kb3dMb2FkZXIsIGlzRmlsbGluZzogcC5pc0ZpbGxpbmcsIGlzRm9jdXNlZDogcC5pc0ZvY3VzZWQsIGxvY2tDb2x1bW5zOiBwLmxvY2tDb2x1bW5zLCBtYXhDb2x1bW5XaWR0aDogcC5tYXhDb2x1bW5XaWR0aCwgbWluQ29sdW1uV2lkdGg6IHAubWluQ29sdW1uV2lkdGgsIG9uSGVhZGVyTWVudUNsaWNrOiBwLm9uSGVhZGVyTWVudUNsaWNrLCBvbk1vdXNlTW92ZTogcC5vbk1vdXNlTW92ZSwgcHJlbGlnaHRDZWxsczogcC5wcmVsaWdodENlbGxzLCByb3dIZWlnaHQ6IHAucm93SGVpZ2h0LCByb3dzOiBwLnJvd3MsIHNlbGVjdGlvbjogcC5zZWxlY3Rpb24sIHRoZW1lOiBwLnRoZW1lLCBmcmVlemVUcmFpbGluZ1Jvd3M6IHAuZnJlZXplVHJhaWxpbmdSb3dzLCBoYXNBcHBlbmRSb3c6IHAuaGFzQXBwZW5kUm93LCB0cmFuc2xhdGVYOiBwLnRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVk6IHAudHJhbnNsYXRlWSwgb25Db2x1bW5Qcm9wb3NlTW92ZTogcC5vbkNvbHVtblByb3Bvc2VNb3ZlLCB2ZXJ0aWNhbEJvcmRlcjogcC52ZXJ0aWNhbEJvcmRlciwgZHJhd0ZvY3VzUmluZzogcC5kcmF3Rm9jdXNSaW5nLCBkcmF3SGVhZGVyOiBwLmRyYXdIZWFkZXIsIGRyYXdDZWxsOiBwLmRyYXdDZWxsLCBleHBlcmltZW50YWw6IHAuZXhwZXJpbWVudGFsLCBncmlkUmVmOiBwLmdyaWRSZWYsIGhlYWRlckljb25zOiBwLmhlYWRlckljb25zLCBpc0RyYWdnYWJsZTogcC5pc0RyYWdnYWJsZSwgb25DYW52YXNCbHVyOiBwLm9uQ2FudmFzQmx1ciwgb25DYW52YXNGb2N1c2VkOiBwLm9uQ2FudmFzRm9jdXNlZCwgb25DZWxsRm9jdXNlZDogcC5vbkNlbGxGb2N1c2VkLCBvbkNvbHVtbk1vdmVkOiBwLm9uQ29sdW1uTW92ZWQsIG9uQ29sdW1uUmVzaXplOiBwLm9uQ29sdW1uUmVzaXplLCBvbkNvbHVtblJlc2l6ZUVuZDogcC5vbkNvbHVtblJlc2l6ZUVuZCwgb25Db2x1bW5SZXNpemVTdGFydDogcC5vbkNvbHVtblJlc2l6ZVN0YXJ0LCBvbkNvbnRleHRNZW51OiBwLm9uQ29udGV4dE1lbnUsIG9uRHJhZ0VuZDogcC5vbkRyYWdFbmQsIG9uRHJhZ0xlYXZlOiBwLm9uRHJhZ0xlYXZlLCBvbkRyYWdPdmVyQ2VsbDogcC5vbkRyYWdPdmVyQ2VsbCwgb25EcmFnU3RhcnQ6IHAub25EcmFnU3RhcnQsIG9uRHJvcDogcC5vbkRyb3AsIG9uSXRlbUhvdmVyZWQ6IHAub25JdGVtSG92ZXJlZCwgb25LZXlEb3duOiBwLm9uS2V5RG93biwgb25LZXlVcDogcC5vbktleVVwLCBvbk1vdXNlRG93bjogcC5vbk1vdXNlRG93biwgb25Nb3VzZVVwOiBwLm9uTW91c2VVcCwgb25Sb3dNb3ZlZDogcC5vblJvd01vdmVkLCBzbW9vdGhTY3JvbGxYOiBwLnNtb290aFNjcm9sbFgsIHNtb290aFNjcm9sbFk6IHAuc21vb3RoU2Nyb2xsWSB9KSkpO1xufTtcbmV4cG9ydCBkZWZhdWx0IEdyaWRTY3JvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbGluZy1kYXRhLWdyaWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/scrolling-data-grid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/use-kinetic-scroll.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/use-kinetic-scroll.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst useKineticScroll = (isEnabled, callback, targetScroller) => {\n    const rafId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isTouching = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const lastScrollPosition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const sameCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(callback);\n    callbackRef.current = callback;\n    const scrollEl = targetScroller.current;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const handleScroll = () => {\n            if (isTouching.current === false && scrollEl !== null) {\n                const currentScrollPosition = [scrollEl.scrollLeft, scrollEl.scrollTop];\n                if (lastScrollPosition.current?.[0] === currentScrollPosition[0] &&\n                    lastScrollPosition.current?.[1] === currentScrollPosition[1]) {\n                    if (sameCount.current > 10) {\n                        // Scroll position hasn't changed, stop the animation frame\n                        lastScrollPosition.current = null;\n                        isTouching.current = null;\n                        return;\n                    }\n                    else {\n                        sameCount.current++;\n                    }\n                }\n                else {\n                    sameCount.current = 0;\n                    callbackRef.current(currentScrollPosition[0], currentScrollPosition[1]);\n                    lastScrollPosition.current = currentScrollPosition;\n                }\n                rafId.current = window.setTimeout(handleScroll, 1000 / 120);\n            }\n        };\n        const startTouch = () => {\n            isTouching.current = true;\n            lastScrollPosition.current = null; // Reset last scroll position on touch start\n            if (rafId.current !== null) {\n                window.clearTimeout(rafId.current);\n                rafId.current = null;\n            }\n        };\n        const endTouch = (event) => {\n            if (event.touches.length === 0) {\n                // All touches have ended\n                isTouching.current = false;\n                sameCount.current = 0;\n                rafId.current = window.setTimeout(handleScroll, 1000 / 120);\n            }\n        };\n        if (isEnabled && scrollEl !== null) {\n            const element = scrollEl;\n            element.addEventListener(\"touchstart\", startTouch);\n            element.addEventListener(\"touchend\", endTouch);\n            return () => {\n                element.removeEventListener(\"touchstart\", startTouch);\n                element.removeEventListener(\"touchend\", endTouch);\n                if (rafId.current !== null) {\n                    window.clearTimeout(rafId.current);\n                }\n            };\n        }\n    }, [isEnabled, scrollEl]);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useKineticScroll);\n//# sourceMappingURL=use-kinetic-scroll.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdsaWRlYXBwcy9nbGlkZS1kYXRhLWdyaWQvZGlzdC9lc20vaW50ZXJuYWwvc2Nyb2xsaW5nLWRhdGEtZ3JpZC91c2Uta2luZXRpYy1zY3JvbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEM7QUFDMUM7QUFDQSxrQkFBa0IsNkNBQU07QUFDeEIsdUJBQXVCLDZDQUFNO0FBQzdCLCtCQUErQiw2Q0FBTTtBQUNyQyxzQkFBc0IsNkNBQU07QUFDNUIsd0JBQXdCLDZDQUFNO0FBQzlCO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpRUFBZSxnQkFBZ0IsRUFBQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hvcml6b24tdGFpbHdpbmQtcmVhY3QtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL0BnbGlkZWFwcHMvZ2xpZGUtZGF0YS1ncmlkL2Rpc3QvZXNtL2ludGVybmFsL3Njcm9sbGluZy1kYXRhLWdyaWQvdXNlLWtpbmV0aWMtc2Nyb2xsLmpzP2YwMGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IHVzZUtpbmV0aWNTY3JvbGwgPSAoaXNFbmFibGVkLCBjYWxsYmFjaywgdGFyZ2V0U2Nyb2xsZXIpID0+IHtcbiAgICBjb25zdCByYWZJZCA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBpc1RvdWNoaW5nID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGxhc3RTY3JvbGxQb3NpdGlvbiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBzYW1lQ291bnQgPSB1c2VSZWYoMCk7XG4gICAgY29uc3QgY2FsbGJhY2tSZWYgPSB1c2VSZWYoY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrUmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgICBjb25zdCBzY3JvbGxFbCA9IHRhcmdldFNjcm9sbGVyLmN1cnJlbnQ7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVG91Y2hpbmcuY3VycmVudCA9PT0gZmFsc2UgJiYgc2Nyb2xsRWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2Nyb2xsUG9zaXRpb24gPSBbc2Nyb2xsRWwuc2Nyb2xsTGVmdCwgc2Nyb2xsRWwuc2Nyb2xsVG9wXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQ/LlswXSA9PT0gY3VycmVudFNjcm9sbFBvc2l0aW9uWzBdICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50Py5bMV0gPT09IGN1cnJlbnRTY3JvbGxQb3NpdGlvblsxXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtZUNvdW50LmN1cnJlbnQgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Nyb2xsIHBvc2l0aW9uIGhhc24ndCBjaGFuZ2VkLCBzdG9wIHRoZSBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTY3JvbGxQb3NpdGlvbi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG91Y2hpbmcuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1lQ291bnQuY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzYW1lQ291bnQuY3VycmVudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrUmVmLmN1cnJlbnQoY3VycmVudFNjcm9sbFBvc2l0aW9uWzBdLCBjdXJyZW50U2Nyb2xsUG9zaXRpb25bMV0pO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2Nyb2xsUG9zaXRpb24uY3VycmVudCA9IGN1cnJlbnRTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmFmSWQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KGhhbmRsZVNjcm9sbCwgMTAwMCAvIDEyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXJ0VG91Y2ggPSAoKSA9PiB7XG4gICAgICAgICAgICBpc1RvdWNoaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgbGFzdFNjcm9sbFBvc2l0aW9uLmN1cnJlbnQgPSBudWxsOyAvLyBSZXNldCBsYXN0IHNjcm9sbCBwb3NpdGlvbiBvbiB0b3VjaCBzdGFydFxuICAgICAgICAgICAgaWYgKHJhZklkLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJhZklkLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHJhZklkLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmRUb3VjaCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsIHRvdWNoZXMgaGF2ZSBlbmRlZFxuICAgICAgICAgICAgICAgIGlzVG91Y2hpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNhbWVDb3VudC5jdXJyZW50ID0gMDtcbiAgICAgICAgICAgICAgICByYWZJZC5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoaGFuZGxlU2Nyb2xsLCAxMDAwIC8gMTIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiBzY3JvbGxFbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNjcm9sbEVsO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBzdGFydFRvdWNoKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGVuZFRvdWNoKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBzdGFydFRvdWNoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBlbmRUb3VjaCk7XG4gICAgICAgICAgICAgICAgaWYgKHJhZklkLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChyYWZJZC5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2lzRW5hYmxlZCwgc2Nyb2xsRWxdKTtcbn07XG5leHBvcnQgZGVmYXVsdCB1c2VLaW5ldGljU2Nyb2xsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWtpbmV0aWMtc2Nyb2xsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@glideapps/glide-data-grid/dist/esm/internal/scrolling-data-grid/use-kinetic-scroll.js\n");

/***/ })

};
;